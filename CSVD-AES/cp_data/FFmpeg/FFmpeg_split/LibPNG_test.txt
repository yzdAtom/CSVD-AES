0<SPLIT>static void file_setpos(struct file *file, const fpos_t *pos) { if (fsetpos(file->file, pos)) { perror(file->file_name); stop(file, READ_ERROR_CODE, "fsetpos"); } }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int ancillary(const char *name) { return PNG_CHUNK_ANCILLARY(PNG_U32(name[0], name[1], name[2], name[3])); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int extract_one_file(const char *filename) { int result = 0; FILE *fp = fopen(filename, "rb"); if (fp != NULL) { png_uint_32 proflen = 0; png_bytep profile = extract(fp, &proflen); if (profile != NULL && profile != no_profile) { size_t len; char *output; { const char *ep = strrchr(filename, '.'); if (ep != NULL) len = ep-filename; else len = strlen(filename); } output = malloc(len + 5); if (output != NULL) { FILE *of; memcpy(output, filename, len); strcpy(output+len, ".icc"); of = fopen(output, "wb"); if (of != NULL) { if (fwrite(profile, proflen, 1, of) == 1 && fflush(of) == 0 && fclose(of) == 0) { if (verbose) printf("%s -> %s\n", filename, output); result = 1; } else { fprintf(stderr, "%s: error writing profile\n", output); if (remove(output)) fprintf(stderr, "%s: could not remove file\n", output); } } else fprintf(stderr, "%s: failed to open output file\n", output); free(output); } else fprintf(stderr, "%s: OOM allocating string!\n", filename); free(profile); } else if (verbose && profile == no_profile) printf("%s has no profile\n", filename); } else fprintf(stderr, "%s: could not open file\n", filename); return result; }<SPLIT>[-0.09900860198293619, 0.6409380450430461, 0.0, -0.11436118199787926, 0.551070379594149, 0.0, 0.9701672076669112, 0.9946065798247155, 0.9059316288753189, -0.27925050329511203, 0.5682770617589697, -0.09566541730555662, 0.6831261438402845, 0.0, 0.0, 0.30852482215402843, 0.4871364861795985, -0.11100716297398205, 0.5938891973556079, 1.2822982768889746, 1.564595164264088, 0.0, -0.08645738172306322, -0.16222078614455715, 0.18424725727220465, 1.3823183092473201, 1.1342209646213146, 2.47944955092491, 1.1753073288427536, 0.969587250454179, 0.9940939011734088, 0.9053924298597907, -0.27935383381430245, 4.332582482518814, 0.0, 0.9653245912203542, 0.9897980601469931, 0.9011791483816026, -0.28182971586402455]
0<SPLIT>unsigned long component(const char *prog, const char *arg, int issRGB) { char *ep; unsigned long c = strtoul(arg, &ep, 0); if (ep <= arg || *ep || c > 65535 || (issRGB && c > 255)) { fprintf(stderr, "%s: %s: invalid component value (%lu)\n", prog, arg, c); usage(prog); } return c; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, 0.4084056692221168, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.270465503877335, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.25252937827156396, -0.22049944857796966, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, 0.40798885073507796, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, 0.4044334392007059, -0.28182971586402455]
0<SPLIT>void writepng_version_info(void) { fprintf(stderr, " Compiled with libpng %s; using libpng %s.\n", PNG_LIBPNG_VER_STRING, png_libpng_ver); fprintf(stderr, " Compiled with zlib %s; using zlib %s.\n", ZLIB_VERSION, zlib_version); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI gamma_end(png_structp ppIn, png_infop pi) { png_const_structp pp = ppIn; gamma_display *dp = voidcast(gamma_display*, png_get_progressive_ptr(pp)); if (!dp->this.speed) gamma_image_validate(dp, pp, pi); else dp->this.ps->validated = 1; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int compare_read(struct display *dp, int applied_transforms) { size_t rowbytes; png_uint_32 width, height; int bit_depth, color_type; int interlace_method, compression_method, filter_method; const char *e = NULL; png_get_IHDR(dp->read_pp, dp->read_ip, &width, &height, &bit_depth, &color_type, &interlace_method, &compression_method, &filter_method); #define C(item) if (item != dp->item){ display_log(dp, APP_WARNING, "IHDR " #item "(%lu) changed to %lu", (unsigned long)dp->item, (unsigned long)item); e = #item; } C(width); C(height); C(bit_depth); C(color_type); C(interlace_method); C(compression_method); C(filter_method); if (e) display_log(dp, APP_ERROR, "IHDR changed (%s)", e); { unsigned long chunks = png_get_valid(dp->read_pp, dp->read_ip, 0xffffffff); if (chunks != dp->chunks) display_log(dp, APP_FAIL, "PNG chunks changed from 0x%lx to 0x%lx", (unsigned long)dp->chunks, chunks); } rowbytes = png_get_rowbytes(dp->read_pp, dp->read_ip); if (rowbytes != dp->original_rowbytes) display_log(dp, APP_ERROR, "PNG rowbytes changed from %lu to %lu", (unsigned long)dp->original_rowbytes, (unsigned long)rowbytes); { png_bytepp rows = png_get_rows(dp->read_pp, dp->read_ip); unsigned int mask; if (bit_depth < 8) { mask = 0xff & (0xff00 >> ((bit_depth * width) & 7)); } else mask = 0; if (rows == NULL) display_log(dp, LIBPNG_BUG, "png_get_rows returned NULL"); if ((applied_transforms & PNG_TRANSFORM_SHIFT) == 0 || (dp->active_transforms & PNG_TRANSFORM_SHIFT) == 0 || color_type == PNG_COLOR_TYPE_PALETTE) { unsigned long y; for (y=0; y<height; ++y) { png_bytep row = rows[y]; png_bytep orig = dp->original_rows[y]; if (memcmp(row, orig, rowbytes-(mask != 0)) != 0 || (mask != 0 && ((row[rowbytes-1] & mask) != (orig[rowbytes-1] & mask)))) { size_t x; for (x=0; x<rowbytes-1; ++x) if (row[x] != orig[x]) break; display_log(dp, APP_FAIL, "byte(%lu,%lu) changed 0x%.2x -> 0x%.2x", (unsigned long)x, (unsigned long)y, orig[x], row[x]); return 0; } } } else { unsigned long y; int bpp; png_byte sig_bits[8]; png_color_8p sBIT; if (png_get_sBIT(dp->read_pp, dp->read_ip, &sBIT) != PNG_INFO_sBIT) display_log(dp, INTERNAL_ERROR, "active shift transform but no sBIT in file"); switch (color_type) { case PNG_COLOR_TYPE_GRAY: sig_bits[0] = sBIT->gray; bpp = bit_depth; break; case PNG_COLOR_TYPE_GA: sig_bits[0] = sBIT->gray; sig_bits[1] = sBIT->alpha; bpp = 2 * bit_depth; break; case PNG_COLOR_TYPE_RGB: sig_bits[0] = sBIT->red; sig_bits[1] = sBIT->green; sig_bits[2] = sBIT->blue; bpp = 3 * bit_depth; break; case PNG_COLOR_TYPE_RGBA: sig_bits[0] = sBIT->red; sig_bits[1] = sBIT->green; sig_bits[2] = sBIT->blue; sig_bits[3] = sBIT->alpha; bpp = 4 * bit_depth; break; default: display_log(dp, LIBPNG_ERROR, "invalid colour type %d", color_type); bpp = 0; break; } { int b; for (b=0; 8*b<bpp; ++b) { if (sig_bits[b] == 0 || sig_bits[b] > bit_depth) display_log(dp, LIBPNG_BUG, "invalid sBIT[%u] value %d returned for PNG bit depth %d", b, sig_bits[b], bit_depth); } } if (bpp < 8 && bpp != bit_depth) { display_log(dp, INTERNAL_ERROR, "invalid bpp %u for bit_depth %u", bpp, bit_depth); } switch (bit_depth) { int b; case 16: for (b = (bpp >> 4); b > 0; ) { unsigned int sig = (unsigned int)(0xffff0000 >> sig_bits[b]); sig_bits[2*b+1] = (png_byte)sig; sig_bits[2*b+0] = (png_byte)(sig >> 8); } break; case 8: for (b=0; b*8 < bpp; ++b) sig_bits[b] = (png_byte)(0xff00 >> sig_bits[b]); break; case 1: sig_bits[0] = 0xff; break; case 2: b = 0x3 & ((0x3<<2) >> sig_bits[0]); b |= b << 2; b |= b << 4; sig_bits[0] = (png_byte)b; break; case 4: b = 0xf & ((0xf << 4) >> sig_bits[0]); b |= b << 4; sig_bits[0] = (png_byte)b; break; default: display_log(dp, LIBPNG_BUG, "invalid bit depth %d", bit_depth); break; } bpp = (bpp+7) >> 3; if (mask != 0) { mask &= sig_bits[0]; if (bpp != 1 || mask == 0) display_log(dp, INTERNAL_ERROR, "mask calculation error %u, %u", bpp, mask); } for (y=0; y<height; ++y) { png_bytep row = rows[y]; png_bytep orig = dp->original_rows[y]; unsigned long x; for (x=0; x<(width-(mask!=0)); ++x) { int b; for (b=0; b<bpp; ++b) { if ((*row++ & sig_bits[b]) != (*orig++ & sig_bits[b])) { display_log(dp, APP_FAIL, "significant bits at (%lu[%u],%lu) changed %.2x->%.2x", x, b, y, orig[-1], row[-1]); return 0; } } } if (mask != 0 && (*row & mask) != (*orig & mask)) { display_log(dp, APP_FAIL, "significant bits at (%lu[end],%lu) changed", x, y); return 0; } } } } return 1; }<SPLIT>[5.004186056441256, 3.549768369698078, 0.0, 4.906788845508823, 3.359868353228144, 0.0, 1.49154691857982, 0.8178632553475105, 1.5692995750795884, 2.0295292673408736, 3.864792762377195, 5.0953977074222285, 3.623407689373479, 0.0, 0.0, 0.30852482215402843, 3.683783795838246, 4.99379286602897, 3.443056300979784, 1.9292831855416035, 3.756922199721509, 0.0, -0.08645738172306322, 1.5771521192305922, 3.065083598156286, 3.235145688435389, 2.0373679067541706, 6.074752741790056, 3.2338643154903592, 1.4908334503424332, 0.8173872120927261, 1.5685972020260743, 2.0288615559433096, 1.7623686513065309, 0.0, 1.4859135779729586, 0.8133108086083498, 1.5635067606227984, 2.0227778188254817]
0<SPLIT>static void random_color(png_colorp color) { static png_uint_32 color_seed[2] = {0x12345678, 0x9abcdef}; make_random_bytes(color_seed, color, sizeof *color); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>void PNGAPI png_read_png(png_structp png_ptr, png_infop info_ptr, int transforms, voidp params) { int row; if (png_ptr == NULL) return; #if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) if (transforms & PNG_TRANSFORM_INVERT_ALPHA) png_set_invert_alpha(png_ptr); #endif png_read_info(png_ptr, info_ptr); if (info_ptr->height > PNG_UINT_32_MAX/png_sizeof(png_bytep)) png_error(png_ptr, "Image is too high to process with png_read_png()"); #if defined(PNG_READ_16_TO_8_SUPPORTED) if (transforms & PNG_TRANSFORM_STRIP_16) png_set_strip_16(png_ptr); #endif #if defined(PNG_READ_STRIP_ALPHA_SUPPORTED) if (transforms & PNG_TRANSFORM_STRIP_ALPHA) png_set_strip_alpha(png_ptr); #endif #if defined(PNG_READ_PACK_SUPPORTED) && !defined(PNG_READ_EXPAND_SUPPORTED) if (transforms & PNG_TRANSFORM_PACKING) png_set_packing(png_ptr); #endif #if defined(PNG_READ_PACKSWAP_SUPPORTED) if (transforms & PNG_TRANSFORM_PACKSWAP) png_set_packswap(png_ptr); #endif #if defined(PNG_READ_EXPAND_SUPPORTED) if (transforms & PNG_TRANSFORM_EXPAND) if ((png_ptr->bit_depth < 8) || (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) || (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))) png_set_expand(png_ptr); #endif #if defined(PNG_READ_INVERT_SUPPORTED) if (transforms & PNG_TRANSFORM_INVERT_MONO) png_set_invert_mono(png_ptr); #endif #if defined(PNG_READ_SHIFT_SUPPORTED) if ((transforms & PNG_TRANSFORM_SHIFT) && png_get_valid(png_ptr, info_ptr, PNG_INFO_sBIT)) { png_color_8p sig_bit; png_get_sBIT(png_ptr, info_ptr, &sig_bit); png_set_shift(png_ptr, sig_bit); } #endif #if defined(PNG_READ_BGR_SUPPORTED) if (transforms & PNG_TRANSFORM_BGR) png_set_bgr(png_ptr); #endif #if defined(PNG_READ_SWAP_ALPHA_SUPPORTED) if (transforms & PNG_TRANSFORM_SWAP_ALPHA) png_set_swap_alpha(png_ptr); #endif #if defined(PNG_READ_SWAP_SUPPORTED) if (transforms & PNG_TRANSFORM_SWAP_ENDIAN) png_set_swap(png_ptr); #endif png_read_update_info(png_ptr, info_ptr); #ifdef PNG_FREE_ME_SUPPORTED png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0); #endif if (info_ptr->row_pointers == NULL) { info_ptr->row_pointers = (png_bytepp)png_malloc(png_ptr, info_ptr->height * png_sizeof(png_bytep)); #ifdef PNG_FREE_ME_SUPPORTED info_ptr->free_me |= PNG_FREE_ROWS; #endif for (row = 0; row < (int)info_ptr->height; row++) { info_ptr->row_pointers[row] = (png_bytep)png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr)); } } png_read_image(png_ptr, info_ptr->row_pointers); info_ptr->valid |= PNG_INFO_IDAT; png_read_end(png_ptr, info_ptr); transforms = transforms; params = params; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 9.775782811575926, 1.1681547828925267, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 2.308256771682101, 5.1484837759987565, -0.1128809368767459, -0.7880534307994381, -0.518115519420462, 0.0, 6.859105271430652, 16.651717299148554, 0.32477585926655006, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void normalize_color_encoding(color_encoding *encoding) { PNG_CONST double whiteY = encoding->red.Y + encoding->green.Y + encoding->blue.Y; if (whiteY != 1) { encoding->red.X /= whiteY; encoding->red.Y /= whiteY; encoding->red.Z /= whiteY; encoding->green.X /= whiteY; encoding->green.Y /= whiteY; encoding->green.Z /= whiteY; encoding->blue.X /= whiteY; encoding->blue.Y /= whiteY; encoding->blue.Z /= whiteY; } }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.7880534307994381, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void standard_row(png_const_structp pp, png_byte std[STANDARD_ROWMAX], png_uint_32 id, png_uint_32 y) { if (WIDTH_FROM_ID(id) == 0) transform_row(pp, std, COL_FROM_ID(id), DEPTH_FROM_ID(id), y); else size_row(std, WIDTH_FROM_ID(id) * bit_size(pp, COL_FROM_ID(id), DEPTH_FROM_ID(id)), y); }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.3615192241061562, -0.10760608081136262, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static png_structp set_modifier_for_read(png_modifier *pm, png_infopp ppi, png_uint_32 id, PNG_CONST char *name) { pm->state = modifier_start; pm->bit_depth = 0; pm->colour_type = 255; pm->pending_len = 0; pm->pending_chunk = 0; pm->flush = 0; pm->buffer_count = 0; pm->buffer_position = 0; return set_store_for_read(&pm->this, ppi, id, name); }<SPLIT>[0.36491818514653585, -0.3507086565438968, 0.0, 0.34210700232091185, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.270836025671124, 0.3762494122151511, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, 0.35306556693537716, -0.4000063039086396, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void internal_error(png_store *ps, png_const_charp message) { store_log(ps, NULL, message, 1); { struct exception_context *the_exception_context = &ps->exception_context; Throw ps; } }<SPLIT>[-0.09900860198293619, -0.46089162338689044, 0.0, -0.11436118199787926, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.09566541730555662, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.11100716297398205, -0.5104391373824448, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static png_uint_32 png_log16bit(png_uint_32 x) { if (x > 0) return (png_uint_32)floor(.5-log(x/65535.)*L2INV); return 0xffffffff; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static png_uint_32 png_exp(png_uint_32 x) { return (png_uint_32)floor(.5 + exp(x * -LN2) * 0xffffffffU); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_expand_mod(PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp, PNG_CONST transform_display *display) { if (that->colour_type == PNG_COLOR_TYPE_PALETTE) image_pixel_convert_PLTE(that); else if (that->bit_depth < 8) that->sample_depth = that->bit_depth = 8; if (that->have_tRNS) image_pixel_add_alpha(that, &display->this); this->next->mod(this->next, that, pp, display); }<SPLIT>[-0.09900860198293619, -0.3727452499124955, 0.0, -0.11436118199787926, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, -0.09566541730555662, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.11100716297398205, -0.42209287060340067, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int main(int argc, char *argv[]) { FILE *fp_rd = stdin; FILE *fp_wr = stdout; FILE *fp_al = NULL; BOOL raw = TRUE; BOOL alpha = FALSE; int argi; for (argi = 1; argi < argc; argi++) { if (argv[argi][0] == '-') { switch (argv[argi][1]) { case 'n': raw = FALSE; break; case 'r': raw = TRUE; break; case 'a': alpha = TRUE; argi++; if ((fp_al = fopen (argv[argi], "wb")) == NULL) { fprintf (stderr, "PNM2PNG\n"); fprintf (stderr, "Error: can not create alpha-channel file %s\n", argv[argi]); exit (1); } break; case 'h': case '?': usage(); exit(0); break; default: fprintf (stderr, "PNG2PNM\n"); fprintf (stderr, "Error: unknown option %s\n", argv[argi]); usage(); exit(1); break; } } else if (fp_rd == stdin) { if ((fp_rd = fopen (argv[argi], "rb")) == NULL) { fprintf (stderr, "PNG2PNM\n"); fprintf (stderr, "Error: file %s does not exist\n", argv[argi]); exit (1); } } else if (fp_wr == stdout) { if ((fp_wr = fopen (argv[argi], "wb")) == NULL) { fprintf (stderr, "PNG2PNM\n"); fprintf (stderr, "Error: can not create file %s\n", argv[argi]); exit (1); } } else { fprintf (stderr, "PNG2PNM\n"); fprintf (stderr, "Error: too many parameters\n"); usage(); exit(1); } } #ifdef __TURBOC__ if (fp_rd == stdin) { setmode (STDIN, O_BINARY); } if ((raw) && (fp_wr == stdout)) { setmode (STDOUT, O_BINARY); } #endif if (png2pnm (fp_rd, fp_wr, fp_al, raw, alpha) == FALSE) { fprintf (stderr, "PNG2PNM\n"); fprintf (stderr, "Error: unsuccessful conversion of PNG-image\n"); exit(1); } fclose (fp_rd); fclose (fp_wr); if (alpha) fclose (fp_al); return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.4942630637605089, 1.274548645530178, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 1.2233340484040143, 0.35306556693537716, 1.123966798029873, -0.917450412529964, -0.518115519420462, 0.0, 0.9057658544417533, 0.9973611507722091, 0.8868902672439317, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>void *png_far_to_near(png_structp png_ptr, png_voidp ptr, int check) { void *near_ptr; void FAR *far_ptr; near_ptr = (void FAR *)ptr; far_ptr = (void FAR *)near_ptr; if (check != 0) if (far_ptr != ptr) png_error(png_ptr, "segment lost in conversion"); return(near_ptr); }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.1936866588694103, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 3.3489446507317613, -0.21031383592774278, -0.26569807294376846, -0.17914063696102905, 0.24712242304476825, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.14353953243697165, 0.11818065472185141, -0.21702784222394986, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, 0.04739993194876201]
0<SPLIT>static void sBIT_error_fn(png_structp pp, png_infop pi) { png_byte bit_depth; png_color_8 bad; if (png_get_color_type(pp, pi) == PNG_COLOR_TYPE_PALETTE) bit_depth = 8; else bit_depth = png_get_bit_depth(pp, pi); bad.red = bad.green = bad.blue = bad.gray = bad.alpha = (png_byte)(bit_depth+1); png_set_sBIT(pp, pi, &bad); }<SPLIT>[-0.09900860198293619, -0.3727452499124955, 0.0, -0.11436118199787926, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, -0.09566541730555662, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.11100716297398205, -0.42209287060340067, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static png_uint_16 ilinear(int fixed_srgb) { return u16d(65535 * sRGB_to_d[fixed_srgb]); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void initimage(Image *image, png_uint_32 opts, const char *file_name, int stride_extra) { freeimage(image); memset(&image->image, 0, sizeof image->image); image->opts = opts; image->file_name = file_name; image->stride_extra = stride_extra; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void checkbuffer(Image *image, const char *arg) { if (check16(image->buffer, 95)) { fflush(stdout); fprintf(stderr, "%s: overwrite at start of image buffer\n", arg); exit(1); } if (check16(image->buffer+16+image->allocsize, 95)) { fflush(stdout); fprintf(stderr, "%s: overwrite at end of image buffer\n", arg); exit(1); } }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.25252937827156396, -0.3333928163445767, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
1<SPLIT>int png_do_rgb_to_gray(png_structp png_ptr, png_row_infop row_info, png_bytep row) { png_uint_32 i; png_uint_32 row_width = row_info->width; int rgb_error = 0; png_debug(1, "in png_do_rgb_to_gray"); if ( (row_info->color_type & PNG_COLOR_MASK_COLOR)) { png_uint_32 rc = png_ptr->rgb_to_gray_red_coeff; png_uint_32 gc = png_ptr->rgb_to_gray_green_coeff; png_uint_32 bc = png_ptr->rgb_to_gray_blue_coeff; if (row_info->color_type == PNG_COLOR_TYPE_RGB) { if (row_info->bit_depth == 8) { #if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL) { png_bytep sp = row; png_bytep dp = row; for (i = 0; i < row_width; i++) { png_byte red = png_ptr->gamma_to_1[*(sp++)]; png_byte green = png_ptr->gamma_to_1[*(sp++)]; png_byte blue = png_ptr->gamma_to_1[*(sp++)]; if (red != green || red != blue) { rgb_error |= 1; *(dp++) = png_ptr->gamma_from_1[ (rc*red + gc*green + bc*blue)>>15]; } else *(dp++) = *(sp - 1); } } else #endif { png_bytep sp = row; png_bytep dp = row; for (i = 0; i < row_width; i++) { png_byte red = *(sp++); png_byte green = *(sp++); png_byte blue = *(sp++); if (red != green || red != blue) { rgb_error |= 1; *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15); } else *(dp++) = *(sp - 1); } } } else { #if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) if (png_ptr->gamma_16_to_1 != NULL && png_ptr->gamma_16_from_1 != NULL) { png_bytep sp = row; png_bytep dp = row; for (i = 0; i < row_width; i++) { png_uint_16 red, green, blue, w; red = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2; green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2; blue = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2; if (red == green && red == blue) w = red; else { png_uint_16 red_1 = png_ptr->gamma_16_to_1[(red&0xff) >> png_ptr->gamma_shift][red>>8]; png_uint_16 green_1 = png_ptr->gamma_16_to_1[(green&0xff) >> png_ptr->gamma_shift][green>>8]; png_uint_16 blue_1 = png_ptr->gamma_16_to_1[(blue&0xff) >> png_ptr->gamma_shift][blue>>8]; png_uint_16 gray16 = (png_uint_16)((rc*red_1 + gc*green_1 + bc*blue_1)>>15); w = png_ptr->gamma_16_from_1[(gray16&0xff) >> png_ptr->gamma_shift][gray16 >> 8]; rgb_error |= 1; } *(dp++) = (png_byte)((w>>8) & 0xff); *(dp++) = (png_byte)(w & 0xff); } } else #endif { png_bytep sp = row; png_bytep dp = row; for (i = 0; i < row_width; i++) { png_uint_16 red, green, blue, gray16; red = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2; green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2; blue = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2; if (red != green || red != blue) rgb_error |= 1; gray16 = (png_uint_16)((rc*red + gc*green + bc*blue)>>15); *(dp++) = (png_byte)((gray16>>8) & 0xff); *(dp++) = (png_byte)(gray16 & 0xff); } } } } if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA) { if (row_info->bit_depth == 8) { #if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL) { png_bytep sp = row; png_bytep dp = row; for (i = 0; i < row_width; i++) { png_byte red = png_ptr->gamma_to_1[*(sp++)]; png_byte green = png_ptr->gamma_to_1[*(sp++)]; png_byte blue = png_ptr->gamma_to_1[*(sp++)]; if (red != green || red != blue) rgb_error |= 1; *(dp++) = png_ptr->gamma_from_1 [(rc*red + gc*green + bc*blue)>>15]; *(dp++) = *(sp++); } } else #endif { png_bytep sp = row; png_bytep dp = row; for (i = 0; i < row_width; i++) { png_byte red = *(sp++); png_byte green = *(sp++); png_byte blue = *(sp++); if (red != green || red != blue) rgb_error |= 1; *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15); *(dp++) = *(sp++); } } } else { #if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) if (png_ptr->gamma_16_to_1 != NULL && png_ptr->gamma_16_from_1 != NULL) { png_bytep sp = row; png_bytep dp = row; for (i = 0; i < row_width; i++) { png_uint_16 red, green, blue, w; red = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2; green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2; blue = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2; if (red == green && red == blue) w = red; else { png_uint_16 red_1 = png_ptr->gamma_16_to_1[(red&0xff) >> png_ptr->gamma_shift][red>>8]; png_uint_16 green_1 = png_ptr->gamma_16_to_1[(green&0xff) >> png_ptr->gamma_shift][green>>8]; png_uint_16 blue_1 = png_ptr->gamma_16_to_1[(blue&0xff) >> png_ptr->gamma_shift][blue>>8]; png_uint_16 gray16 = (png_uint_16)((rc * red_1 + gc * green_1 + bc * blue_1)>>15); w = png_ptr->gamma_16_from_1[(gray16&0xff) >> png_ptr->gamma_shift][gray16 >> 8]; rgb_error |= 1; } *(dp++) = (png_byte)((w>>8) & 0xff); *(dp++) = (png_byte)(w & 0xff); *(dp++) = *(sp++); *(dp++) = *(sp++); } } else #endif { png_bytep sp = row; png_bytep dp = row; for (i = 0; i < row_width; i++) { png_uint_16 red, green, blue, gray16; red = (png_uint_16)((*(sp)<<8) | *(sp + 1)); sp += 2; green = (png_uint_16)((*(sp)<<8) | *(sp + 1)); sp += 2; blue = (png_uint_16)((*(sp)<<8) | *(sp + 1)); sp += 2; if (red != green || red != blue) rgb_error |= 1; gray16 = (png_uint_16)((rc*red + gc*green + bc*blue)>>15); *(dp++) = (png_byte)((gray16>>8) & 0xff); *(dp++) = (png_byte)(gray16 & 0xff); *(dp++) = *(sp++); *(dp++) = *(sp++); } } } } row_info->channels -= 2; row_info->color_type = (png_byte)(row_info->color_type & ~PNG_COLOR_MASK_COLOR); row_info->pixel_depth = (png_byte)(row_info->channels * row_info->bit_depth); row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width); } return rgb_error; }<SPLIT>[4.849543794064766, 4.144756390650244, 0.0, 4.7546327840692255, 3.9556739839989916, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, -0.27925050329511203, 4.384243721262491, 1.9492988439508436, 1.7315986329451447, 0.0, 0.0, 0.30852482215402843, 4.206871537418752, 1.8999746666332415, 1.6098712653146163, -0.39986248560786075, 0.13958259121676436, 0.0, 13.584173872103296, 5.055897929980891, 3.7325944576294265, -0.14353953243697165, -0.4462861841111837, -0.21702784222394986, 0.14602883551895066, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, -0.27935383381430245, 1.7623686513065309, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, -0.28182971586402455]
0<SPLIT>BOOL InitBitmap (BYTE *pDiData, int cxWinSize, int cyWinSize) { BYTE *dst; int x, y, col; dst = pDiData; for (y = 0; y < cyWinSize; y++) { col = 0; for (x = 0; x < cxWinSize; x++) { *dst++ = 127; *dst++ = 127; *dst++ = 127; col += 3; } while ((col % 4) != 0) { dst++; col++; } } return TRUE; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.18995094088131478, -0.1936866588694103, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.152192975752131, 0.19837465696559078, -0.17914063696102905, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void rpng_win_cleanup() { if (image_data) { free(image_data); image_data = NULL; } if (dib) { free(dib); dib = NULL; } }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5250039928580447, -0.6720729196443977, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>void readpng2_version_info(void) { fprintf(stderr, " Compiled with libpng %s; using libpng %s\n", PNG_LIBPNG_VER_STRING, png_libpng_ver); fprintf(stderr, " and with zlib %s; using zlib %s.\n", ZLIB_VERSION, zlib_version); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int fail(png_modifier *pm) { return !pm->log && !pm->this.verbose && (pm->this.nerrors > 0 || (pm->this.treat_warnings_as_errors && pm->this.nwarnings > 0)); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void standard_text_validate(standard_display *dp, png_const_structp pp, png_infop pi, int check_end) { png_textp tp = NULL; png_uint_32 num_text = png_get_text(pp, pi, &tp, NULL); if (num_text == 2 && tp != NULL) { standard_check_text(pp, tp, "image name", dp->ps->current->name); if (check_end) standard_check_text(pp, tp+1, "end marker", "end"); } else { char msg[64]; sprintf(msg, "expected two text items, got %lu", (unsigned long)num_text); png_error(pp, msg); } }<SPLIT>[0.36491818514653585, -0.21848909633230443, 0.0, 0.34210700232091185, -0.27880174897953136, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1509627274668249, 0.3762494122151511, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.21031383592774278, 0.35306556693537716, -0.2674869037400733, -0.14106852214680915, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int find(const char *name) { int i = NINFO; while (--i >= 0) { if (memcmp(chunk_info[i].name, name, 4) == 0) break; } return i; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void display_clean(struct display *dp) { #ifdef PNG_WRITE_SUPPORTED display_clean_write(dp); #endif display_clean_read(dp); dp->original_rowbytes = 0; dp->original_rows = NULL; dp->chunks = 0; png_destroy_read_struct(&dp->original_pp, &dp->original_ip, NULL); dp->results = 0; }<SPLIT>[-0.09900860198293619, -0.3727452499124955, 0.0, -0.11436118199787926, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, -0.09566541730555662, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.11100716297398205, -0.48835257068768384, -0.5292594673383866, -0.4084991676475909, 0.0, 0.02378964451747194, 0.9973611507722091, -0.44813145170234975, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int repl_getch(void) { char ch; int fd = fileno(stdin); struct termio old_tty, new_tty; ioctl(fd, TCGETA, &old_tty); new_tty = old_tty; new_tty.c_lflag &= ~(ICANON | ECHO | ISIG); ioctl(fd, TCSETA, &new_tty); fread(&ch, 1, sizeof(ch), stdin); ioctl(fd, TCSETA, &old_tty); return ch; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.42209287060340067, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, 0.417570182313826, -0.3427350002065907, -0.1980344553542678, 0.11818065472185141, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void clear_keep(void) { int i = NINFO; while (--i >= 0) chunk_info[i].keep = 0; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void set_color(png_colorp color, png_bytep trans, unsigned int red, unsigned int green, unsigned int blue, unsigned int alpha, png_const_bytep gamma_table) { color->red = gamma_table[red]; color->green = gamma_table[green]; color->blue = gamma_table[blue]; *trans = (png_byte)alpha; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void init_display(display *d, const char *program) { memset(d, 0, sizeof *d); d->png_ptr = NULL; d->info_ptr = d->end_ptr = NULL; d->error_count = d->warning_count = 0; d->program = program; d->file = program; d->test = init; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void freeimage(Image *image) { freebuffer(image); png_image_free(&image->image); if (image->input_file != NULL) { fclose(image->input_file); image->input_file = NULL; } if (image->input_memory != NULL) { free(image->input_memory); image->input_memory = NULL; image->input_memory_size = 0; } if (image->tmpfile_name[0] != 0 && (image->opts & KEEP_TMPFILES) == 0) { remove(image->tmpfile_name); image->tmpfile_name[0] = 0; } }<SPLIT>[-0.25365086435942685, -0.17441590959510697, 0.0, -0.2665172434374763, -0.23624420392447085, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.1909204935349246, -0.25297036047912586, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.26569807294376846, -0.22331377035055117, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.25252937827156396, -0.22049944857796966, -0.21702784222394986, -0.22825425296243224, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_expand_gray_1_2_4_to_8_set(PNG_CONST image_transform *this, transform_display *that, png_structp pp, png_infop pi) { png_set_expand_gray_1_2_4_to_8(pp); this->next->set(this->next, that, pp, pi); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void set_text(png_structp png_ptr, png_infop info_ptr, png_textp text, png_charp param) { switch (param[0]) { case '<': { png_bytep file = NULL; text->text_length = load_file(param+1, &file); text->text = (png_charp)file; } break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': { png_bytep data = NULL; png_size_t fake_len = load_fake(param, &data); if (fake_len > 0) { text->text_length = fake_len; text->text = (png_charp)data; break; } } default: text->text = param; break; } png_set_text(png_ptr, info_ptr, text, 1); if (text->text != param) free(text->text); }<SPLIT>[-0.25365086435942685, 0.06798661745947907, 0.0, -0.2665172434374763, -0.0021777061216379156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.02884721983962376, -0.25297036047912586, 0.0905112586940592, 0.0, 0.0, 0.30852482215402843, -0.03595125540090747, -0.26569807294376846, 0.01963846329182043, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void transform_info_imp(transform_display *dp, png_structp pp, png_infop pi) { standard_info_part1(&dp->this, pp, pi); dp->transform_list->set(dp->transform_list, dp, pp, pi); { int i = dp->this.use_update_info; do png_read_update_info(pp, pi); while (--i > 0); } standard_info_part2(&dp->this, pp, pi, 1); dp->output_colour_type = png_get_color_type(pp, pi); dp->output_bit_depth = png_get_bit_depth(pp, pi); switch (dp->output_colour_type) { case PNG_COLOR_TYPE_PALETTE: if (dp->output_bit_depth > 8) goto error; case PNG_COLOR_TYPE_GRAY: if (dp->output_bit_depth == 1 || dp->output_bit_depth == 2 || dp->output_bit_depth == 4) break; default: if (dp->output_bit_depth == 8 || dp->output_bit_depth == 16) break; error: { char message[128]; size_t pos; pos = safecat(message, sizeof message, 0, "invalid final bit depth: colour type("); pos = safecatn(message, sizeof message, pos, dp->output_colour_type); pos = safecat(message, sizeof message, pos, ") with bit depth: "); pos = safecatn(message, sizeof message, pos, dp->output_bit_depth); png_error(pp, message); } } { image_pixel test_pixel; memset(&test_pixel, 0, sizeof test_pixel); test_pixel.colour_type = dp->this.colour_type; test_pixel.bit_depth = dp->this.bit_depth; if (test_pixel.colour_type == PNG_COLOR_TYPE_PALETTE) test_pixel.sample_depth = 8; else test_pixel.sample_depth = test_pixel.bit_depth; test_pixel.have_tRNS = dp->this.is_transparent; test_pixel.red_sBIT = test_pixel.green_sBIT = test_pixel.blue_sBIT = test_pixel.alpha_sBIT = test_pixel.sample_depth; dp->transform_list->mod(dp->transform_list, &test_pixel, pp, dp); if (test_pixel.colour_type != dp->output_colour_type) { char message[128]; size_t pos = safecat(message, sizeof message, 0, "colour type "); pos = safecatn(message, sizeof message, pos, dp->output_colour_type); pos = safecat(message, sizeof message, pos, " expected "); pos = safecatn(message, sizeof message, pos, test_pixel.colour_type); png_error(pp, message); } if (test_pixel.bit_depth != dp->output_bit_depth) { char message[128]; size_t pos = safecat(message, sizeof message, 0, "bit depth "); pos = safecatn(message, sizeof message, pos, dp->output_bit_depth); pos = safecat(message, sizeof message, pos, " expected "); pos = safecatn(message, sizeof message, pos, test_pixel.bit_depth); png_error(pp, message); } if (test_pixel.colour_type == PNG_COLOR_TYPE_PALETTE) { if (test_pixel.sample_depth != 8) png_error(pp, "pngvalid: internal: palette sample depth not 8"); } else if (test_pixel.sample_depth != dp->output_bit_depth) { char message[128]; size_t pos = safecat(message, sizeof message, 0, "internal: sample depth "); pos = safecatn(message, sizeof message, pos, dp->output_bit_depth); pos = safecat(message, sizeof message, pos, " expected "); pos = safecatn(message, sizeof message, pos, test_pixel.sample_depth); png_error(pp, message); } } }<SPLIT>[3.148478907923368, 1.213889472626613, 0.0, 3.0809161082336582, 1.1043184653099358, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 1.5072845643593127, 3.2077383893393976, 1.2757410289865097, 0.0, 0.0, 0.30852482215402843, 1.3976966289308497, 3.137501946391533, 1.1681399314193952, 1.670489222080552, 0.9068970536268617, 0.0, -0.08645738172306322, -0.16222078614455715, 0.9220224177425181, 0.7283792342397666, 1.3600077001545285, -0.21702784222394986, 0.14602883551895066, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static void make_size_image(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type, png_byte PNG_CONST bit_depth, int PNG_CONST interlace_type, png_uint_32 PNG_CONST w, png_uint_32 PNG_CONST h, int PNG_CONST do_interlace) { context(ps, fault); check_interlace_type(interlace_type); Try { png_infop pi; png_structp pp; unsigned int pixel_size; char name[FILE_NAME_SIZE]; PNG_CONST png_uint_32 id = FILEID(colour_type, bit_depth, 0, interlace_type, w, h, do_interlace); standard_name_from_id(name, sizeof name, 0, id); pp = set_store_for_write(ps, &pi, name); if (pp == NULL) Throw ps; png_set_IHDR(pp, pi, w, h, bit_depth, colour_type, interlace_type, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE); #ifdef PNG_TEXT_SUPPORTED { static char key[] = "image name"; size_t pos; png_text text; char copy[FILE_NAME_SIZE]; text.compression = TEXT_COMPRESSION; text.key = key; pos = safecat(copy, sizeof copy, 0, ps->wname); text.text = copy; text.text_length = pos; text.itxt_length = 0; text.lang = 0; text.lang_key = 0; png_set_text(pp, pi, &text, 1); } #endif if (colour_type == 3) init_standard_palette(ps, pp, pi, 1U << bit_depth, 0); png_write_info(pp, pi); pixel_size = bit_size(pp, colour_type, bit_depth); if (png_get_rowbytes(pp, pi) != ((w * pixel_size) + 7) / 8) png_error(pp, "row size incorrect"); else { int npasses = npasses_from_interlace_type(pp, interlace_type); png_uint_32 y; int pass; #ifdef PNG_WRITE_FILTER_SUPPORTED int nfilter = PNG_FILTER_VALUE_LAST; #endif png_byte image[16][SIZE_ROWMAX]; memset(image, 0xff, sizeof image); if (!do_interlace && npasses != png_set_interlace_handling(pp)) png_error(pp, "write: png_set_interlace_handling failed"); for (y=0; y<h; ++y) size_row(image[y], w * pixel_size, y); for (pass=0; pass<npasses; ++pass) { PNG_CONST png_uint_32 wPass = PNG_PASS_COLS(w, pass); for (y=0; y<h; ++y) { png_const_bytep row = image[y]; png_byte tempRow[SIZE_ROWMAX]; if (do_interlace && interlace_type == PNG_INTERLACE_ADAM7) { if (PNG_ROW_IN_INTERLACE_PASS(y, pass) && wPass > 0) { memset(tempRow, 0xff, sizeof tempRow); interlace_row(tempRow, row, pixel_size, w, pass); row = tempRow; } else continue; } #ifdef PNG_WRITE_FILTER_SUPPORTED png_set_filter(pp, 0, nfilter >= PNG_FILTER_VALUE_LAST ? PNG_ALL_FILTERS : nfilter); if (nfilter-- == 0) nfilter = PNG_FILTER_VALUE_LAST-1; #endif png_write_row(pp, row); } } } #ifdef PNG_TEXT_SUPPORTED { static char key[] = "end marker"; static char comment[] = "end"; png_text text; text.compression = TEXT_COMPRESSION; text.key = key; text.text = comment; text.text_length = (sizeof comment)-1; text.itxt_length = 0; text.lang = 0; text.lang_key = 0; png_set_text(pp, pi, &text, 1); } #endif png_write_end(pp, pi); store_storefile(ps, id); store_write_reset(ps); } Catch(fault) { store_write_reset(fault); } }<SPLIT>[8.560958091100542, 1.78684090021018, 0.0, 8.406378258619554, 1.6575665510257227, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 2.7259964294363535, 6.039227366463645, 0.9338478260175336, 0.0, 0.0, 0.30852482215402843, 2.5794874525016223, 5.921938325847688, 0.8368414309979795, -0.14106852214680915, -0.518115519420462, 0.0, 5.425893930303695, 4.4761069615225075, 1.6597975782128316, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int validation_checkfp(int count, int argc, char **argv) { int result; checkfp_command command; checkfp_control control; command.number[0] = 0; command.limit = 3; command.verbose = verbose; command.ctimes = 0; command.cmillions = 0; command.cinvalid = 0; command.cnoaccept = 0; while (--argc > 0) { ++argv; if (argc > 1 && strcmp(*argv, "-l") == 0) { --argc; command.limit = atoi(*++argv); } else { fprintf(stderr, "unknown argument %s\n", *argv); return 1; } } control.cnumber = 0; control.check_state = start; control.at_start = 1; control.cdigits_in_state = 0; control.limit = command.limit; control.state = 0; control.is_negative = 0; control.is_zero = 1; control.number_was_valid = 0; result = check_all_characters(&command, control); printf("checkfp: %s: checked %d,%.3d,%.3d,%.3d strings (%d invalid)\n", result ? "pass" : "FAIL", command.cmillions / 1000, command.cmillions % 1000, command.ctimes / 1000, command.ctimes % 1000, command.cinvalid); return result; }<SPLIT>[-0.25365086435942685, 0.2663159577768676, 0.0, -0.2665172434374763, 0.21061001915366473, 0.0, -0.07259221415890627, -0.06585336703851451, 0.07672169611998206, 0.380400859743741, 0.2086571671460724, -0.25297036047912586, 0.29564718047544486, 0.0, 0.0, 0.30852482215402843, 0.1577849451844651, -0.26569807294376846, 0.24050413023943099, -0.011671540416283347, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2545115582693773, -0.03454968660237938, -0.10760608081136262, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, 0.07638646465193619, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, 0.07326963308010803, 0.3766295797615486]
0<SPLIT>static void signal_handler(int signum) { size_t pos = 0; char msg[64]; pos = safecat(msg, sizeof msg, pos, "caught signal: "); switch (signum) { case SIGABRT: pos = safecat(msg, sizeof msg, pos, "abort"); break; case SIGFPE: pos = safecat(msg, sizeof msg, pos, "floating point exception"); break; case SIGILL: pos = safecat(msg, sizeof msg, pos, "illegal instruction"); break; case SIGINT: pos = safecat(msg, sizeof msg, pos, "interrupt"); break; case SIGSEGV: pos = safecat(msg, sizeof msg, pos, "invalid memory access"); break; case SIGTERM: pos = safecat(msg, sizeof msg, pos, "termination request"); break; default: pos = safecat(msg, sizeof msg, pos, "unknown "); pos = safecatn(msg, sizeof msg, pos, signum); break; } store_log(&pm.this, NULL, msg, 1); if (signum != SIGTERM) { struct exception_context *the_exception_context = &pm.this.exception_context; Throw &pm.this; } else exit(1); }<SPLIT>[0.21027592277004517, 0.2222427710396702, 0.0, 0.18995094088131478, 0.16805247409860422, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.22863605018012226, 0.21894446904158188, 0.2500614200795814, 0.0, 0.0, 0.30852482215402843, 0.17715856524300236, 0.19837465696559078, 0.19633099684990887, 0.24712242304476825, 2.0030605713555723, 0.0, -0.08645738172306322, -0.16222078614455715, 0.11398295627503194, 0.8918640029916549, 0.23107402248845843, -0.21702784222394986, 1.3624488730834452, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI pngtest_warning(png_structp png_ptr, png_const_charp message) { PNG_CONST char *name = "UNKNOWN (ERROR!)"; char *test; test = png_get_error_ptr(png_ptr); if (test == NULL) fprintf(STDERR, "%s: libpng warning: %s\n", name, message); else fprintf(STDERR, "%s: libpng warning: %s\n", test, message); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void PNGCBAPI warning(png_structp png_ptr, const char *message) { display *d = (display*)png_get_error_ptr(png_ptr); fprintf(stderr, "%s(%s): libpng warning: %s\n", d->file, d->test, message); ++(d->warning_count); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>int main(void) { fprintf(stderr, " test ignored: no support to find out about unknown chunks\n"); return 77; }<SPLIT>[0.05563366039355449, -0.416818436649693, 0.0, 0.037794879441717756, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3907093238754231, 0.061639525868012635, -0.4109321056604391, 0.0, 0.0, 3.3489446507317613, -0.36530279639604085, 0.04368374699580437, -0.4000063039086396, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void modifier_read_imp(png_modifier *pm, png_bytep pb, png_size_t st) { while (st > 0) { size_t cb; png_uint_32 len, chunk; png_modification *mod; if (pm->buffer_position >= pm->buffer_count) switch (pm->state) { static png_byte sign[8] = { 137, 80, 78, 71, 13, 10, 26, 10 }; case modifier_start: store_read_imp(&pm->this, pm->buffer, 8); pm->buffer_count = 8; pm->buffer_position = 0; if (memcmp(pm->buffer, sign, 8) != 0) png_error(pm->this.pread, "invalid PNG file signature"); pm->state = modifier_signature; break; case modifier_signature: store_read_imp(&pm->this, pm->buffer, 13+12); pm->buffer_count = 13+12; pm->buffer_position = 0; if (png_get_uint_32(pm->buffer) != 13 || png_get_uint_32(pm->buffer+4) != CHUNK_IHDR) png_error(pm->this.pread, "invalid IHDR"); mod = pm->modifications; while (mod != NULL) { if (mod->chunk == CHUNK_IHDR && mod->modify_fn && (*mod->modify_fn)(pm, mod, 0)) { mod->modified = 1; modifier_setbuffer(pm); } mod = mod->next; } pm->bit_depth = pm->buffer[8+8]; pm->colour_type = pm->buffer[8+8+1]; pm->state = modifier_IHDR; pm->flush = 0; break; case modifier_IHDR: default: if ((cb = pm->flush) > 0) { if (cb > st) cb = st; pm->flush -= cb; store_read_imp(&pm->this, pb, cb); pb += cb; st -= cb; if (st == 0) return; } if (pm->pending_chunk != 0) { png_save_uint_32(pm->buffer, pm->pending_len); png_save_uint_32(pm->buffer+4, pm->pending_chunk); pm->pending_len = 0; pm->pending_chunk = 0; } else store_read_imp(&pm->this, pm->buffer, 8); pm->buffer_count = 8; pm->buffer_position = 0; len = png_get_uint_32(pm->buffer); chunk = png_get_uint_32(pm->buffer+4); if (chunk == CHUNK_PLTE || chunk == CHUNK_IDAT || chunk == CHUNK_IEND) { mod = pm->modifications; while (mod != NULL) { if ((mod->add == chunk || (mod->add == CHUNK_PLTE && chunk == CHUNK_IDAT)) && mod->modify_fn != NULL && !mod->modified && !mod->added) { mod->added = 1; if ((*mod->modify_fn)(pm, mod, 1 )) { if (pm->buffer_count > 0) modifier_setbuffer(pm); else { pm->buffer_position = 0; mod->removed = 1; } pm->pending_len = len; pm->pending_chunk = chunk; break; } } mod = mod->next; } if (mod != NULL) break; } if (len+12 <= sizeof pm->buffer) { store_read_imp(&pm->this, pm->buffer+pm->buffer_count, len+12-pm->buffer_count); pm->buffer_count = len+12; mod = pm->modifications; while (mod != NULL) { if (mod->chunk == chunk) { if (mod->modify_fn == NULL) { pm->buffer_count = pm->buffer_position = 0; mod->removed = 1; break; } else if ((*mod->modify_fn)(pm, mod, 0)) { mod->modified = 1; if (pm->buffer_count == 0) { pm->buffer_position = 0; break; } modifier_setbuffer(pm); } } mod = mod->next; } } else pm->flush = len+12 - pm->buffer_count; break; } cb = pm->buffer_count - pm->buffer_position; if (cb > st) cb = st; memcpy(pb, pm->buffer + pm->buffer_position, cb); st -= cb; pb += cb; pm->buffer_position += cb; } }<SPLIT>[5.313470581194237, 2.403865514530944, 0.0, 5.211100968388017, 2.2533721817965704, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 2.8658486106747025, 5.410007593769367, 2.5065565596748236, 0.0, 0.0, 0.30852482215402843, 2.715102792911383, 5.303174685968543, 2.3608145329364922, 0.24712242304476825, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 1.6597975782128316, -0.1980344553542678, 0.23107402248845843, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int image_transform_png_set_tRNS_to_alpha_add(image_transform *this, PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth) { UNUSED(bit_depth) this->next = *that; *that = this; return (colour_type & PNG_COLOR_MASK_ALPHA) == 0; }<SPLIT>[0.36491818514653585, -0.46089162338689044, 0.0, 0.34210700232091185, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, 0.3762494122151511, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, 0.35306556693537716, -0.5104391373824448, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>BOOL PngSaveImage (PTSTR pstrFileName, png_byte *pDiData, int iWidth, int iHeight, png_color bkgColor) { const int ciBitDepth = 8; const int ciChannels = 3; static FILE *pfFile; png_uint_32 ulRowBytes; static png_byte **ppbRowPointers = NULL; int i; if (!pstrFileName) return FALSE; if (!(pfFile = fopen(pstrFileName, "wb"))) return FALSE; png_ptr = png_create_write_struct(png_get_libpng_ver(NULL), NULL, (png_error_ptr)png_cexcept_error, (png_error_ptr)NULL); if (!png_ptr) { fclose(pfFile); return FALSE; } info_ptr = png_create_info_struct(png_ptr); if (!info_ptr) { fclose(pfFile); png_destroy_write_struct(&png_ptr, (png_infopp) NULL); return FALSE; } Try { #ifdef PNG_STDIO_SUPPORTED png_init_io(png_ptr, pfFile); #else png_set_write_fn(png_ptr, (png_voidp)pfFile, png_write_data, png_flush); #endif png_set_IHDR(png_ptr, info_ptr, iWidth, iHeight, ciBitDepth, PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE); png_write_info(png_ptr, info_ptr); png_set_bgr(png_ptr); ulRowBytes = iWidth * ciChannels; if ((ppbRowPointers = (png_bytepp) malloc(iHeight * sizeof(png_bytep))) == NULL) Throw "Visualpng: Out of memory"; for (i = 0; i < iHeight; i++) ppbRowPointers[i] = pDiData + i * (((ulRowBytes + 3) >> 2) << 2); png_write_image (png_ptr, ppbRowPointers); png_write_end(png_ptr, info_ptr); free (ppbRowPointers); ppbRowPointers = NULL; png_destroy_write_struct(&png_ptr, (png_infopp) NULL); } Catch (msg) { png_destroy_write_struct(&png_ptr, (png_infopp) NULL); if(ppbRowPointers) free (ppbRowPointers); fclose(pfFile); return FALSE; } fclose (pfFile); return TRUE; }<SPLIT>[1.9113408089114425, 0.6629746384116447, 0.0, 1.863667616716882, 0.5936279246492095, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.8479814242356677, 1.9492988439508436, 0.6147475032464892, 0.0, 0.0, 0.30852482215402843, 0.7777407870576574, 1.8999746666332415, 0.5497160639660857, 0.5059163865058198, -0.1892664641018488, 0.0, 0.02378964451747194, 1.5771521192305922, 0.5707009127566546, 0.01994523631491676, 0.4568607580216725, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void modifier_progressive_read(png_modifier *pm, png_structp pp, png_infop pi) { if (pm->this.pread != pp || pm->this.current == NULL || pm->this.next == NULL) png_error(pp, "store state damaged (progressive)"); for (;;) { static png_uint_32 noise = 1; png_size_t cb, cbAvail; png_byte buffer[512]; noise = (noise << 9) | ((noise ^ (noise >> (9-5))) & 0x1ff); cb = noise & 0x1ff; cbAvail = store_read_buffer_avail(&pm->this); if (pm->buffer_count > pm->buffer_position) cbAvail += pm->buffer_count - pm->buffer_position; if (cb > cbAvail) { if (cbAvail == 0) break; cb = cbAvail; } modifier_read_imp(pm, buffer, cb); png_process_data(pp, pi, buffer, cb); } if (pm->buffer_count > pm->buffer_position || pm->this.next != &pm->this.current->data || pm->this.readpos < pm->this.current->datacount) png_error(pp, "progressive read implementation error"); }<SPLIT>[2.2206253336644237, 0.0018768373536828752, 0.0, 2.167979739596076, -0.06601402370422871, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, 0.2885726992822718, 2.2639087302979823, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, 0.21590580536007686, 2.2093564865728146, -0.04662123679246273, -0.14106852214680915, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, -0.08904460951967552, -0.22049944857796966, 2.47944955092491, -0.22825425296243224, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 1.7623686513065309, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static void gpc_sCp(Pixel *out, const Pixel *in, const Background *back) { (void)back; if (in->a <= 128) { out->r = out->g = out->b = 255; out->a = 0; } else { out->r = sRGB((double)in->r / in->a); out->g = sRGB((double)in->g / in->a); out->b = sRGB((double)in->b / in->a); out->a = u8d(in->a / 257.); } }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void transform_disable(PNG_CONST char *name) { image_transform *list = image_transform_first; while (list != &image_transform_end) { if (strcmp(list->name, name) == 0) { list->enable = 0; return; } list = list->list; } fprintf(stderr, "pngvalid: --transform-disable=%s: unknown transform\n", name); exit(99); }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void image_transform_mod_end(PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp, PNG_CONST transform_display *display) { PNG_CONST unsigned int scale = (1U<<that->sample_depth)-1; UNUSED(this) UNUSED(pp) UNUSED(display) that->red = sample_scale(that->redf, scale); that->rede += 1./(2*((1U<<that->red_sBIT)-1)); if (that->colour_type & PNG_COLOR_MASK_COLOR) { that->green = sample_scale(that->greenf, scale); that->blue = sample_scale(that->bluef, scale); that->greene += 1./(2*((1U<<that->green_sBIT)-1)); that->bluee += 1./(2*((1U<<that->blue_sBIT)-1)); } else { that->blue = that->green = that->red; that->bluef = that->greenf = that->redf; that->bluee = that->greene = that->rede; } if ((that->colour_type & PNG_COLOR_MASK_ALPHA) || that->colour_type == PNG_COLOR_TYPE_PALETTE) { that->alpha = sample_scale(that->alphaf, scale); that->alphae += 1./(2*((1U<<that->alpha_sBIT)-1)); } else { that->alpha = scale; that->alpha = 1; that->alphae = 0; } }<SPLIT>[2.3752675960409144, 0.13409639756527525, 0.0, 2.320135801035673, 0.06165861146095288, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.4284248805206208, 2.4212136734715513, 0.1588898992878544, 0.0, 0.0, 0.30852482215402843, 0.3515211457698377, 2.3640473965426008, 0.08589816337610359, -0.39986248560786075, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void standard_info_part2(standard_display *dp, png_const_structp pp, png_const_infop pi, int nImages) { dp->pixel_size = bit_size(pp, png_get_color_type(pp, pi), png_get_bit_depth(pp, pi)); dp->bit_width = png_get_image_width(pp, pi) * dp->pixel_size; dp->cbRow = png_get_rowbytes(pp, pi); if (dp->cbRow != (dp->bit_width+7)/8) png_error(pp, "bad png_get_rowbytes calculation"); store_ensure_image(dp->ps, pp, nImages, dp->cbRow, dp->h); }<SPLIT>[0.21027592277004517, -0.3947818432810943, 0.0, 0.18995094088131478, -0.44903192919977347, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.33077267477327355, 0.21894446904158188, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, 0.19837465696559078, -0.44417943729816173, 0.11772544131424245, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.3070243011888601, 0.005287286955244392, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int chrm_modify(png_modifier *pm, png_modification *me, int add) { UNUSED(add) png_save_uint_32(pm->buffer, 32); png_save_uint_32(pm->buffer+ 4, CHUNK_cHRM); png_save_uint_32(pm->buffer+ 8, ((chrm_modification*)me)->wx); png_save_uint_32(pm->buffer+12, ((chrm_modification*)me)->wy); png_save_uint_32(pm->buffer+16, ((chrm_modification*)me)->rx); png_save_uint_32(pm->buffer+20, ((chrm_modification*)me)->ry); png_save_uint_32(pm->buffer+24, ((chrm_modification*)me)->gx); png_save_uint_32(pm->buffer+28, ((chrm_modification*)me)->gy); png_save_uint_32(pm->buffer+32, ((chrm_modification*)me)->bx); png_save_uint_32(pm->buffer+36, ((chrm_modification*)me)->by); return 1; }<SPLIT>[-0.09900860198293619, -0.30663546980669937, 0.0, -0.11436118199787926, -0.36391683908965244, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.29081490870517385, -0.09566541730555662, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.11100716297398205, -0.3558331705191175, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void insert_zTXt(png_structp png_ptr, png_infop info_ptr, int nparams, png_charpp params) { png_text text; check_param_count(nparams, 2); clear_text(&text, params[0]); text.compression = 0; set_text(png_ptr, info_ptr, &text, params[1]); }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>png_size_t png_check_keyword(png_structp png_ptr, png_charp key, png_charpp new_key) { png_size_t key_len; png_charp kp, dp; int kflag; int kwarn=0; png_debug(1, "in png_check_keyword\n"); *new_key = NULL; if (key == NULL || (key_len = png_strlen(key)) == 0) { png_warning(png_ptr, "zero length keyword"); return ((png_size_t)0); } png_debug1(2, "Keyword to be checked is '%s'\n", key); *new_key = (png_charp)png_malloc_warn(png_ptr, (png_uint_32)(key_len + 2)); if (*new_key == NULL) { png_warning(png_ptr, "Out of memory while procesing keyword"); return ((png_size_t)0); } for (kp = key, dp = *new_key; *kp != '\0'; kp++, dp++) { if ((png_byte)*kp < 0x20 || ((png_byte)*kp > 0x7E && (png_byte)*kp < 0xA1)) { #if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE) char msg[40]; png_snprintf(msg, 40, "invalid keyword character 0x%02X", (png_byte)*kp); png_warning(png_ptr, msg); #else png_warning(png_ptr, "invalid character in keyword"); #endif *dp = ' '; } else { *dp = *kp; } } *dp = '\0'; kp = *new_key + key_len - 1; if (*kp == ' ') { png_warning(png_ptr, "trailing spaces removed from keyword"); while (*kp == ' ') { *(kp--) = '\0'; key_len--; } } kp = *new_key; if (*kp == ' ') { png_warning(png_ptr, "leading spaces removed from keyword"); while (*kp == ' ') { kp++; key_len--; } } png_debug1(2, "Checking for multiple internal spaces in '%s'\n", kp); for (kflag = 0, dp = *new_key; *kp != '\0'; kp++) { if (*kp == ' ' && kflag == 0) { *(dp++) = *kp; kflag = 1; } else if (*kp == ' ') { key_len--; kwarn=1; } else { *(dp++) = *kp; kflag = 0; } } *dp = '\0'; if (kwarn) png_warning(png_ptr, "extra interior spaces removed from keyword"); if (key_len == 0) { png_free(png_ptr, *new_key); *new_key=NULL; png_warning(png_ptr, "Zero length keyword"); } if (key_len > 79) { png_warning(png_ptr, "keyword length must be 1 - 79 characters"); new_key[79] = '\0'; key_len = 79; } return (key_len); }<SPLIT>[2.684552120793896, 1.5003651864183964, 0.0, 2.6244479239148673, 1.4022212806953596, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, -0.27925050329511203, 1.7070733946998113, 2.73582355981869, 1.4808769507678954, 0.0, 0.0, 0.30852482215402843, 1.6301800696332969, 2.6734292164821736, 1.3669190316722448, 0.37651940477529405, -0.07965011232897776, 0.0, 0.02378964451747194, 2.1569430876889752, 0.9571545682411045, 0.18343000506680518, 0.23107402248845843, -0.21702784222394986, 0.14602883551895066, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, -0.27935383381430245, 0.04889276383167627, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, -0.28182971586402455]
0<SPLIT>static void perform_gamma_scale16_tests(png_modifier *pm) { #ifndef PNG_MAX_GAMMA_8 #define PNG_MAX_GAMMA_8 11 #endif #define SBIT_16_TO_8 PNG_MAX_GAMMA_8 unsigned int i, j; for (i=0; i<pm->ngamma_tests; ++i) { for (j=0; j<pm->ngamma_tests; ++j) { if (i != j && fabs(pm->gammas[j]/pm->gammas[i]-1) >= PNG_GAMMA_THRESHOLD) { gamma_transform_test(pm, 0, 16, 0, pm->interlace_type, 1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8, pm->use_input_precision_16to8, 1 ); if (fail(pm)) return; gamma_transform_test(pm, 2, 16, 0, pm->interlace_type, 1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8, pm->use_input_precision_16to8, 1 ); if (fail(pm)) return; gamma_transform_test(pm, 4, 16, 0, pm->interlace_type, 1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8, pm->use_input_precision_16to8, 1 ); if (fail(pm)) return; gamma_transform_test(pm, 6, 16, 0, pm->interlace_type, 1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8, pm->use_input_precision_16to8, 1 ); if (fail(pm)) return; } } } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.9507312480792999, 0.12549492904354367, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.23527942541861413, -0.26569807294376846, -0.7092182376352943, -0.917450412529964, -0.518115519420462, 0.0, 4.984905825341554, 2.736734056147358, -0.2373385487108316, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void writepng_error_handler(png_structp png_ptr, png_const_charp msg) { mainprog_info *mainprog_ptr; fprintf(stderr, "writepng libpng error: %s\n", msg); fflush(stderr); mainprog_ptr = png_get_error_ptr(png_ptr); if (mainprog_ptr == NULL) { fprintf(stderr, "writepng severe error: jmpbuf not recoverable; terminating.\n"); fflush(stderr); exit(99); } longjmp(mainprog_ptr->jmpbuf, 1); }<SPLIT>[2.065983071287933, -0.3507086565438968, 0.0, 2.015823678156479, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.051068312296575644, 2.106603787124413, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.09407211557651925, 2.054665576603028, -0.37791973721387856, -0.14106852214680915, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.3070243011888601, -0.22049944857796966, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static png_uint_32 png_log8bit(unsigned x) { if (x > 0) return (png_uint_32)floor(.5-log(x/255.)*L2INV); return 0xffffffff; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.7880534307994381, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>void PNGAPI png_read_row(png_structrp png_ptr, png_bytep row, png_bytep dsp_row) { png_row_info row_info; if (png_ptr == NULL) return; png_debug2(1, "in png_read_row (row %lu, pass %d)", (unsigned long)png_ptr->row_number, png_ptr->pass); if (!(png_ptr->flags & PNG_FLAG_ROW_INIT)) png_read_start_row(png_ptr); row_info.width = png_ptr->iwidth; row_info.color_type = png_ptr->color_type; row_info.bit_depth = png_ptr->bit_depth; row_info.channels = png_ptr->channels; row_info.pixel_depth = png_ptr->pixel_depth; row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_depth, row_info.width); if (png_ptr->row_number == 0 && png_ptr->pass == 0) { #if defined(PNG_WRITE_INVERT_SUPPORTED) && !defined(PNG_READ_INVERT_SUPPORTED) if (png_ptr->transformations & PNG_INVERT_MONO) png_warning(png_ptr, "PNG_READ_INVERT_SUPPORTED is not defined"); #endif #if defined(PNG_WRITE_FILLER_SUPPORTED) && !defined(PNG_READ_FILLER_SUPPORTED) if (png_ptr->transformations & PNG_FILLER) png_warning(png_ptr, "PNG_READ_FILLER_SUPPORTED is not defined"); #endif #if defined(PNG_WRITE_PACKSWAP_SUPPORTED) && \ !defined(PNG_READ_PACKSWAP_SUPPORTED) if (png_ptr->transformations & PNG_PACKSWAP) png_warning(png_ptr, "PNG_READ_PACKSWAP_SUPPORTED is not defined"); #endif #if defined(PNG_WRITE_PACK_SUPPORTED) && !defined(PNG_READ_PACK_SUPPORTED) if (png_ptr->transformations & PNG_PACK) png_warning(png_ptr, "PNG_READ_PACK_SUPPORTED is not defined"); #endif #if defined(PNG_WRITE_SHIFT_SUPPORTED) && !defined(PNG_READ_SHIFT_SUPPORTED) if (png_ptr->transformations & PNG_SHIFT) png_warning(png_ptr, "PNG_READ_SHIFT_SUPPORTED is not defined"); #endif #if defined(PNG_WRITE_BGR_SUPPORTED) && !defined(PNG_READ_BGR_SUPPORTED) if (png_ptr->transformations & PNG_BGR) png_warning(png_ptr, "PNG_READ_BGR_SUPPORTED is not defined"); #endif #if defined(PNG_WRITE_SWAP_SUPPORTED) && !defined(PNG_READ_SWAP_SUPPORTED) if (png_ptr->transformations & PNG_SWAP_BYTES) png_warning(png_ptr, "PNG_READ_SWAP_SUPPORTED is not defined"); #endif } #ifdef PNG_READ_INTERLACING_SUPPORTED if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE)) { switch (png_ptr->pass) { case 0: if (png_ptr->row_number & 0x07) { if (dsp_row != NULL) png_combine_row(png_ptr, dsp_row, 1); png_read_finish_row(png_ptr); return; } break; case 1: if ((png_ptr->row_number & 0x07) || png_ptr->width < 5) { if (dsp_row != NULL) png_combine_row(png_ptr, dsp_row, 1); png_read_finish_row(png_ptr); return; } break; case 2: if ((png_ptr->row_number & 0x07) != 4) { if (dsp_row != NULL && (png_ptr->row_number & 4)) png_combine_row(png_ptr, dsp_row, 1); png_read_finish_row(png_ptr); return; } break; case 3: if ((png_ptr->row_number & 3) || png_ptr->width < 3) { if (dsp_row != NULL) png_combine_row(png_ptr, dsp_row, 1); png_read_finish_row(png_ptr); return; } break; case 4: if ((png_ptr->row_number & 3) != 2) { if (dsp_row != NULL && (png_ptr->row_number & 2)) png_combine_row(png_ptr, dsp_row, 1); png_read_finish_row(png_ptr); return; } break; case 5: if ((png_ptr->row_number & 1) || png_ptr->width < 2) { if (dsp_row != NULL) png_combine_row(png_ptr, dsp_row, 1); png_read_finish_row(png_ptr); return; } break; default: case 6: if (!(png_ptr->row_number & 1)) { png_read_finish_row(png_ptr); return; } break; } } #endif if (!(png_ptr->mode & PNG_HAVE_IDAT)) png_error(png_ptr, "Invalid attempt to read row data"); png_read_IDAT_data(png_ptr, png_ptr->row_buf, row_info.rowbytes + 1); if (png_ptr->row_buf[0] > PNG_FILTER_VALUE_NONE) { if (png_ptr->row_buf[0] < PNG_FILTER_VALUE_LAST) png_read_filter_row(png_ptr, &row_info, png_ptr->row_buf + 1, png_ptr->prev_row + 1, png_ptr->row_buf[0]); else png_error(png_ptr, "bad adaptive filter value"); } memcpy(png_ptr->prev_row, png_ptr->row_buf, row_info.rowbytes + 1); #ifdef PNG_MNG_FEATURES_SUPPORTED if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) && (png_ptr->filter_type == PNG_INTRAPIXEL_DIFFERENCING)) { png_do_read_intrapixel(&row_info, png_ptr->row_buf + 1); } #endif #ifdef PNG_READ_TRANSFORMS_SUPPORTED if (png_ptr->transformations) png_do_read_transformations(png_ptr, &row_info); #endif if (png_ptr->transformed_pixel_depth == 0) { png_ptr->transformed_pixel_depth = row_info.pixel_depth; if (row_info.pixel_depth > png_ptr->maximum_pixel_depth) png_error(png_ptr, "sequential row overflow"); } else if (png_ptr->transformed_pixel_depth != row_info.pixel_depth) png_error(png_ptr, "internal sequential row size calculation error"); #ifdef PNG_READ_INTERLACING_SUPPORTED if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE)) { if (png_ptr->pass < 6) png_do_read_interlace(&row_info, png_ptr->row_buf + 1, png_ptr->pass, png_ptr->transformations); if (dsp_row != NULL) png_combine_row(png_ptr, dsp_row, 1); if (row != NULL) png_combine_row(png_ptr, row, 0); } else #endif { if (row != NULL) png_combine_row(png_ptr, row, -1); if (dsp_row != NULL) png_combine_row(png_ptr, dsp_row, -1); } png_read_finish_row(png_ptr); if (png_ptr->read_row_fn != NULL) (*(png_ptr->read_row_fn))(png_ptr, png_ptr->row_number, png_ptr->pass); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 8.710690381498749, 2.9981292202601297, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 3.838772756306544, 5.457865595938329, 0.3730235304079973, -0.7880534307994381, -0.518115519420462, 0.0, 13.584173872103296, 13.172971488398254, 1.4490046752213135, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>PNG_NORETURN static void stop_invalid(struct file *file, const char *what) { stop(file, INVALID_ERROR_CODE, what); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int testimage(Image *image, png_uint_32 opts, format_list *pf) { int result; Image copy; checkopaque(image); copy = *image; copy.opts = opts; copy.buffer = NULL; copy.bufsize = 0; copy.allocsize = 0; image->input_file = NULL; image->input_memory = NULL; image->input_memory_size = 0; image->tmpfile_name[0] = 0; { png_uint_32 counter; Image output; newimage(&output); result = 1; for (counter=0; counter<2*FORMAT_COUNT; ++counter) if (format_isset(pf, counter >> 1)) { png_uint_32 format = counter >> 1; png_color background_color; png_colorp background = NULL; if ((counter & 1) == 0) { if ((format & PNG_FORMAT_FLAG_ALPHA) == 0 && (image->image.format & PNG_FORMAT_FLAG_ALPHA) != 0) { random_color(&background_color); background = &background_color; if ((format & PNG_FORMAT_FLAG_COLORMAP) != 0 && (format & PNG_FORMAT_FLAG_LINEAR) == 0) ++counter; } else ++counter; } resetimage(&copy); copy.opts = opts; result = read_file(&copy, format, background); if (!result) break; result = compare_two_images(image, &copy, 0, background); if (!result) break; #ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED output.opts = opts; result = write_one_file(&output, &copy, 0); if (!result) break; result = compare_two_images(image, &output, 0, background); if (!result) break; if ((format & PNG_FORMAT_FLAG_LINEAR) != 0 && (format & PNG_FORMAT_FLAG_COLORMAP) == 0) { output.opts = opts; result = write_one_file(&output, &copy, 1); if (!result) break; result = compare_two_images(image, &output, 1, background); if (!result) break; } #endif } freeimage(&output); } freeimage(&copy); return result; }<SPLIT>[6.08668189307669, 0.9935235389406257, 0.0, 5.971881275586002, 0.8915307400346333, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 1.6870945116657614, 3.365043332512967, 0.5691617428506257, 0.0, 0.0, 0.30852482215402843, 1.572059209457685, 3.292192856361319, 0.4834563638818026, 0.37651940477529405, -0.2988828158747199, 0.0, 3.9926825891767375, 0.9973611507722091, 0.8517581167453454, -0.08904460951967552, 0.23107402248845843, -0.21702784222394986, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_gray_to_rgb_mod(PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp, PNG_CONST transform_display *display) { if ((that->colour_type & PNG_COLOR_MASK_COLOR) == 0 && that->have_tRNS) image_pixel_add_alpha(that, &display->this); if (that->colour_type == PNG_COLOR_TYPE_GRAY) { if (that->bit_depth < 8) that->sample_depth = that->bit_depth = 8; that->colour_type = PNG_COLOR_TYPE_RGB; } else if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA) that->colour_type = PNG_COLOR_TYPE_RGB_ALPHA; this->next->mod(this->next, that, pp, display); }<SPLIT>[1.2927717594054797, -0.2845988764381006, 0.0, 1.2550433709584938, -0.34263806656212215, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.09102607836467534, 1.3200790712565666, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.152192975752131, 1.281211026754096, -0.33374660382435645, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5250039928580447, -0.6720729196443977, 0.6817979554923368, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static unsigned int sample(png_const_bytep row, png_byte colour_type, png_byte bit_depth, png_uint_32 x, unsigned int sample_index) { png_uint_32 bit_index, result; x *= bit_depth; bit_index = x; if ((colour_type & 1) == 0) { if (colour_type & 2) bit_index *= 3; if (colour_type & 4) bit_index += x; if (colour_type & (2+4)) bit_index += sample_index * bit_depth; } row += bit_index >> 3; result = *row; if (bit_depth == 8) return result; else if (bit_depth > 8) return (result << 8) + *++row; bit_index &= 7; return (result >> (8-bit_index-bit_depth)) & ((1U<<bit_depth)-1); }<SPLIT>[0.36491818514653585, -0.10830612948931077, 0.0, 0.34210700232091185, -0.17240788634188003, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.051068312296575644, 0.3762494122151511, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.1134457356350565, 0.35306556693537716, -0.157054070266268, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>BOOL FillBitmap (BYTE *pDiData, int cxWinSize, int cyWinSize, BYTE *pbImage, int cxImgSize, int cyImgSize, int cImgChannels, BOOL bStretched) { BYTE *pStretchedImage; BYTE *pImg; BYTE *src, *dst; BYTE r, g, b, a; const int cDIChannels = 3; WORD wImgRowBytes; WORD wDIRowBytes; int cxNewSize, cyNewSize; int cxImgPos, cyImgPos; int xImg, yImg; int xWin, yWin; int xOld, yOld; int xNew, yNew; if (bStretched) { cxNewSize = cxWinSize - 2 * MARGIN; cyNewSize = cyWinSize - 2 * MARGIN; if ((cyNewSize * cxImgSize) > (cyImgSize * cxNewSize)) { cyNewSize = cxNewSize * cyImgSize / cxImgSize; cxImgPos = MARGIN; cyImgPos = (cyWinSize - cyNewSize) / 2; } else { cxNewSize = cyNewSize * cxImgSize / cyImgSize; cyImgPos = MARGIN; cxImgPos = (cxWinSize - cxNewSize) / 2; } pStretchedImage = malloc (cImgChannels * cxNewSize * cyNewSize); pImg = pStretchedImage; for (yNew = 0; yNew < cyNewSize; yNew++) { yOld = yNew * cyImgSize / cyNewSize; for (xNew = 0; xNew < cxNewSize; xNew++) { xOld = xNew * cxImgSize / cxNewSize; r = *(pbImage + cImgChannels * ((yOld * cxImgSize) + xOld) + 0); g = *(pbImage + cImgChannels * ((yOld * cxImgSize) + xOld) + 1); b = *(pbImage + cImgChannels * ((yOld * cxImgSize) + xOld) + 2); *pImg++ = r; *pImg++ = g; *pImg++ = b; if (cImgChannels == 4) { a = *(pbImage + cImgChannels * ((yOld * cxImgSize) + xOld) + 3); *pImg++ = a; } } } wImgRowBytes = cImgChannels * cxNewSize; wDIRowBytes = (WORD) ((cDIChannels * cxWinSize + 3L) >> 2) << 2; for (yImg = 0, yWin = cyImgPos; yImg < cyNewSize; yImg++, yWin++) { if (yWin >= cyWinSize - cyImgPos) break; src = pStretchedImage + yImg * wImgRowBytes; dst = pDiData + yWin * wDIRowBytes + cxImgPos * cDIChannels; for (xImg = 0, xWin = cxImgPos; xImg < cxNewSize; xImg++, xWin++) { if (xWin >= cxWinSize - cxImgPos) break; r = *src++; g = *src++; b = *src++; *dst++ = b; *dst++ = g; *dst++ = r; if (cImgChannels == 4) { a = *src++; } } } if (pStretchedImage != NULL) { free (pStretchedImage); pStretchedImage = NULL; } } else { cxImgPos = (cxWinSize - cxImgSize) / 2; cyImgPos = (cyWinSize - cyImgSize) / 2; if (cxImgPos < MARGIN) cxImgPos = MARGIN; if (cyImgPos < MARGIN) cyImgPos = MARGIN; wImgRowBytes = cImgChannels * cxImgSize; wDIRowBytes = (WORD) ((cDIChannels * cxWinSize + 3L) >> 2) << 2; for (yImg = 0, yWin = cyImgPos; yImg < cyImgSize; yImg++, yWin++) { if (yWin >= cyWinSize - MARGIN) break; src = pbImage + yImg * wImgRowBytes; dst = pDiData + yWin * wDIRowBytes + cxImgPos * cDIChannels; for (xImg = 0, xWin = cxImgPos; xImg < cxImgSize; xImg++, xWin++) { if (xWin >= cxWinSize - MARGIN) break; r = *src++; g = *src++; b = *src++; *dst++ = b; *dst++ = g; *dst++ = r; if (cImgChannels == 4) { a = *src++; } } } } return TRUE; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 1.7115115552772848, 1.8916330488285558, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 1.940157990569893, 1.7452837566634551, 1.9853428991255544, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 2.0462512336972813, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>void png_write_data(png_structp png_ptr, png_const_bytep data, png_size_t length) { if (png_ptr->write_data_fn != NULL ) (*(png_ptr->write_data_fn))(png_ptr, (png_bytep)data, length); else png_error(png_ptr, "Call to NULL write function"); }<SPLIT>[-0.09900860198293619, -0.4829282167554892, 0.0, -0.11436118199787926, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.09566541730555662, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.11100716297398205, -0.5325257040772059, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int main(int argc, char **argv) { int err = 0; printf("\n"); if (argc > 1) { int i; for (i=1; i<argc; ++i) { FILE *ip = fopen(argv[i], "rb"); if (ip == NULL || !read_one_file(ip, argv[i])) { err = 1; perror(argv[i]); fprintf(stderr, "%s: read error\n", argv[i]); printf("\n", argv[i]); } (void)fclose(ip); } } else { if (!read_one_file(stdin, "-")) { err = 1; perror("stdin"); fprintf(stderr, "stdin: read error\n"); printf("\n"); } } return err; }<SPLIT>[-0.25365086435942685, 0.04595002409088034, 0.0, -0.2665172434374763, -0.0021777061216379156, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 0.008868336805573909, -0.25297036047912586, 0.06771837849612745, 0.0, 0.0, 0.30852482215402843, -0.03595125540090747, -0.26569807294376846, 0.01963846329182043, 0.24712242304476825, 0.9068970536268617, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, 0.5103995425705821, 0.11818065472185141, -0.21702784222394986, 0.8010242403613708, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 1.7623686513065309, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
1<SPLIT>void PNGAPI png_set_iCCP(png_structp png_ptr, png_infop info_ptr, png_charp name, int compression_type, png_charp profile, png_uint_32 proflen) { png_charp new_iccp_name; png_charp new_iccp_profile; png_debug1(1, "in %s storage function\n", "iCCP"); if (png_ptr == NULL || info_ptr == NULL || name == NULL || profile == NULL) return; new_iccp_name = (png_charp)png_malloc_warn(png_ptr, png_strlen(name)+1); if (new_iccp_name == NULL) { png_warning(png_ptr, "Insufficient memory to process iCCP chunk."); return; } png_strcpy(new_iccp_name, name); new_iccp_profile = (png_charp)png_malloc_warn(png_ptr, proflen); if (new_iccp_profile == NULL) { png_free (png_ptr, new_iccp_name); png_warning(png_ptr, "Insufficient memory to process iCCP profile."); return; } png_memcpy(new_iccp_profile, profile, (png_size_t)proflen); png_free_data(png_ptr, info_ptr, PNG_FREE_ICCP, 0); info_ptr->iccp_proflen = proflen; info_ptr->iccp_name = new_iccp_name; info_ptr->iccp_profile = new_iccp_profile; info_ptr->iccp_compression = (png_byte)compression_type; #ifdef PNG_FREE_ME_SUPPORTED info_ptr->free_me |= PNG_FREE_ICCP; #endif info_ptr->valid |= PNG_INFO_iCCP; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.6464191252001059, 0.06165861146095288, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.13841132512592785, 0.66244738687495, -0.0024481034029406237, -0.7880534307994381, -0.518115519420462, 0.0, 0.02378964451747194, 1.5771521192305922, 0.00858650477927287, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static png_uint_16 ilineara_g22(int fixed_srgb, int alpha) { return u16d((257 * alpha) * g22_to_d[fixed_srgb]); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void modifier_setbuffer(png_modifier *pm) { modifier_crc(pm->buffer); pm->buffer_count = png_get_uint_32(pm->buffer)+12; pm->buffer_position = 0; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void perform_interlace_macro_validation(void) { int pass; for (pass=0; pass<7; ++pass) { png_uint_32 m, f, v; m = PNG_PASS_START_ROW(pass); f = png_pass_start_row(pass); if (m != f) { fprintf(stderr, "PNG_PASS_START_ROW(%d) = %u != %x\n", pass, m, f); exit(99); } m = PNG_PASS_START_COL(pass); f = png_pass_start_col(pass); if (m != f) { fprintf(stderr, "PNG_PASS_START_COL(%d) = %u != %x\n", pass, m, f); exit(99); } m = PNG_PASS_ROW_SHIFT(pass); f = png_pass_row_shift(pass); if (m != f) { fprintf(stderr, "PNG_PASS_ROW_SHIFT(%d) = %u != %x\n", pass, m, f); exit(99); } m = PNG_PASS_COL_SHIFT(pass); f = png_pass_col_shift(pass); if (m != f) { fprintf(stderr, "PNG_PASS_COL_SHIFT(%d) = %u != %x\n", pass, m, f); exit(99); } for (v=0;;) { m = PNG_ROW_FROM_PASS_ROW(v, pass); f = png_row_from_pass_row(v, pass); if (m != f) { fprintf(stderr, "PNG_ROW_FROM_PASS_ROW(%u, %d) = %u != %x\n", v, pass, m, f); exit(99); } m = PNG_COL_FROM_PASS_COL(v, pass); f = png_col_from_pass_col(v, pass); if (m != f) { fprintf(stderr, "PNG_COL_FROM_PASS_COL(%u, %d) = %u != %x\n", v, pass, m, f); exit(99); } m = PNG_ROW_IN_INTERLACE_PASS(v, pass); f = png_row_in_interlace_pass(v, pass); if (m != f) { fprintf(stderr, "PNG_ROW_IN_INTERLACE_PASS(%u, %d) = %u != %x\n", v, pass, m, f); exit(99); } m = PNG_COL_IN_INTERLACE_PASS(v, pass); f = png_col_in_interlace_pass(v, pass); if (m != f) { fprintf(stderr, "PNG_COL_IN_INTERLACE_PASS(%u, %d) = %u != %x\n", v, pass, m, f); exit(99); } ++v; m = PNG_PASS_ROWS(v, pass); f = png_pass_rows(v, pass); if (m != f) { fprintf(stderr, "PNG_PASS_ROWS(%u, %d) = %u != %x\n", v, pass, m, f); exit(99); } m = PNG_PASS_COLS(v, pass); f = png_pass_cols(v, pass); if (m != f) { fprintf(stderr, "PNG_PASS_COLS(%u, %d) = %u != %x\n", v, pass, m, f); exit(99); } if (v > 1024) { if (v == PNG_UINT_31_MAX) break; v = (v << 1) ^ v; if (v >= PNG_UINT_31_MAX) v = PNG_UINT_31_MAX-1; } } } }<SPLIT>[2.9938366455468772, 1.4783285930497976, 0.0, 2.9287600467940615, 1.3596637356402992, 0.0, 2.012926629492729, 2.0550665266879453, 1.9009835481817232, 4.33830903797686, 1.727052277733861, 3.0504334461658287, 1.5492555913616908, 0.0, 0.0, 0.30852482215402843, 1.6108064495747596, 2.9828110364217464, 1.4331787317565279, 2.1880771490026554, 1.0165134053997327, 0.0, -0.08645738172306322, -0.16222078614455715, 1.0625510197368635, 2.145247230089466, 1.8115811712209564, 2.47944955092491, 1.9238735058055194, 2.0120796502306875, 2.054334035657505, 1.9001995881092162, 4.337076945700922, 2.6191065950439585, 0.0, 2.006502564725563, 2.048721569378853, 1.8946705667433963, 4.3273853535149875]
0<SPLIT>static void buffer_destroy_list(struct buffer_list *list) { if (list != NULL) { struct buffer_list *next = list->next; DELETE(list); buffer_destroy_list(next); } }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.3615192241061562, -0.4462861841111837, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void gpc_pre(Pixel *out, const Pixel *in, const Background *back) { (void)back; out->r = ilineara(in->r, in->a); if (in->g == in->r) { out->g = out->r; if (in->b == in->r) out->b = out->r; else out->b = ilineara(in->b, in->a); } else { out->g = ilineara(in->g, in->a); if (in->b == in->r) out->b = out->r; else if (in->b == in->g) out->b = out->g; else out->b = ilineara(in->b, in->a); } out->a = in->a * 257; }<SPLIT>[-0.25365086435942685, -0.10830612948931077, 0.0, -0.2665172434374763, -0.17240788634188003, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.13098384443277505, -0.25297036047912586, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, -0.26569807294376846, -0.157054070266268, -0.6586564490689124, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static png_uint_32 crc_one_byte(png_uint_32 crc, int b) { return crc_table[(crc ^ b) & 0xff] ^ (crc >> 8); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void modifier_current_encoding(PNG_CONST png_modifier *pm, color_encoding *ce) { if (pm->current_encoding != 0) *ce = *pm->current_encoding; else memset(ce, 0, sizeof *ce); ce->gamma = pm->current_gamma; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void row_copy(png_bytep toBuffer, png_const_bytep fromBuffer, unsigned int bitWidth) { memcpy(toBuffer, fromBuffer, bitWidth >> 3); if ((bitWidth & 7) != 0) { unsigned int mask; toBuffer += bitWidth >> 3; fromBuffer += bitWidth >> 3; mask = 0xff >> (bitWidth & 7); *toBuffer = (png_byte)((*toBuffer & mask) | (*fromBuffer & ~mask)); } }<SPLIT>[0.21027592277004517, -0.3727452499124955, 0.0, 0.18995094088131478, -0.42775315667224323, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3107937917392237, 0.21894446904158188, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, 0.19837465696559078, -0.42209287060340067, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static png_uint_32 png_col_from_pass_col(png_uint_32 xIn, int pass) { switch (pass) { case 0: return xIn * 8; case 1: return xIn * 8 + 4; case 2: return xIn * 4; case 3: return xIn * 4 + 2; case 4: return xIn * 2; case 5: return xIn * 2 + 1; case 6: return xIn; default: break; } return 0xff; }<SPLIT>[-0.09900860198293619, -0.30663546980669937, 0.0, -0.11436118199787926, -0.36391683908965244, 0.0, 0.7963739706959416, -0.2425966915157195, 0.7400896423242515, 2.0295292673408736, -0.29081490870517385, -0.09566541730555662, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.11100716297398205, -0.3558331705191175, -0.7880534307994381, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, 0.29241985090139744, -0.7849662874110047, 6.074752741790056, 0.5203119240003335, 0.7958385171580944, -0.24285292239137013, 0.7395912368182198, 2.0288615559433096, 0.04889276383167627, 0.0, 0.791794928969486, -0.24561270062351, 0.7355972453213037, 2.0227778188254817]
0<SPLIT>static void buffer_start_read(struct buffer *buffer) { buffer->current = &buffer->first; buffer->read_count = 0; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void display_destroy(struct display *dp) { #ifdef PNG_WRITE_SUPPORTED buffer_destroy(&dp->written_file); #endif buffer_destroy(&dp->original_file); }<SPLIT>[-0.09900860198293619, -0.4829282167554892, 0.0, -0.11436118199787926, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.09566541730555662, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.11100716297398205, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, 0.02378964451747194, 0.9973611507722091, -0.6237922041952815, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_rgb_to_gray_set(PNG_CONST image_transform *this, transform_display *that, png_structp pp, png_infop pi) { PNG_CONST int error_action = 1; #ifdef PNG_FLOATING_POINT_SUPPORTED png_set_rgb_to_gray(pp, error_action, data.red_to_set, data.green_to_set); #else png_set_rgb_to_gray_fixed(pp, error_action, data.red_to_set, data.green_to_set); #endif #ifdef PNG_READ_cHRM_SUPPORTED if (that->pm->current_encoding != 0) { #ifdef PNG_FLOATING_POINT_SUPPORTED #define API_function png_get_cHRM_XYZ #define API_form "FP" #define API_type double #define API_cvt(x) (x) #else #define API_function png_get_cHRM_XYZ_fixed #define API_form "fixed" #define API_type png_fixed_point #define API_cvt(x) ((double)(x)/PNG_FP_1) #endif API_type rX, gX, bX; API_type rY, gY, bY; API_type rZ, gZ, bZ; if ((API_function(pp, pi, &rX, &rY, &rZ, &gX, &gY, &gZ, &bX, &bY, &bZ) & PNG_INFO_cHRM) != 0) { double maxe; PNG_CONST char *el; color_encoding e, o; modifier_current_encoding(that->pm, &o); normalize_color_encoding(&o); if (data.red_to_set == -1 && data.green_to_set == -1 && (fabs(o.red.Y - data.red_coefficient) > DBL_EPSILON || fabs(o.green.Y - data.green_coefficient) > DBL_EPSILON || fabs(o.blue.Y - data.blue_coefficient) > DBL_EPSILON)) png_error(pp, "internal pngvalid cHRM coefficient error"); e.gamma = o.gamma; e.red.X = API_cvt(rX); e.red.Y = API_cvt(rY); e.red.Z = API_cvt(rZ); e.green.X = API_cvt(gX); e.green.Y = API_cvt(gY); e.green.Z = API_cvt(gZ); e.blue.X = API_cvt(bX); e.blue.Y = API_cvt(bY); e.blue.Z = API_cvt(bZ); maxe = 0; el = "-"; #define CHECK(col,x)\ {\ double err = fabs(o.col.x - e.col.x);\ if (err > maxe)\ {\ maxe = err;\ el = #col "(" #x ")";\ }\ } CHECK(red,X) CHECK(red,Y) CHECK(red,Z) CHECK(green,X) CHECK(green,Y) CHECK(green,Z) CHECK(blue,X) CHECK(blue,Y) CHECK(blue,Z) if (maxe >= 1E-5) { size_t pos = 0; char buffer[256]; pos = safecat(buffer, sizeof buffer, pos, API_form); pos = safecat(buffer, sizeof buffer, pos, " cHRM "); pos = safecat(buffer, sizeof buffer, pos, el); pos = safecat(buffer, sizeof buffer, pos, " error: "); pos = safecatd(buffer, sizeof buffer, pos, maxe, 7); pos = safecat(buffer, sizeof buffer, pos, " "); pos = safecat_color_encoding(buffer, sizeof buffer, pos, &o, 0); pos = safecat(buffer, sizeof buffer, pos, " -> "); pos = safecat_color_encoding(buffer, sizeof buffer, pos, &e, 0); png_error(pp, buffer); } } } #endif this->next->set(this->next, that, pp, pi); }<SPLIT>[2.9938366455468772, 1.3461090328382055, 0.0, 2.9287600467940615, 1.2319911004751174, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 1.607178979529562, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, 1.494564729223536, -0.26569807294376846, -0.5104391373824448, -0.5292594673383866, -0.518115519420462, 0.0, 10.717751189849382, 10.27401664610634, 0.7112295147509999, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void clear_text(png_text *text, png_charp keyword) { text->compression = -1; text->key = keyword; text->text = NULL; text->text_length = 0; text->itxt_length = 0; text->lang = NULL; text->lang_key = NULL; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>void PNGAPI png_set_iCCP(png_structp png_ptr, png_infop info_ptr, png_charp name, int compression_type, png_charp profile, png_uint_32 proflen) { png_charp new_iccp_name; png_charp new_iccp_profile; png_debug1(1, "in %s storage function\n", "iCCP"); if (png_ptr == NULL || info_ptr == NULL || name == NULL || profile == NULL) return; new_iccp_name = (png_charp)png_malloc_warn(png_ptr, png_strlen(name)+1); if (new_iccp_name == NULL) { png_warning(png_ptr, "Insufficient memory to process iCCP chunk."); return; } png_strcpy(new_iccp_name, name); new_iccp_profile = (png_charp)png_malloc_warn(png_ptr, proflen); if (new_iccp_profile == NULL) { png_free (png_ptr, new_iccp_name); png_warning(png_ptr, "Insufficient memory to process iCCP profile."); return; } png_memcpy(new_iccp_profile, profile, (png_size_t)proflen); png_free_data(png_ptr, info_ptr, PNG_FREE_ICCP, 0); info_ptr->iccp_proflen = proflen; info_ptr->iccp_name = new_iccp_name; info_ptr->iccp_profile = new_iccp_profile; info_ptr->iccp_compression = (png_byte)compression_type; #ifdef PNG_FREE_ME_SUPPORTED info_ptr->free_me |= PNG_FREE_ICCP; #endif info_ptr->valid |= PNG_INFO_iCCP; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.6464191252001059, 0.06165861146095288, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.13841132512592785, 0.66244738687495, -0.0024481034029406237, -0.7880534307994381, -0.518115519420462, 0.0, 0.02378964451747194, 1.5771521192305922, 0.00858650477927287, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>void PNGCBAPI count_zero_samples(png_structp png_ptr, png_row_infop row_info, png_bytep data) { png_bytep dp = data; if (png_ptr == NULL) return; if (row_info->color_type == 0 || row_info->color_type == 3) { int pos = 0; png_uint_32 n, nstop; for (n = 0, nstop=row_info->width; n<nstop; n++) { if (row_info->bit_depth == 1) { if (((*dp << pos++ ) & 0x80) == 0) zero_samples++; if (pos == 8) { pos = 0; dp++; } } if (row_info->bit_depth == 2) { if (((*dp << (pos+=2)) & 0xc0) == 0) zero_samples++; if (pos == 8) { pos = 0; dp++; } } if (row_info->bit_depth == 4) { if (((*dp << (pos+=4)) & 0xf0) == 0) zero_samples++; if (pos == 8) { pos = 0; dp++; } } if (row_info->bit_depth == 8) if (*dp++ == 0) zero_samples++; if (row_info->bit_depth == 16) { if ((*dp | *(dp+1)) == 0) zero_samples++; dp+=2; } } } else { png_uint_32 n, nstop; int channel; int color_channels = row_info->channels; if (row_info->color_type > 3)color_channels--; for (n = 0, nstop=row_info->width; n<nstop; n++) { for (channel = 0; channel < color_channels; channel++) { if (row_info->bit_depth == 8) if (*dp++ == 0) zero_samples++; if (row_info->bit_depth == 16) { if ((*dp | *(dp+1)) == 0) zero_samples++; dp+=2; } } if (row_info->color_type > 3) { dp++; if (row_info->bit_depth == 16) dp++; } } } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 1.102887309518897, 1.0404821477273452, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 1.0877187079942534, 1.1265201167843093, 1.1018802313351121, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3950401602637228, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static size_t safecat_color_encoding(char *buffer, size_t bufsize, size_t pos, PNG_CONST color_encoding *e, double encoding_gamma) { if (e != 0) { if (encoding_gamma != 0) pos = safecat(buffer, bufsize, pos, "("); pos = safecat(buffer, bufsize, pos, "R("); pos = safecatd(buffer, bufsize, pos, e->red.X, 4); pos = safecat(buffer, bufsize, pos, ","); pos = safecatd(buffer, bufsize, pos, e->red.Y, 4); pos = safecat(buffer, bufsize, pos, ","); pos = safecatd(buffer, bufsize, pos, e->red.Z, 4); pos = safecat(buffer, bufsize, pos, "),G("); pos = safecatd(buffer, bufsize, pos, e->green.X, 4); pos = safecat(buffer, bufsize, pos, ","); pos = safecatd(buffer, bufsize, pos, e->green.Y, 4); pos = safecat(buffer, bufsize, pos, ","); pos = safecatd(buffer, bufsize, pos, e->green.Z, 4); pos = safecat(buffer, bufsize, pos, "),B("); pos = safecatd(buffer, bufsize, pos, e->blue.X, 4); pos = safecat(buffer, bufsize, pos, ","); pos = safecatd(buffer, bufsize, pos, e->blue.Y, 4); pos = safecat(buffer, bufsize, pos, ","); pos = safecatd(buffer, bufsize, pos, e->blue.Z, 4); pos = safecat(buffer, bufsize, pos, ")"); if (encoding_gamma != 0) pos = safecat(buffer, bufsize, pos, ")"); } if (encoding_gamma != 0) { pos = safecat(buffer, bufsize, pos, "^"); pos = safecatd(buffer, bufsize, pos, encoding_gamma, 5); } return pos; }<SPLIT>[-0.25365086435942685, 0.15613299093387398, 0.0, -0.2665172434374763, 0.08293738398848315, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 0.10876275197582316, -0.25297036047912586, 0.18168277948578615, 0.0, 0.0, 0.30852482215402843, 0.04154322483324156, -0.26569807294376846, 0.10798473007086465, -0.39986248560786075, 1.1261297571726039, 0.0, -0.08645738172306322, -0.16222078614455715, 0.14911510677361828, 0.40140969673598975, -0.5591795518777907, -0.21702784222394986, 1.1753073288427536, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static void summarize_gamma_errors(png_modifier *pm, png_const_charp who, int low_bit_depth, int indexed) { fflush(stderr); if (who) printf("\nGamma correction with %s:\n", who); else printf("\nBasic gamma correction:\n"); if (low_bit_depth) { print_one(" 2 bit gray: ", pm->error_gray_2); print_one(" 4 bit gray: ", pm->error_gray_4); print_one(" 8 bit gray: ", pm->error_gray_8); print_one(" 8 bit color:", pm->error_color_8); if (indexed) print_one(" indexed: ", pm->error_indexed); } print_one("16 bit gray: ", pm->error_gray_16); print_one("16 bit color:", pm->error_color_16); fflush(stdout); }<SPLIT>[-0.25365086435942685, -0.17441590959510697, 0.0, -0.2665172434374763, -0.23624420392447085, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.1909204935349246, -0.25297036047912586, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.26569807294376846, -0.22331377035055117, -0.270465503877335, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.3070243011888601, -0.4462861841111837, 0.6817979554923368, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>void PNGCBAPI read_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass) { if (png_ptr == NULL || row_number > PNG_UINT_31_MAX) return; if (status_pass != pass) { fprintf(stdout, "\n Pass %d: ", pass); status_pass = pass; status_dots = 31; } status_dots--; if (status_dots == 0) { fprintf(stdout, "\n "); status_dots=30; } fprintf(stdout, "r"); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void store_pool_init(png_store *ps, store_pool *pool) { memset(pool, 0, sizeof *pool); pool->store = ps; pool->list = NULL; pool->max = pool->current = pool->limit = pool->total = 0; pool->max_max = pool->max_limit = pool->max_total = 0; store_pool_mark(pool->mark); }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static store_palette_entry * make_standard_palette(png_store* ps, int npalette, int do_tRNS) { static png_uint_32 palette_seed[2] = { 0x87654321, 9 }; int i = 0; png_byte values[256][4]; for (; i<8; ++i) { values[i][1] = (png_byte)((i&1) ? 255U : 0U); values[i][2] = (png_byte)((i&2) ? 255U : 0U); values[i][3] = (png_byte)((i&4) ? 255U : 0U); } { int j = 0; png_byte random_bytes[4]; png_byte need[256]; need[0] = 0; memset(need+1, 1, (sizeof need)-2); need[255] = 0; while (i<70) { png_byte b; if (j==0) { make_four_random_bytes(palette_seed, random_bytes); j = 4; } b = random_bytes[--j]; if (need[b]) { values[i][1] = b; values[i][2] = b; values[i++][3] = b; } } } for (; i<256; ++i) make_four_random_bytes(palette_seed, values[i]); { store_palette_entry *palette; png_byte selector[4]; make_four_random_bytes(palette_seed, selector); if (do_tRNS) for (i=0; i<256; ++i) values[i][0] = (png_byte)(i ^ selector[0]); else for (i=0; i<256; ++i) values[i][0] = 255; palette = store_write_palette(ps, npalette); for (i=0; i<npalette; ++i) { palette[i].alpha = values[i ^ selector[1]][0]; palette[i].red = values[i ^ selector[1]][1]; palette[i].green = values[i ^ selector[1]][2]; palette[i].blue = values[i ^ selector[1]][3]; } return palette; } }<SPLIT>[2.8391943831703865, 0.6409380450430461, 0.0, 2.7766039853544644, 0.551070379594149, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, -0.27925050329511203, 0.9478758394059169, 2.8931285029922593, 0.6831261438402845, 0.0, 0.0, 0.30852482215402843, 0.8552352672918063, 2.82812012645196, 0.5938891973556079, -0.14106852214680915, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, 0.7463616652495864, 0.18343000506680518, -0.10760608081136262, 0.6817979554923368, 0.33317037975964214, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, -0.27935383381430245, 0.9056307075691036, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, -0.28182971586402455]
0<SPLIT>static void readpng2_row_callback(png_structp png_ptr, png_bytep new_row, png_uint_32 row_num, int pass) { mainprog_info *mainprog_ptr; if (!new_row) return; mainprog_ptr = png_get_progressive_ptr(png_ptr); mainprog_ptr->pass = pass; png_progressive_combine_row(png_ptr, mainprog_ptr->row_pointers[row_num], new_row); (*mainprog_ptr->mainprog_display_row)(row_num); return; }<SPLIT>[1.4474140217819704, -0.3727452499124955, 0.0, 1.4071994323980908, -0.406474384144713, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1509627274668249, 1.477384014430136, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, 1.4359019367238823, -0.4000063039086396, -0.39986248560786075, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void writepng_cleanup(mainprog_info *mainprog_ptr) { png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr; png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr; if (png_ptr && info_ptr) png_destroy_write_struct(&png_ptr, &info_ptr); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI store_warning(png_structp ppIn, png_const_charp message) { png_const_structp pp = ppIn; png_store *ps = voidcast(png_store*, png_get_error_ptr(pp)); if (!ps->expect_warning) store_log(ps, pp, message, 0 ); else ps->saw_warning = 1; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void gpc_nop6(Pixel *out, const Pixel *in, const Background *back) { (void)back; if (in->a == 0) out->r = out->g = out->b = 65535; else { out->r = in->r; out->g = in->g; out->b = in->b; } out->a = in->a; }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.7880534307994381, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5794989157753407, -0.7849662874110047, 0.6817979554923368, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int image_transform_png_set_scale_16_add(image_transform *this, PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth) { UNUSED(colour_type) this->next = *that; *that = this; return bit_depth > 8; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gp_abgr16(Pixel *p, png_const_voidp pb) { png_const_uint_16p pp = voidcast(png_const_uint_16p, pb); p->r = pp[3]; p->g = pp[2]; p->b = pp[1]; p->a = pp[0]; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int image_transform_png_set_expand_gray_1_2_4_to_8_add(image_transform *this, PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth) { return image_transform_png_set_expand_add(this, that, colour_type, bit_depth); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static png_byte sRGB(double linear ) { return u8d(255 * sRGB_from_linear(linear)); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gp_bgr16(Pixel *p, png_const_voidp pb) { png_const_uint_16p pp = voidcast(png_const_uint_16p, pb); p->r = pp[2]; p->g = pp[1]; p->b = pp[0]; p->a = 65535; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void standard_image_validate(standard_display *dp, png_const_structp pp, int iImage, int iDisplay) { png_uint_32 y; if (iImage >= 0) store_image_check(dp->ps, pp, iImage); if (iDisplay >= 0) store_image_check(dp->ps, pp, iDisplay); for (y=0; y<dp->h; ++y) standard_row_validate(dp, pp, iImage, iDisplay, y); dp->ps->validated = 1; }<SPLIT>[-0.09900860198293619, -0.3727452499124955, 0.0, -0.11436118199787926, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, -0.09566541730555662, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.11100716297398205, -0.42209287060340067, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void display_clean_write(struct display *dp) { if (dp->write_pp != NULL) png_destroy_write_struct(&dp->write_pp, NULL); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int write_one_file(Image *output, Image *image, int convert_to_8bit) { if (image->opts & FAST_WRITE) image->image.flags |= PNG_IMAGE_FLAG_FAST; if (image->opts & USE_STDIO) { FILE *f = tmpfile(); if (f != NULL) { if (png_image_write_to_stdio(&image->image, f, convert_to_8bit, image->buffer+16, (png_int_32)image->stride, image->colormap)) { if (fflush(f) == 0) { rewind(f); initimage(output, image->opts, "tmpfile", image->stride_extra); output->input_file = f; if (!checkopaque(image)) return 0; } else return logclose(image, f, "tmpfile", ": flush: "); } else { fclose(f); return logerror(image, "tmpfile", ": write failed", ""); } } else return logerror(image, "tmpfile", ": open: ", strerror(errno)); } else { static int counter = 0; char name[32]; sprintf(name, "%s%d.png", tmpf, ++counter); if (png_image_write_to_file(&image->image, name, convert_to_8bit, image->buffer+16, (png_int_32)image->stride, image->colormap)) { initimage(output, image->opts, output->tmpfile_name, image->stride_extra); strcpy(output->tmpfile_name, name); if (!checkopaque(image)) return 0; } else return logerror(image, name, ": write failed", ""); } if (read_file(output, image->image.format | FORMAT_NO_CHANGE, NULL)) { png_uint_32 original_format = image->image.format; if (convert_to_8bit) original_format &= ~PNG_FORMAT_FLAG_LINEAR; if ((output->image.format & BASE_FORMATS) != (original_format & BASE_FORMATS)) return logerror(image, image->file_name, ": format changed on read: ", output->file_name); return compare_two_images(image, output, 0, NULL); } else return logerror(output, output->tmpfile_name, ": read of new file failed", ""); }<SPLIT>[0.9834872346524985, 0.7731576052546384, 0.0, 0.9507312480792999, 0.6787430147593306, 0.0, 0.9701672076669112, 0.9946065798247155, 0.9059316288753189, 2.0295292673408736, 0.8280025412016178, 1.0054691849094282, 0.8198834250278749, 0.0, 0.0, 0.30852482215402843, 0.7389935469405828, 0.9718292068145229, 0.7264085975241742, 1.4116952586195004, 0.6876643500811196, 0.0, -0.08645738172306322, -0.16222078614455715, 0.07885080577644558, 1.0008538488262473, 1.1342209646213146, 3.3782753486411963, 0.42674115187998785, 0.969587250454179, 0.9940939011734088, 0.9053924298597907, 2.0288615559433096, 3.475844538781386, 0.0, 0.9653245912203542, 0.9897980601469931, 0.9011791483816026, 2.0227778188254817]
0<SPLIT>static int check_some_characters(checkfp_command *co, checkfp_control c, const char *tests) { int i; --(c.limit); if (c.cnumber+4 < sizeof co->number && c.limit >= 0) { if (c.limit > 0) for (i=0; tests[i]; ++i) { if (!check_one_character(co, c, tests[i])) return 0; } else return check_all_characters(co, c); } return 1; }<SPLIT>[-0.09900860198293619, -0.2845988764381006, 0.0, -0.11436118199787926, -0.3213592940345919, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 1.040052222782594, -0.270836025671124, -0.09566541730555662, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.11100716297398205, -0.3116600371295954, -0.270465503877335, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.03454968660237938, -0.4462861841111837, 0.6817979554923368, 0.23959960763929639, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 1.039626388904333, 2.6191065950439585, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 1.0350888753871217]
0<SPLIT>int main(int argc, char **argv) { #ifndef DOS_OS2_W32 FILE *keybd; #endif #ifdef sgi FILE *tmpfile; char tmpline[80]; #endif char *inname = NULL, outname[256]; char *p, pnmchar, pnmline[256]; char *bgstr, *textbuf = NULL; ulg rowbytes; int rc, len = 0; int error = 0; int text = FALSE; int maxval; double LUT_exponent; double CRT_exponent = 2.2; double default_display_exponent; double default_gamma = 0.0; wpng_info.infile = NULL; wpng_info.outfile = NULL; wpng_info.image_data = NULL; wpng_info.row_pointers = NULL; wpng_info.filter = FALSE; wpng_info.interlaced = FALSE; wpng_info.have_bg = FALSE; wpng_info.have_time = FALSE; wpng_info.have_text = 0; wpng_info.gamma = 0.0; #if defined(NeXT) LUT_exponent = 1.0 / 2.2; #elif defined(sgi) LUT_exponent = 1.0 / 1.7; tmpfile = fopen("/etc/config/system.glGammaVal", "r"); if (tmpfile) { double sgi_gamma; fgets(tmpline, 80, tmpfile); fclose(tmpfile); sgi_gamma = atof(tmpline); if (sgi_gamma > 0.0) LUT_exponent = 1.0 / sgi_gamma; } #elif defined(Macintosh) LUT_exponent = 1.8 / 2.61; #else LUT_exponent = 1.0; #endif default_display_exponent = LUT_exponent * CRT_exponent; if ((p = getenv("SCREEN_GAMMA")) != NULL) { double exponent = atof(p); if (exponent > 0.0) default_gamma = 1.0 / exponent; } if (default_gamma == 0.0) default_gamma = 1.0 / default_display_exponent; while (*++argv && !error) { if (!strncmp(*argv, "-i", 2)) { wpng_info.interlaced = TRUE; } else if (!strncmp(*argv, "-time", 3)) { wpng_info.modtime = time(NULL); wpng_info.have_time = TRUE; } else if (!strncmp(*argv, "-text", 3)) { text = TRUE; } else if (!strncmp(*argv, "-gamma", 2)) { if (!*++argv) ++error; else { wpng_info.gamma = atof(*argv); if (wpng_info.gamma <= 0.0) ++error; else if (wpng_info.gamma > 1.01) fprintf(stderr, PROGNAME " warning: file gammas are usually less than 1.0\n"); } } else if (!strncmp(*argv, "-bgcolor", 4)) { if (!*++argv) ++error; else { bgstr = *argv; if (strlen(bgstr) != 7 || bgstr[0] != '#') ++error; else { unsigned r, g, b; sscanf(bgstr+1, "%2x%2x%2x", &r, &g, &b); wpng_info.bg_red = (uch)r; wpng_info.bg_green = (uch)g; wpng_info.bg_blue = (uch)b; wpng_info.have_bg = TRUE; } } } else { if (**argv != '-') { inname = *argv; if (argv[1]) ++error; } else ++error; } } if (!inname) { if (isatty(0)) { fprintf(stderr, PROGNAME ": must give input filename or provide image data via stdin\n"); ++error; } else { #ifdef DOS_OS2_W32 setmode(fileno(stdin), O_BINARY); setmode(fileno(stdout), O_BINARY); #endif if ((wpng_info.infile = fdopen(fileno(stdin), "rb")) == NULL) { fprintf(stderr, PROGNAME ": unable to reopen stdin in binary mode\n"); ++error; } else if ((wpng_info.outfile = fdopen(fileno(stdout), "wb")) == NULL) { fprintf(stderr, PROGNAME ": unable to reopen stdout in binary mode\n"); fclose(wpng_info.infile); ++error; } else wpng_info.filter = TRUE; } } else if ((len = strlen(inname)) > 250) { fprintf(stderr, PROGNAME ": input filename is too long [%d chars]\n", len); ++error; } else if (!(wpng_info.infile = fopen(inname, "rb"))) { fprintf(stderr, PROGNAME ": can't open input file [%s]\n", inname); ++error; } if (!error) { fgets(pnmline, 256, wpng_info.infile); if (pnmline[0] != 'P' || ((pnmchar = pnmline[1]) != '5' && pnmchar != '6' && pnmchar != '8')) { fprintf(stderr, PROGNAME ": input file [%s] is not a binary PGM, PPM or PAM file\n", inname); ++error; } else { wpng_info.pnmtype = (int)(pnmchar - '0'); if (wpng_info.pnmtype != 8) wpng_info.have_bg = FALSE; do { fgets(pnmline, 256, wpng_info.infile); } while (pnmline[0] == '#'); sscanf(pnmline, "%ld %ld", &wpng_info.width, &wpng_info.height); do { fgets(pnmline, 256, wpng_info.infile); } while (pnmline[0] == '#'); sscanf(pnmline, "%d", &maxval); if (wpng_info.width <= 0L || wpng_info.height <= 0L || maxval != 255) { fprintf(stderr, PROGNAME ": only positive width/height, maxval == 255 allowed \n"); ++error; } wpng_info.sample_depth = 8; if (!wpng_info.filter) { if ((p = strrchr(inname, '.')) == NULL || (p - inname) != (len - 4)) { strcpy(outname, inname); strcpy(outname+len, ".png"); } else { len -= 4; strncpy(outname, inname, len); strcpy(outname+len, ".png"); } if ((wpng_info.outfile = fopen(outname, "rb")) != NULL) { fprintf(stderr, PROGNAME ": output file exists [%s]\n", outname); fclose(wpng_info.outfile); ++error; } else if (!(wpng_info.outfile = fopen(outname, "wb"))) { fprintf(stderr, PROGNAME ": can't open output file [%s]\n", outname); ++error; } } } if (error) { fclose(wpng_info.infile); wpng_info.infile = NULL; if (wpng_info.filter) { fclose(wpng_info.outfile); wpng_info.outfile = NULL; } } } if (error) { fprintf(stderr, "\n%s %s: %s\n", PROGNAME, VERSION, APPNAME); writepng_version_info(); fprintf(stderr, "\n %s, %s, %.5f ", PROGNAME, PROGNAME, default_gamma); exit(1); } if (text && #ifndef DOS_OS2_W32 (keybd = fdopen(fileno(stderr), "r")) != NULL && #endif (textbuf = (char *)malloc((5 + 9)*75)) != NULL) { int i, valid, result; fprintf(stderr, "Enter text info (no more than 72 characters per line);\n"); fprintf(stderr, "to skip a field, hit the <Enter> key.\n"); do { valid = TRUE; p = textbuf + TEXT_TITLE_OFFSET; fprintf(stderr, " Title: "); fflush(stderr); if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) { if (p[len-1] == '\n') p[--len] = '\0'; wpng_info.title = p; wpng_info.have_text |= TEXT_TITLE; if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) { fprintf(stderr, " " PROGNAME " warning: character code" " %u is %sdiscouraged by the PNG\n specification " "[first occurrence was at character position #%d]\n", (unsigned)p[result], (p[result] == 27)? "strongly " : "", result+1); fflush(stderr); #ifdef FORBID_LATIN1_CTRL wpng_info.have_text &= ~TEXT_TITLE; valid = FALSE; #else if (p[result] == 27) { wpng_info.have_text &= ~TEXT_TITLE; valid = FALSE; } #endif } } } while (!valid); do { valid = TRUE; p = textbuf + TEXT_AUTHOR_OFFSET; fprintf(stderr, " Author: "); fflush(stderr); if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) { if (p[len-1] == '\n') p[--len] = '\0'; wpng_info.author = p; wpng_info.have_text |= TEXT_AUTHOR; if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) { fprintf(stderr, " " PROGNAME " warning: character code" " %u is %sdiscouraged by the PNG\n specification " "[first occurrence was at character position #%d]\n", (unsigned)p[result], (p[result] == 27)? "strongly " : "", result+1); fflush(stderr); #ifdef FORBID_LATIN1_CTRL wpng_info.have_text &= ~TEXT_AUTHOR; valid = FALSE; #else if (p[result] == 27) { wpng_info.have_text &= ~TEXT_AUTHOR; valid = FALSE; } #endif } } } while (!valid); do { valid = TRUE; p = textbuf + TEXT_DESC_OFFSET; fprintf(stderr, " Description (up to 9 lines):\n"); for (i = 1; i < 10; ++i) { fprintf(stderr, " [%d] ", i); fflush(stderr); if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) p += len; else break; } if ((len = p - (textbuf + TEXT_DESC_OFFSET)) > 1) { if (p[-1] == '\n') { p[-1] = '\0'; --len; } wpng_info.desc = textbuf + TEXT_DESC_OFFSET; wpng_info.have_text |= TEXT_DESC; p = textbuf + TEXT_DESC_OFFSET; if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) { fprintf(stderr, " " PROGNAME " warning: character code" " %u is %sdiscouraged by the PNG\n specification " "[first occurrence was at character position #%d]\n", (unsigned)p[result], (p[result] == 27)? "strongly " : "", result+1); fflush(stderr); #ifdef FORBID_LATIN1_CTRL wpng_info.have_text &= ~TEXT_DESC; valid = FALSE; #else if (p[result] == 27) { wpng_info.have_text &= ~TEXT_DESC; valid = FALSE; } #endif } } } while (!valid); do { valid = TRUE; p = textbuf + TEXT_COPY_OFFSET; fprintf(stderr, " Copyright: "); fflush(stderr); if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) { if (p[len-1] == '\n') p[--len] = '\0'; wpng_info.copyright = p; wpng_info.have_text |= TEXT_COPY; if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) { fprintf(stderr, " " PROGNAME " warning: character code" " %u is %sdiscouraged by the PNG\n specification " "[first occurrence was at character position #%d]\n", (unsigned)p[result], (p[result] == 27)? "strongly " : "", result+1); fflush(stderr); #ifdef FORBID_LATIN1_CTRL wpng_info.have_text &= ~TEXT_COPY; valid = FALSE; #else if (p[result] == 27) { wpng_info.have_text &= ~TEXT_COPY; valid = FALSE; } #endif } } } while (!valid); do { valid = TRUE; p = textbuf + TEXT_EMAIL_OFFSET; fprintf(stderr, " E-mail: "); fflush(stderr); if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) { if (p[len-1] == '\n') p[--len] = '\0'; wpng_info.email = p; wpng_info.have_text |= TEXT_EMAIL; if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) { fprintf(stderr, " " PROGNAME " warning: character code" " %u is %sdiscouraged by the PNG\n specification " "[first occurrence was at character position #%d]\n", (unsigned)p[result], (p[result] == 27)? "strongly " : "", result+1); fflush(stderr); #ifdef FORBID_LATIN1_CTRL wpng_info.have_text &= ~TEXT_EMAIL; valid = FALSE; #else if (p[result] == 27) { wpng_info.have_text &= ~TEXT_EMAIL; valid = FALSE; } #endif } } } while (!valid); do { valid = TRUE; p = textbuf + TEXT_URL_OFFSET; fprintf(stderr, " URL: "); fflush(stderr); if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) { if (p[len-1] == '\n') p[--len] = '\0'; wpng_info.url = p; wpng_info.have_text |= TEXT_URL; if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) { fprintf(stderr, " " PROGNAME " warning: character code" " %u is %sdiscouraged by the PNG\n specification " "[first occurrence was at character position #%d]\n", (unsigned)p[result], (p[result] == 27)? "strongly " : "", result+1); fflush(stderr); #ifdef FORBID_LATIN1_CTRL wpng_info.have_text &= ~TEXT_URL; valid = FALSE; #else if (p[result] == 27) { wpng_info.have_text &= ~TEXT_URL; valid = FALSE; } #endif } } } while (!valid); #ifndef DOS_OS2_W32 fclose(keybd); #endif } else if (text) { fprintf(stderr, PROGNAME ": unable to allocate memory for text\n"); text = FALSE; wpng_info.have_text = 0; } if ((rc = writepng_init(&wpng_info)) != 0) { switch (rc) { case 2: fprintf(stderr, PROGNAME ": libpng initialization problem (longjmp)\n"); break; case 4: fprintf(stderr, PROGNAME ": insufficient memory\n"); break; case 11: fprintf(stderr, PROGNAME ": internal logic error (unexpected PNM type)\n"); break; default: fprintf(stderr, PROGNAME ": unknown writepng_init() error\n"); break; } exit(rc); } if (text && textbuf) { free(textbuf); textbuf = NULL; } if (wpng_info.pnmtype == 5) rowbytes = wpng_info.width; else if (wpng_info.pnmtype == 6) rowbytes = wpng_info.width * 3; else rowbytes = wpng_info.width * 4; fprintf(stderr, "Encoding image data...\n"); fflush(stderr); if (wpng_info.interlaced) { long i; ulg bytes; ulg image_bytes = rowbytes * wpng_info.height; wpng_info.image_data = (uch *)malloc(image_bytes); wpng_info.row_pointers = (uch **)malloc(wpng_info.height*sizeof(uch *)); if (wpng_info.image_data == NULL || wpng_info.row_pointers == NULL) { fprintf(stderr, PROGNAME ": insufficient memory for image data\n"); writepng_cleanup(&wpng_info); wpng_cleanup(); exit(5); } for (i = 0; i < wpng_info.height; ++i) wpng_info.row_pointers[i] = wpng_info.image_data + i*rowbytes; bytes = fread(wpng_info.image_data, 1, image_bytes, wpng_info.infile); if (bytes != image_bytes) { fprintf(stderr, PROGNAME ": expected %lu bytes, got %lu bytes\n", image_bytes, bytes); fprintf(stderr, " (continuing anyway)\n"); } if (writepng_encode_image(&wpng_info) != 0) { fprintf(stderr, PROGNAME ": libpng problem (longjmp) while writing image data\n"); writepng_cleanup(&wpng_info); wpng_cleanup(); exit(2); } } else { long j; ulg bytes; wpng_info.image_data = (uch *)malloc(rowbytes); if (wpng_info.image_data == NULL) { fprintf(stderr, PROGNAME ": insufficient memory for row data\n"); writepng_cleanup(&wpng_info); wpng_cleanup(); exit(5); } error = 0; for (j = wpng_info.height; j > 0L; --j) { bytes = fread(wpng_info.image_data, 1, rowbytes, wpng_info.infile); if (bytes != rowbytes) { fprintf(stderr, PROGNAME ": expected %lu bytes, got %lu bytes (row %ld)\n", rowbytes, bytes, wpng_info.height-j); ++error; break; } if (writepng_encode_row(&wpng_info) != 0) { fprintf(stderr, PROGNAME ": libpng problem (longjmp) while writing row %ld\n", wpng_info.height-j); ++error; break; } } if (error) { writepng_cleanup(&wpng_info); wpng_cleanup(); exit(2); } if (writepng_encode_finish(&wpng_info) != 0) { fprintf(stderr, PROGNAME ": error on final libpng call\n"); writepng_cleanup(&wpng_info); wpng_cleanup(); exit(2); } } fprintf(stderr, "Done.\n"); fflush(stderr); writepng_cleanup(&wpng_info); wpng_cleanup(); return 0; }<SPLIT>[6.395966417829672, 11.020173521653048, 0.0, 6.276193398465196, 10.573372240060904, 0.0, 13.83086674351866, 13.720125942183474, 14.007448566409641, 4.668134719496286, 10.817444058226544, 4.623482877901521, 10.028207024992298, 0.0, 0.0, 0.30852482215402843, 10.425803576209212, 4.529720136119611, 9.64938154220764, 4.905413765343697, 14.608941025235742, 0.0, 4.543917720379413, 18.970881172982082, 8.686227677930102, 10.59196028227037, 5.424168939752382, 6.074752741790056, 13.058795388126661, 13.82699351436445, 13.716975514982563, 14.003686680143892, 4.66682200138058, 3.475844538781386, 0.0, 13.806519597784598, 13.696880170929312, 13.98214949014522, 4.656615001327775]
0<SPLIT>void png_fixed_warning(png_const_structrp png_ptr, png_const_charp msg) { fprintf(stderr, "overflow in: %s\n", msg); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, 0.417570182313826, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gp_g8(Pixel *p, png_const_voidp pb) { png_const_bytep pp = voidcast(png_const_bytep, pb); p->r = p->g = p->b = pp[0]; p->a = 255; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void image_transform_default_ini(PNG_CONST image_transform *this, transform_display *that) { this->next->ini(this->next, that); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static size_t standard_name(char *buffer, size_t bufsize, size_t pos, png_byte colour_type, int bit_depth, unsigned int npalette, int interlace_type, png_uint_32 w, png_uint_32 h, int do_interlace) { pos = safecat(buffer, bufsize, pos, colour_types[colour_type]); if (npalette > 0) { pos = safecat(buffer, bufsize, pos, "["); pos = safecatn(buffer, bufsize, pos, npalette); pos = safecat(buffer, bufsize, pos, "]"); } pos = safecat(buffer, bufsize, pos, " "); pos = safecatn(buffer, bufsize, pos, bit_depth); pos = safecat(buffer, bufsize, pos, " bit"); if (interlace_type != PNG_INTERLACE_NONE) { pos = safecat(buffer, bufsize, pos, " interlaced"); if (do_interlace) pos = safecat(buffer, bufsize, pos, "(pngvalid)"); else pos = safecat(buffer, bufsize, pos, "(libpng)"); } if (w > 0 || h > 0) { pos = safecat(buffer, bufsize, pos, " "); pos = safecatn(buffer, bufsize, pos, w); pos = safecat(buffer, bufsize, pos, "x"); pos = safecatn(buffer, bufsize, pos, h); } return pos; }<SPLIT>[-0.25365086435942685, -0.17441590959510697, 0.0, -0.2665172434374763, 0.231888791681195, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.1909204935349246, -0.25297036047912586, -0.16021042348318995, 0.0, 0.0, 3.3489446507317613, 0.17715856524300236, -0.26569807294376846, 0.262590696934192, 0.11772544131424245, 1.674211516036959, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, 0.5648944654878781, -0.4462861841111837, -0.21702784222394986, 1.3624488730834452, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 0.04739993194876201]
1<SPLIT>void png_handle_tRNS(png_structp png_ptr, png_infop info_ptr, png_uint_32 length) { png_byte readbuf[PNG_MAX_PALETTE_LENGTH]; png_debug(1, "in png_handle_tRNS\n"); if (!(png_ptr->mode & PNG_HAVE_IHDR)) png_error(png_ptr, "Missing IHDR before tRNS"); else if (png_ptr->mode & PNG_HAVE_IDAT) { png_warning(png_ptr, "Invalid tRNS after IDAT"); png_crc_finish(png_ptr, length); return; } else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS)) { png_warning(png_ptr, "Duplicate tRNS chunk"); png_crc_finish(png_ptr, length); return; } if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY) { png_byte buf[2]; if (length != 2) { png_warning(png_ptr, "Incorrect tRNS chunk length"); png_crc_finish(png_ptr, length); return; } png_crc_read(png_ptr, buf, 2); png_ptr->num_trans = 1; png_ptr->trans_values.gray = png_get_uint_16(buf); } else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB) { png_byte buf[6]; if (length != 6) { png_warning(png_ptr, "Incorrect tRNS chunk length"); png_crc_finish(png_ptr, length); return; } png_crc_read(png_ptr, buf, (png_size_t)length); png_ptr->num_trans = 1; png_ptr->trans_values.red = png_get_uint_16(buf); png_ptr->trans_values.green = png_get_uint_16(buf + 2); png_ptr->trans_values.blue = png_get_uint_16(buf + 4); } else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) { if (!(png_ptr->mode & PNG_HAVE_PLTE)) { png_warning(png_ptr, "Missing PLTE before tRNS"); } if (length > (png_uint_32)png_ptr->num_palette || length > PNG_MAX_PALETTE_LENGTH) { png_warning(png_ptr, "Incorrect tRNS chunk length"); png_crc_finish(png_ptr, length); return; } if (length == 0) { png_warning(png_ptr, "Zero length tRNS chunk"); png_crc_finish(png_ptr, length); return; } png_crc_read(png_ptr, readbuf, (png_size_t)length); png_ptr->num_trans = (png_uint_16)length; } else { png_warning(png_ptr, "tRNS chunk not allowed with alpha channel"); png_crc_finish(png_ptr, length); return; } if (png_crc_finish(png_ptr, 0)) return; png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans, &(png_ptr->trans_values)); }<SPLIT>[1.1381294970289892, 1.1037065057836193, 0.0, 1.102887309518897, 1.0192033751998149, 0.0, 1.6653401555507896, 1.7015798777335354, 1.5692995750795884, 3.34883199341858, 1.1476646697464155, 1.1627741280829973, 1.1617766279968509, 0.0, 0.0, 0.30852482215402843, 1.0683450879357161, 1.1265201167843093, 1.05770709794559, 0.11772544131424245, 1.1261297571726039, 0.0, -0.08645738172306322, 0.417570182313826, 0.6760973642524136, 0.8918640029916549, 0.005287286955244392, 0.6817979554923368, 1.4560196452037908, 1.664582183638518, 1.7009206574961395, 1.5685972020260743, 3.347841778661945, 0.9056307075691036, 0.0, 1.6594432402238268, 1.6957470663015664, 1.5635067606227984, 3.339696410076628]
0<SPLIT>int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow) { HACCEL hAccel; HWND hwnd; MSG msg; WNDCLASS wndclass; int ixBorders, iyBorders; wndclass.style = CS_HREDRAW | CS_VREDRAW; wndclass.lpfnWndProc = WndProc; wndclass.cbClsExtra = 0; wndclass.cbWndExtra = 0; wndclass.hInstance = hInstance; wndclass.hIcon = LoadIcon (hInstance, szIconName) ; wndclass.hCursor = LoadCursor (NULL, IDC_ARROW); wndclass.hbrBackground = NULL; wndclass.lpszMenuName = szProgName; wndclass.lpszClassName = szProgName; if (!RegisterClass (&wndclass)) { MessageBox (NULL, TEXT ("Error: this program requires Windows NT!"), szProgName, MB_ICONERROR); return 0; } if ((szCmdLine != NULL) && (*szCmdLine != '\0')) if (szCmdLine[0] == '"') strncpy (szCmdFileName, szCmdLine + 1, strlen(szCmdLine) - 2); else strcpy (szCmdFileName, szCmdLine); else strcpy (szCmdFileName, ""); ixBorders = 2 * (GetSystemMetrics (SM_CXBORDER) + GetSystemMetrics (SM_CXDLGFRAME)); iyBorders = 2 * (GetSystemMetrics (SM_CYBORDER) + GetSystemMetrics (SM_CYDLGFRAME)) + GetSystemMetrics (SM_CYCAPTION) + GetSystemMetrics (SM_CYMENUSIZE) + 1; hwnd = CreateWindow (szProgName, szAppName, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 512 + 2 * MARGIN + ixBorders, 384 + 2 * MARGIN + iyBorders, NULL, NULL, hInstance, NULL); ShowWindow (hwnd, iCmdShow); UpdateWindow (hwnd); hAccel = LoadAccelerators (hInstance, szProgName); while (GetMessage (&msg, NULL, 0, 0)) { if (!TranslateAccelerator (hwnd, hAccel, &msg)) { TranslateMessage (&msg); DispatchMessage (&msg); } } return msg.wParam; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.18995094088131478, 0.48723406201155817, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.4677628661210612, 0.19837465696559078, 0.5276294972713247, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.32477585926655006, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void make_random_bytes(png_uint_32* seed, void* pv, size_t size) { png_uint_32 u0 = seed[0], u1 = seed[1]; png_bytep bytes = voidcast(png_bytep, pv); size_t i; for (i=0; i<size; ++i) { png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff; u1 <<= 8; u1 |= u0 >> 24; u0 <<= 8; u0 |= u; *bytes++ = (png_byte)u; } seed[0] = u0; seed[1] = u1; }<SPLIT>[0.36491818514653585, -0.2625622830695019, 0.0, 0.34210700232091185, -0.3213592940345919, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1909204935349246, 0.3762494122151511, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, 0.35306556693537716, -0.3116600371295954, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.4705090699407485, -0.6720729196443977, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void readpng_cleanup(int free_image_data) { if (free_image_data && image_data) { free(image_data); image_data = NULL; } }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
1<SPLIT>void png_handle_cHRM(png_structp png_ptr, png_infop info_ptr, png_uint_32 length) { png_byte buf[32]; png_fixed_point x_white, y_white, x_red, y_red, x_green, y_green, x_blue, y_blue; png_debug(1, "in png_handle_cHRM"); if (!(png_ptr->mode & PNG_HAVE_IHDR)) png_error(png_ptr, "Missing IHDR before cHRM"); else if (png_ptr->mode & PNG_HAVE_IDAT) { png_warning(png_ptr, "Invalid cHRM after IDAT"); png_crc_finish(png_ptr, length); return; } else if (png_ptr->mode & PNG_HAVE_PLTE) png_warning(png_ptr, "Missing PLTE before cHRM"); if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM) #ifdef PNG_READ_sRGB_SUPPORTED && !(info_ptr->valid & PNG_INFO_sRGB) #endif ) { png_warning(png_ptr, "Duplicate cHRM chunk"); png_crc_finish(png_ptr, length); return; } if (length != 32) { png_warning(png_ptr, "Incorrect cHRM chunk length"); png_crc_finish(png_ptr, length); return; } png_crc_read(png_ptr, buf, 32); if (png_crc_finish(png_ptr, 0)) return; x_white = png_get_fixed_point(NULL, buf); y_white = png_get_fixed_point(NULL, buf + 4); x_red = png_get_fixed_point(NULL, buf + 8); y_red = png_get_fixed_point(NULL, buf + 12); x_green = png_get_fixed_point(NULL, buf + 16); y_green = png_get_fixed_point(NULL, buf + 20); x_blue = png_get_fixed_point(NULL, buf + 24); y_blue = png_get_fixed_point(NULL, buf + 28); if (x_white == PNG_FIXED_ERROR || y_white == PNG_FIXED_ERROR || x_red == PNG_FIXED_ERROR || y_red == PNG_FIXED_ERROR || x_green == PNG_FIXED_ERROR || y_green == PNG_FIXED_ERROR || x_blue == PNG_FIXED_ERROR || y_blue == PNG_FIXED_ERROR) { png_warning(png_ptr, "Ignoring cHRM chunk with negative chromaticities"); return; } #ifdef PNG_READ_sRGB_SUPPORTED if ((info_ptr != NULL) && (info_ptr->valid & PNG_INFO_sRGB)) { if (PNG_OUT_OF_RANGE(x_white, 31270, 1000) || PNG_OUT_OF_RANGE(y_white, 32900, 1000) || PNG_OUT_OF_RANGE(x_red, 64000L, 1000) || PNG_OUT_OF_RANGE(y_red, 33000, 1000) || PNG_OUT_OF_RANGE(x_green, 30000, 1000) || PNG_OUT_OF_RANGE(y_green, 60000L, 1000) || PNG_OUT_OF_RANGE(x_blue, 15000, 1000) || PNG_OUT_OF_RANGE(y_blue, 6000, 1000)) { PNG_WARNING_PARAMETERS(p) png_warning_parameter_signed(p, 1, PNG_NUMBER_FORMAT_fixed, x_white); png_warning_parameter_signed(p, 2, PNG_NUMBER_FORMAT_fixed, y_white); png_warning_parameter_signed(p, 3, PNG_NUMBER_FORMAT_fixed, x_red); png_warning_parameter_signed(p, 4, PNG_NUMBER_FORMAT_fixed, y_red); png_warning_parameter_signed(p, 5, PNG_NUMBER_FORMAT_fixed, x_green); png_warning_parameter_signed(p, 6, PNG_NUMBER_FORMAT_fixed, y_green); png_warning_parameter_signed(p, 7, PNG_NUMBER_FORMAT_fixed, x_blue); png_warning_parameter_signed(p, 8, PNG_NUMBER_FORMAT_fixed, y_blue); png_formatted_warning(png_ptr, p, "Ignoring incorrect cHRM white(@1,@2) r(@3,@4)g(@5,@6)b(@7,@8) " "when sRGB is also present"); } return; } #endif #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED if ((png_ptr->transformations & PNG_RGB_TO_GRAY) == 0) { if (y_red <= (1<<17) && y_green <= (1<<17) && y_blue <= (1<<17)) { png_uint_32 w = y_red + y_green + y_blue; png_ptr->rgb_to_gray_red_coeff = (png_uint_16)(((png_uint_32)y_red * 32768)/w); png_ptr->rgb_to_gray_green_coeff = (png_uint_16)(((png_uint_32)y_green * 32768)/w); png_ptr->rgb_to_gray_blue_coeff = (png_uint_16)(((png_uint_32)y_blue * 32768)/w); } } #endif png_set_cHRM_fixed(png_ptr, info_ptr, x_white, y_white, x_red, y_red, x_green, y_green, x_blue, y_blue); }<SPLIT>[3.921690219805821, 1.5885115598927912, 0.0, 3.8416964154316435, 1.4660575982779505, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 1.699703585821447, 1.9468199911084094, 1.9492988439508436, 0.6147475032464892, 0.0, 0.0, 0.30852482215402843, 1.8239162702186693, 1.8999746666332415, 0.5276294972713247, 0.11772544131424245, 0.4684316465353775, 0.0, 5.7566350090253, 3.3165250246057414, 0.7463616652495864, 0.4559046196532859, 0.005287286955244392, 1.5806237532086234, 0.6138826961206794, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 1.6991165002636506, 0.04889276383167627, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 1.693548171012695]
0<SPLIT>void PNGAPI png_set_read_fn(png_structrp png_ptr, png_voidp io_ptr, png_rw_ptr read_data_fn) { if (png_ptr == NULL) return; png_ptr->io_ptr = io_ptr; if (read_data_fn != NULL) png_ptr->read_data_fn = read_data_fn; else png_ptr->read_data_fn = png_default_read_data; png_ptr->read_data_fn = read_data_fn; if (png_ptr->write_data_fn != NULL) { png_ptr->write_data_fn = NULL; png_warning(png_ptr, "Can't set both read_data_fn and write_data_fn in the" " same structure"); } png_ptr->output_flush_fn = NULL; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.11436118199787926, -0.23624420392447085, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.22968745598628004, -0.11100716297398205, -0.24540033704531222, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, 0.417570182313826, -0.4129993012037634, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void gpc_gpre(Pixel *out, const Pixel *in, const Background *back) { (void)back; if (in->r == in->g && in->g == in->b) out->r = out->g = out->b = ilineara(in->g, in->a); else out->r = out->g = out->b = u16d(in->a * 257 * YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b])); out->a = 257 * in->a; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static double digitize(double value, int depth, int do_round) { PNG_CONST unsigned int digitization_factor = (1U << depth) -1; if (value <= 0) value = 0; else if (value >= 1) value = 1; value *= digitization_factor; if (do_round) value += .5; return floor(value)/digitization_factor; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 1.102887309518897, -0.44903192919977347, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.2684346961033546, -0.26569807294376846, -0.7092182376352943, -0.917450412529964, -0.518115519420462, 0.0, 2.11848314308764, 0.417570182313826, -0.4832636022009361, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static png_uint_32 png_pass_rows(png_uint_32 height, int pass) { png_uint_32 tiles = height>>3; png_uint_32 rows = 0; unsigned int x, y; height &= 7; ++pass; for (y=0; y<8; ++y) for (x=0; x<8; ++x) if (adam7[y][x] == pass) { rows += tiles; if (y < height) ++rows; break; } return rows; }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.6586564490689124, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.08904460951967552, -0.5591795518777907, -0.21702784222394986, 0.33317037975964214, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 1.7623686513065309, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static int image_transform_png_set_expand_16_add(image_transform *this, PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth) { UNUSED(colour_type) this->next = *that; *that = this; return bit_depth < 16; }<SPLIT>[-0.09900860198293619, -0.46089162338689044, 0.0, -0.11436118199787926, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.09566541730555662, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.11100716297398205, -0.5104391373824448, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static png_uint_32 image_transform_add(PNG_CONST image_transform **this, unsigned int max, png_uint_32 counter, char *name, size_t sizeof_name, size_t *pos, png_byte colour_type, png_byte bit_depth) { for (;;) { png_uint_32 mask; image_transform *list; if (counter == 0) { image_transform_reset_count(); if (max <= 1) counter = 1; else counter = random_32(); } else { switch (max) { case 0: ++counter; break; case 1: counter <<= 1; break; default: counter = random_32(); break; } } *this = &image_transform_end; list = image_transform_first; mask = 1; while (list != &image_transform_end) { if ((counter & mask) != 0 && list->enable && (max == 0 || list->local_use < max)) { if (list->add(list, this, colour_type, bit_depth) || max == 0) { *pos = safecat(name, sizeof_name, *pos, " +"); *pos = safecat(name, sizeof_name, *pos, list->name); } else { *this = list->next; list->next = 0; list->local_use = max; } } mask <<= 1; list = list->list; } if (*this != &image_transform_end) return counter; if (!image_transform_test_counter(counter, max)) return 0; } }<SPLIT>[1.9113408089114425, 0.5527916715686512, 0.0, 3.9938524768712407, 1.6150090059706623, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.380400859743741, 0.7480870090654184, 1.9492988439508436, 0.5919546230485575, 0.0, 0.0, 3.3489446507317613, 1.9789052306869674, 4.0656474062102514, 1.6982175320936606, -0.270465503877335, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, 1.0625510197368635, 0.3469147738186936, -0.22049944857796966, 5.17592694407377, 0.23959960763929639, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.3801362775450152, 0.9056307075691036, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 1.3643185231999084]
0<SPLIT>static int next_format(png_bytep colour_type, png_bytep bit_depth, unsigned int* palette_number, int no_low_depth_gray) { if (*bit_depth == 0) { *colour_type = 0; if (no_low_depth_gray) *bit_depth = 8; else *bit_depth = 1; *palette_number = 0; return 1; } if (*colour_type == 3) { if (++*palette_number < PALETTE_COUNT(*bit_depth)) return 1; *palette_number = 0; } *bit_depth = (png_byte)(*bit_depth << 1); if (*bit_depth <= 8 #ifdef DO_16BIT || (*colour_type != 3 && *bit_depth <= 16) #endif ) return 1; switch (*colour_type) { case 0: *colour_type = 2; *bit_depth = 8; return 1; case 2: *colour_type = 3; *bit_depth = 1; return 1; case 3: *colour_type = 4; *bit_depth = 8; return 1; case 4: *colour_type = 6; *bit_depth = 8; return 1; default: return 0; } }<SPLIT>[0.21027592277004517, 0.42057211135705874, 0.0, 0.18995094088131478, 0.33828265431884635, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 1.040052222782594, 0.40844599748657096, 0.21894446904158188, 0.3868187012671718, 0.0, 0.0, 0.30852482215402843, 0.3321475257113004, 0.19837465696559078, 0.3067638303237141, -0.5292594673383866, 0.13958259121676436, 0.0, 0.02378964451747194, 0.9973611507722091, 0.07885080577644558, -0.14353953243697165, -0.6720729196443977, -0.21702784222394986, 0.33317037975964214, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 1.039626388904333, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 1.0350888753871217]
0<SPLIT>static void store_pool_error(png_store *ps, png_const_structp pp, PNG_CONST char *msg) { if (pp != NULL) png_error(pp, msg); store_log(ps, pp, msg, 1 ); }<SPLIT>[0.36491818514653585, -0.5049648101240879, 0.0, 0.34210700232091185, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, 0.3762494122151511, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, 0.35306556693537716, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static struct IDAT_list * IDAT_list_extend(struct IDAT_list *tail) { struct IDAT_list *next = tail->next; if (next == NULL) { unsigned int length = 2 * tail->length; if (length < tail->length) length = tail->length; next = png_voidcast(IDAT_list*, malloc(IDAT_list_size(NULL, length))); CLEAR(*next); if (next == NULL) return NULL; next->next = NULL; next->length = length; tail->next = next; } return next; }<SPLIT>[0.5195604475230265, -0.24052568970090316, 0.0, 0.4942630637605089, -0.30008052150706166, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1509627274668249, 0.5335543553887203, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.21031383592774278, 0.5077564769051636, -0.28957347043483433, -0.14106852214680915, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.1980344553542678, 0.005287286955244392, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
1<SPLIT>void png_handle_iCCP(png_structp png_ptr, png_infop info_ptr, png_uint_32 length) { png_charp chunkdata; png_byte compression_type; png_bytep pC; png_charp profile; png_uint_32 skip = 0; png_uint_32 profile_size, profile_length; png_size_t slength, prefix_length, data_length; png_debug(1, "in png_handle_iCCP\n"); if (!(png_ptr->mode & PNG_HAVE_IHDR)) png_error(png_ptr, "Missing IHDR before iCCP"); else if (png_ptr->mode & PNG_HAVE_IDAT) { png_warning(png_ptr, "Invalid iCCP after IDAT"); png_crc_finish(png_ptr, length); return; } else if (png_ptr->mode & PNG_HAVE_PLTE) png_warning(png_ptr, "Out of place iCCP chunk"); if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP)) { png_warning(png_ptr, "Duplicate iCCP chunk"); png_crc_finish(png_ptr, length); return; } #ifdef PNG_MAX_MALLOC_64K if (length > (png_uint_32)65535L) { png_warning(png_ptr, "iCCP chunk too large to fit in memory"); skip = length - (png_uint_32)65535L; length = (png_uint_32)65535L; } #endif chunkdata = (png_charp)png_malloc(png_ptr, length + 1); slength = (png_size_t)length; png_crc_read(png_ptr, (png_bytep)chunkdata, slength); if (png_crc_finish(png_ptr, skip)) { png_free(png_ptr, chunkdata); return; } chunkdata[slength] = 0x00; for (profile = chunkdata; *profile; profile++) ; ++profile; if ( profile >= chunkdata + slength - 1) { png_free(png_ptr, chunkdata); png_warning(png_ptr, "Malformed iCCP chunk"); return; } compression_type = *profile++; if (compression_type) { png_warning(png_ptr, "Ignoring nonzero compression type in iCCP chunk"); compression_type=0x00; } prefix_length = profile - chunkdata; chunkdata = png_decompress_chunk(png_ptr, compression_type, chunkdata, slength, prefix_length, &data_length); profile_length = data_length - prefix_length; if ( prefix_length > data_length || profile_length < 4) { png_free(png_ptr, chunkdata); png_warning(png_ptr, "Profile size field missing from iCCP chunk"); return; } pC = (png_bytep)(chunkdata+prefix_length); profile_size = ((*(pC ))<<24) | ((*(pC+1))<<16) | ((*(pC+2))<< 8) | ((*(pC+3)) ); if(profile_size < profile_length) profile_length = profile_size; if(profile_size > profile_length) { png_free(png_ptr, chunkdata); png_warning(png_ptr, "Ignoring truncated iCCP profile."); return; } png_set_iCCP(png_ptr, info_ptr, chunkdata, compression_type, chunkdata + prefix_length, profile_length); png_free(png_ptr, chunkdata); }<SPLIT>[3.61240569505284, 1.213889472626613, 0.0, 3.5373842925524492, 1.1255972378374661, 0.0, 0.9701672076669112, 0.9946065798247155, 0.9059316288753189, 2.0295292673408736, 1.5872000964955122, 3.6796532188601057, 1.0933979874030557, 0.0, 0.0, 0.30852482215402843, 1.494564729223536, 3.601574676300892, 0.9914473978613069, 0.24712242304476825, 0.5780479983082486, 0.0, 0.5750247757201478, 1.5771521192305922, 1.027418869238277, 0.6738843113224704, 0.11818065472185141, 1.5806237532086234, 0.8945950124817165, 0.969587250454179, 0.9940939011734088, 0.9053924298597907, 2.0288615559433096, 0.04889276383167627, 0.0, 0.9653245912203542, 0.9897980601469931, 0.9011791483816026, 2.0227778188254817]
0<SPLIT>BOOL LoadImageFile (HWND hwnd, PTSTR pstrPathName, png_byte **ppbImage, int *pxImgSize, int *pyImgSize, int *piChannels, png_color *pBkgColor) { static TCHAR szTmp [MAX_PATH]; if (*ppbImage) { free (*ppbImage); *ppbImage = NULL; } SetCursor (LoadCursor (NULL, IDC_WAIT)); ShowCursor (TRUE); PngLoadImage (pstrPathName, ppbImage, pxImgSize, pyImgSize, piChannels, pBkgColor); ShowCursor (FALSE); SetCursor (LoadCursor (NULL, IDC_ARROW)); if (*ppbImage != NULL) { sprintf (szTmp, "VisualPng - %s", strrchr(pstrPathName, '\\') + 1); SetWindowText (hwnd, szTmp); } else { MessageBox (hwnd, TEXT ("Error in loading the PNG image"), szProgName, MB_ICONEXCLAMATION | MB_OK); return FALSE; } return TRUE; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.18995094088131478, 0.16805247409860422, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.17715856524300236, 0.19837465696559078, 0.19633099684990887, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void allocbuffer(Image *image) { png_size_t size = PNG_IMAGE_BUFFER_SIZE(image->image, image->stride); if (size+32 > image->bufsize) { freebuffer(image); image->buffer = voidcast(png_bytep, malloc(size+32)); if (image->buffer == NULL) { fflush(stdout); fprintf(stderr, "simpletest: out of memory allocating %lu(+32) byte buffer\n", (unsigned long)size); exit(1); } image->bufsize = size+32; } memset(image->buffer, 95, image->bufsize); memset(image->buffer+16, BUFFER_INIT8, size); image->allocsize = size; }<SPLIT>[-0.25365086435942685, -0.17441590959510697, 0.0, -0.2665172434374763, -0.23624420392447085, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.1909204935349246, -0.25297036047912586, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.26569807294376846, -0.22331377035055117, -0.011671540416283347, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.14353953243697165, 0.005287286955244392, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static void perform_gamma_transform_tests(png_modifier *pm) { png_byte colour_type = 0; png_byte bit_depth = 0; unsigned int palette_number = 0; while (next_format(&colour_type, &bit_depth, &palette_number, 1)) { unsigned int i, j; for (i=0; i<pm->ngamma_tests; ++i) for (j=0; j<pm->ngamma_tests; ++j) if (i != j) { gamma_transform_test(pm, colour_type, bit_depth, palette_number, pm->interlace_type, 1/pm->gammas[i], pm->gammas[j], 0, pm->use_input_precision, 0 ); if (fail(pm)) return; } } }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.3615192241061562, -0.10760608081136262, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI store_read(png_structp ppIn, png_bytep pb, png_size_t st) { png_const_structp pp = ppIn; png_store *ps = voidcast(png_store*, png_get_io_ptr(pp)); if (ps == NULL || ps->pread != pp) png_error(pp, "bad store read call"); store_read_imp(ps, pb, st); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
