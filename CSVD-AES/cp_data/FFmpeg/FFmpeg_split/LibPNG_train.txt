0<SPLIT>int main(int argc, char **argv) { FILE *fp = stdout; const char *file_name = NULL; int color_type = 8; int bit_depth = 32; unsigned int colors[5]; unsigned int filters = PNG_ALL_FILTERS; png_fixed_point gamma = 0; chunk_insert *head_insert = NULL; chunk_insert **insert_ptr = &head_insert; memset(colors, 0, sizeof colors); while (--argc > 0) { char *arg = *++argv; if (strcmp(arg, "--sRGB") == 0) { gamma = PNG_DEFAULT_sRGB; continue; } if (strcmp(arg, "--linear") == 0) { gamma = PNG_FP_1; continue; } if (strcmp(arg, "--1.8") == 0) { gamma = PNG_GAMMA_MAC_18; continue; } if (strcmp(arg, "--nofilters") == 0) { filters = PNG_FILTER_NONE; continue; } if (strncmp(arg, "--color=", 8) == 0) { parse_color(arg+8, colors); continue; } if (argc >= 3 && strcmp(arg, "--insert") == 0) { png_const_charp what = *++argv; png_charp param = *++argv; chunk_insert *new_insert; argc -= 2; new_insert = find_insert(what, param); if (new_insert != NULL) { *insert_ptr = new_insert; insert_ptr = &new_insert->next; } continue; } if (arg[0] == '-') { fprintf(stderr, "makepng: %s: invalid option\n", arg); exit(1); } if (strcmp(arg, "palette") == 0) { color_type = PNG_COLOR_TYPE_PALETTE; continue; } if (strncmp(arg, "gray", 4) == 0) { if (arg[4] == 0) { color_type = PNG_COLOR_TYPE_GRAY; continue; } else if (strcmp(arg+4, "a") == 0 || strcmp(arg+4, "alpha") == 0 || strcmp(arg+4, "-alpha") == 0) { color_type = PNG_COLOR_TYPE_GRAY_ALPHA; continue; } } if (strncmp(arg, "rgb", 3) == 0) { if (arg[3] == 0) { color_type = PNG_COLOR_TYPE_RGB; continue; } else if (strcmp(arg+3, "a") == 0 || strcmp(arg+3, "alpha") == 0 || strcmp(arg+3, "-alpha") == 0) { color_type = PNG_COLOR_TYPE_RGB_ALPHA; continue; } } if (color_type == 8 && isdigit(arg[0])) { color_type = atoi(arg); if (color_type < 0 || color_type > 6 || color_type == 1 || color_type == 5) { fprintf(stderr, "makepng: %s: not a valid color type\n", arg); exit(1); } continue; } if (bit_depth == 32 && isdigit(arg[0])) { bit_depth = atoi(arg); if (bit_depth <= 0 || bit_depth > 16 || (bit_depth & -bit_depth) != bit_depth) { fprintf(stderr, "makepng: %s: not a valid bit depth\n", arg); exit(1); } continue; } if (argc == 1) { fp = fopen(arg, "wb"); if (fp == NULL) { fprintf(stderr, "%s: %s: could not open\n", arg, strerror(errno)); exit(1); } file_name = arg; continue; } fprintf(stderr, "makepng: %s: unknown argument\n", arg); exit(1); } if (color_type == 8 || bit_depth == 32) { fprintf(stderr, "usage: makepng [--sRGB|--linear|--1.8] " "[--color=...] color-type bit-depth [file-name]\n" " Make a test PNG file, by default writes to stdout.\n"); exit(1); } { const unsigned int lim = (color_type == PNG_COLOR_TYPE_PALETTE ? 255U : (1U<<bit_depth)-1); unsigned int i; for (i=1; i<=colors[0]; ++i) if (colors[i] > lim) { fprintf(stderr, "makepng: --color=...: %u out of range [0..%u]\n", colors[i], lim); exit(1); } } if (filters == PNG_ALL_FILTERS) { if ((color_type & PNG_COLOR_MASK_PALETTE) != 0 || bit_depth < 8) filters = PNG_FILTER_NONE; else if (color_type & PNG_COLOR_MASK_COLOR) { if (bit_depth == 8) filters &= ~(PNG_FILTER_NONE | PNG_FILTER_AVG); else filters = PNG_FILTER_SUB | PNG_FILTER_PAETH; } else filters &= ~PNG_FILTER_NONE; } { int ret = write_png(&file_name, fp, color_type, bit_depth, gamma, head_insert, filters, colors); if (ret != 0 && file_name != NULL) remove(file_name); return ret; } }<SPLIT>[0.36491818514653585, 3.1310730956947026, 0.0, 0.34210700232091185, 2.955571675205069, 0.0, 4.446031947086303, 4.529473069368816, 6.378717185060543, 7.636565853171125, 2.8858274937087525, 0.3762494122151511, 3.258721606206571, 0.0, 0.0, 0.30852482215402843, 2.7344764129699204, 0.35306556693537716, 3.089671233863607, 1.9292831855416035, 6.3877146422704145, 0.0, -0.08645738172306322, -0.16222078614455715, 1.800326180207177, 3.7255999946910543, 1.6986878034543498, 1.5806237532086234, 4.824567441536237, 4.444561916375874, 4.528227682787063, 6.37683180023163, 7.63452750249751, 1.7623686513065309, 0.0, 4.435917836237717, 4.519543090919859, 6.365381949371468, 7.619681831642853]
0<SPLIT>static int format_set(format_list *pf, png_uint_32 format) { if (format < FORMAT_COUNT) return pf->bits[format >> 5] |= ((png_uint_32)1) << (format & 31); return 0; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>void png_formatted_warning(png_structp png_ptr, png_warning_parameters p, png_const_charp message) { size_t i; char msg[128]; for (i=0; i<(sizeof msg)-1 && *message != '\0'; ++i) { if (*message == '@') { int parameter = -1; switch (*++message) { case '1': parameter = 0; break; case '2': parameter = 1; break; case '\0': continue; default: break; } if (parameter >= 0 && parameter < PNG_WARNING_PARAMETER_COUNT) { png_const_charp parm = p[parameter]; png_const_charp pend = p[parameter] + (sizeof p[parameter]); for (; i<(sizeof msg)-1 && parm != '\0' && parm < pend; ++i) msg[i] = *parm++; ++message; continue; } } msg[i] = *message++; } msg[i] = '\0'; png_warning(png_ptr, msg); }<SPLIT>[3.921690219805821, 0.20020617767107143, 0.0, 3.8416964154316435, 0.14677370157107394, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.6881503599632689, 3.994263105207244, 0.22726853988164963, 0.0, 0.0, 0.30852482215402843, 0.6227518265893592, 3.910956496240465, 0.15215786346038676, -0.14106852214680915, -0.2988828158747199, 0.0, -0.08645738172306322, 0.417570182313826, 0.043718655277859224, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int main(void) { fwrite(signature, sizeof signature, 1, stdout); put_chunk(IHDR, sizeof IHDR); for (;;) put_chunk(unknown, sizeof unknown); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gp_rgb16(Pixel *p, png_const_voidp pb) { png_const_uint_16p pp = voidcast(png_const_uint_16p, pb); p->r = pp[0]; p->g = pp[1]; p->b = pp[2]; p->a = 65535; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void make_four_random_bytes(png_uint_32* seed, png_bytep bytes) { make_random_bytes(seed, bytes, 4); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void image_transform_reset_count(void) { image_transform *next = image_transform_first; int count = 0; while (next != &image_transform_end) { next->local_use = 0; next->next = 0; next = next->list; ++count; } if (count > 32) abort(); }<SPLIT>[0.21027592277004517, -0.3507086565438968, 0.0, 0.18995094088131478, -0.406474384144713, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.29081490870517385, 0.21894446904158188, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, 0.19837465696559078, -0.4000063039086396, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void rpng2_x_redisplay_image(ulg startcol, ulg startrow, ulg width, ulg height) { uch bg_red = rpng2_info.bg_red; uch bg_green = rpng2_info.bg_green; uch bg_blue = rpng2_info.bg_blue; uch *src, *src2=NULL; char *dest; uch r, g, b, a; ulg i, row, lastrow = 0; ulg pixel; int ximage_rowbytes = ximage->bytes_per_line; Trace((stderr, "beginning display loop (image_channels == %d)\n", rpng2_info.channels)) Trace((stderr, " (width = %ld, rowbytes = %d, ximage_rowbytes = %d)\n", rpng2_info.width, rpng2_info.rowbytes, ximage_rowbytes)) Trace((stderr, " (bpp = %d)\n", ximage->bits_per_pixel)) Trace((stderr, " (byte_order = %s)\n", ximage->byte_order == MSBFirst? "MSBFirst" : (ximage->byte_order == LSBFirst? "LSBFirst" : "unknown"))) if (depth == 24 || depth == 32) { ulg red, green, blue; int bpp = ximage->bits_per_pixel; for (lastrow = row = startrow; row < startrow+height; ++row) { src = rpng2_info.image_data + row*rpng2_info.rowbytes; if (bg_image) src2 = bg_data + row*bg_rowbytes; dest = ximage->data + row*ximage_rowbytes; if (rpng2_info.channels == 3) { for (i = rpng2_info.width; i > 0; --i) { red = *src++; green = *src++; blue = *src++; #ifdef NO_24BIT_MASKS pixel = (red << RShift) | (green << GShift) | (blue << BShift); if (bpp == 32) { *dest++ = (char)((pixel >> 24) & 0xff); *dest++ = (char)((pixel >> 16) & 0xff); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } else { *dest++ = (char)((pixel >> 16) & 0xff); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } #else red = (RShift < 0)? red << (-RShift) : red >> RShift; green = (GShift < 0)? green << (-GShift) : green >> GShift; blue = (BShift < 0)? blue << (-BShift) : blue >> BShift; pixel = (red & RMask) | (green & GMask) | (blue & BMask); if (bpp == 32) { *dest++ = (char)((pixel >> 24) & 0xff); *dest++ = (char)((pixel >> 16) & 0xff); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } else { *dest++ = (char)((pixel >> 16) & 0xff); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } #endif } } else { for (i = rpng2_info.width; i > 0; --i) { r = *src++; g = *src++; b = *src++; a = *src++; if (bg_image) { bg_red = *src2++; bg_green = *src2++; bg_blue = *src2++; } if (a == 255) { red = r; green = g; blue = b; } else if (a == 0) { red = bg_red; green = bg_green; blue = bg_blue; } else { alpha_composite(red, r, a, bg_red); alpha_composite(green, g, a, bg_green); alpha_composite(blue, b, a, bg_blue); } #ifdef NO_24BIT_MASKS pixel = (red << RShift) | (green << GShift) | (blue << BShift); if (bpp == 32) { *dest++ = (char)((pixel >> 24) & 0xff); *dest++ = (char)((pixel >> 16) & 0xff); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } else { *dest++ = (char)((pixel >> 16) & 0xff); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } #else red = (RShift < 0)? red << (-RShift) : red >> RShift; green = (GShift < 0)? green << (-GShift) : green >> GShift; blue = (BShift < 0)? blue << (-BShift) : blue >> BShift; pixel = (red & RMask) | (green & GMask) | (blue & BMask); if (bpp == 32) { *dest++ = (char)((pixel >> 24) & 0xff); *dest++ = (char)((pixel >> 16) & 0xff); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } else { *dest++ = (char)((pixel >> 16) & 0xff); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } #endif } } if (((row+1) & 0xf) == 0) { XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0, (int)lastrow, rpng2_info.width, 16); XFlush(display); lastrow = row + 1; } } } else if (depth == 16) { ush red, green, blue; for (lastrow = row = startrow; row < startrow+height; ++row) { src = rpng2_info.row_pointers[row]; if (bg_image) src2 = bg_data + row*bg_rowbytes; dest = ximage->data + row*ximage_rowbytes; if (rpng2_info.channels == 3) { for (i = rpng2_info.width; i > 0; --i) { red = ((ush)(*src) << 8); ++src; green = ((ush)(*src) << 8); ++src; blue = ((ush)(*src) << 8); ++src; pixel = ((red >> RShift) & RMask) | ((green >> GShift) & GMask) | ((blue >> BShift) & BMask); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } } else { for (i = rpng2_info.width; i > 0; --i) { r = *src++; g = *src++; b = *src++; a = *src++; if (bg_image) { bg_red = *src2++; bg_green = *src2++; bg_blue = *src2++; } if (a == 255) { red = ((ush)r << 8); green = ((ush)g << 8); blue = ((ush)b << 8); } else if (a == 0) { red = ((ush)bg_red << 8); green = ((ush)bg_green << 8); blue = ((ush)bg_blue << 8); } else { alpha_composite(r, r, a, bg_red); alpha_composite(g, g, a, bg_green); alpha_composite(b, b, a, bg_blue); red = ((ush)r << 8); green = ((ush)g << 8); blue = ((ush)b << 8); } pixel = ((red >> RShift) & RMask) | ((green >> GShift) & GMask) | ((blue >> BShift) & BMask); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } } if (((row+1) & 0xf) == 0) { XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0, (int)lastrow, rpng2_info.width, 16); XFlush(display); lastrow = row + 1; } } } else { } Trace((stderr, "calling final XPutImage()\n")) if (lastrow < startrow+height) { XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0, (int)lastrow, rpng2_info.width, rpng2_info.height-lastrow); XFlush(display); } }<SPLIT>[4.6949015316882745, 3.6819879299096705, 0.0, 4.602476722629628, 3.508819760920856, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 3.9447082945133944, 3.8369581620336746, 3.099171444821049, 0.0, 0.0, 0.30852482215402843, 3.7806518961309323, 3.7562655862706786, 2.9571518336950406, -0.270465503877335, -0.518115519420462, 0.0, 3.441447457974062, 3.3165250246057414, 3.7325944576294265, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gamma_display_init(gamma_display *dp, png_modifier *pm, png_uint_32 id, double file_gamma, double screen_gamma, png_byte sbit, int threshold_test, int use_input_precision, int scale16, int expand16, int do_background, PNG_CONST png_color_16 *pointer_to_the_background_color, double background_gamma) { standard_display_init(&dp->this, &pm->this, id, 0, pm->use_update_info); dp->pm = pm; dp->file_gamma = file_gamma; dp->screen_gamma = screen_gamma; dp->background_gamma = background_gamma; dp->sbit = sbit; dp->threshold_test = threshold_test; dp->use_input_precision = use_input_precision; dp->scale16 = scale16; dp->expand16 = expand16; dp->do_background = do_background; if (do_background && pointer_to_the_background_color != 0) dp->background_color = *pointer_to_the_background_color; else memset(&dp->background_color, 0, sizeof dp->background_color); dp->maxerrout = dp->maxerrpc = dp->maxerrabs = 0; }<SPLIT>[0.21027592277004517, -0.10830612948931077, 0.0, 0.18995094088131478, -0.17240788634188003, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.07104719533062549, 0.21894446904158188, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.13281935569359377, 0.19837465696559078, -0.157054070266268, -0.011671540416283347, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static png_uint_32 png_pass_start_col(int pass) { int x, y; ++pass; for (x=0; x<8; ++x) for (y=0; y<8; ++y) if (adam7[y][x] == pass) return x; return 0xf; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.6586564490689124, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.03454968660237938, -0.5591795518777907, -0.21702784222394986, 0.42674115187998785, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 1.7623686513065309, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static int check_one_character(checkfp_command *co, checkfp_control c, int ch) { png_size_t index = 0; const char test = (char)ch; const int number_is_valid = png_check_fp_number(&test, 1, &c.state, &index); const int character_accepted = (index == 1); if (c.check_state != exponent && isdigit(ch) && ch != '0') c.is_zero = 0; if (c.check_state == start && c.at_start && ch == '-') c.is_negative = 1; if (isprint(ch)) co->number[c.cnumber++] = (char)ch; else { co->number[c.cnumber++] = '<'; co->number[c.cnumber++] = hexdigits[(ch >> 4) & 0xf]; co->number[c.cnumber++] = hexdigits[ch & 0xf]; co->number[c.cnumber++] = '>'; } co->number[c.cnumber] = 0; if (co->verbose > 1) fprintf(stderr, "%s\n", co->number); if (++(co->ctimes) == 1000000) { if (co->verbose == 1) fputc('.', stderr); co->ctimes = 0; ++(co->cmillions); } if (!number_is_valid) ++(co->cinvalid); if (!character_accepted) ++(co->cnoaccept); if (index != 0 && index != 1) { fprintf(stderr, "%s: read beyond end of string (%lu)\n", co->number, (unsigned long)index); return 0; } if (PNG_FP_IS_NEGATIVE(c.state) != (number_is_valid && !c.is_zero && c.is_negative)) { fprintf(stderr, "%s: negative when it is not\n", co->number); return 0; } if (PNG_FP_IS_ZERO(c.state) != (number_is_valid && c.is_zero)) { fprintf(stderr, "%s: zero when it is not\n", co->number); return 0; } if (PNG_FP_IS_POSITIVE(c.state) != (number_is_valid && !c.is_zero && !c.is_negative)) { fprintf(stderr, "%s: positive when it is not\n", co->number); return 0; } if (isdigit(ch)) { if (!character_accepted) { fprintf(stderr, "%s: digit '%c' not accepted\n", co->number, ch); return 0; } if (!number_is_valid) { fprintf(stderr, "%s: saw a digit (%c) but number not valid\n", co->number, ch); return 0; } ++c.cdigits_in_state; c.at_start = 0; c.number_was_valid = 1; if (c.cdigits_in_state < 1) return check_all_characters(co, c); else return check_some_characters(co, c, state_characters[c.check_state].tests); } else if (((ch == '+' || ch == '-') && c.check_state != fraction && c.at_start) || (ch == '.' && c.check_state == start) || ((ch == 'e' || ch == 'E') && c.number_was_valid && c.check_state != exponent)) { if (!character_accepted) { fprintf(stderr, "%s: character '%c' not accepted\n", co->number, ch); return 0; } if (number_is_valid && (c.check_state != start || ch != '.')) { fprintf(stderr, "%s: saw a non-digit (%c) but number valid\n", co->number, ch); return 0; } c.number_was_valid = number_is_valid; if (c.check_state == start && ch == '.') { c.check_state = fraction; c.at_start = !number_is_valid; c.cdigits_in_state = 0; c.limit = co->limit; return check_all_characters(co, c); } else if (c.check_state < exponent && (ch == 'e' || ch == 'E')) { c.check_state = exponent; c.at_start = 1; c.cdigits_in_state = 0; c.limit = co->limit; return check_all_characters(co, c); } else { if (ch != '-' && ch != '+') { fprintf(stderr, "checkfp: internal error (1)\n"); return 0; } c.at_start = 0; return check_all_characters(co, c); } } else { if (character_accepted) { fprintf(stderr, "%s: character '%c' [0x%.2x] accepted\n", co->number, ch, ch); return 0; } if (number_is_valid != c.number_was_valid) { fprintf(stderr, "%s: character '%c' [0x%.2x] changed number validity\n", co->number, ch, ch); return 0; } } return 1; }<SPLIT>[3.3031211702998586, 2.447938701268142, 0.0, 3.2330721696732554, 2.317208499379161, 0.0, 2.5343063404056374, 2.5852965001195605, 2.7301934809370603, 4.668134719496286, 2.646080897300154, 3.365043332512967, 2.552142320070687, 0.0, 0.0, 0.30852482215402843, 2.5213665923260105, 3.292192856361319, 2.4270742330207753, 0.8941073316973973, 2.5511423302199274, 0.0, -0.08645738172306322, -0.16222078614455715, 1.413872524722727, 1.7637827696683932, 0.9084342290881006, 0.6817979554923368, 2.204585822166557, 2.5333258501189415, 2.584454102899553, 2.7292055533170707, 4.66682200138058, 1.7623686513065309, 0.0, 2.5270915514781676, 2.5781833239947827, 2.722580082044891, 4.656615001327775]
1<SPLIT>static void png_format_buffer(png_structp png_ptr, png_charp buffer, png_const_charp error_message) { int iout = 0, iin = 0; while (iin < 4) { int c = png_ptr->chunk_name[iin++]; if (isnonalpha(c)) { buffer[iout++] = PNG_LITERAL_LEFT_SQUARE_BRACKET; buffer[iout++] = png_digit[(c & 0xf0) >> 4]; buffer[iout++] = png_digit[c & 0x0f]; buffer[iout++] = PNG_LITERAL_RIGHT_SQUARE_BRACKET; } else { buffer[iout++] = (png_byte)c; } } if (error_message == NULL) buffer[iout] = '\0'; else { buffer[iout++] = ':'; buffer[iout++] = ' '; png_memcpy(buffer + iout, error_message, PNG_MAX_ERROR_TEXT); buffer[iout + PNG_MAX_ERROR_TEXT - 1] = '\0'; } }<SPLIT>[0.36491818514653585, 0.0018768373536828752, 0.0, 0.34210700232091185, -0.044735251176698444, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.04882610287367361, 0.3762494122151511, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, 0.0027959847161670454, 0.35306556693537716, -0.04662123679246273, -0.14106852214680915, 0.13958259121676436, 0.0, -0.08645738172306322, 0.417570182313826, -0.27247069920941797, -0.1980344553542678, -0.22049944857796966, 0.6817979554923368, -0.22825425296243224, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI standard_info(png_structp pp, png_infop pi) { standard_display *dp = voidcast(standard_display*, png_get_progressive_ptr(pp)); standard_info_imp(dp, pp, pi, 1 ); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.18995094088131478, -0.5554257918374248, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4815445167472644, 0.19837465696559078, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void rpng2_win_init() { ulg i; ulg rowbytes = rpng2_info.rowbytes; Trace((stderr, "beginning rpng2_win_init()\n")) Trace((stderr, " rowbytes = %d\n", rpng2_info.rowbytes)) Trace((stderr, " width = %ld\n", rpng2_info.width)) Trace((stderr, " height = %ld\n", rpng2_info.height)) rpng2_info.image_data = (uch *)malloc(rowbytes * rpng2_info.height); if (!rpng2_info.image_data) { readpng2_cleanup(&rpng2_info); return; } rpng2_info.row_pointers = (uch **)malloc(rpng2_info.height * sizeof(uch *)); if (!rpng2_info.row_pointers) { free(rpng2_info.image_data); rpng2_info.image_data = NULL; readpng2_cleanup(&rpng2_info); return; } for (i = 0; i < rpng2_info.height; ++i) rpng2_info.row_pointers[i] = rpng2_info.image_data + i*rowbytes; if (rpng2_win_create_window()) { readpng2_cleanup(&rpng2_info); return; } rpng2_info.state = kWindowInit; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.34210700232091185, -0.08729279623175898, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.03595125540090747, 0.35306556693537716, -0.06870780348722379, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void PNGCBAPI display_warning(png_structp pp, png_const_charp warning) { display_log(get_dp(pp), LIBPNG_WARNING, "%s", warning); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void insert_tEXt(png_structp png_ptr, png_infop info_ptr, int nparams, png_charpp params) { png_text text; check_param_count(nparams, 2); clear_text(&text, params[0]); set_text(png_ptr, info_ptr, &text, params[1]); }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static size_t safecat(char *buffer, size_t bufsize, size_t pos, PNG_CONST char *cat) { while (pos < bufsize && cat != NULL && *cat != 0) buffer[pos++] = *cat++; if (pos >= bufsize) pos = bufsize-1; buffer[pos] = 0; return pos; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void standard_palette_validate(standard_display *dp, png_const_structp pp, png_infop pi) { int npalette; store_palette palette; if (read_palette(palette, &npalette, pp, pi) != dp->is_transparent) png_error(pp, "validate: palette transparency changed"); if (npalette != dp->npalette) { size_t pos = 0; char msg[64]; pos = safecat(msg, sizeof msg, pos, "validate: palette size changed: "); pos = safecatn(msg, sizeof msg, pos, dp->npalette); pos = safecat(msg, sizeof msg, pos, " -> "); pos = safecatn(msg, sizeof msg, pos, npalette); png_error(pp, msg); } { int i = npalette; while (--i >= 0) if (palette[i].red != dp->palette[i].red || palette[i].green != dp->palette[i].green || palette[i].blue != dp->palette[i].blue || palette[i].alpha != dp->palette[i].alpha) png_error(pp, "validate: PLTE or tRNS chunk changed"); } }<SPLIT>[-0.25365086435942685, -0.04219634938351458, 0.0, -0.2665172434374763, -0.10857156875928925, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.07104719533062549, -0.25297036047912586, -0.023453142295599506, 0.0, 0.0, 0.30852482215402843, -0.13281935569359377, -0.26569807294376846, -0.09079437018198484, 0.37651940477529405, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.03454968660237938, 0.11818065472185141, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int rpng2_x_msb(ulg u32val) { int i; for (i = 31; i >= 0; --i) { if (u32val & 0x80000000L) break; u32val <<= 1; } return i; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.6586564490689124, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3070243011888601, -0.6720729196443977, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static void image_transform_png_set_gray_to_rgb_set(PNG_CONST image_transform *this, transform_display *that, png_structp pp, png_infop pi) { png_set_gray_to_rgb(pp); this->next->set(this->next, that, pp, pi); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gpc_noop(Pixel *out, const Pixel *in, const Background *back) { (void)back; out->r = in->r; out->g = in->g; out->b = in->b; out->a = in->a; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gp_abgr8(Pixel *p, png_const_voidp pb) { png_const_bytep pp = voidcast(png_const_bytep, pb); p->r = pp[3]; p->g = pp[2]; p->b = pp[1]; p->a = pp[0]; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI pngtest_read_data(png_structp png_ptr, png_bytep data, png_size_t length) { png_size_t check = 0; png_voidp io_ptr; io_ptr = png_get_io_ptr(png_ptr); if (io_ptr != NULL) { check = fread(data, 1, length, (png_FILE_p)io_ptr); } if (check != length) { png_error(png_ptr, "Read Error"); } #ifdef PNG_IO_STATE_SUPPORTED pngtest_check_io_state(png_ptr, length, PNG_IO_READING); #endif }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.34210700232091185, 0.48723406201155817, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.4871364861795985, 0.35306556693537716, 0.39511009710275835, -0.7880534307994381, -0.518115519420462, 0.0, 0.13403667075800713, 2.1569430876889752, 0.21937940777079099, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>int main(int argc, char **argv) { int ok = 0; FILE *fp = tmpfile(); if (fp != NULL) { int err = 0; int nfiles = 0; if (argc > 1) { int i; for (i=1; i<argc; ++i) { if (add_one_file(fp, argv[i])) ++nfiles; else { err = 1; break; } } } else { char filename[FILENAME_MAX+1]; while (fgets(filename, FILENAME_MAX+1, stdin)) { size_t len = strlen(filename); if (filename[len-1] == '\n') { filename[len-1] = 0; if (add_one_file(fp, filename)) ++nfiles; else { err = 1; break; } } else { fprintf(stderr, "timepng: truncated file name ...%s\n", filename+len-32); err = 1; break; } } if (ferror(stdin)) { fprintf(stderr, "timepng: stdin: read error\n"); err = 1; } } if (!err) { if (nfiles > 0) ok = perform_one_test(fp, nfiles); else fprintf(stderr, "usage: timepng {files} or ls files | timepng\n"); } (void)fclose(fp); } else fprintf(stderr, "timepng: could not open temporary file\n"); return ok == 0; }<SPLIT>[-0.09900860198293619, 0.7951941986232371, 0.0, -0.11436118199787926, 0.7213005598143911, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 1.040052222782594, 0.7081292429973187, -0.09566541730555662, 0.8426763052258066, 0.0, 0.0, 0.30852482215402843, 0.6421254466478965, -0.11100716297398205, 0.7705817309136963, 0.8941073316973973, 1.1261297571726039, 0.0, -0.08645738172306322, -0.16222078614455715, 0.21937940777079099, 0.8373690800743588, 0.7955408613214935, 0.6817979554923368, 0.7074534682410251, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 1.039626388904333, 2.6191065950439585, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 1.0350888753871217]
0<SPLIT>static void store_pool_delete(png_store *ps, store_pool *pool) { if (pool->list != NULL) { fprintf(stderr, "%s: %s %s: memory lost (list follows):\n", ps->test, pool == &ps->read_memory_pool ? "read" : "write", pool == &ps->read_memory_pool ? (ps->current != NULL ? ps->current->name : "unknown file") : ps->wname); ++ps->nerrors; do { store_memory *next = pool->list; pool->list = next->next; next->next = NULL; fprintf(stderr, "\t%lu bytes @ %p\n", (unsigned long)next->size, (PNG_CONST void*)(next+1)); store_memory_free(NULL, pool, next); } while (pool->list != NULL); } if (pool->max > pool->max_max) pool->max_max = pool->max; pool->max = 0; if (pool->current != 0) fprintf(stderr, "%s: %s %s: memory counter mismatch (internal error)\n", ps->test, pool == &ps->read_memory_pool ? "read" : "write", pool == &ps->read_memory_pool ? (ps->current != NULL ? ps->current->name : "unknown file") : ps->wname); pool->current = 0; if (pool->limit > pool->max_limit) pool->max_limit = pool->limit; pool->limit = 0; if (pool->total > pool->max_total) pool->max_total = pool->total; pool->total = 0; store_pool_mark(pool->mark); }<SPLIT>[0.5195604475230265, 0.15613299093387398, 0.0, 0.4942630637605089, 0.08293738398848315, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.2086571671460724, 0.5335543553887203, 0.18168277948578615, 0.0, 0.0, 0.30852482215402843, 0.13841132512592785, 0.5077564769051636, 0.10798473007086465, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int gama_modify(png_modifier *pm, png_modification *me, int add) { UNUSED(add) png_save_uint_32(pm->buffer, 4); png_save_uint_32(pm->buffer+4, CHUNK_gAMA); png_save_uint_32(pm->buffer+8, ((gama_modification*)me)->gamma); return 1; }<SPLIT>[-0.09900860198293619, -0.46089162338689044, 0.0, -0.11436118199787926, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.09566541730555662, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.11100716297398205, -0.5104391373824448, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_expand_gray_1_2_4_to_8_mod(PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp, PNG_CONST transform_display *display) { image_transform_png_set_expand_mod(this, that, pp, display); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int main(int argc, char **argv) { #ifdef sgi char tmpline[80]; #endif char *p, *bgstr = NULL; int rc, alen, flen; int error = 0; int timing = FALSE; int have_bg = FALSE; #ifdef FEATURE_LOOP int loop = FALSE; long loop_interval = -1; #endif double LUT_exponent; double CRT_exponent = 2.2; double default_display_exponent; XEvent e; KeySym k; displayname = (char *)NULL; filename = (char *)NULL; memset(&rpng2_info, 0, sizeof(mainprog_info)); #if defined(NeXT) LUT_exponent = 1.0 / 2.2; #elif defined(sgi) LUT_exponent = 1.0 / 1.7; infile = fopen("/etc/config/system.glGammaVal", "r"); if (infile) { double sgi_gamma; fgets(tmpline, 80, infile); fclose(infile); sgi_gamma = atof(tmpline); if (sgi_gamma > 0.0) LUT_exponent = 1.0 / sgi_gamma; } #elif defined(Macintosh) LUT_exponent = 1.8 / 2.61; #else LUT_exponent = 1.0; #endif default_display_exponent = LUT_exponent * CRT_exponent; if ((p = getenv("SCREEN_GAMMA")) != NULL) rpng2_info.display_exponent = atof(p); else rpng2_info.display_exponent = default_display_exponent; while (*++argv && !error) { if (!strncmp(*argv, "-display", 2)) { if (!*++argv) ++error; else displayname = *argv; } else if (!strncmp(*argv, "-gamma", 2)) { if (!*++argv) ++error; else { rpng2_info.display_exponent = atof(*argv); if (rpng2_info.display_exponent <= 0.0) ++error; } } else if (!strncmp(*argv, "-bgcolor", 4)) { if (!*++argv) ++error; else { bgstr = *argv; if (strlen(bgstr) != 7 || bgstr[0] != '#') ++error; else { have_bg = TRUE; bg_image = FALSE; } } } else if (!strncmp(*argv, "-bgpat", 4)) { if (!*++argv) ++error; else { pat = atoi(*argv); if (pat >= 0 && pat < num_bgpat) { bg_image = TRUE; have_bg = FALSE; } else ++error; } } else if (!strncmp(*argv, "-usleep", 2)) { if (!*++argv) ++error; else { usleep_duration = (ulg)atol(*argv); demo_timing = TRUE; } } else if (!strncmp(*argv, "-pause", 2)) { pause_after_pass = TRUE; } else if (!strncmp(*argv, "-timing", 2)) { timing = TRUE; #ifdef FEATURE_LOOP } else if (!strncmp(*argv, "-loop", 2)) { loop = TRUE; if (!argv[1] || !is_number(argv[1])) loop_interval = 2; else { ++argv; loop_interval = atol(*argv); if (loop_interval < 0) loop_interval = 2; else if (loop_interval > 100000) loop_interval = 100000; } #endif } else { if (**argv != '-') { filename = *argv; if (argv[1]) ++error; } else ++error; } } if (!filename) ++error; if (error) { fprintf(stderr, "\n%s %s: %s\n\n", PROGNAME, VERSION, appname); readpng2_version_info(); fprintf(stderr, "\n" "Usage: %s [-display xdpy] [-gamma exp] [-bgcolor bg | -bgpat pat]\n" #ifdef FEATURE_LOOP " %*s [-usleep dur | -timing] [-pause] [-loop [sec]] file.png\n\n" #else " %*s [-usleep dur | -timing] [-pause] file.png\n\n" #endif " xdpy\tname of the target X display (e.g., ``hostname:0'')\n" " exp \ttransfer-function exponent (``gamma'') of the display\n" "\t\t system in floating-point format (e.g., ``%.1f''); equal\n" "\t\t to the product of the lookup-table exponent (varies)\n" "\t\t and the CRT exponent (usually 2.2); must be positive\n" " bg \tdesired background color in 7-character hex RGB format\n" "\t\t (e.g., ``#ff7700'' for orange: same as HTML colors);\n" "\t\t used with transparent images; overrides -bgpat\n" " pat \tdesired background pattern number (0-%d); used with\n" "\t\t transparent images; overrides -bgcolor\n" #ifdef FEATURE_LOOP " -loop\tloops through background images after initial display\n" "\t\t is complete (depends on -bgpat)\n" " sec \tseconds to display each background image (default = 2)\n" #endif " dur \tduration in microseconds to wait after displaying each\n" "\t\t row (for demo purposes)\n" " -timing\tenables delay for every block read, to simulate modem\n" "\t\t download of image (~36 Kbps)\n" " -pause\tpauses after displaying each pass until mouse clicked\n" "\nPress Q, Esc or mouse button 1 (within image window, after image\n" "is displayed) to quit.\n" "\n", PROGNAME, (int)strlen(PROGNAME), " ", default_display_exponent, num_bgpat-1); exit(1); } if (!(infile = fopen(filename, "rb"))) { fprintf(stderr, PROGNAME ": can't open PNG file [%s]\n", filename); ++error; } else { incount = fread(inbuf, 1, INBUFSIZE, infile); if (incount < 8 || !readpng2_check_sig(inbuf, 8)) { fprintf(stderr, PROGNAME ": [%s] is not a PNG file: incorrect signature\n", filename); ++error; } else if ((rc = readpng2_init(&rpng2_info)) != 0) { switch (rc) { case 2: fprintf(stderr, PROGNAME ": [%s] has bad IHDR (libpng longjmp)\n", filename); break; case 4: fprintf(stderr, PROGNAME ": insufficient memory\n"); break; default: fprintf(stderr, PROGNAME ": unknown readpng2_init() error\n"); break; } ++error; } else { Trace((stderr, "about to call XOpenDisplay()\n")) display = XOpenDisplay(displayname); if (!display) { readpng2_cleanup(&rpng2_info); fprintf(stderr, PROGNAME ": can't open X display [%s]\n", displayname? displayname : "default"); ++error; } } if (error) fclose(infile); } if (error) { fprintf(stderr, PROGNAME ": aborting.\n"); exit(2); } alen = strlen(appname); flen = strlen(filename); if (alen + flen + 3 > 1023) sprintf(titlebar, "%s: ...%s", appname, filename+(alen+flen+6-1023)); else sprintf(titlebar, "%s: %s", appname, filename); if (have_bg) { unsigned r, g, b; sscanf(bgstr+1, "%2x%2x%2x", &r, &g, &b); rpng2_info.bg_red = (uch)r; rpng2_info.bg_green = (uch)g; rpng2_info.bg_blue = (uch)b; } else rpng2_info.need_bgcolor = TRUE; rpng2_info.state = kPreInit; rpng2_info.mainprog_init = rpng2_x_init; rpng2_info.mainprog_display_row = rpng2_x_display_row; rpng2_info.mainprog_finish_display = rpng2_x_finish_display; for (;;) { Trace((stderr, "about to call readpng2_decode_data()\n")) if (readpng2_decode_data(&rpng2_info, inbuf, incount)) ++error; Trace((stderr, "done with readpng2_decode_data()\n")) if (error || incount != INBUFSIZE || rpng2_info.state == kDone) { if (rpng2_info.state == kDone) { Trace((stderr, "done decoding PNG image\n")) } else if (ferror(infile)) { fprintf(stderr, PROGNAME ": error while reading PNG image file\n"); exit(3); } else if (feof(infile)) { fprintf(stderr, PROGNAME ": end of file reached " "(unexpectedly) while reading PNG image file\n"); exit(3); } else { } break; } if (timing) sleep(1); incount = fread(inbuf, 1, INBUFSIZE, infile); } fclose(infile); Trace((stderr, "about to call readpng2_cleanup()\n")) readpng2_cleanup(&rpng2_info); if (error) { fprintf(stderr, PROGNAME ": libpng error while decoding PNG image\n"); exit(3); } #ifdef FEATURE_LOOP if (loop && bg_image) { Trace((stderr, "entering -loop loop (FEATURE_LOOP)\n")) for (;;) { int i, use_sleep; struct timeval now, then; if (gettimeofday(&then, NULL) == 0) { then.tv_sec += loop_interval; use_sleep = FALSE; } else use_sleep = TRUE; if (XCheckMaskEvent(display, KeyPressMask | ButtonPressMask, &e)) if (QUIT(e,k)) break; if (++pat >= num_bgpat) pat = 0; rpng2_x_reload_bg_image(); if (use_sleep || gettimeofday(&now, NULL) != 0) { for (i = loop_interval; i > 0; --i) { sleep(1); if (XCheckMaskEvent(display, KeyPressMask | ButtonPressMask, &e) && QUIT(e,k)) break; } } else { if (now.tv_sec < then.tv_sec || (now.tv_sec == then.tv_sec && now.tv_usec < then.tv_usec)) { int quit = FALSE; long seconds_to_go = then.tv_sec - now.tv_sec; long usleep_usec; while (seconds_to_go-- > 1) { int seconds_done = 0; for (i = seconds_to_go; i > 0 && !quit; --i) { sleep(1); if (XCheckMaskEvent(display, KeyPressMask | ButtonPressMask, &e) && QUIT(e,k)) quit = TRUE; if (++seconds_done > 1000) break; } if (quit) break; if (gettimeofday(&now, NULL) == 0) { if (now.tv_sec >= then.tv_sec) break; seconds_to_go = then.tv_sec - now.tv_sec; } else ++seconds_to_go; } if (quit) break; if (gettimeofday(&now, NULL) == 0) { usleep_usec = 1000000L*(then.tv_sec - now.tv_sec) + then.tv_usec - now.tv_usec; if (usleep_usec > 0) usleep((ulg)usleep_usec); } } } rpng2_x_redisplay_image (0, 0, rpng2_info.width, rpng2_info.height); } } else #endif if (rpng2_info.state >= kWindowInit) { Trace((stderr, "entering final wait-for-quit-event loop\n")) do { XNextEvent(display, &e); if (e.type == Expose) { XExposeEvent *ex = (XExposeEvent *)&e; rpng2_x_redisplay_image (ex->x, ex->y, ex->width, ex->height); } } while (!QUIT(e,k)); } else { fprintf(stderr, PROGNAME ": init callback never called: probable " "libpng error while decoding PNG metadata\n"); exit(4); } Trace((stderr, "about to call rpng2_x_cleanup()\n")) rpng2_x_cleanup(); return 0; }<SPLIT>[9.024884878230013, 6.546745067827506, 0.0, 8.862846442938345, 6.275060189499791, 0.0, 4.967411657999212, 4.882959718323225, 4.886139306100936, 1.040052222782594, 7.101371813893271, 4.308872991554383, 4.261608334915568, 0.0, 0.0, 0.30852482215402843, 6.841683865379819, 4.220338316180038, 4.083566735127855, 2.7056650759247582, 6.716563697589027, 0.0, 13.804667924584367, 10.27401664610634, 4.575766069595499, 4.652013684285088, 2.8276214811204197, 6.9735785395063425, 4.918138213656582, 4.965808116264128, 4.881641060948428, 4.884621062857493, 1.039626388904333, 2.6191065950439585, 0.0, 4.956506822990321, 4.872517593997146, 4.875144821828777, 1.0350888753871217]
0<SPLIT>void readpng_version_info() { fprintf(stderr, " Compiled without libpng, zlib or PBMPLUS/NetPBM.\n"); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int output_quantization_factor(PNG_CONST png_modifier *pm, int in_depth, int out_depth) { if (out_depth == 16 && in_depth != 16 && pm->calculations_use_input_precision) return 257; else return 1; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>void usage() { fprintf (stderr, "PNM2PNG\n"); fprintf (stderr, " by Willem van Schaik, 1999\n"); #ifdef __TURBOC__ fprintf (stderr, " for Turbo-C and Borland-C compilers\n"); #else fprintf (stderr, " for Linux (and Unix) compilers\n"); #endif fprintf (stderr, "Usage: pnm2png [options] <file>.<pnm> [<file>.png]\n"); fprintf (stderr, " or: ... | pnm2png [options]\n"); fprintf (stderr, "Options:\n"); fprintf (stderr, " -i[nterlace] write png-file with interlacing on\n"); fprintf (stderr, " -a[lpha] <file>.pgm read PNG alpha channel as pgm-file\n"); fprintf (stderr, " -h | -? print this help-information\n"); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.3265555562789663, -0.26569807294376846, -0.4000063039086396, -0.917450412529964, -0.518115519420462, 0.0, 0.02378964451747194, 1.5771521192305922, -0.3427350002065907, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void resetimage(Image *image) { if (image->input_file != NULL) rewind(image->input_file); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void perform_one_test_safe(FILE *fp, int argc, const char **argv, png_uint_32 *default_flags, display *d, const char *test) { if (setjmp(d->error_return) == 0) { d->test = test; #ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED perform_one_test(fp, argc, argv, default_flags, d, 0); #endif #ifdef PNG_READ_USER_CHUNKS_SUPPORTED perform_one_test(fp, argc, argv, default_flags, d, 1); #endif d->test = init; } }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.4084991676475909, 0.0, 0.13403667075800713, 2.1569430876889752, -0.5535279031981089, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void transform_from_formats(Transform *result, Image *in_image, const Image *out_image, png_const_colorp background, int via_linear) { png_uint_32 in_format, out_format; png_uint_32 in_base, out_base; memset(result, 0, sizeof *result); result->in_image = in_image; result->out_image = out_image; in_format = in_image->image.format; out_format = out_image->image.format; if (in_format & PNG_FORMAT_FLAG_LINEAR) result->in_opaque = 65535; else result->in_opaque = 255; result->output_8bit = (out_format & PNG_FORMAT_FLAG_LINEAR) == 0; result->is_palette = 0; result->accumulate = (in_image->opts & ACCUMULATE) != 0; result->in_gp = get_pixel(in_format); result->out_gp = get_pixel(out_format); in_format &= BASE_FORMATS | PNG_FORMAT_FLAG_COLORMAP; in_base = in_format & BASE_FORMATS; out_format &= BASE_FORMATS | PNG_FORMAT_FLAG_COLORMAP; out_base = out_format & BASE_FORMATS; if (via_linear) { if (out_format & (PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_COLORMAP)) { fprintf(stderr, "internal transform via linear error 0x%x->0x%x\n", in_format, out_format); exit(1); } result->transform = gpc_fn[in_base][out_base | PNG_FORMAT_FLAG_LINEAR]; result->from_linear = gpc_fn[out_base | PNG_FORMAT_FLAG_LINEAR][out_base]; result->error_ptr = gpc_error_via_linear[in_format][out_format]; } else if (~in_format & out_format & PNG_FORMAT_FLAG_COLORMAP) { result->transform = gpc_fn[in_base][out_base]; result->from_linear = NULL; result->error_ptr = gpc_error_to_colormap[in_base][out_base]; } else { if (in_format & out_format & PNG_FORMAT_FLAG_COLORMAP) result->transform = gpc_fn_colormapped[in_base][out_base]; else result->transform = gpc_fn[in_base][out_base]; result->from_linear = NULL; result->error_ptr = gpc_error[in_format][out_format]; } result->background = NULL; if (in_format & ~out_format & PNG_FORMAT_FLAG_ALPHA) { result->background = &result->background_color; if (out_format & PNG_FORMAT_FLAG_LINEAR || via_linear) { if (out_format & PNG_FORMAT_FLAG_COLORMAP) { result->background_color.ir = result->background_color.ig = result->background_color.ib = 0; result->background_color.dr = result->background_color.dg = result->background_color.db = 0; } else { result->background_color.ir = result->background_color.ig = result->background_color.ib = BUFFER_INIT8 * 257; result->background_color.dr = result->background_color.dg = result->background_color.db = 0; } } else { if (background != NULL) { if (out_format & PNG_FORMAT_FLAG_COLOR) { result->background_color.ir = background->red; result->background_color.ig = background->green; result->background_color.ib = background->blue; result->background_color.dr = sRGB_to_d[background->red]; result->background_color.dg = sRGB_to_d[background->green]; result->background_color.db = sRGB_to_d[background->blue]; } else { result->background_color.ir = result->background_color.ig = result->background_color.ib = background->green; result->background_color.dr = result->background_color.dg = result->background_color.db = sRGB_to_d[background->green]; } } else if ((out_format & PNG_FORMAT_FLAG_COLORMAP) == 0) { result->background_color.ir = result->background_color.ig = result->background_color.ib = BUFFER_INIT8; result->background_color.dr = result->background_color.dg = result->background_color.db = sRGB_to_d[BUFFER_INIT8]; } else result->background = NULL; } } if (result->background == NULL) { result->background_color.ir = result->background_color.ig = result->background_color.ib = -1; result->background_color.dr = result->background_color.dg = result->background_color.db = 1E30; } result->error[0] = result->error_ptr[0]; result->error[1] = result->error_ptr[1]; result->error[2] = result->error_ptr[2]; result->error[3] = result->error_ptr[3]; }<SPLIT>[5.9320396307002, 2.117389800739161, 0.0, 5.819725214146405, 1.9767481389386767, 0.0, 1.3177536816088504, 1.3480932287791254, 1.2376156019774536, 0.380400859743741, 2.686038663368254, 6.039227366463645, 2.210249117101711, 0.0, 0.0, 0.30852482215402843, 2.5407402123845477, 5.921938325847688, 2.0736891659045984, -0.14106852214680915, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, 1.1679474712326225, 0.18343000506680518, -0.3333928163445767, 0.6817979554923368, 0.5203119240003335, 1.3170847170463484, 1.3475072793347742, 1.2369948159429325, 0.3801362775450152, 2.6191065950439585, 0.0, 1.3123839157220905, 1.3427725632242797, 1.2323429545022004, 0.3766295797615486]
0<SPLIT>static void init_gamma_errors(png_modifier *pm) { pm->error_gray_2 = pm->error_gray_4 = pm->error_gray_8 = -1.; pm->error_color_8 = -1.; pm->error_indexed = -1.; pm->error_gray_16 = pm->error_color_16 = -1.; }<SPLIT>[-0.09900860198293619, -0.4829282167554892, 0.0, -0.11436118199787926, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.09566541730555662, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.11100716297398205, -0.5325257040772059, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI error_handler(png_structp png_ptr, png_const_charp message) { stop(get_control(png_ptr), LIBPNG_ERROR_CODE, message); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>int readpng_get_bgcolor(uch *red, uch *green, uch *blue) { png_color_16p pBackground; if (setjmp(png_jmpbuf(png_ptr))) { png_destroy_read_struct(&png_ptr, &info_ptr, NULL); return 2; } if (!png_get_valid(png_ptr, info_ptr, PNG_INFO_bKGD)) return 1; png_get_bKGD(png_ptr, info_ptr, &pBackground); if (bit_depth == 16) { *red = pBackground->red >> 8; *green = pBackground->green >> 8; *blue = pBackground->blue >> 8; } else if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8) { if (bit_depth == 1) *red = *green = *blue = pBackground->gray? 255 : 0; else if (bit_depth == 2) *red = *green = *blue = (255/3) * pBackground->gray; else *red = *green = *blue = (255/15) * pBackground->gray; } else { *red = (uch)pBackground->red; *green = (uch)pBackground->green; *blue = (uch)pBackground->blue; } return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.798575186639703, -0.08729279623175898, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.022169604774704303, 0.8171382968447365, -0.06870780348722379, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
1<SPLIT>void png_do_expand_palette(png_row_infop row_info, png_bytep row, png_const_colorp palette, png_const_bytep trans_alpha, int num_trans) { int shift, value; png_bytep sp, dp; png_uint_32 i; png_uint_32 row_width=row_info->width; png_debug(1, "in png_do_expand_palette"); if (row_info->color_type == PNG_COLOR_TYPE_PALETTE) { if (row_info->bit_depth < 8) { switch (row_info->bit_depth) { case 1: { sp = row + (png_size_t)((row_width - 1) >> 3); dp = row + (png_size_t)row_width - 1; shift = 7 - (int)((row_width + 7) & 0x07); for (i = 0; i < row_width; i++) { if ((*sp >> shift) & 0x01) *dp = 1; else *dp = 0; if (shift == 7) { shift = 0; sp--; } else shift++; dp--; } break; } case 2: { sp = row + (png_size_t)((row_width - 1) >> 2); dp = row + (png_size_t)row_width - 1; shift = (int)((3 - ((row_width + 3) & 0x03)) << 1); for (i = 0; i < row_width; i++) { value = (*sp >> shift) & 0x03; *dp = (png_byte)value; if (shift == 6) { shift = 0; sp--; } else shift += 2; dp--; } break; } case 4: { sp = row + (png_size_t)((row_width - 1) >> 1); dp = row + (png_size_t)row_width - 1; shift = (int)((row_width & 0x01) << 2); for (i = 0; i < row_width; i++) { value = (*sp >> shift) & 0x0f; *dp = (png_byte)value; if (shift == 4) { shift = 0; sp--; } else shift += 4; dp--; } break; } default: break; } row_info->bit_depth = 8; row_info->pixel_depth = 8; row_info->rowbytes = row_width; } else if (row_info->bit_depth == 8) { { if (trans_alpha != NULL) { sp = row + (png_size_t)row_width - 1; dp = row + (png_size_t)(row_width << 2) - 1; for (i = 0; i < row_width; i++) { if ((int)(*sp) >= num_trans) *dp-- = 0xff; else *dp-- = trans_alpha[*sp]; *dp-- = palette[*sp].blue; *dp-- = palette[*sp].green; *dp-- = palette[*sp].red; sp--; } row_info->bit_depth = 8; row_info->pixel_depth = 32; row_info->rowbytes = row_width * 4; row_info->color_type = 6; row_info->channels = 4; } else { sp = row + (png_size_t)row_width - 1; dp = row + (png_size_t)(row_width * 3) - 1; for (i = 0; i < row_width; i++) { *dp-- = palette[*sp].blue; *dp-- = palette[*sp].green; *dp-- = palette[*sp].red; sp--; } row_info->bit_depth = 8; row_info->pixel_depth = 24; row_info->rowbytes = row_width * 3; row_info->color_type = 2; row_info->channels = 3; } } } } }<SPLIT>[2.8391943831703865, 2.183499580844957, 0.0, 2.7766039853544644, 2.0405844565212674, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 2.3463976517894065, 2.8931285029922593, 2.2786277576955065, 0.0, 0.0, 0.30852482215402843, 2.2113886713894146, 2.82812012645196, 2.139948865988882, -0.39986248560786075, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 1.8705904812043497, -0.25252937827156396, -0.4462861841111837, -0.21702784222394986, -0.04111270872174079, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 1.7623686513065309, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static int one_file(struct global *global, const char *file_name, const char *out_name) { int rc; struct control control; if (global->verbose) fprintf(stderr, "FILE %s -> %s\n", file_name, out_name ? out_name : "<none>"); rc = control_init(&control, global, file_name, out_name); if (rc == 0) rc = read_png(&control); rc |= control_end(&control); return rc; }<SPLIT>[0.21027592277004517, -0.3507086565438968, 0.0, 0.18995094088131478, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.29081490870517385, 0.21894446904158188, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, 0.19837465696559078, -0.4000063039086396, -0.011671540416283347, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.1980344553542678, 0.11818065472185141, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void rpng2_x_cleanup(void) { if (bg_image && bg_data) { free(bg_data); bg_data = NULL; } if (rpng2_info.image_data) { free(rpng2_info.image_data); rpng2_info.image_data = NULL; } if (rpng2_info.row_pointers) { free(rpng2_info.row_pointers); rpng2_info.row_pointers = NULL; } if (ximage) { if (ximage->data) { free(ximage->data); ximage->data = (char *)NULL; } XDestroyImage(ximage); ximage = NULL; } if (have_gc) XFreeGC(display, gc); if (have_window) XDestroyWindow(display, window); if (have_colormap) XFreeColormap(display, colormap); if (have_nondefault_visual) XFree(visual_list); }<SPLIT>[-0.25365086435942685, 0.023913430722281605, 0.0, -0.2665172434374763, -0.02345647864916818, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, -0.27925050329511203, -0.011110546228475942, -0.25297036047912586, 0.04492549829819571, 0.0, 0.0, 0.30852482215402843, -0.05532487545944473, -0.26569807294376846, -0.024534670097701678, -0.011671540416283347, -0.4084991676475909, 0.0, -0.08645738172306322, 0.417570182313826, -0.20220639821224526, -0.08904460951967552, -0.10760608081136262, -0.21702784222394986, -0.04111270872174079, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, -0.27935383381430245, 0.9056307075691036, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, -0.28182971586402455]
0<SPLIT>static void standard_palette_init(standard_display *dp) { store_palette_entry *palette = store_current_palette(dp->ps, &dp->npalette); if (dp->npalette > 0) { int i = dp->npalette; memcpy(dp->palette, palette, i * sizeof *palette); while (--i >= 0) if (palette[i].alpha < 255) break; #ifdef __GNUC__ if (i >= 0) dp->is_transparent = 1; else dp->is_transparent = 0; #else dp->is_transparent = (i >= 0); #endif } }<SPLIT>[0.21027592277004517, -0.1964525029637057, 0.0, 0.18995094088131478, -0.2575229764520011, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, -0.1509627274668249, 0.061639525868012635, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.21031383592774278, 0.04368374699580437, -0.4000063039086396, -0.39986248560786075, -0.1892664641018488, 0.0, 0.4647777494796126, 1.5771521192305922, -0.44813145170234975, -0.3070243011888601, -0.4462861841111837, -0.21702784222394986, -0.13468348084208653, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 1.7623686513065309, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static int png_pass_col_shift(int pass) { int x, y, base=(-1), inc=8; ++pass; for (x=0; x<8; ++x) for (y=0; y<8; ++y) if (adam7[y][x] == pass) { if (base == (-1)) base = x; else if (base == x) {} else if (inc == x-base) base=x; else if (inc == 8) inc = x-base, base=x; else if (inc != x-base) return 0xff; } if (base == (-1)) return 0xfe; switch (inc) { case 1: return 0; case 2: return 1; case 4: return 2; case 8: return 3; default: break; } return (inc << 8) + 0xfd; }<SPLIT>[0.05563366039355449, -0.020159756014915854, 0.0, 0.037794879441717756, -0.08729279623175898, 0.0, 1.8391333925217592, 1.3480932287791254, 1.7351415616306558, 4.008483356457433, -0.011110546228475942, 0.061639525868012635, -0.0006602620976677653, 0.0, 0.0, 0.30852482215402843, -0.07469849551798198, 0.04368374699580437, -0.06870780348722379, -0.6586564490689124, 1.78382786780983, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, 1.2188335404954318, -0.3333928163445767, -0.21702784222394986, 2.391727366407248, 1.8383309169346027, 1.3475072793347742, 1.7343983950676451, 4.007331890021263, 2.6191065950439585, 0.0, 1.832972902474695, 1.3427725632242797, 1.7290886636830973, 3.9981557057022012]
0<SPLIT>static void sBIT0_error_fn(png_structp pp, png_infop pi) { png_color_8 bad; bad.red = bad.green = bad.blue = bad.gray = bad.alpha = 0; png_set_sBIT(pp, pi, &bad); }<SPLIT>[-0.09900860198293619, -0.5049648101240879, 0.0, -0.11436118199787926, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.09566541730555662, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.11100716297398205, -0.554612270771967, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gpc_unpc(Pixel *out, const Pixel *in, const Background *back) { (void)back; if (in->a <= 128) { out->r = out->g = out->b = 255; out->a = 0; } else { out->r = sRGB((double)in->r / in->a); out->g = sRGB((double)in->g / in->a); out->b = sRGB((double)in->b / in->a); out->a = u8d(in->a / 257.); } }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void gp_bgra16(Pixel *p, png_const_voidp pb) { png_const_uint_16p pp = voidcast(png_const_uint_16p, pb); p->r = pp[2]; p->g = pp[1]; p->b = pp[0]; p->a = pp[3]; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int image_transform_png_set_@_add(image_transform *this, PNG_CONST image_transform **that, char *name, size_t sizeof_name, size_t *pos, png_byte colour_type, png_byte bit_depth) { this->next = *that; *that = this; *pos = safecat(name, sizeof_name, *pos, " +@"); return 1; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int buffer_from_file(struct buffer *buffer, FILE *fp) { struct buffer_list *last = &buffer->first; size_t count = 0; for (;;) { size_t r = fread(last->buffer+count, 1, (sizeof last->buffer)-count, fp); if (r > 0) { count += r; if (count >= sizeof last->buffer) { assert(count == sizeof last->buffer); count = 0; if (last->next == NULL) { last = buffer_extend(last); if (last == NULL) return MEMORY; } else last = last->next; } } else { if (feof(fp)) { buffer->last = last; buffer->end_count = count; return 0; } return errno == 0 ? ERANGE : errno; } } }<SPLIT>[-0.09900860198293619, 0.1781695843024727, 0.0, -0.11436118199787926, 0.10421615651601342, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, 0.7102265412631674, 0.14872051804392286, -0.09566541730555662, 0.2044756596837179, 0.0, 0.0, 0.30852482215402843, 0.08029046495031608, -0.11100716297398205, 0.1300712967656257, -0.011671540416283347, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, 0.4559046196532859, 0.23107402248845843, 3.3782753486411963, 0.23959960763929639, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, 0.7098813332246741, 2.6191065950439585, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 0.7058592275743352]
0<SPLIT>static void png_read_data(png_structp png_ptr, png_bytep data, png_size_t length) { png_size_t check; check = (png_size_t)fread(data, (png_size_t)1, length, (FILE *)png_ptr->io_ptr); if (check != length) { png_error(png_ptr, "Read Error"); } }<SPLIT>[0.21027592277004517, -0.416818436649693, 0.0, 0.18995094088131478, -0.47031070172730377, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3507515578073234, 0.21894446904158188, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, 0.19837465696559078, -0.4662660039929228, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int image_transform_test_counter(png_uint_32 counter, unsigned int max) { image_transform *next = image_transform_first; while (next != &image_transform_end) { counter >>= 1; if (max > 1 && next->local_use < max) return 1; next = next->list; } return max <= 1 && counter == 0; }<SPLIT>[0.5195604475230265, -0.3727452499124955, 0.0, 0.4942630637605089, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.270836025671124, 0.5335543553887203, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, 0.5077564769051636, -0.42209287060340067, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void usage(const char *prog) { size_t i; static const char *usage_string[] = {"str", "str", 0, 0, 0, "str", "str"}; fprintf(stderr, "Usage: %s {[options] png-file}\n", prog); for (i=0; i < (sizeof usage_string)/(sizeof usage_string[0]); ++i) { if (usage_string[i] != 0) fputs(usage_string[i], stderr); fputc('\n', stderr); } exit(255); }<SPLIT>[-0.09900860198293619, 3.241256062537696, 0.0, -0.11436118199787926, 3.0619655378427204, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 2.9257852597768523, -0.09566541730555662, 3.2131358458107075, 0.0, 0.0, 0.30852482215402843, 2.773223653086995, -0.11100716297398205, 3.045498100474085, -0.011671540416283347, -0.4084991676475909, 0.0, 0.4647777494796126, 2.1569430876889752, -0.4129993012037634, -0.3070243011888601, -0.10760608081136262, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void transform_set_encoding(transform_display *this) { png_modifier *pm = this->pm; modifier_set_encoding(pm); if (modifier_color_encoding_is_set(pm)) { if (modifier_color_encoding_is_sRGB(pm)) srgb_modification_init(&this->srgb_mod, pm, PNG_sRGB_INTENT_ABSOLUTE); else { gama_modification_init(&this->gama_mod, pm, pm->current_gamma); if (pm->current_encoding != 0) chrm_modification_init(&this->chrm_mod, pm, pm->current_encoding); } } }<SPLIT>[0.36491818514653585, -0.2845988764381006, 0.0, 0.34210700232091185, -0.34263806656212215, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.21089937656897445, 0.3762494122151511, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, 0.35306556693537716, -0.33374660382435645, -0.011671540416283347, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.1980344553542678, -0.10760608081136262, 0.6817979554923368, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void readpng2_error_handler(png_structp png_ptr, png_const_charp msg) { mainprog_info *mainprog_ptr; fprintf(stderr, "readpng2 libpng error: %s\n", msg); fflush(stderr); mainprog_ptr = png_get_error_ptr(png_ptr); if (mainprog_ptr == NULL) { fprintf(stderr, "readpng2 severe error: jmpbuf not recoverable; terminating.\n"); fflush(stderr); exit(99); } longjmp(mainprog_ptr->jmpbuf, 1); }<SPLIT>[2.065983071287933, -0.3507086565438968, 0.0, 2.015823678156479, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.051068312296575644, 2.106603787124413, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.09407211557651925, 2.054665576603028, -0.37791973721387856, -0.14106852214680915, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.3070243011888601, -0.22049944857796966, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void modifier_init(png_modifier *pm) { memset(pm, 0, sizeof *pm); store_init(&pm->this); pm->modifications = NULL; pm->state = modifier_start; pm->sbitlow = 1U; pm->ngammas = 0; pm->ngamma_tests = 0; pm->gammas = 0; pm->current_gamma = 0; pm->encodings = 0; pm->nencodings = 0; pm->current_encoding = 0; pm->encoding_counter = 0; pm->encoding_ignored = 0; pm->repeat = 0; pm->test_uses_encoding = 0; pm->maxout8 = pm->maxpc8 = pm->maxabs8 = pm->maxcalc8 = 0; pm->maxout16 = pm->maxpc16 = pm->maxabs16 = pm->maxcalc16 = 0; pm->maxcalcG = 0; pm->limit = 4E-3; pm->log8 = pm->log16 = 0; pm->error_gray_2 = pm->error_gray_4 = pm->error_gray_8 = 0; pm->error_gray_16 = pm->error_color_8 = pm->error_color_16 = 0; pm->error_indexed = 0; pm->use_update_info = 0; pm->interlace_type = PNG_INTERLACE_NONE; pm->test_standard = 0; pm->test_size = 0; pm->test_transform = 0; pm->use_input_precision = 0; pm->use_input_precision_sbit = 0; pm->use_input_precision_16to8 = 0; pm->calculations_use_input_precision = 0; pm->assume_16_bit_calculations = 0; pm->test_gamma_threshold = 0; pm->test_gamma_transform = 0; pm->test_gamma_sbit = 0; pm->test_gamma_scale16 = 0; pm->test_gamma_background = 0; pm->test_gamma_alpha_mode = 0; pm->test_gamma_expand16 = 0; pm->test_exhaustive = 0; pm->log = 0; }<SPLIT>[-0.09900860198293619, 0.3764989246198613, 0.0, -0.11436118199787926, 0.2957251092637858, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.3285304653503715, -0.09566541730555662, 0.40961158146510357, 0.0, 0.0, 0.30852482215402843, 0.2546530454771514, -0.11100716297398205, 0.3288503970184752, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.816625966246759, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gp_rgba8(Pixel *p, png_const_voidp pb) { png_const_bytep pp = voidcast(png_const_bytep, pb); p->r = pp[0]; p->g = pp[1]; p->b = pp[2]; p->a = pp[3]; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void buffer_start_write(struct buffer *buffer) { buffer->last = &buffer->first; buffer->end_count = 0; buffer->current = NULL; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gp_ga8(Pixel *p, png_const_voidp pb) { png_const_bytep pp = voidcast(png_const_bytep, pb); p->r = p->g = p->b = pp[0]; p->a = pp[1]; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void transform_row(png_const_structp pp, png_byte buffer[TRANSFORM_ROWMAX], png_byte colour_type, png_byte bit_depth, png_uint_32 y) { png_uint_32 v = y << 7; png_uint_32 i = 0; switch (bit_size(pp, colour_type, bit_depth)) { case 1: while (i<128/8) buffer[i] = (png_byte)(v & 0xff), v += 17, ++i; return; case 2: while (i<128/4) buffer[i] = (png_byte)(v & 0xff), v += 33, ++i; return; case 4: while (i<128/2) buffer[i] = (png_byte)(v & 0xff), v += 65, ++i; return; case 8: while (i<128) buffer[i] = (png_byte)(v & 0xff), ++v, ++i; return; case 16: while (i<128) { buffer[2*i] = (png_byte)((v>>8) & 0xff); buffer[2*i+1] = (png_byte)(v & 0xff); ++v; ++i; } return; case 24: while (i<128) { buffer[3*i+0] = (png_byte)((v >> 8) & 0xff); buffer[3*i+1] = (png_byte)(v & 0xff); buffer[3*i+2] = (png_byte)(((v >> 8) ^ v) & 0xff); ++v; ++i; } return; case 32: while (i<128) { buffer[4*i+0] = (png_byte)((v >> 8) & 0xff); buffer[4*i+1] = (png_byte)(v & 0xff); buffer[4*i+2] = (png_byte)((v >> 8) & 0xff); buffer[4*i+3] = (png_byte)(v & 0xff); ++v; ++i; } return; case 48: while (i<128) { png_uint_32 t = v++; buffer[6*i+0] = (png_byte)((t >> 8) & 0xff); buffer[6*i+1] = (png_byte)(t & 0xff); t *= 257; buffer[6*i+2] = (png_byte)((t >> 8) & 0xff); buffer[6*i+3] = (png_byte)(t & 0xff); t *= 17; buffer[6*i+4] = (png_byte)((t >> 8) & 0xff); buffer[6*i+5] = (png_byte)(t & 0xff); ++i; } return; case 64: while (i<128) { png_uint_32 t = v++; buffer[8*i+0] = (png_byte)((t >> 8) & 0xff); buffer[8*i+1] = (png_byte)(t & 0xff); buffer[8*i+4] = (png_byte)((t >> 8) & 0xff); buffer[8*i+5] = (png_byte)(t & 0xff); t *= 257; buffer[8*i+2] = (png_byte)((t >> 8) & 0xff); buffer[8*i+3] = (png_byte)(t & 0xff); buffer[8*i+6] = (png_byte)((t >> 8) & 0xff); buffer[8*i+7] = (png_byte)(t & 0xff); ++i; } return; default: break; } png_error(pp, "internal error"); }<SPLIT>[1.4474140217819704, 1.2359260659952118, 0.0, 1.4071994323980908, 1.1255972378374661, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 1.3074957340188142, 1.477384014430136, 1.2985339091844414, 0.0, 0.0, 0.30852482215402843, 1.203960428345477, 1.4359019367238823, 1.1902264981141564, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 1.1679474712326225, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static double chromaticity_x(CIE_color c) { return c.X / (c.X + c.Y + c.Z); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int png_pass_row_shift(int pass) { int x, y, base=(-1), inc=8; ++pass; for (y=0; y<8; ++y) for (x=0; x<8; ++x) if (adam7[y][x] == pass) { if (base == (-1)) base = y; else if (base == y) {} else if (inc == y-base) base=y; else if (inc == 8) inc = y-base, base=y; else if (inc != y-base) return 0xff; } if (base == (-1)) return 0xfe; switch (inc) { case 2: return 1; case 4: return 2; case 8: return 3; default: break; } return (inc << 8) + 0xfd; }<SPLIT>[0.05563366039355449, -0.04219634938351458, 0.0, 0.037794879441717756, -0.10857156875928925, 0.0, 1.6653401555507896, 1.3480932287791254, 1.5692995750795884, 3.6786576749380067, -0.031089429262525795, 0.061639525868012635, -0.023453142295599506, 0.0, 0.0, 0.30852482215402843, -0.09407211557651925, 0.04368374699580437, -0.09079437018198484, -0.6586564490689124, 1.674211516036959, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, 1.1098436946608394, -0.3333928163445767, -0.21702784222394986, 2.204585822166557, 1.664582183638518, 1.3475072793347742, 1.5685972020260743, 3.6775868343416036, 2.6191065950439585, 0.0, 1.6594432402238268, 1.3427725632242797, 1.5635067606227984, 3.6689260578894145]
0<SPLIT>static int modifier_color_encoding_is_sRGB(PNG_CONST png_modifier *pm) { return pm->current_encoding != 0 && pm->current_encoding == pm->encodings && pm->current_encoding->gamma == pm->current_gamma; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int random_choice(void) { unsigned char x; RANDOMIZE(x); return x & 1; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static store_palette_entry * store_current_palette(png_store *ps, int *npalette) { if (ps->current == NULL) store_log(ps, ps->pread, "no current stream for palette", 1); *npalette = ps->current->npalette; return ps->current->palette; }<SPLIT>[0.36491818514653585, -0.4829282167554892, 0.0, 0.34210700232091185, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3907093238754231, 0.3762494122151511, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, 0.35306556693537716, -0.5325257040772059, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>void png_handle_sCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length) { png_charp buffer, ep; #ifdef PNG_FLOATING_POINT_SUPPORTED double width, height; png_charp vp; #else #ifdef PNG_FIXED_POINT_SUPPORTED png_charp swidth, sheight; #endif #endif png_size_t slength; png_debug(1, "in png_handle_sCAL\n"); if (!(png_ptr->mode & PNG_HAVE_IHDR)) png_error(png_ptr, "Missing IHDR before sCAL"); else if (png_ptr->mode & PNG_HAVE_IDAT) { png_warning(png_ptr, "Invalid sCAL after IDAT"); png_crc_finish(png_ptr, length); return; } else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sCAL)) { png_warning(png_ptr, "Duplicate sCAL chunk"); png_crc_finish(png_ptr, length); return; } png_debug1(2, "Allocating and reading sCAL chunk data (%lu bytes)\n", length + 1); buffer = (png_charp)png_malloc_warn(png_ptr, length + 1); if (buffer == NULL) { png_warning(png_ptr, "Out of memory while processing sCAL chunk"); return; } slength = (png_size_t)length; png_crc_read(png_ptr, (png_bytep)buffer, slength); if (png_crc_finish(png_ptr, 0)) { png_free(png_ptr, buffer); return; } buffer[slength] = 0x00; ep = buffer + 1; #ifdef PNG_FLOATING_POINT_SUPPORTED width = strtod(ep, &vp); if (*vp) { png_warning(png_ptr, "malformed width string in sCAL chunk"); return; } #else #ifdef PNG_FIXED_POINT_SUPPORTED swidth = (png_charp)png_malloc_warn(png_ptr, png_strlen(ep) + 1); if (swidth == NULL) { png_warning(png_ptr, "Out of memory while processing sCAL chunk width"); return; } png_memcpy(swidth, ep, (png_size_t)png_strlen(ep)); #endif #endif for (ep = buffer; *ep; ep++) ; ep++; #ifdef PNG_FLOATING_POINT_SUPPORTED height = strtod(ep, &vp); if (*vp) { png_warning(png_ptr, "malformed height string in sCAL chunk"); return; } #else #ifdef PNG_FIXED_POINT_SUPPORTED sheight = (png_charp)png_malloc_warn(png_ptr, png_strlen(ep) + 1); if (swidth == NULL) { png_warning(png_ptr, "Out of memory while processing sCAL chunk height"); return; } png_memcpy(sheight, ep, (png_size_t)png_strlen(ep)); #endif #endif if (buffer + slength < ep #ifdef PNG_FLOATING_POINT_SUPPORTED || width <= 0. || height <= 0. #endif ) { png_warning(png_ptr, "Invalid sCAL data"); png_free(png_ptr, buffer); #if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED) png_free(png_ptr, swidth); png_free(png_ptr, sheight); #endif return; } #ifdef PNG_FLOATING_POINT_SUPPORTED png_set_sCAL(png_ptr, info_ptr, buffer[0], width, height); #else #ifdef PNG_FIXED_POINT_SUPPORTED png_set_sCAL_s(png_ptr, info_ptr, buffer[0], swidth, sheight); #endif #endif png_free(png_ptr, buffer); #if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED) png_free(png_ptr, swidth); png_free(png_ptr, sheight); #endif }<SPLIT>[1.7566985465349518, 1.764804306841581, 0.0, 1.7115115552772848, 1.6575665510257227, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 1.699703585821447, 1.8469255759381602, 1.7919939007772745, 0.4324044616630353, 0.0, 0.0, 0.30852482215402843, 1.7464217899845202, 1.7452837566634551, 0.35093696371323624, 0.11772544131424245, 0.4684316465353775, 0.0, 3.8824355629362026, 15.492135362231787, 1.09768317023545, 0.40140969673598975, 0.005287286955244392, 0.6817979554923368, 0.6138826961206794, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 1.6991165002636506, 0.04889276383167627, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 1.693548171012695]
0<SPLIT>png_uint_32 get_data (FILE *pnm_file, int depth) { static int bits_left = 0; static int old_value = 0; static int mask = 0; int i; png_uint_32 ret_value; if (mask == 0) for (i = 0; i < depth; i++) mask = (mask >> 1) | 0x80; if (bits_left <= 0) { old_value = fgetc (pnm_file); bits_left = 8; } ret_value = old_value & mask; for (i = 1; i < (8 / depth); i++) ret_value = ret_value || (ret_value >> depth); old_value = (old_value << depth) & 0xFF; bits_left -= depth; return ret_value; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static unsigned int modifier_total_encodings(PNG_CONST png_modifier *pm) { return 1 + pm->ngammas + pm->nencodings + ((pm->bit_depth == 16 || pm->assume_16_bit_calculations) ? pm->nencodings : 0); }<SPLIT>[0.9834872346524985, -0.46089162338689044, 0.0, 0.9507312480792999, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.29081490870517385, 1.0054691849094282, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, 0.9718292068145229, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int main(int argc, char *argv[]) { FILE *fp_rd = stdin; FILE *fp_al = NULL; FILE *fp_wr = stdout; BOOL interlace = FALSE; BOOL alpha = FALSE; int argi; for (argi = 1; argi < argc; argi++) { if (argv[argi][0] == '-') { switch (argv[argi][1]) { case 'i': interlace = TRUE; break; case 'a': alpha = TRUE; argi++; if ((fp_al = fopen (argv[argi], "rb")) == NULL) { fprintf (stderr, "PNM2PNG\n"); fprintf (stderr, "Error: alpha-channel file %s does not exist\n", argv[argi]); exit (1); } break; case 'h': case '?': usage(); exit(0); break; default: fprintf (stderr, "PNM2PNG\n"); fprintf (stderr, "Error: unknown option %s\n", argv[argi]); usage(); exit(1); break; } } else if (fp_rd == stdin) { if ((fp_rd = fopen (argv[argi], "rb")) == NULL) { fprintf (stderr, "PNM2PNG\n"); fprintf (stderr, "Error: file %s does not exist\n", argv[argi]); exit (1); } } else if (fp_wr == stdout) { if ((fp_wr = fopen (argv[argi], "wb")) == NULL) { fprintf (stderr, "PNM2PNG\n"); fprintf (stderr, "Error: can not create PNG-file %s\n", argv[argi]); exit (1); } } else { fprintf (stderr, "PNM2PNG\n"); fprintf (stderr, "Error: too many parameters\n"); usage(); exit (1); } } #ifdef __TURBOC__ if (fp_rd == stdin) { setmode (STDIN, O_BINARY); } if (fp_wr == stdout) { setmode (STDOUT, O_BINARY); } #endif if (pnm2png (fp_rd, fp_wr, fp_al, interlace, alpha) == FALSE) { fprintf (stderr, "PNM2PNG\n"); fprintf (stderr, "Error: unsuccessful converting to PNG-image\n"); exit (1); } fclose (fp_rd); fclose (fp_wr); if (alpha) fclose (fp_al); return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.4942630637605089, 1.2107123279475873, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 1.1652131882284025, 0.35306556693537716, 1.05770709794559, -0.917450412529964, -0.518115519420462, 0.0, 0.9057658544417533, 0.9973611507722091, 0.816625966246759, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>int main(void) { fprintf(stderr, "pngfix does not work without read support\n"); return 77; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 6.389364479309494, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.39986248560786075, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3615192241061562, -0.4462861841111837, -0.21702784222394986, -0.22825425296243224, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, 0.04739993194876201]
0<SPLIT>static png_voidp PNGCBAPI store_malloc(png_structp ppIn, png_alloc_size_t cb) { png_const_structp pp = ppIn; store_pool *pool = voidcast(store_pool*, png_get_mem_ptr(pp)); store_memory *new = voidcast(store_memory*, malloc(cb + (sizeof *new) + (sizeof pool->mark))); if (new != NULL) { if (cb > pool->max) pool->max = cb; pool->current += cb; if (pool->current > pool->limit) pool->limit = pool->current; pool->total += cb; new->size = cb; memcpy(new->mark, pool->mark, sizeof new->mark); memcpy((png_byte*)(new+1) + cb, pool->mark, sizeof pool->mark); new->pool = pool; new->next = pool->list; pool->list = new; ++new; } else { store_log(pool->store, pp, "out of memory", 1 ); } return new; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 1.559355493837688, -0.08729279623175898, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.11903770506739059, 1.5905928466936687, -0.06870780348722379, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int png_have_neon(png_structp png_ptr) { int fd = open("/proc/self/auxv", O_RDONLY); Elf32_auxv_t aux; if (fd == -1) { png_warning(png_ptr, "/proc/self/auxv open failed"); return 0; } while (safe_read(png_ptr, fd, &aux, sizeof aux) == sizeof aux) { if (aux.a_type == AT_HWCAP && (aux.a_un.a_val & HWCAP_NEON) != 0) { close(fd); return 1; } } close(fd); return 0; }<SPLIT>[-0.09900860198293619, -0.1964525029637057, 0.0, -0.11436118199787926, -0.2575229764520011, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1909204935349246, -0.09566541730555662, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.11100716297398205, -0.24540033704531222, -0.270465503877335, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.1980344553542678, -0.22049944857796966, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int rpng_win_display_image() { uch *src, *dest; uch r, g, b, a; ulg i, row, lastrow; RECT rect; Trace((stderr, "beginning display loop (image_channels == %d)\n", image_channels)) Trace((stderr, "(width = %ld, rowbytes = %ld, wimage_rowbytes = %d)\n", image_width, image_rowbytes, wimage_rowbytes)) for (lastrow = row = 0; row < image_height; ++row) { src = image_data + row*image_rowbytes; dest = wimage_data + row*wimage_rowbytes; if (image_channels == 3) { for (i = image_width; i > 0; --i) { r = *src++; g = *src++; b = *src++; *dest++ = b; *dest++ = g; *dest++ = r; } } else { for (i = image_width; i > 0; --i) { r = *src++; g = *src++; b = *src++; a = *src++; if (a == 255) { *dest++ = b; *dest++ = g; *dest++ = r; } else if (a == 0) { *dest++ = bg_blue; *dest++ = bg_green; *dest++ = bg_red; } else { alpha_composite(*dest++, b, a, bg_blue); alpha_composite(*dest++, g, a, bg_green); alpha_composite(*dest++, r, a, bg_red); } } } if (((row+1) & 0xf) == 0) { rect.left = 0L; rect.top = (LONG)lastrow; rect.right = (LONG)image_width; rect.bottom = (LONG)lastrow + 16L; InvalidateRect(global_hwnd, &rect, FALSE); UpdateWindow(global_hwnd); lastrow = row + 1; } } Trace((stderr, "calling final image-flush routine\n")) if (lastrow < image_height) { rect.left = 0L; rect.top = (LONG)lastrow; rect.right = (LONG)image_width; rect.bottom = (LONG)image_height; InvalidateRect(global_hwnd, &rect, FALSE); UpdateWindow(global_hwnd); } return 0; }<SPLIT>[2.065983071287933, 0.7511210118860397, 0.0, 2.015823678156479, 0.6787430147593306, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.9478758394059169, 2.106603787124413, 0.7970905448299431, 0.0, 0.0, 0.30852482215402843, 0.8746088873503436, 2.054665576603028, 0.7264085975241742, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.8868902672439317, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void readpng_cleanup(int free_image_data) { if (free_image_data && image_data) { free(image_data); image_data = NULL; } if (png_ptr && info_ptr) { png_destroy_read_struct(&png_ptr, &info_ptr, NULL); png_ptr = NULL; info_ptr = NULL; } }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void make_error(png_store* volatile psIn, png_byte PNG_CONST colour_type, png_byte bit_depth, int interlace_type, int test, png_const_charp name) { png_store * volatile ps = psIn; context(ps, fault); check_interlace_type(interlace_type); Try { png_structp pp; png_infop pi; pp = set_store_for_write(ps, &pi, name); if (pp == NULL) Throw ps; png_set_IHDR(pp, pi, transform_width(pp, colour_type, bit_depth), transform_height(pp, colour_type, bit_depth), bit_depth, colour_type, interlace_type, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE); if (colour_type == 3) init_standard_palette(ps, pp, pi, 1U << bit_depth, 0); #define exception__prev exception_prev_1 #define exception__env exception_env_1 Try { ps->expect_error = !error_test[test].warning; ps->expect_warning = error_test[test].warning; ps->saw_warning = 0; error_test[test].fn(pp, pi); png_write_info(pp, pi); if (ps->expect_warning && ps->saw_warning) Throw ps; store_log(ps, pp, error_test[test].msg, 1 ); } Catch (fault) ps = fault; #undef exception__prev #undef exception__env ps->expect_error = 0; ps->expect_warning = 0; if (png_get_rowbytes(pp, pi) != transform_rowsize(pp, colour_type, bit_depth)) png_error(pp, "row size incorrect"); else { png_uint_32 h = transform_height(pp, colour_type, bit_depth); int npasses = png_set_interlace_handling(pp); int pass; if (npasses != npasses_from_interlace_type(pp, interlace_type)) png_error(pp, "write: png_set_interlace_handling failed"); for (pass=0; pass<npasses; ++pass) { png_uint_32 y; for (y=0; y<h; ++y) { png_byte buffer[TRANSFORM_ROWMAX]; transform_row(pp, buffer, colour_type, bit_depth, y); png_write_row(pp, buffer); } } } png_write_end(pp, pi); store_write_reset(ps); } Catch(fault) { store_write_reset(fault); } }<SPLIT>[1.9113408089114425, 0.8172307919918359, 0.0, 1.863667616716882, 0.7213005598143911, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.9878336054740167, 1.9492988439508436, 0.7742976646320114, 0.0, 0.0, 0.30852482215402843, 0.8939825074088809, 1.8999746666332415, 0.6822354641346521, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, 2.1569430876889752, 0.5355687622580682, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int PNGCBAPI read_user_chunk_callback(png_struct *png_ptr, png_unknown_chunkp chunk) { png_uint_32 *my_user_chunk_data; if (chunk->name[0] == 115 && chunk->name[1] == 84 && chunk->name[2] == 69 && chunk->name[3] == 82) { if (chunk->size != 1) return (-1); if (chunk->data[0] != 0 && chunk->data[0] != 1) return (-1); my_user_chunk_data=(png_uint_32 *) png_get_user_chunk_ptr(png_ptr); my_user_chunk_data[0]=chunk->data[0]+1; return (1); } if (chunk->name[0] != 118 || chunk->name[1] != 112 || chunk->name[2] != 65 || chunk->name[3] != 103) return (0); if (chunk->size != 9) return (-1); my_user_chunk_data=(png_uint_32 *) png_get_user_chunk_ptr(png_ptr); my_user_chunk_data[1]=png_get_uint_31(png_ptr, chunk->data); my_user_chunk_data[2]=png_get_uint_31(png_ptr, chunk->data + 4); my_user_chunk_data[3]=(png_uint_32)chunk->data[8]; return (1); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 1.863667616716882, -0.10857156875928925, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.13841132512592785, 1.8999746666332415, -0.09079437018198484, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void check_error(display *d, png_uint_32 flags, const char *message) { while (flags) { png_uint_32 flag = flags & -(png_int_32)flags; int i = find_by_flag(flag); fprintf(stderr, "%s(%s): chunk %s: %s\n", d->file, d->test, chunk_info[i].name, message); ++(d->error_count); flags &= ~flag; } }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gpc_g8(Pixel *out, const Pixel *in, const Background *back) { (void)back; if (in->r == in->g && in->g == in->b) out->r = out->g = out->b = in->g; else out->r = out->g = out->b = sRGB(YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b])); out->a = in->a; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int main(int argc, char **argv) { int i; int extracted = 0; for (i=1; i<argc; ++i) { if (strcmp(argv[i], "-q") == 0) verbose = 0; else if (extract_one_file(argv[i])) extracted = 1; } return extracted == 0; }<SPLIT>[-0.09900860198293619, -0.3507086565438968, 0.0, -0.11436118199787926, -0.406474384144713, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.33077267477327355, -0.09566541730555662, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.11100716297398205, -0.4000063039086396, -0.270465503877335, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.03454968660237938, -0.3333928163445767, 0.6817979554923368, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void newimage(Image *image) { memset(image, 0, sizeof *image); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int writepng_init(mainprog_info *mainprog_ptr) { png_structp png_ptr; png_infop info_ptr; int color_type, interlace_type; png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr, writepng_error_handler, NULL); if (!png_ptr) return 4; info_ptr = png_create_info_struct(png_ptr); if (!info_ptr) { png_destroy_write_struct(&png_ptr, NULL); return 4; } if (setjmp(mainprog_ptr->jmpbuf)) { png_destroy_write_struct(&png_ptr, &info_ptr); return 2; } png_init_io(png_ptr, mainprog_ptr->outfile); png_set_compression_level(png_ptr, Z_BEST_COMPRESSION); if (mainprog_ptr->pnmtype == 5) color_type = PNG_COLOR_TYPE_GRAY; else if (mainprog_ptr->pnmtype == 6) color_type = PNG_COLOR_TYPE_RGB; else if (mainprog_ptr->pnmtype == 8) color_type = PNG_COLOR_TYPE_RGB_ALPHA; else { png_destroy_write_struct(&png_ptr, &info_ptr); return 11; } interlace_type = mainprog_ptr->interlaced? PNG_INTERLACE_ADAM7 : PNG_INTERLACE_NONE; png_set_IHDR(png_ptr, info_ptr, mainprog_ptr->width, mainprog_ptr->height, mainprog_ptr->sample_depth, color_type, interlace_type, PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT); if (mainprog_ptr->gamma > 0.0) png_set_gAMA(png_ptr, info_ptr, mainprog_ptr->gamma); if (mainprog_ptr->have_bg) { png_color_16 background; background.red = mainprog_ptr->bg_red; background.green = mainprog_ptr->bg_green; background.blue = mainprog_ptr->bg_blue; png_set_bKGD(png_ptr, info_ptr, &background); } if (mainprog_ptr->have_time) { png_time modtime; png_convert_from_time_t(&modtime, mainprog_ptr->modtime); png_set_tIME(png_ptr, info_ptr, &modtime); } if (mainprog_ptr->have_text) { png_text text[6]; int num_text = 0; if (mainprog_ptr->have_text & TEXT_TITLE) { text[num_text].compression = PNG_TEXT_COMPRESSION_NONE; text[num_text].key = "Title"; text[num_text].text = mainprog_ptr->title; ++num_text; } if (mainprog_ptr->have_text & TEXT_AUTHOR) { text[num_text].compression = PNG_TEXT_COMPRESSION_NONE; text[num_text].key = "Author"; text[num_text].text = mainprog_ptr->author; ++num_text; } if (mainprog_ptr->have_text & TEXT_DESC) { text[num_text].compression = PNG_TEXT_COMPRESSION_NONE; text[num_text].key = "Description"; text[num_text].text = mainprog_ptr->desc; ++num_text; } if (mainprog_ptr->have_text & TEXT_COPY) { text[num_text].compression = PNG_TEXT_COMPRESSION_NONE; text[num_text].key = "Copyright"; text[num_text].text = mainprog_ptr->copyright; ++num_text; } if (mainprog_ptr->have_text & TEXT_EMAIL) { text[num_text].compression = PNG_TEXT_COMPRESSION_NONE; text[num_text].key = "E-mail"; text[num_text].text = mainprog_ptr->email; ++num_text; } if (mainprog_ptr->have_text & TEXT_URL) { text[num_text].compression = PNG_TEXT_COMPRESSION_NONE; text[num_text].key = "URL"; text[num_text].text = mainprog_ptr->url; ++num_text; } png_set_text(png_ptr, info_ptr, text, num_text); } png_write_info(png_ptr, info_ptr); png_set_packing(png_ptr); mainprog_ptr->png_ptr = png_ptr; mainprog_ptr->info_ptr = info_ptr; return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 4.7546327840692255, 1.3596637356402992, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 1.8432898902772066, 4.839101956059183, 1.4331787317565279, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 1.4490046752213135, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int find_parameters(png_const_charp what, png_charp param, png_charp *list, int nparams) { int i; for (i=0; *param && i<nparams; ++i) { list[i] = param; while (*++param) if (*param == '\n' || *param == ':') { *param++ = 0; break; } } if (*param) { fprintf(stderr, "--insert %s: too many parameters (%s)\n", what, param); exit(1); } list[i] = NULL; return i; }<SPLIT>[0.21027592277004517, -0.17441590959510697, 0.0, 0.18995094088131478, -0.23624420392447085, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.13098384443277505, 0.21894446904158188, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, 0.19837465696559078, -0.22331377035055117, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.3615192241061562, -0.4462861841111837, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int readpng2_check_sig(uch *sig, int num) { return !png_sig_cmp(sig, 0, num); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static char *dos_kbd_gets(char *buf, int len) { int ch, count=0; do { buf[count++] = ch = getche(); } while (ch != '\r' && count < len-1); buf[count--] = '\0'; if (buf[count] == '\r') buf[count] = '\n'; fprintf(stderr, "\n"); fflush(stderr); return buf; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4040500365131154, -0.26569807294376846, -0.7092182376352943, -0.917450412529964, -0.518115519420462, 0.0, 1.346753959403894, 0.417570182313826, -0.4129993012037634, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static png_byte png_exp8bit(png_uint_32 log) { return (png_byte)floor(.5 + exp(log * -LN2) * 255); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void bad_parameter_count(png_const_charp what, int nparams) { fprintf(stderr, "--insert %s: bad parameter count %d\n", what, nparams); exit(1); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_tRNS_to_alpha_mod(PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp, PNG_CONST transform_display *display) { if (that->colour_type == PNG_COLOR_TYPE_PALETTE) image_pixel_convert_PLTE(that); if (that->have_tRNS) image_pixel_add_alpha(that, &display->this); else { if (that->bit_depth < 8) that->bit_depth =8; if (that->sample_depth < 8) that->sample_depth = 8; } this->next->mod(this->next, that, pp, display); }<SPLIT>[0.5195604475230265, -0.2625622830695019, 0.0, 0.4942630637605089, -0.3213592940345919, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.17094161050087475, 0.5335543553887203, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, 0.5077564769051636, -0.3116600371295954, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.4705090699407485, -0.5591795518777907, 0.6817979554923368, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int generate_palette(png_colorp palette, png_bytep trans, int bit_depth, png_const_bytep gamma_table, unsigned int *colors) { switch (colors[0]) { default: fprintf(stderr, "makepng: --colors=...: invalid count %u\n", colors[0]); exit(1); case 1: set_color(palette+0, trans+0, colors[1], colors[1], colors[1], 255, gamma_table); return 1; case 2: set_color(palette+0, trans+0, colors[1], colors[1], colors[1], colors[2], gamma_table); return 1; case 3: set_color(palette+0, trans+0, colors[1], colors[2], colors[3], 255, gamma_table); return 1; case 4: set_color(palette+0, trans+0, colors[1], colors[2], colors[3], colors[4], gamma_table); return 1; case 0: if (bit_depth == 1) { set_color(palette+0, trans+0, 255, 0, 0, 0, gamma_table); set_color(palette+1, trans+1, 255, 255, 255, 255, gamma_table); return 2; } else { unsigned int size = 1U << (bit_depth/2); unsigned int x, y, ip; for (x=0; x<size; ++x) for (y=0; y<size; ++y) { ip = x + (size * y); #define interp(pos, c1, c2) ((pos * c1) + ((size-pos) * c2)) #define xyinterp(x, y, c1, c2, c3, c4) (((size * size / 2) + (interp(x, c1, c2) * y + (size-y) * interp(x, c3, c4))) / (size*size)) set_color(palette+ip, trans+ip, xyinterp(x, y, 0, 255, 0, 255), xyinterp(x, y, 255, 0, 0, 255), xyinterp(x, y, 0, 0, 255, 255), xyinterp(x, y, 0, 102, 204, 255), gamma_table); } return ip+1; } } }<SPLIT>[1.7566985465349518, 0.5527916715686512, 0.0, 1.7115115552772848, 0.4659552894840279, 0.0, 0.9701672076669112, 0.2876332819158955, 0.9059316288753189, 1.699703585821447, 0.7281081260313685, 1.7919939007772745, 0.546368862652694, 0.0, 0.0, 0.30852482215402843, 0.6421254466478965, 1.7452837566634551, 0.4613697971870415, -0.011671540416283347, 1.564595164264088, 0.0, -0.08645738172306322, 0.9973611507722091, 0.07885080577644558, 1.1643386175781356, 0.005287286955244392, 4.277101146357483, 1.5495904173241366, 0.969587250454179, 0.28726714485067795, 0.9053924298597907, 1.6991165002636506, 2.6191065950439585, 0.0, 0.9653245912203542, 0.2838490539924199, 0.9011791483816026, 1.693548171012695]
0<SPLIT>static png_uint_32 standard_height(png_const_structp pp, png_uint_32 id) { png_uint_32 height = HEIGHT_FROM_ID(id); if (height == 0) height = transform_height(pp, COL_FROM_ID(id), DEPTH_FROM_ID(id)); return height; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static size_t safe_read(png_structp png_ptr, int fd, void *buffer_in, size_t nbytes) { size_t ntotal = 0; char *buffer = png_voidcast(char*, buffer_in); while (nbytes > 0) { unsigned int nread; int iread; if (nbytes > INT_MAX) nread = INT_MAX; else nread = (unsigned int)nbytes; iread = read(fd, buffer, nread); if (iread == -1) { if (errno != EINTR) { png_warning(png_ptr, "/proc read failed"); return 0; } } else if (iread < 0) { png_warning(png_ptr, "OS /proc read bug"); return 0; } else if (iread > 0) { buffer += iread; nbytes -= (unsigned int)iread; ntotal += (unsigned int)iread; } else return ntotal; } return ntotal; }<SPLIT>[1.2927717594054797, 0.1781695843024727, 0.0, 1.2550433709584938, 0.10421615651601342, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 1.3698779043020206, 0.3285304653503715, 1.3200790712565666, 0.2044756596837179, 0.0, 0.0, 0.30852482215402843, 0.2546530454771514, 1.281211026754096, 0.1300712967656257, -0.011671540416283347, 1.3453624607183459, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, 0.5648944654878781, 0.005287286955244392, 0.6817979554923368, 0.8945950124817165, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 1.3693714445839917, 1.7623686513065309, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 1.3643185231999084]
0<SPLIT>static void init_validate_info(validate_info *vi, gamma_display *dp, png_const_structp pp, int in_depth, int out_depth) { PNG_CONST unsigned int outmax = (1U<<out_depth)-1; vi->pp = pp; vi->dp = dp; if (dp->sbit > 0 && dp->sbit < in_depth) { vi->sbit = dp->sbit; vi->isbit_shift = in_depth - dp->sbit; } else { vi->sbit = (png_byte)in_depth; vi->isbit_shift = 0; } vi->sbit_max = (1U << vi->sbit)-1; vi->screen_gamma = dp->screen_gamma; if (fabs(vi->screen_gamma-1) < PNG_GAMMA_THRESHOLD) vi->screen_gamma = vi->screen_inverse = 0; else vi->screen_inverse = 1/vi->screen_gamma; vi->use_input_precision = dp->use_input_precision; vi->outmax = outmax; vi->maxabs = abserr(dp->pm, in_depth, out_depth); vi->maxpc = pcerr(dp->pm, in_depth, out_depth); vi->maxcalc = calcerr(dp->pm, in_depth, out_depth); vi->maxout = outerr(dp->pm, in_depth, out_depth); vi->outquant = output_quantization_factor(dp->pm, in_depth, out_depth); vi->maxout_total = vi->maxout + vi->outquant * .5; vi->outlog = outlog(dp->pm, in_depth, out_depth); if ((dp->this.colour_type & PNG_COLOR_MASK_ALPHA) != 0 || (dp->this.colour_type == 3 && dp->this.is_transparent)) { vi->do_background = dp->do_background; if (vi->do_background != 0) { PNG_CONST double bg_inverse = 1/dp->background_gamma; double r, g, b; r = dp->background_color.red; r /= outmax; g = dp->background_color.green; g /= outmax; b = dp->background_color.blue; b /= outmax; #if 0 if (fabs(bg_inverse-1) >= PNG_GAMMA_THRESHOLD) #endif { r = pow(r, bg_inverse); g = pow(g, bg_inverse); b = pow(b, bg_inverse); } vi->background_red = r; vi->background_green = g; vi->background_blue = b; } } else vi->do_background = 0; if (vi->do_background == 0) vi->background_red = vi->background_green = vi->background_blue = 0; vi->gamma_correction = 1/(dp->file_gamma*dp->screen_gamma); if (fabs(vi->gamma_correction-1) < PNG_GAMMA_THRESHOLD) vi->gamma_correction = 0; vi->file_inverse = 1/dp->file_gamma; if (fabs(vi->file_inverse-1) < PNG_GAMMA_THRESHOLD) vi->file_inverse = 0; vi->scale16 = dp->scale16; }<SPLIT>[0.6742027098995172, 0.8392673853604347, 0.0, 0.6464191252001059, 0.7425793323419214, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.8479814242356677, 0.3762494122151511, 0.8198834250278749, 0.0, 0.0, 0.30852482215402843, 0.7583671669991201, 0.35306556693537716, 0.7264085975241742, 0.5059163865058198, -0.1892664641018488, 0.0, 0.24428369699854227, 0.9973611507722091, 0.7814938157481727, 0.12893508214950905, 0.4568607580216725, 0.6817979554923368, -0.22825425296243224, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void gpc_gb16(Pixel *out, const Pixel *in, const Background *back) { if (in->a <= 0) out->r = out->g = out->b = back->ig; else if (in->a >= 65535) out->r = out->g = out->b = isRGB(in->g); else { double a = in->a / 65535.; double a1 = 1-a; a /= 65535; out->r = out->g = out->b = sRGB(in->g * a + back->dg * a1); } out->a = 255; }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.270465503877335, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.1980344553542678, -0.3333928163445767, 1.5806237532086234, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int findb(const png_byte *name) { int i = NINFO; while (--i >= 0) { if (memcmp(chunk_info[i].name, name, 4) == 0) break; } return i; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void uarb_printx(uarb num, int digits, FILE *out) { while (digits > 0) if (num[--digits] > 0) { fprintf(out, "0x%x", num[digits]); while (digits > 0) fprintf(out, "%.4x", num[--digits]); } else if (digits == 0) fputs("0x0", out); }<SPLIT>[-0.09900860198293619, -0.3727452499124955, 0.0, -0.11436118199787926, -0.42775315667224323, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.3507515578073234, -0.09566541730555662, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.11100716297398205, -0.42209287060340067, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.41601414702345235, -0.5591795518777907, 0.6817979554923368, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
1<SPLIT>void png_do_expand_palette(png_row_infop row_info, png_bytep row, png_const_colorp palette, png_const_bytep trans_alpha, int num_trans) { int shift, value; png_bytep sp, dp; png_uint_32 i; png_uint_32 row_width=row_info->width; png_debug(1, "in png_do_expand_palette"); if (row_info->color_type == PNG_COLOR_TYPE_PALETTE) { if (row_info->bit_depth < 8) { switch (row_info->bit_depth) { case 1: { sp = row + (png_size_t)((row_width - 1) >> 3); dp = row + (png_size_t)row_width - 1; shift = 7 - (int)((row_width + 7) & 0x07); for (i = 0; i < row_width; i++) { if ((*sp >> shift) & 0x01) *dp = 1; else *dp = 0; if (shift == 7) { shift = 0; sp--; } else shift++; dp--; } break; } case 2: { sp = row + (png_size_t)((row_width - 1) >> 2); dp = row + (png_size_t)row_width - 1; shift = (int)((3 - ((row_width + 3) & 0x03)) << 1); for (i = 0; i < row_width; i++) { value = (*sp >> shift) & 0x03; *dp = (png_byte)value; if (shift == 6) { shift = 0; sp--; } else shift += 2; dp--; } break; } case 4: { sp = row + (png_size_t)((row_width - 1) >> 1); dp = row + (png_size_t)row_width - 1; shift = (int)((row_width & 0x01) << 2); for (i = 0; i < row_width; i++) { value = (*sp >> shift) & 0x0f; *dp = (png_byte)value; if (shift == 4) { shift = 0; sp--; } else shift += 4; dp--; } break; } default: break; } row_info->bit_depth = 8; row_info->pixel_depth = 8; row_info->rowbytes = row_width; } if (row_info->bit_depth == 8) { { if (num_trans > 0) { sp = row + (png_size_t)row_width - 1; dp = row + (png_size_t)(row_width << 2) - 1; for (i = 0; i < row_width; i++) { if ((int)(*sp) >= num_trans) *dp-- = 0xff; else *dp-- = trans_alpha[*sp]; *dp-- = palette[*sp].blue; *dp-- = palette[*sp].green; *dp-- = palette[*sp].red; sp--; } row_info->bit_depth = 8; row_info->pixel_depth = 32; row_info->rowbytes = row_width * 4; row_info->color_type = 6; row_info->channels = 4; } else { sp = row + (png_size_t)row_width - 1; dp = row + (png_size_t)(row_width * 3) - 1; for (i = 0; i < row_width; i++) { *dp-- = palette[*sp].blue; *dp-- = palette[*sp].green; *dp-- = palette[*sp].red; sp--; } row_info->bit_depth = 8; row_info->pixel_depth = 24; row_info->rowbytes = row_width * 3; row_info->color_type = 2; row_info->channels = 3; } } } } }<SPLIT>[2.8391943831703865, 2.183499580844957, 0.0, 2.7766039853544644, 2.0405844565212674, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 2.3463976517894065, 2.8931285029922593, 2.2786277576955065, 0.0, 0.0, 0.30852482215402843, 2.2113886713894146, 2.82812012645196, 2.139948865988882, -0.39986248560786075, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 1.8705904812043497, -0.25252937827156396, -0.4462861841111837, -0.21702784222394986, -0.04111270872174079, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 1.7623686513065309, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static void perform_gamma_threshold_tests(png_modifier *pm) { png_byte colour_type = 0; png_byte bit_depth = 0; unsigned int palette_number = 0; while (next_format(&colour_type, &bit_depth, &palette_number, 1)) if (palette_number == 0) { double test_gamma = 1.0; while (test_gamma >= .4) { gamma_threshold_test(pm, colour_type, bit_depth, pm->interlace_type, test_gamma, 1/test_gamma); test_gamma *= .95; } gamma_threshold_test(pm, colour_type, bit_depth, pm->interlace_type, .45455, 2.2); if (fail(pm)) return; } }<SPLIT>[0.9834872346524985, -0.17441590959510697, 0.0, 0.9507312480792999, -0.23624420392447085, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.031089429262525795, 1.0054691849094282, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.09407211557651925, 0.9718292068145229, -0.22331377035055117, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int npasses_from_interlace_type(png_const_structp pp, int interlace_type) { switch (interlace_type) { default: png_error(pp, "invalid interlace type"); case PNG_INTERLACE_NONE: return 1; case PNG_INTERLACE_ADAM7: return PNG_INTERLACE_ADAM7_PASSES; } }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.6586564490689124, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.41601414702345235, -0.6720729196443977, 0.6817979554923368, -0.22825425296243224, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, 0.04889276383167627, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int logpixel(const Transform *transform, png_uint_32 x, png_uint_32 y, const Pixel *in, const Pixel *calc, const Pixel *out, const char *reason) { const png_uint_32 in_format = transform->in_image->image.format; const png_uint_32 out_format = transform->out_image->image.format; png_uint_32 back_format = out_format & ~PNG_FORMAT_FLAG_ALPHA; const char *via_linear = ""; char pixel_in[64], pixel_calc[64], pixel_out[64], pixel_loc[64]; char background_info[100]; print_pixel(pixel_in, in, in_format); print_pixel(pixel_calc, calc, out_format); print_pixel(pixel_out, out, out_format); if (transform->is_palette) sprintf(pixel_loc, "palette: %lu", (unsigned long)y); else sprintf(pixel_loc, "%lu,%lu", (unsigned long)x, (unsigned long)y); if (transform->from_linear != NULL) { via_linear = " (via linear)"; back_format |= PNG_FORMAT_FLAG_LINEAR; } if (transform->background != NULL) { Pixel back; char pixel_back[64]; back.r = transform->background->ir; back.g = transform->background->ig; back.b = transform->background->ib; back.a = -1; print_pixel(pixel_back, &back, back_format); sprintf(background_info, " on background %s", pixel_back); } else background_info[0] = 0; if (transform->in_image->file_name != transform->out_image->file_name) { char error_buffer[512]; sprintf(error_buffer, "(%s) %s error%s:\n %s%s ->\n %s\n not: %s.\n" "Use --preserve and examine: ", pixel_loc, reason, via_linear, pixel_in, background_info, pixel_out, pixel_calc); return logerror(transform->in_image, transform->in_image->file_name, error_buffer, transform->out_image->file_name); } else { char error_buffer[512]; sprintf(error_buffer, "(%s) %s error%s:\n %s%s ->\n %s\n not: %s.\n" " The error happened when reading the original file with this format.", pixel_loc, reason, via_linear, pixel_in, background_info, pixel_out, pixel_calc); return logerror(transform->in_image, transform->in_image->file_name, error_buffer, ""); } }<SPLIT>[0.36491818514653585, 0.5968648583058486, 0.0, 0.34210700232091185, 0.5085128345390885, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.5882559447930196, 0.3762494122151511, 0.637540383444421, 0.0, 0.0, 0.30852482215402843, 0.5065101062381357, 0.35306556693537716, 0.5497160639660857, 0.7647103499668715, 1.78382786780983, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2896437087679637, 0.5103995425705821, 0.7955408613214935, -0.21702784222394986, 0.23959960763929639, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>void PNGCBAPI count_filters(png_structp png_ptr, png_row_infop row_info, png_bytep data) { if (png_ptr != NULL && row_info != NULL) ++filters_used[*(data - 1)]; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int checkopaque(Image *image) { if (image->image.opaque != NULL) { png_image_free(&image->image); return logerror(image, image->file_name, ": opaque not NULL", ""); } else if (image->image.warning_or_error != 0 && (image->opts & STRICT) != 0) return logerror(image, image->file_name, " --strict", ""); else return 1; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.5292594673383866, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.3615192241061562, -0.5591795518777907, 0.6817979554923368, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static png_uint_32 png_pass_cols(png_uint_32 width, int pass) { png_uint_32 tiles = width>>3; png_uint_32 cols = 0; unsigned int x, y; width &= 7; ++pass; for (x=0; x<8; ++x) for (y=0; y<8; ++y) if (adam7[y][x] == pass) { cols += tiles; if (x < width) ++cols; break; } return cols; }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.6586564490689124, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.08904460951967552, -0.5591795518777907, -0.21702784222394986, 0.33317037975964214, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 1.7623686513065309, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static void chunk_end(struct chunk **chunk_var) { struct chunk *chunk = *chunk_var; *chunk_var = NULL; CLEAR(*chunk); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>BOOL CALLBACK AboutDlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) { switch (message) { case WM_INITDIALOG : ShowWindow (hDlg, SW_HIDE); CenterAbout (hDlg, GetWindow (hDlg, GW_OWNER)); ShowWindow (hDlg, SW_SHOW); return TRUE ; case WM_COMMAND : switch (LOWORD (wParam)) { case IDOK : case IDCANCEL : EndDialog (hDlg, 0) ; return TRUE ; } break ; } return FALSE ; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
1<SPLIT>void PNGAPI png_set_sPLT(png_structp png_ptr, png_infop info_ptr, png_sPLT_tp entries, int nentries) { png_sPLT_tp np; int i; np = (png_sPLT_tp)png_malloc_warn(png_ptr, (info_ptr->splt_palettes_num + nentries) * png_sizeof(png_sPLT_t)); if (np == NULL) { png_warning(png_ptr, "No memory for sPLT palettes."); return; } png_memcpy(np, info_ptr->splt_palettes, info_ptr->splt_palettes_num * png_sizeof(png_sPLT_t)); png_free(png_ptr, info_ptr->splt_palettes); info_ptr->splt_palettes=NULL; for (i = 0; i < nentries; i++) { png_sPLT_tp to = np + info_ptr->splt_palettes_num + i; png_sPLT_tp from = entries + i; to->name = (png_charp)png_malloc(png_ptr, png_strlen(from->name) + 1); png_strcpy(to->name, from->name); to->entries = (png_sPLT_entryp)png_malloc(png_ptr, from->nentries * png_sizeof(png_sPLT_t)); png_memcpy(to->entries, from->entries, from->nentries * png_sizeof(png_sPLT_t)); to->nentries = from->nentries; to->depth = from->depth; } info_ptr->splt_palettes = np; info_ptr->splt_palettes_num += nentries; info_ptr->valid |= PNG_INFO_sPLT; #ifdef PNG_FREE_ME_SUPPORTED info_ptr->free_me |= PNG_FREE_SPLT; #endif }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.798575186639703, 0.12549492904354367, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.21590580536007686, 0.8171382968447365, 0.06381159668134254, -0.7880534307994381, -0.518115519420462, 0.0, 0.02378964451747194, 1.5771521192305922, 0.07885080577644558, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void gamma_composition_test(png_modifier *pm, PNG_CONST png_byte colour_type, PNG_CONST png_byte bit_depth, PNG_CONST int palette_number, PNG_CONST int interlace_type, PNG_CONST double file_gamma, PNG_CONST double screen_gamma, PNG_CONST int use_input_precision, PNG_CONST int do_background, PNG_CONST int expand_16) { size_t pos = 0; png_const_charp base; double bg; char name[128]; png_color_16 background; switch (do_background) { default: base = ""; bg = 4; break; case PNG_BACKGROUND_GAMMA_SCREEN: base = " bckg(Screen):"; bg = 1/screen_gamma; break; case PNG_BACKGROUND_GAMMA_FILE: base = " bckg(File):"; bg = file_gamma; break; case PNG_BACKGROUND_GAMMA_UNIQUE: base = " bckg(Unique):"; bg = (file_gamma + screen_gamma) / 3; break; #ifdef PNG_READ_ALPHA_MODE_SUPPORTED case ALPHA_MODE_OFFSET + PNG_ALPHA_PNG: base = " alpha(PNG)"; bg = 4; break; case ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD: base = " alpha(Porter-Duff)"; bg = 4; break; case ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED: base = " alpha(Optimized)"; bg = 4; break; case ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN: base = " alpha(Broken)"; bg = 4; break; #endif } if (expand_16 || bit_depth == 16) { png_uint_32 r = random_32(); background.red = (png_uint_16)r; background.green = (png_uint_16)(r >> 16); r = random_32(); background.blue = (png_uint_16)r; background.gray = (png_uint_16)(r >> 16); #if DIGITIZE if (expand_16 && (do_background == PNG_BACKGROUND_GAMMA_UNIQUE || do_background == PNG_BACKGROUND_GAMMA_FILE) && fabs(bg*screen_gamma-1) > PNG_GAMMA_THRESHOLD) { background.red = (png_uint_16)((background.red >> 8) * 257); background.green = (png_uint_16)((background.green >> 8) * 257); background.blue = (png_uint_16)((background.blue >> 8) * 257); background.gray = (png_uint_16)((background.gray >> 8) * 257); } #endif } else { png_uint_32 r = random_32(); background.red = (png_byte)r; background.green = (png_byte)(r >> 8); background.blue = (png_byte)(r >> 16); background.gray = (png_byte)(r >> 24); } background.index = 193; if (!(colour_type & PNG_COLOR_MASK_COLOR)) { background.red = background.green = background.blue = background.gray; } pos = safecat(name, sizeof name, pos, "gamma "); pos = safecatd(name, sizeof name, pos, file_gamma, 3); pos = safecat(name, sizeof name, pos, "->"); pos = safecatd(name, sizeof name, pos, screen_gamma, 3); pos = safecat(name, sizeof name, pos, base); if (do_background < ALPHA_MODE_OFFSET) { pos = safecat(name, sizeof name, pos, "("); if (colour_type & PNG_COLOR_MASK_COLOR) { pos = safecatn(name, sizeof name, pos, background.red); pos = safecat(name, sizeof name, pos, ","); pos = safecatn(name, sizeof name, pos, background.green); pos = safecat(name, sizeof name, pos, ","); pos = safecatn(name, sizeof name, pos, background.blue); } else pos = safecatn(name, sizeof name, pos, background.gray); pos = safecat(name, sizeof name, pos, ")^"); pos = safecatd(name, sizeof name, pos, bg, 3); } gamma_test(pm, colour_type, bit_depth, palette_number, interlace_type, file_gamma, screen_gamma, 0, 0, name, use_input_precision, 0, expand_16, do_background, &background, bg); }<SPLIT>[3.4577634326763493, 1.7427677134729824, 0.0, 3.3852282311128525, 1.6150090059706623, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 2.026735523244609, 2.8931285029922593, 1.1617766279968509, 0.0, 0.0, 0.30852482215402843, 1.9014107504528184, 2.82812012645196, 1.05770709794559, 0.24712242304476825, 0.7972807018539907, 0.0, 3.110706379252456, 2.1569430876889752, 1.4490046752213135, 0.40140969673598975, 0.11818065472185141, 0.6817979554923368, 0.5203119240003335, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static void gamma_image_validate(gamma_display *dp, png_const_structp pp, png_infop pi) { PNG_CONST png_store* PNG_CONST ps = dp->this.ps; PNG_CONST png_byte in_ct = dp->this.colour_type; PNG_CONST png_byte in_bd = dp->this.bit_depth; PNG_CONST png_uint_32 w = dp->this.w; PNG_CONST png_uint_32 h = dp->this.h; PNG_CONST size_t cbRow = dp->this.cbRow; PNG_CONST png_byte out_ct = png_get_color_type(pp, pi); PNG_CONST png_byte out_bd = png_get_bit_depth(pp, pi); PNG_CONST unsigned int samples_per_pixel = (out_ct & 2U) ? 3U : 1U; int processing; png_uint_32 y; PNG_CONST store_palette_entry *in_palette = dp->this.palette; PNG_CONST int in_is_transparent = dp->this.is_transparent; int out_npalette = -1; int out_is_transparent = 0; store_palette out_palette; validate_info vi; store_image_check(dp->this.ps, pp, 0); init_validate_info(&vi, dp, pp, in_ct==3?8:in_bd, out_ct==3?8:out_bd); processing = (vi.gamma_correction > 0 && !dp->threshold_test) || in_bd != out_bd || in_ct != out_ct || vi.do_background; if (in_ct == 3 && out_ct == 3) processing = 0; if (processing && out_ct == 3) out_is_transparent = read_palette(out_palette, &out_npalette, pp, pi); for (y=0; y<h; ++y) { png_const_bytep pRow = store_image_row(ps, pp, 0, y); png_byte std[STANDARD_ROWMAX]; transform_row(pp, std, in_ct, in_bd, y); if (processing) { unsigned int x; for (x=0; x<w; ++x) { double alpha = 1; PNG_CONST unsigned int in_index = in_ct == 3 ? sample(std, 3, in_bd, x, 0) : 256; PNG_CONST unsigned int out_index = out_ct == 3 ? sample(std, 3, out_bd, x, 0) : 256; if ((in_ct & PNG_COLOR_MASK_ALPHA) != 0 || (in_ct == 3 && in_is_transparent)) { PNG_CONST unsigned int input_alpha = in_ct == 3 ? dp->this.palette[in_index].alpha : sample(std, in_ct, in_bd, x, samples_per_pixel); unsigned int output_alpha = 65536 ; if (out_ct == 3) { if (out_is_transparent) output_alpha = out_palette[out_index].alpha; } else if ((out_ct & PNG_COLOR_MASK_ALPHA) != 0) output_alpha = sample(pRow, out_ct, out_bd, x, samples_per_pixel); if (output_alpha != 65536) alpha = gamma_component_validate("alpha", &vi, input_alpha, output_alpha, -1, 0); else { alpha = input_alpha >> vi.isbit_shift; alpha /= vi.sbit_max; } } if ((in_ct & PNG_COLOR_MASK_COLOR) == 0) (void)gamma_component_validate("gray", &vi, sample(std, in_ct, in_bd, x, 0), sample(pRow, out_ct, out_bd, x, 0), alpha, vi.background_red); else { (void)gamma_component_validate("red", &vi, in_ct == 3 ? in_palette[in_index].red : sample(std, in_ct, in_bd, x, 0), out_ct == 3 ? out_palette[out_index].red : sample(pRow, out_ct, out_bd, x, 0), alpha, vi.background_red); (void)gamma_component_validate("green", &vi, in_ct == 3 ? in_palette[in_index].green : sample(std, in_ct, in_bd, x, 1), out_ct == 3 ? out_palette[out_index].green : sample(pRow, out_ct, out_bd, x, 1), alpha, vi.background_green); (void)gamma_component_validate("blue", &vi, in_ct == 3 ? in_palette[in_index].blue : sample(std, in_ct, in_bd, x, 2), out_ct == 3 ? out_palette[out_index].blue : sample(pRow, out_ct, out_bd, x, 2), alpha, vi.background_blue); } } } else if (memcmp(std, pRow, cbRow) != 0) { char msg[64]; sprintf(msg, "gamma: below threshold row %lu changed", (unsigned long)y); png_error(pp, msg); } } dp->this.ps->validated = 1; }<SPLIT>[9.024884878230013, 1.6766579333671863, 0.0, 8.862846442938345, 1.5511726883880714, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 2.686038663368254, 9.18532622993503, 1.7543915131430763, 0.0, 0.0, 0.30852482215402843, 2.5407402123845477, 9.015756525243416, 1.6319578320093775, 1.4116952586195004, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, 0.9922867187396908, 0.29241985090139744, 1.0213275968547075, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int image_transform_png_set_rgb_to_gray_add(image_transform *this, PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth) { UNUSED(bit_depth) this->next = *that; *that = this; return (colour_type & PNG_COLOR_MASK_COLOR) != 0; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void chrm_modification_init(chrm_modification *me, png_modifier *pm, PNG_CONST color_encoding *encoding) { CIE_color white = white_point(encoding); me->encoding = encoding; me->wx = fix(chromaticity_x(white)); me->wy = fix(chromaticity_y(white)); me->rx = fix(chromaticity_x(encoding->red)); me->ry = fix(chromaticity_y(encoding->red)); me->gx = fix(chromaticity_x(encoding->green)); me->gy = fix(chromaticity_y(encoding->green)); me->bx = fix(chromaticity_x(encoding->blue)); me->by = fix(chromaticity_y(encoding->blue)); modification_init(&me->this); me->this.chunk = CHUNK_cHRM; me->this.modify_fn = chrm_modify; me->this.add = CHUNK_PLTE; me->this.next = pm->modifications; pm->modifications = &me->this; }<SPLIT>[0.05563366039355449, -0.1964525029637057, 0.0, 0.037794879441717756, -0.2575229764520011, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.17094161050087475, 0.061639525868012635, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, 0.04368374699580437, -0.24540033704531222, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, -0.4705090699407485, -0.3333928163445767, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int main(int argc, const char **argv) { volatile int result = 1; if (argc == 4) { long x = atol(argv[1]); long y = atol(argv[2]); FILE *f = fopen(argv[3], "rb"); volatile png_bytep row = NULL; if (f != NULL) { png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL); if (png_ptr != NULL) { png_infop info_ptr = png_create_info_struct(png_ptr); if (info_ptr != NULL) { if (setjmp(png_jmpbuf(png_ptr)) == 0) { png_uint_32 width, height; int bit_depth, color_type, interlace_method, compression_method, filter_method; png_bytep row_tmp; png_init_io(png_ptr, f); png_read_info(png_ptr, info_ptr); row = png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr)); row_tmp = row; if (png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, &interlace_method, &compression_method, &filter_method)) { int passes, pass; switch (interlace_method) { case PNG_INTERLACE_NONE: passes = 1; break; case PNG_INTERLACE_ADAM7: passes = PNG_INTERLACE_ADAM7_PASSES; break; default: png_error(png_ptr, "pngpixel: unknown interlace"); } png_start_read_image(png_ptr); for (pass=0; pass<passes; ++pass) { png_uint_32 ystart, xstart, ystep, xstep; png_uint_32 py; if (interlace_method == PNG_INTERLACE_ADAM7) { if (PNG_PASS_COLS(width, pass) == 0) continue; xstart = PNG_PASS_START_COL(pass); ystart = PNG_PASS_START_ROW(pass); xstep = PNG_PASS_COL_OFFSET(pass); ystep = PNG_PASS_ROW_OFFSET(pass); } else { ystart = xstart = 0; ystep = xstep = 1; } for (py = ystart; py < height; py += ystep) { png_uint_32 px, ppx; png_read_row(png_ptr, row_tmp, NULL); if (y == py) for (px = xstart, ppx = 0; px < width; px += xstep, ++ppx) if (x == px) { print_pixel(png_ptr, info_ptr, row_tmp, ppx); goto pass_loop_end; } } } pass_loop_end: row = NULL; png_free(png_ptr, row_tmp); } else png_error(png_ptr, "pngpixel: png_get_IHDR failed"); } else { if (row != NULL) { png_bytep row_tmp = row; row = NULL; png_free(png_ptr, row_tmp); } } png_destroy_info_struct(png_ptr, &info_ptr); } else fprintf(stderr, "pngpixel: out of memory allocating png_info\n"); png_destroy_read_struct(&png_ptr, NULL, NULL); } else fprintf(stderr, "pngpixel: out of memory allocating png_struct\n"); } else fprintf(stderr, "pngpixel: %s: could not open file\n", argv[3]); } else fprintf(stderr, "pngpixel: usage: pngpixel x y png-file\n"); return result; }<SPLIT>[13.509510487148242, 1.7207311201043836, 0.0, 13.275372224686658, 1.6150090059706623, 0.0, 1.3177536816088504, 1.3480932287791254, 1.2376156019774536, 2.689180630379727, 3.3053840374237993, 13.747169581968539, 1.7999772735389399, 0.0, 0.0, 0.30852482215402843, 3.1606960542577403, 13.501792914367224, 1.6982175320936606, 2.5762680941942326, 1.674211516036959, 0.0, -0.08645738172306322, -0.16222078614455715, 1.1679474712326225, 2.581206613427835, 3.053408216653634, 6.074752741790056, 1.2688781009630994, 1.3170847170463484, 1.3475072793347742, 1.2369948159429325, 2.6883516673026273, 6.902796313731095, 0.0, 1.3123839157220905, 1.3427725632242797, 1.2323429545022004, 2.6812371144510547]
1<SPLIT>void png_write_iCCP(png_structp png_ptr, png_const_charp name, int compression_type, png_const_charp profile, int profile_len) { PNG_iCCP; png_size_t name_len; png_charp new_name; compression_state comp; int embedded_profile_len = 0; png_debug(1, "in png_write_iCCP"); comp.num_output_ptr = 0; comp.max_output_ptr = 0; comp.output_ptr = NULL; comp.input = NULL; comp.input_len = 0; if ((name_len = png_check_keyword(png_ptr, name, &new_name)) == 0) return; if (compression_type != PNG_COMPRESSION_TYPE_BASE) png_warning(png_ptr, "Unknown compression type in iCCP chunk"); if (profile == NULL) profile_len = 0; if (profile_len > 3) embedded_profile_len = ((*( (png_const_bytep)profile ))<<24) | ((*( (png_const_bytep)profile + 1))<<16) | ((*( (png_const_bytep)profile + 2))<< 8) | ((*( (png_const_bytep)profile + 3)) ); if (embedded_profile_len < 0) { png_warning(png_ptr, "Embedded profile length in iCCP chunk is negative"); png_free(png_ptr, new_name); return; } if (profile_len < embedded_profile_len) { png_warning(png_ptr, "Embedded profile length too large in iCCP chunk"); png_free(png_ptr, new_name); return; } if (profile_len > embedded_profile_len) { png_warning(png_ptr, "Truncating profile to actual length in iCCP chunk"); profile_len = embedded_profile_len; } if (profile_len) profile_len = png_text_compress(png_ptr, profile, (png_size_t)profile_len, PNG_COMPRESSION_TYPE_BASE, &comp); png_write_chunk_start(png_ptr, png_iCCP, (png_uint_32)(name_len + profile_len + 2)); new_name[name_len + 1] = 0x00; png_write_chunk_data(png_ptr, (png_bytep)new_name, (png_size_t)(name_len + 2)); if (profile_len) png_write_compressed_data_out(png_ptr, &comp); png_write_chunk_end(png_ptr); png_free(png_ptr, new_name); }<SPLIT>[2.684552120793896, 0.6629746384116447, 0.0, 2.6244479239148673, 0.5936279246492095, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, 0.7102265412631674, 0.9478758394059169, 2.73582355981869, 0.7059190240382162, 0.0, 0.0, 0.30852482215402843, 0.8746088873503436, 2.6734292164821736, 0.6159757640503689, 0.6353133682363457, 0.7972807018539907, 0.0, -0.08645738172306322, 0.417570182313826, 0.3599080097651364, 0.5103995425705821, 0.34396739025506545, -0.21702784222394986, 0.6138826961206794, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, 0.7098813332246741, 0.04889276383167627, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 0.7058592275743352]
0<SPLIT>static png_uint_16 ilineara(int fixed_srgb, int alpha) { return u16d((257 * alpha) * sRGB_to_d[fixed_srgb]); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gp_bgra8(Pixel *p, png_const_voidp pb) { png_const_bytep pp = voidcast(png_const_bytep, pb); p->r = pp[2]; p->g = pp[1]; p->b = pp[0]; p->a = pp[3]; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gpc_sG(Pixel *out, const Pixel *in, const Background *back) { (void)back; out->r = out->g = out->b = sRGB(YfromRGBint(in->r, in->g, in->b)/65535); out->a = 255; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void modifier_crc(png_bytep buffer) { uInt datalen = png_get_uint_32(buffer); uLong crc = crc32(0, buffer+4, datalen+4); png_save_uint_32(buffer+datalen+8, (png_uint_32)crc); }<SPLIT>[0.5195604475230265, -0.5049648101240879, 0.0, 0.4942630637605089, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3907093238754231, 0.5335543553887203, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, 0.5077564769051636, -0.554612270771967, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>void png_write_iCCP(png_structp png_ptr, png_charp name, int compression_type, png_charp profile, int profile_len) { #ifdef PNG_USE_LOCAL_ARRAYS PNG_iCCP; #endif png_size_t name_len; png_charp new_name; compression_state comp; png_debug(1, "in png_write_iCCP\n"); comp.num_output_ptr = 0; comp.max_output_ptr = 0; comp.output_ptr = NULL; comp.input = NULL; comp.input_len = 0; if (name == NULL || (name_len = png_check_keyword(png_ptr, name, &new_name)) == 0) { png_warning(png_ptr, "Empty keyword in iCCP chunk"); return; } if (compression_type != PNG_COMPRESSION_TYPE_BASE) png_warning(png_ptr, "Unknown compression type in iCCP chunk"); if (profile == NULL) profile_len = 0; if (profile_len) profile_len = png_text_compress(png_ptr, profile, (png_size_t)profile_len, PNG_COMPRESSION_TYPE_BASE, &comp); png_write_chunk_start(png_ptr, (png_bytep)png_iCCP, (png_uint_32)name_len+profile_len+2); new_name[name_len+1]=0x00; png_write_chunk_data(png_ptr, (png_bytep)new_name, name_len + 2); if (profile_len) png_write_compressed_data_out(png_ptr, &comp); png_write_chunk_end(png_ptr); png_free(png_ptr, new_name); }<SPLIT>[1.2927717594054797, 0.1781695843024727, 0.0, 1.2550433709584938, 0.12549492904354367, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.3285304653503715, 1.3200790712565666, 0.13609701908992267, 0.0, 0.0, 0.30852482215402843, 0.27402666553568866, 1.281211026754096, 0.06381159668134254, 0.5059163865058198, 0.029966239443893296, 0.0, 0.02378964451747194, 1.5771521192305922, 0.043718655277859224, 0.12893508214950905, 0.23107402248845843, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void type_sep(FILE *out) { putc(':', out); putc(' ', out); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>void png_push_read_zTXt(png_structp png_ptr, png_infop info_ptr) { if (png_ptr->buffer_size && png_ptr->current_text_left) { png_size_t text_size; if (png_ptr->buffer_size < (png_uint_32)png_ptr->current_text_left) text_size = png_ptr->buffer_size; else text_size = png_ptr->current_text_left; png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size); png_ptr->current_text_left -= text_size; png_ptr->current_text_ptr += text_size; } if (!(png_ptr->current_text_left)) { png_textp text_ptr; png_charp text; png_charp key; int ret; png_size_t text_size, key_size; if (png_ptr->buffer_size < 4) { png_push_save_buffer(png_ptr); return; } png_push_crc_finish(png_ptr); key = png_ptr->current_text; for (text = key; *text; text++) ; if (text >= key + png_ptr->current_text_size) { png_ptr->current_text = NULL; png_free(png_ptr, key); return; } text++; if (*text != PNG_TEXT_COMPRESSION_zTXt) { png_ptr->current_text = NULL; png_free(png_ptr, key); return; } text++; png_ptr->zstream.next_in = (png_bytep)text; png_ptr->zstream.avail_in = (uInt)(png_ptr->current_text_size - (text - key)); png_ptr->zstream.next_out = png_ptr->zbuf; png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size; key_size = text - key; text_size = 0; text = NULL; ret = Z_STREAM_END; while (png_ptr->zstream.avail_in) { ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH); if (ret != Z_OK && ret != Z_STREAM_END) { inflateReset(&png_ptr->zstream); png_ptr->zstream.avail_in = 0; png_ptr->current_text = NULL; png_free(png_ptr, key); png_free(png_ptr, text); return; } if (!(png_ptr->zstream.avail_out) || ret == Z_STREAM_END) { if (text == NULL) { text = (png_charp)png_malloc(png_ptr, (png_ptr->zbuf_size - png_ptr->zstream.avail_out + key_size + 1)); png_memcpy(text + key_size, png_ptr->zbuf, png_ptr->zbuf_size - png_ptr->zstream.avail_out); png_memcpy(text, key, key_size); text_size = key_size + png_ptr->zbuf_size - png_ptr->zstream.avail_out; *(text + text_size) = '\0'; } else { png_charp tmp; tmp = text; text = (png_charp)png_malloc(png_ptr, text_size + (png_ptr->zbuf_size - png_ptr->zstream.avail_out + 1)); png_memcpy(text, tmp, text_size); png_free(png_ptr, tmp); png_memcpy(text + text_size, png_ptr->zbuf, png_ptr->zbuf_size - png_ptr->zstream.avail_out); text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out; *(text + text_size) = '\0'; } if (ret != Z_STREAM_END) { png_ptr->zstream.next_out = png_ptr->zbuf; png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size; } } else { break; } if (ret == Z_STREAM_END) break; } inflateReset(&png_ptr->zstream); png_ptr->zstream.avail_in = 0; if (ret != Z_STREAM_END) { png_ptr->current_text = NULL; png_free(png_ptr, key); png_free(png_ptr, text); return; } png_ptr->current_text = NULL; png_free(png_ptr, key); key = text; text += key_size; text_ptr = (png_textp)png_malloc(png_ptr, png_sizeof(png_text)); text_ptr->compression = PNG_TEXT_COMPRESSION_zTXt; text_ptr->key = key; text_ptr->itxt_length = 0; text_ptr->lang = NULL; text_ptr->lang_key = NULL; text_ptr->text = text; ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1); png_free(png_ptr, key); png_free(png_ptr, text_ptr); if (ret) png_warning(png_ptr, "Insufficient memory to store text chunk"); } }<SPLIT>[5.004186056441256, 2.271645954319352, 0.0, 4.906788845508823, 2.1469783191589187, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 1.3698779043020206, 2.7259964294363535, 5.0953977074222285, 2.3697992784872333, 0.0, 0.0, 0.30852482215402843, 2.5988610725601595, 4.99379286602897, 2.228295132767926, 0.5059163865058198, 0.029966239443893296, 0.0, -0.08645738172306322, 0.417570182313826, 2.0813833841958678, 0.40140969673598975, 0.34396739025506545, -0.21702784222394986, 0.42674115187998785, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 1.3693714445839917, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 1.3643185231999084]
0<SPLIT>void PNGAPI png_set_write_fn(png_structp png_ptr, png_voidp io_ptr, png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn) { if (png_ptr == NULL) return; png_ptr->io_ptr = io_ptr; if (write_data_fn != NULL) png_ptr->write_data_fn = write_data_fn; else png_ptr->write_data_fn = png_default_write_data; png_ptr->write_data_fn = write_data_fn; if (output_flush_fn != NULL) png_ptr->output_flush_fn = output_flush_fn; else png_ptr->output_flush_fn = png_default_flush; png_ptr->output_flush_fn = output_flush_fn; if (png_ptr->read_data_fn != NULL) { png_ptr->read_data_fn = NULL; png_warning(png_ptr, "Can't set both read_data_fn and write_data_fn in the same structure"); } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.11436118199787926, -0.17240788634188003, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.17156659581066827, -0.11100716297398205, -0.157054070266268, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
1<SPLIT>void png_handle_pCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length) { png_charp purpose; png_int_32 X0, X1; png_byte type, nparams; png_charp buf, units, endptr; png_charpp params; png_size_t slength; int i; png_debug(1, "in png_handle_pCAL\n"); if (!(png_ptr->mode & PNG_HAVE_IHDR)) png_error(png_ptr, "Missing IHDR before pCAL"); else if (png_ptr->mode & PNG_HAVE_IDAT) { png_warning(png_ptr, "Invalid pCAL after IDAT"); png_crc_finish(png_ptr, length); return; } else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL)) { png_warning(png_ptr, "Duplicate pCAL chunk"); png_crc_finish(png_ptr, length); return; } png_debug1(2, "Allocating and reading pCAL chunk data (%lu bytes)\n", length + 1); purpose = (png_charp)png_malloc_warn(png_ptr, length + 1); if (purpose == NULL) { png_warning(png_ptr, "No memory for pCAL purpose."); return; } slength = (png_size_t)length; png_crc_read(png_ptr, (png_bytep)purpose, slength); if (png_crc_finish(png_ptr, 0)) { png_free(png_ptr, purpose); return; } purpose[slength] = 0x00; png_debug(3, "Finding end of pCAL purpose string\n"); for (buf = purpose; *buf; buf++) ; endptr = purpose + slength; if (endptr <= buf + 12) { png_warning(png_ptr, "Invalid pCAL data"); png_free(png_ptr, purpose); return; } png_debug(3, "Reading pCAL X0, X1, type, nparams, and units\n"); X0 = png_get_int_32((png_bytep)buf+1); X1 = png_get_int_32((png_bytep)buf+5); type = buf[9]; nparams = buf[10]; units = buf + 11; png_debug(3, "Checking pCAL equation type and number of parameters\n"); if ((type == PNG_EQUATION_LINEAR && nparams != 2) || (type == PNG_EQUATION_BASE_E && nparams != 3) || (type == PNG_EQUATION_ARBITRARY && nparams != 3) || (type == PNG_EQUATION_HYPERBOLIC && nparams != 4)) { png_warning(png_ptr, "Invalid pCAL parameters for equation type"); png_free(png_ptr, purpose); return; } else if (type >= PNG_EQUATION_LAST) { png_warning(png_ptr, "Unrecognized equation type for pCAL chunk"); } for (buf = units; *buf; buf++) ; png_debug(3, "Allocating pCAL parameters array\n"); params = (png_charpp)png_malloc_warn(png_ptr, (png_uint_32)(nparams *png_sizeof(png_charp))) ; if (params == NULL) { png_free(png_ptr, purpose); png_warning(png_ptr, "No memory for pCAL params."); return; } for (i = 0; i < (int)nparams; i++) { buf++; png_debug1(3, "Reading pCAL parameter %d\n", i); for (params[i] = buf; *buf != 0x00 && buf <= endptr; buf++) ; if (buf > endptr) { png_warning(png_ptr, "Invalid pCAL data"); png_free(png_ptr, purpose); png_free(png_ptr, params); return; } } png_set_pCAL(png_ptr, info_ptr, purpose, X0, X1, type, nparams, units, params); png_free(png_ptr, purpose); png_free(png_ptr, params); }<SPLIT>[3.3031211702998586, 1.5003651864183964, 0.0, 3.2330721696732554, 1.4022212806953596, 0.0, 1.1439604446378808, 1.1713499043019204, 1.0717736154263862, 2.3593549488603003, 1.8469255759381602, 3.365043332512967, 1.5720484715596224, 0.0, 0.0, 0.30852482215402843, 1.7464217899845202, 3.292192856361319, 1.455265298451289, 0.5059163865058198, 1.2357461089454749, 0.0, -0.08645738172306322, 0.417570182313826, 1.5895332772156587, 1.0553487717435432, 0.34396739025506545, 0.6817979554923368, 1.4560196452037908, 1.143335983750264, 1.1708005902540914, 1.0711936229013617, 2.3586066116229683, 0.04889276383167627, 0.0, 1.1388542534712223, 1.1662853116856364, 1.0667610514419015, 2.352007466638268]
0<SPLIT>static void rpng2_x_init(void) { ulg i; ulg rowbytes = rpng2_info.rowbytes; Trace((stderr, "beginning rpng2_x_init()\n")) Trace((stderr, " rowbytes = %d\n", rpng2_info.rowbytes)) Trace((stderr, " width = %ld\n", rpng2_info.width)) Trace((stderr, " height = %ld\n", rpng2_info.height)) rpng2_info.image_data = (uch *)malloc(rowbytes * rpng2_info.height); if (!rpng2_info.image_data) { readpng2_cleanup(&rpng2_info); return; } rpng2_info.row_pointers = (uch **)malloc(rpng2_info.height * sizeof(uch *)); if (!rpng2_info.row_pointers) { free(rpng2_info.image_data); rpng2_info.image_data = NULL; readpng2_cleanup(&rpng2_info); return; } for (i = 0; i < rpng2_info.height; ++i) rpng2_info.row_pointers[i] = rpng2_info.image_data + i*rowbytes; if (rpng2_x_create_window()) { readpng2_cleanup(&rpng2_info); rpng2_x_cleanup(); exit(2); } rpng2_info.state = kWindowInit; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.9507312480792999, -0.06601402370422871, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.060916844891778815, 0.9718292068145229, -0.04662123679246273, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void png_write_data(png_structp png_ptr, png_bytep data, png_size_t length) { png_uint_32 check; check = fwrite(data, 1, length, (FILE *)(png_ptr->io_ptr)); if (check != length) { png_error(png_ptr, "Write Error"); } }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void PNGCBAPI png_default_flush(png_structp png_ptr) { png_FILE_p io_ptr; if (png_ptr == NULL) return; io_ptr = (png_FILE_p)CVT_PTR((png_ptr->io_ptr)); fflush(io_ptr); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void readpng2_info_callback(png_structp png_ptr, png_infop info_ptr) { mainprog_info *mainprog_ptr; int color_type, bit_depth; png_uint_32 width, height; #ifdef PNG_FLOATING_POINT_SUPPORTED double gamma; #else png_fixed_point gamma; #endif mainprog_ptr = png_get_progressive_ptr(png_ptr); if (mainprog_ptr == NULL) { fprintf(stderr, "readpng2 error: main struct not recoverable in info_callback.\n"); fflush(stderr); return; } png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, NULL, NULL, NULL); mainprog_ptr->width = (ulg)width; mainprog_ptr->height = (ulg)height; if (mainprog_ptr->need_bgcolor && png_get_valid(png_ptr, info_ptr, PNG_INFO_bKGD)) { png_color_16p pBackground; png_get_bKGD(png_ptr, info_ptr, &pBackground); if (bit_depth == 16) { mainprog_ptr->bg_red = pBackground->red >> 8; mainprog_ptr->bg_green = pBackground->green >> 8; mainprog_ptr->bg_blue = pBackground->blue >> 8; } else if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8) { if (bit_depth == 1) mainprog_ptr->bg_red = mainprog_ptr->bg_green = mainprog_ptr->bg_blue = pBackground->gray? 255 : 0; else if (bit_depth == 2) mainprog_ptr->bg_red = mainprog_ptr->bg_green = mainprog_ptr->bg_blue = (255/3) * pBackground->gray; else mainprog_ptr->bg_red = mainprog_ptr->bg_green = mainprog_ptr->bg_blue = (255/15) * pBackground->gray; } else { mainprog_ptr->bg_red = (uch)pBackground->red; mainprog_ptr->bg_green = (uch)pBackground->green; mainprog_ptr->bg_blue = (uch)pBackground->blue; } } if (color_type == PNG_COLOR_TYPE_PALETTE) png_set_expand(png_ptr); if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8) png_set_expand(png_ptr); if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)) png_set_expand(png_ptr); #ifdef PNG_READ_16_TO_8_SUPPORTED if (bit_depth == 16) #ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED png_set_scale_16(png_ptr); #else png_set_strip_16(png_ptr); #endif #endif if (color_type == PNG_COLOR_TYPE_GRAY || color_type == PNG_COLOR_TYPE_GRAY_ALPHA) png_set_gray_to_rgb(png_ptr); #ifdef PNG_FLOATING_POINT_SUPPORTED if (png_get_gAMA(png_ptr, info_ptr, &gamma)) png_set_gamma(png_ptr, mainprog_ptr->display_exponent, gamma); else png_set_gamma(png_ptr, mainprog_ptr->display_exponent, 0.45455); #else if (png_get_gAMA_fixed(png_ptr, info_ptr, &gamma)) png_set_gamma_fixed(png_ptr, (png_fixed_point)(100000*mainprog_ptr->display_exponent+.5), gamma); else png_set_gamma_fixed(png_ptr, (png_fixed_point)(100000*mainprog_ptr->display_exponent+.5), 45455); #endif mainprog_ptr->passes = png_set_interlace_handling(png_ptr); png_read_update_info(png_ptr, info_ptr); mainprog_ptr->rowbytes = (int)png_get_rowbytes(png_ptr, info_ptr); mainprog_ptr->channels = png_get_channels(png_ptr, info_ptr); (*mainprog_ptr->mainprog_init)(); return; }<SPLIT>[7.633104516841597, 1.1698162858894157, 0.0, 7.493441889981972, 1.0830396927824055, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 2.046714406278659, 7.769581741372906, 0.7970905448299431, 0.0, 0.0, 0.30852482215402843, 1.940157990569893, 7.623538335515339, 0.7264085975241742, 1.1529012951584487, 0.13958259121676436, 0.0, 1.1262599069228236, 6.215479866897657, 0.6760973642524136, 0.5103995425705821, 1.0213275968547075, -0.21702784222394986, 0.05245806339860493, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static void store_read_imp(png_store *ps, png_bytep pb, png_size_t st) { if (ps->current == NULL || ps->next == NULL) png_error(ps->pread, "store state damaged"); while (st > 0) { size_t cbAvail = store_read_buffer_size(ps) - ps->readpos; if (cbAvail > 0) { if (cbAvail > st) cbAvail = st; memcpy(pb, ps->next->buffer + ps->readpos, cbAvail); st -= cbAvail; pb += cbAvail; ps->readpos += cbAvail; } else if (!store_read_buffer_next(ps)) png_error(ps->pread, "read beyond end of file"); } }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void IDAT_list_end(struct IDAT_list *IDAT_list) { struct IDAT_list *list = IDAT_list->next; CLEAR(*IDAT_list); while (list != NULL) { struct IDAT_list *next = list->next; clear(list, IDAT_list_size(list, 0)); free(list); list = next; } }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.14106852214680915, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3070243011888601, 0.005287286955244392, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>BOOL PngLoadImage (PTSTR pstrFileName, png_byte **ppbImageData, int *piWidth, int *piHeight, int *piChannels, png_color *pBkgColor) { static FILE *pfFile; png_byte pbSig[8]; int iBitDepth; int iColorType; double dGamma; png_color_16 *pBackground; png_uint_32 ulChannels; png_uint_32 ulRowBytes; png_byte *pbImageData = *ppbImageData; static png_byte **ppbRowPointers = NULL; int i; if (!pstrFileName) { *ppbImageData = pbImageData = NULL; return FALSE; } if (!(pfFile = fopen(pstrFileName, "rb"))) { *ppbImageData = pbImageData = NULL; return FALSE; } fread(pbSig, 1, 8, pfFile); if (png_sig_cmp(pbSig, 0, 8)) { *ppbImageData = pbImageData = NULL; return FALSE; } png_ptr = png_create_read_struct(png_get_libpng_ver(NULL), NULL, (png_error_ptr)png_cexcept_error, (png_error_ptr)NULL); if (!png_ptr) { *ppbImageData = pbImageData = NULL; return FALSE; } info_ptr = png_create_info_struct(png_ptr); if (!info_ptr) { png_destroy_read_struct(&png_ptr, NULL, NULL); *ppbImageData = pbImageData = NULL; return FALSE; } Try { #ifdef PNG_STDIO_SUPPORTED png_init_io(png_ptr, pfFile); #else png_set_read_fn(png_ptr, (png_voidp)pfFile, png_read_data); #endif png_set_sig_bytes(png_ptr, 8); png_read_info(png_ptr, info_ptr); png_get_IHDR(png_ptr, info_ptr, piWidth, piHeight, &iBitDepth, &iColorType, NULL, NULL, NULL); #ifdef PNG_READ_16_TO_8_SUPPORTED if (iBitDepth == 16) # ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED png_set_scale_16(png_ptr); # else png_set_strip_16(png_ptr); # endif #endif if (iColorType == PNG_COLOR_TYPE_PALETTE) png_set_expand(png_ptr); if (iBitDepth < 8) png_set_expand(png_ptr); if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)) png_set_expand(png_ptr); if (iColorType == PNG_COLOR_TYPE_GRAY || iColorType == PNG_COLOR_TYPE_GRAY_ALPHA) png_set_gray_to_rgb(png_ptr); if (png_get_bKGD(png_ptr, info_ptr, &pBackground)) { png_set_background(png_ptr, pBackground, PNG_BACKGROUND_GAMMA_FILE, 1, 1.0); pBkgColor->red = (byte) pBackground->red; pBkgColor->green = (byte) pBackground->green; pBkgColor->blue = (byte) pBackground->blue; } else { pBkgColor = NULL; } if (png_get_gAMA(png_ptr, info_ptr, &dGamma)) png_set_gamma(png_ptr, (double) 2.2, dGamma); png_read_update_info(png_ptr, info_ptr); png_get_IHDR(png_ptr, info_ptr, piWidth, piHeight, &iBitDepth, &iColorType, NULL, NULL, NULL); ulRowBytes = png_get_rowbytes(png_ptr, info_ptr); ulChannels = png_get_channels(png_ptr, info_ptr); *piChannels = ulChannels; if (pbImageData) { free (pbImageData); pbImageData = NULL; } if ((pbImageData = (png_byte *) malloc(ulRowBytes * (*piHeight) * sizeof(png_byte))) == NULL) { png_error(png_ptr, "Visual PNG: out of memory"); } *ppbImageData = pbImageData; if ((ppbRowPointers = (png_bytepp) malloc((*piHeight) * sizeof(png_bytep))) == NULL) { png_error(png_ptr, "Visual PNG: out of memory"); } for (i = 0; i < (*piHeight); i++) ppbRowPointers[i] = pbImageData + i * ulRowBytes; png_read_image(png_ptr, ppbRowPointers); png_read_end(png_ptr, NULL); free (ppbRowPointers); ppbRowPointers = NULL; } Catch (msg) { png_destroy_read_struct(&png_ptr, &info_ptr, NULL); *ppbImageData = pbImageData = NULL; if(ppbRowPointers) free (ppbRowPointers); fclose(pfFile); return FALSE; } fclose (pfFile); return TRUE; }<SPLIT>[2.8391943831703865, 2.117389800739161, 0.0, 2.7766039853544644, 1.9767481389386767, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, -0.27925050329511203, 2.2864610026872567, 2.8931285029922593, 1.9367345547265302, 0.0, 0.0, 0.30852482215402843, 2.153267811213803, 2.82812012645196, 1.808650365567466, 0.7647103499668715, -0.4084991676475909, 0.0, 0.6852718019606829, 4.4761069615225075, 1.6246654277142452, 0.29241985090139744, 0.6826474935548865, -0.21702784222394986, -0.04111270872174079, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, -0.27935383381430245, 0.04889276383167627, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, -0.28182971586402455]
0<SPLIT>static int pixel_cmp(png_const_bytep pa, png_const_bytep pb, png_uint_32 bit_width) { #if PNG_LIBPNG_VER < 10506 if (memcmp(pa, pb, bit_width>>3) == 0) { png_uint_32 p; if ((bit_width & 7) == 0) return 0; p = pa[bit_width >> 3]; p ^= pb[bit_width >> 3]; if (p == 0) return 0; bit_width &= 7; p >>= 8-bit_width; if (p == 0) return 0; } #else if (memcmp(pa, pb, (bit_width+7)>>3) == 0) return 0; #endif { png_uint_32 where = 0; while (pa[where] == pb[where]) ++where; return 1+where; } }<SPLIT>[0.9834872346524985, -0.10830612948931077, 0.0, 0.9507312480792999, -0.17240788634188003, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 1.040052222782594, 0.02884721983962376, 0.5335543553887203, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.03595125540090747, 0.5077564769051636, -0.2674869037400733, -0.6586564490689124, -0.07965011232897776, 0.0, 0.4647777494796126, 1.5771521192305922, -0.27247069920941797, -0.25252937827156396, -0.6720729196443977, -0.21702784222394986, 0.14602883551895066, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 1.039626388904333, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 1.0350888753871217]
0<SPLIT>static struct buffer_list * buffer_extend(struct buffer_list *current) { struct buffer_list *add; assert(current->next == NULL); add = NEW(struct buffer_list); if (add == NULL) return NULL; add->next = NULL; current->next = add; return add; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI pngtest_error(png_structp png_ptr, png_const_charp message) { pngtest_warning(png_ptr, message); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.18995094088131478, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5202917568643389, 0.19837465696559078, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
1<SPLIT>void PNGAPI png_read_png(png_structp png_ptr, png_infop info_ptr, int transforms, voidp params) { int row; if(png_ptr == NULL) return; #if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) if (transforms & PNG_TRANSFORM_INVERT_ALPHA) png_set_invert_alpha(png_ptr); #endif png_read_info(png_ptr, info_ptr); if (info_ptr->height > PNG_UINT_32_MAX/png_sizeof(png_bytep)) png_error(png_ptr,"Image is too high to process with png_read_png()"); #if defined(PNG_READ_16_TO_8_SUPPORTED) if (transforms & PNG_TRANSFORM_STRIP_16) png_set_strip_16(png_ptr); #endif #if defined(PNG_READ_STRIP_ALPHA_SUPPORTED) if (transforms & PNG_TRANSFORM_STRIP_ALPHA) png_set_strip_alpha(png_ptr); #endif #if defined(PNG_READ_PACK_SUPPORTED) && !defined(PNG_READ_EXPAND_SUPPORTED) if (transforms & PNG_TRANSFORM_PACKING) png_set_packing(png_ptr); #endif #if defined(PNG_READ_PACKSWAP_SUPPORTED) if (transforms & PNG_TRANSFORM_PACKSWAP) png_set_packswap(png_ptr); #endif #if defined(PNG_READ_EXPAND_SUPPORTED) if (transforms & PNG_TRANSFORM_EXPAND) if ((png_ptr->bit_depth < 8) || (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) || (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))) png_set_expand(png_ptr); #endif #if defined(PNG_READ_INVERT_SUPPORTED) if (transforms & PNG_TRANSFORM_INVERT_MONO) png_set_invert_mono(png_ptr); #endif #if defined(PNG_READ_SHIFT_SUPPORTED) if ((transforms & PNG_TRANSFORM_SHIFT) && png_get_valid(png_ptr, info_ptr, PNG_INFO_sBIT)) { png_color_8p sig_bit; png_get_sBIT(png_ptr, info_ptr, &sig_bit); png_set_shift(png_ptr, sig_bit); } #endif #if defined(PNG_READ_BGR_SUPPORTED) if (transforms & PNG_TRANSFORM_BGR) png_set_bgr(png_ptr); #endif #if defined(PNG_READ_SWAP_ALPHA_SUPPORTED) if (transforms & PNG_TRANSFORM_SWAP_ALPHA) png_set_swap_alpha(png_ptr); #endif #if defined(PNG_READ_SWAP_SUPPORTED) if (transforms & PNG_TRANSFORM_SWAP_ENDIAN) png_set_swap(png_ptr); #endif png_read_update_info(png_ptr, info_ptr); #ifdef PNG_FREE_ME_SUPPORTED png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0); #endif if(info_ptr->row_pointers == NULL) { info_ptr->row_pointers = (png_bytepp)png_malloc(png_ptr, info_ptr->height * png_sizeof(png_bytep)); #ifdef PNG_FREE_ME_SUPPORTED info_ptr->free_me |= PNG_FREE_ROWS; #endif for (row = 0; row < (int)info_ptr->height; row++) { info_ptr->row_pointers[row] = (png_bytep)png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr)); } } png_read_image(png_ptr, info_ptr->row_pointers); info_ptr->valid |= PNG_INFO_IDAT; png_read_end(png_ptr, info_ptr); transforms = transforms; params = params; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 9.775782811575926, 1.1681547828925267, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 2.308256771682101, 5.1484837759987565, -0.1128809368767459, -0.7880534307994381, -0.518115519420462, 0.0, 6.859105271430652, 16.651717299148554, 0.32477585926655006, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void check_handling(display *d, int def, png_uint_32 chunks, png_uint_32 known, png_uint_32 unknown, const char *position, int set_callback) { while (chunks) { png_uint_32 flag = chunks & -(png_int_32)chunks; int i = find_by_flag(flag); int keep = chunk_info[i].keep; const char *type; const char *errorx = NULL; if (chunk_info[i].unknown) { if (keep == PNG_HANDLE_CHUNK_AS_DEFAULT) { type = "UNKNOWN (default)"; keep = def; } else type = "UNKNOWN (specified)"; if (flag & known) errorx = "chunk processed"; else switch (keep) { case PNG_HANDLE_CHUNK_AS_DEFAULT: if (flag & unknown) errorx = "DEFAULT: unknown chunk saved"; break; case PNG_HANDLE_CHUNK_NEVER: if (flag & unknown) errorx = "DISCARD: unknown chunk saved"; break; case PNG_HANDLE_CHUNK_IF_SAFE: if (ancillary(chunk_info[i].name)) { if (!(flag & unknown)) errorx = "IF-SAFE: unknown ancillary chunk lost"; } else if (flag & unknown) errorx = "IF-SAFE: unknown critical chunk saved"; break; case PNG_HANDLE_CHUNK_ALWAYS: if (!(flag & unknown)) errorx = "SAVE: unknown chunk lost"; break; default: errorx = "internal error: bad keep"; break; } } else { type = "KNOWN"; if (flag & known) { if (keep != PNG_HANDLE_CHUNK_AS_DEFAULT) errorx = "!DEFAULT: known chunk processed"; } else switch (keep) { case PNG_HANDLE_CHUNK_AS_DEFAULT: errorx = "DEFAULT: known chunk not processed"; break; case PNG_HANDLE_CHUNK_NEVER: if (flag & unknown) errorx = "DISCARD: known chunk saved"; break; case PNG_HANDLE_CHUNK_IF_SAFE: if (ancillary(chunk_info[i].name)) { if (!(flag & unknown)) errorx = "IF-SAFE: known ancillary chunk lost"; } else if (flag & unknown) errorx = "IF-SAFE: known critical chunk saved"; break; case PNG_HANDLE_CHUNK_ALWAYS: if (!(flag & unknown)) errorx = "SAVE: known chunk lost"; break; default: errorx = "internal error: bad keep (2)"; break; } } if (errorx != NULL) { ++(d->error_count); fprintf(stderr, "%s(%s%s): %s %s %s: %s\n", d->file, d->test, set_callback ? ",callback" : "", type, chunk_info[i].name, position, errorx); } chunks &= ~flag; } }<SPLIT>[0.21027592277004517, 1.4342554063126, 0.0, 0.18995094088131478, 1.3171061905852386, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 1.3274746170528642, 0.21894446904158188, 1.5036698309658272, 0.0, 0.0, 0.30852482215402843, 1.2233340484040143, 0.19837465696559078, 1.3890055983670058, 0.11772544131424245, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5707009127566546, -0.3070243011888601, 0.005287286955244392, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void standard_display_init(standard_display *dp, png_store* ps, png_uint_32 id, int do_interlace, int use_update_info) { memset(dp, 0, sizeof *dp); dp->ps = ps; dp->colour_type = COL_FROM_ID(id); dp->bit_depth = DEPTH_FROM_ID(id); if (dp->bit_depth < 1 || dp->bit_depth > 16) internal_error(ps, "internal: bad bit depth"); if (dp->colour_type == 3) dp->red_sBIT = dp->blue_sBIT = dp->green_sBIT = dp->alpha_sBIT = 8; else dp->red_sBIT = dp->blue_sBIT = dp->green_sBIT = dp->alpha_sBIT = dp->bit_depth; dp->interlace_type = INTERLACE_FROM_ID(id); check_interlace_type(dp->interlace_type); dp->id = id; dp->w = 0; dp->h = 0; dp->npasses = 0; dp->pixel_size = 0; dp->bit_width = 0; dp->cbRow = 0; dp->do_interlace = do_interlace; dp->is_transparent = 0; dp->speed = ps->speed; dp->use_update_info = use_update_info; dp->npalette = 0; memset(&dp->transparent, 0, sizeof dp->transparent); memset(dp->palette, 0xff, sizeof dp->palette); }<SPLIT>[0.21027592277004517, 0.04595002409088034, 0.0, 0.18995094088131478, -0.02345647864916818, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.06880498590772346, 0.21894446904158188, 0.06771837849612745, 0.0, 0.0, 0.30852482215402843, 0.0027959847161670454, 0.19837465696559078, -0.0024481034029406237, 0.11772544131424245, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.11398295627503194, -0.3615192241061562, -0.10760608081136262, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int validation_muldiv(int count, int argc, char **argv) { int tested = 0; int overflow = 0; int error = 0; int error64 = 0; int passed = 0; int randbits = 0; png_uint_32 randbuffer; png_fixed_point a; png_int_32 times, div; while (--argc > 0) { fprintf(stderr, "unknown argument %s\n", *++argv); return 1; } randbuffer = RAND_MAX; while (randbuffer != 0) ++randbits, randbuffer >>= 1; printf("Using random number generator that makes %d bits\n", randbits); for (div=0; div<32; div += randbits) randbuffer = (randbuffer << randbits) ^ rand(); a = 0; times = div = 0; do { png_fixed_point result; long long int fp, fpround; unsigned long hi, lo; int ok; { long u1, u2; int n = 0; if (a < 0) u1 = -a, n = 1; else u1 = a; if (times < 0) u2 = -times, n = !n; else u2 = times; png_64bit_product(u1, u2, &hi, &lo); if (n) { lo = ((~lo) + 1) & 0xffffffff; hi = ~hi; if (lo == 0) ++hi; } } fp = a; fp *= times; if ((fp & 0xffffffff) != lo || ((fp >> 32) & 0xffffffff) != hi) { fprintf(stderr, "png_64bit_product %d * %d -> %lx|%.8lx not %llx\n", a, times, hi, lo, fp); ++error64; } if (div != 0) { if ((fp < 0) != (div < 0)) fp -= div/2; else fp += div/2; fp /= div; fpround = fp; ok = fpround <= PNG_UINT_31_MAX && fpround >= -1-(long long int)PNG_UINT_31_MAX; if (!ok) ++overflow; } else ok = 0, ++overflow, fpround = fp; if (verbose) fprintf(stderr, "TEST %d * %d / %d -> %lld (%s)\n", a, times, div, fp, ok ? "ok" : "overflow"); ++tested; if (png_muldiv(&result, a, times, div) != ok) { ++error; if (ok) fprintf(stderr, "%d * %d / %d -> overflow (expected %lld)\n", a, times, div, fp); else fprintf(stderr, "%d * %d / %d -> %d (expected overflow %lld)\n", a, times, div, result, fp); } else if (ok && result != fpround) { ++error; fprintf(stderr, "%d * %d / %d -> %d not %lld\n", a, times, div, result, fp); } else ++passed; a += times; times += div; div = randbuffer; randbuffer = (randbuffer << randbits) ^ rand(); } while (--count > 0); printf("%d tests including %d overflows, %d passed, %d failed (%d 64 bit " "errors)\n", tested, overflow, passed, error, error64); return 0; }<SPLIT>[2.065983071287933, 1.456291999681199, 0.0, 2.015823678156479, 1.3596637356402992, 0.0, 1.1439604446378808, 1.1713499043019204, 1.2376156019774536, -0.27925050329511203, 1.5872000964955122, 2.106603787124413, 1.526462711163759, 0.0, 0.0, 0.30852482215402843, 1.494564729223536, 2.054665576603028, 1.4331787317565279, 1.2822982768889746, 3.0992240890842826, 0.0, -0.08645738172306322, -0.16222078614455715, 1.3787403742241406, 1.709287846751097, 1.3600077001545285, -0.21702784222394986, 1.8303027336851738, 1.143335983750264, 1.1708005902540914, 1.2369948159429325, -0.27935383381430245, 1.7623686513065309, 0.0, 1.1388542534712223, 1.1662853116856364, 1.2323429545022004, -0.28182971586402455]
0<SPLIT>png_voidp PNGCBAPI png_debug_malloc(png_structp png_ptr, png_alloc_size_t size) { if (size == 0) return (NULL); { memory_infop pinfo; png_set_mem_fn(png_ptr, NULL, NULL, NULL); pinfo = (memory_infop)png_malloc(png_ptr, png_sizeof(*pinfo)); pinfo->size = size; current_allocation += size; total_allocation += size; num_allocations ++; if (current_allocation > maximum_allocation) maximum_allocation = current_allocation; pinfo->pointer = png_malloc(png_ptr, size); png_set_mem_fn(png_ptr, NULL, png_debug_malloc, png_debug_free); if (size != 0 && pinfo->pointer == NULL) { current_allocation -= size; total_allocation -= size; png_error(png_ptr, "out of memory in pngtest->png_debug_malloc"); } pinfo->next = pinformation; pinformation = pinfo; png_memset(pinfo->pointer, 0xdd, pinfo->size); if (verbose) printf("png_malloc %lu bytes at %p\n", (unsigned long)size, pinfo->pointer); return (png_voidp)(pinfo->pointer); } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.9507312480792999, 0.04037983893342262, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.1577849451844651, 0.9718292068145229, 0.06381159668134254, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>png_uint_16 invsRGB(unsigned int i) { unsigned int x = nearbyint(finvsRGB(i)); if (x > 65535) { fprintf(stderr, "invsRGB(%u) overflows to %u\n", i, x); exit(1); } return (png_uint_16)x; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 3.3489446507317613, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.14106852214680915, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.1980344553542678, -0.10760608081136262, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.04739993194876201]
0<SPLIT>int main(int argc, char **argv) { unsigned int i, i16, ibase; double min_error = 0; double max_error = 0; double min_error16 = 0; double max_error16 = 0; double adjust; double adjust_lo = 0.4, adjust_hi = 0.6, adjust_mid = 0.5; unsigned int ec_lo = 0, ec_hi = 0, ec_mid = 0; unsigned int error_count = 0; unsigned int error_count16 = 0; int test_only = 0; if (argc > 1) test_only = strcmp("--test", argv[1]) == 0; for (i=0; i<256; ++i) { png_sRGB_table[i] = invsRGB(i); } for (;;) { if (ec_lo == 0) adjust = adjust_lo; else if (ec_hi == 0) adjust = adjust_hi; else if (ec_mid == 0) adjust = adjust_mid; else if (ec_mid < ec_hi) adjust = (adjust_mid + adjust_hi)/2; else if (ec_mid < ec_lo) adjust = (adjust_mid + adjust_lo)/2; else { fprintf(stderr, "not reached: %u .. %u .. %u\n", ec_lo, ec_mid, ec_hi); exit(1); } for (i=0; i<=511; ++i) { double lo = 255 * sRGB(i << 15); double hi = 255 * sRGB((i+1) << 15); unsigned int calc; calc = nearbyint((lo+adjust) * 256); if (calc > 65535) { fprintf(stderr, "table[%d][0]: overflow %08x (%d)\n", i, calc, calc); exit(1); } png_sRGB_base[i] = calc; calc = nearbyint((hi-lo) * 32); if (calc > 255) { fprintf(stderr, "table[%d][1]: overflow %08x (%d)\n", i, calc, calc); exit(1); } png_sRGB_delta[i] = calc; } error_count16 = 0; for (i16=0; i16 <= 65535; ++i16) { unsigned int i = 255*i16; unsigned int iexact = nearbyint(255*sRGB(i)); unsigned int icalc = PNG_sRGB_FROM_LINEAR(i); if (icalc != iexact) ++error_count16; } if (ec_lo == 0) ec_lo = error_count16; else if (ec_hi == 0) ec_hi = error_count16; else if (ec_mid == 0) { ec_mid = error_count16; printf("\n", ec_lo, ec_mid, ec_hi); } else if (error_count16 < ec_mid) { printf("\n", adjust, ec_mid, error_count16); ec_mid = error_count16; adjust_mid = adjust; } else if (adjust < adjust_mid && error_count16 < ec_lo) { printf("\n", adjust, ec_lo, error_count16); ec_lo = error_count16; adjust_lo = adjust; } else if (adjust > adjust_mid && error_count16 < ec_hi) { printf("\n", adjust, ec_hi, error_count16); ec_hi = error_count16; adjust_hi = adjust; } else { adjust = adjust_mid; printf("\n", adjust, ec_mid); break; } } for (ibase=0; ibase<65536; ibase+=128) { png_uint_16 base = png_sRGB_base[ibase >> 7], trybase = base, ob=base; png_byte delta = png_sRGB_delta[ibase >> 7], trydelta = delta, od=delta; unsigned int ecbase = 0, eco; for (;;) { png_sRGB_base[ibase >> 7] = trybase; png_sRGB_delta[ibase >> 7] = trydelta; error_count16 = 0; for (i16=ibase; i16 < ibase+128; ++i16) { unsigned int i = 255*i16; unsigned int iexact = nearbyint(255*sRGB(i)); unsigned int icalc = PNG_sRGB_FROM_LINEAR(i); if (icalc != iexact) ++error_count16; } if (error_count16 == 0) break; if (ecbase == 0) { eco = ecbase = error_count16; ++trybase; } else if (error_count16 < ecbase) { if (trybase > base) { base = trybase; ++trybase; } else if (trybase < base) { base = trybase; --trybase; } else if (trydelta > delta) { delta = trydelta; ++trydelta; } else if (trydelta < delta) { delta = trydelta; --trydelta; } else { fprintf(stderr, "makesRGB: impossible\n"); exit(1); } ecbase = error_count16; } else { if (trybase > base) trybase = base-1; else if (trybase < base) { trybase = base; ++trydelta; } else if (trydelta > delta) trydelta = delta-1; else if (trydelta < delta) break; } } png_sRGB_base[ibase >> 7] = base; png_sRGB_delta[ibase >> 7] = delta; if (base != ob || delta != od) { printf("\n", ibase>>7, ob, od, base, delta, eco, ecbase); } else if (0) printf("\n", ibase>>7, ob, od, ecbase); } min_error = -.4999; max_error = .4999; error_count = 0; for (i=0; i <= max_input; ++i) { unsigned int iexact = nearbyint(255*sRGB(i)); unsigned int icalc = PNG_sRGB_FROM_LINEAR(i); if (icalc != iexact) { double err = 255*sRGB(i) - icalc; if (err > (max_error+.001) || err < (min_error-.001)) { printf( "\n", i, iexact, icalc, png_sRGB_base[i>>15], png_sRGB_delta[i>>15], err); } ++error_count; if (err > max_error) max_error = err; else if (err < min_error) min_error = err; } } error_count16 = 0; max_error16 = 0; min_error16 = 0; for (i16=0; i16 <= 65535; ++i16) { unsigned int i = 255*i16; unsigned int iexact = nearbyint(255*sRGB(i)); unsigned int icalc = PNG_sRGB_FROM_LINEAR(i); if (icalc != iexact) { double err = 255*sRGB(i) - icalc; ++error_count16; if (err > max_error16) max_error16 = err; else if (err < min_error16) min_error16 = err; if (abs(icalc - iexact) > 1) printf( "\n", i16, iexact, icalc, png_sRGB_base[i>>15], png_sRGB_delta[i>>15], err); } } for (i16=0; i16 <= 255; ++i16) { unsigned int i = 255 * png_sRGB_table[i16]; unsigned int iexact = nearbyint(255*sRGB(i)); unsigned int icalc = PNG_sRGB_FROM_LINEAR(i); if (i16 != iexact) { fprintf(stderr, "8-bit rounding error: %d -> %d\n", i16, iexact); exit(1); } if (icalc != i16) { double finv = finvsRGB(i16); printf("\n", i16, finv, icalc, fsRGB(255*finv)); } } printf("\n", min_error, max_error, error_count, (100.*error_count)/max_input); printf("\n", min_error16, max_error16, error_count16, (100.*error_count16)/65535); if (!test_only) { printf("PNG_CONST png_uint_16 png_sRGB_table[256] =\n{\n "); for (i=0; i<255; ) { do { printf("%d,", png_sRGB_table[i++]); } while ((i & 0x7) != 0 && i<255); if (i<255) printf("\n "); } printf("%d\n};\n\n", png_sRGB_table[i]); printf("PNG_CONST png_uint_16 png_sRGB_base[512] =\n{\n "); for (i=0; i<511; ) { do { printf("%d,", png_sRGB_base[i++]); } while ((i & 0x7) != 0 && i<511); if (i<511) printf("\n "); } printf("%d\n};\n\n", png_sRGB_base[i]); printf("PNG_CONST png_byte png_sRGB_delta[512] =\n{\n "); for (i=0; i<511; ) { do { printf("%d,", png_sRGB_delta[i++]); } while ((i & 0xf) != 0 && i<511); if (i<511) printf("\n "); } printf("%d\n};\n\n", png_sRGB_delta[i]); } return 0; }<SPLIT>[2.2206253336644237, 5.77546429992655, 0.0, 2.167979739596076, 5.509024378508701, 0.0, 8.617069634389573, 8.771312856821735, 9.03218896987762, 9.615519942287683, 5.523040054203332, 2.2639087302979823, 5.993867229958379, 0.0, 0.0, 0.30852482215402843, 5.291794260696839, 2.2093564865728146, 5.7400592372349335, 4.387825838421595, 15.157022784100098, 0.0, -0.08645738172306322, -0.16222078614455715, 4.821691123085603, 9.44756690100715, 4.859702100919346, 10.56888173037149, 11.0938091735994, 8.614531515481907, 8.769188220723446, 9.029650888896764, 9.612997836575463, 2.6191065950439585, 0.0, 8.600629730258554, 8.755237127847298, 9.014692398336251, 9.595059718519574]
0<SPLIT>static void store_read_reset(png_store *ps) { #ifdef PNG_READ_SUPPORTED if (ps->pread != NULL) { anon_context(ps); Try png_destroy_read_struct(&ps->pread, &ps->piread, NULL); Catch_anonymous { ; } ps->pread = NULL; ps->piread = NULL; } #endif #ifdef PNG_USER_MEM_SUPPORTED store_pool_delete(ps, &ps->read_memory_pool); #endif ps->current = NULL; ps->next = NULL; ps->readpos = 0; ps->validated = 0; }<SPLIT>[0.05563366039355449, -0.13034272285790952, 0.0, 0.037794879441717756, -0.1936866588694103, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.1110049613987252, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.17156659581066827, -0.26569807294376846, -0.5325257040772059, -0.7880534307994381, -0.518115519420462, 0.0, 1.457000985644429, 2.1569430876889752, -0.377867150705177, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void test_one_file(struct display *dp, const char *filename) { dp->operation = "cache file"; dp->transforms = 0; display_cache_file(dp, filename); update_display(dp); if (dp->ignored_transforms != 0) { read_png(dp, &dp->original_file, "ignored transforms", dp->ignored_transforms); if (!compare_read(dp, 0)) return; } #ifdef PNG_WRITE_SUPPORTED dp->operation = "write"; write_png(dp, dp->original_ip, 0); read_png(dp, &dp->written_file, NULL, 0); if (!compare_read(dp, 0)) return; #endif { unsigned int active = dp->active_transforms; const int exhaustive = (dp->options & EXHAUSTIVE) != 0; unsigned int current = first_transform(active); unsigned int bad_transforms = 0; unsigned int bad_combo = ~0U; unsigned int bad_combo_list = 0; for (;;) { read_png(dp, &dp->original_file, "active transforms", current); #ifdef PNG_WRITE_SUPPORTED if ((current & write_transforms) == current) { dp->operation = "reversible transforms"; write_png(dp, dp->read_ip, current); read_png(dp, &dp->written_file, NULL, 0); if (!compare_read(dp, current)) { if (is_combo(current)) { bad_combo &= current; bad_combo_list |= current; } else bad_transforms |= current; } } #endif if (exhaustive) { unsigned int next = current; do { if (next == read_transforms) goto combo; ++next; } while ((next & read_transforms) <= current || (next & active) == 0 || (next & bad_transforms) != 0 || skip_transform(dp, next)); assert((next & read_transforms) == next); current = next; } else { active &= ~current; if (active == 0) goto combo; current = first_transform(active); } } combo: if (dp->options & FIND_BAD_COMBOS) { if (bad_combo != ~0U) printf("%s[0x%x]: PROBLEM: 0x%x[0x%x] ANTIDOTE: 0x%x\n", dp->filename, active, bad_combo, bad_combo_list, rw_transforms & ~bad_combo_list); else printf("%s: no %sbad combos found\n", dp->filename, (dp->options & SKIP_BUGS) ? "additional " : ""); } } }<SPLIT>[7.169177729712126, 1.2359260659952118, 0.0, 7.036973705663181, 1.1255972378374661, 0.0, 0.9701672076669112, 0.9946065798247155, 1.403457588528521, 2.0295292673408736, 2.046714406278659, 4.623482877901521, 0.728711904236148, 0.0, 0.0, 0.30852482215402843, 1.9207843705113556, 4.529720136119611, 0.63806233074513, 1.0235043134279231, 2.4415259784470567, 0.0, 4.102929615417272, 2.1569430876889752, 0.5707009127566546, 1.327823386330024, 1.1342209646213146, 2.47944955092491, 1.081736556722408, 0.969587250454179, 0.9940939011734088, 1.4027960089845035, 2.0288615559433096, 2.6191065950439585, 0.0, 0.9653245912203542, 0.9897980601469931, 1.3979248575624994, 2.0227778188254817]
0<SPLIT>int main(void) { unsigned int i; unsigned char buf[MAX_LENGTH]; unsigned long crc; unsigned char c; int inchar; for (i=8; i; i--) { c=GETBREAK; putchar(c); } if (inchar != EOF) for (;;) { unsigned long length; c=GETBREAK; buf[0] = c; length = c; length <<= 8; c=GETBREAK; buf[1] = c; length += c; length <<= 8; c=GETBREAK; buf[2] = c; length += c; length <<= 8; c=GETBREAK; buf[3] = c; length += c; c=GETBREAK; buf[4] = c; c=GETBREAK; buf[5] = c; c=GETBREAK; buf[6] = c; c=GETBREAK; buf[7] = c; if (buf[4] == 105 && buf[5] == 84 && buf[6] == 88 && buf[7] == 116) { if (length >= MAX_LENGTH-12) break; crc = crc32(0, Z_NULL, 0); for (i=8; i < length + 12; i++) { c=GETBREAK; buf[i] = c; } crc = crc32(crc, buf+4, (uInt)length+4); for (;;) { if (((crc >> 24) & 0xff) == buf[length+8] && ((crc >> 16) & 0xff) == buf[length+9] && ((crc >> 8) & 0xff) == buf[length+10] && ((crc ) & 0xff) == buf[length+11]) break; length++; if (length >= MAX_LENGTH-12) break; c=GETBREAK; buf[length+11]=c; crc = crc32(crc, buf+7+length, 1); } buf[0] = (unsigned char)((length << 24) & 0xff); buf[1] = (unsigned char)((length << 16) & 0xff); buf[2] = (unsigned char)((length << 8) & 0xff); buf[3] = (unsigned char)((length ) & 0xff); for (i=0; i<length+12; i++) putchar(buf[i]); } else { for (i=0; i<8; i++) putchar(buf[i]); for (i=8; i< length+12; i++) { c=GETBREAK; putchar(c); } if (inchar == EOF) { break; } if (buf[4] == 73 && buf[5] == 69 && buf[6] == 78 && buf[7] == 68) break; } if (inchar == EOF) break; if (buf[4] == 73 && buf[5] == 69 && buf[6] == 78 && buf[7] == 68) break; } return 0; }<SPLIT>[1.9113408089114425, 1.0816699124150206, 0.0, 1.863667616716882, 0.9766458301447543, 0.0, 2.012926629492729, 2.0550665266879453, 1.9009835481817232, 3.34883199341858, 1.2275802018826147, 1.9492988439508436, 1.1389837477989193, 0.0, 0.0, 0.30852482215402843, 1.126465948111328, 1.8999746666332415, 1.0356205312508289, 0.24712242304476825, 1.8934442195827013, 0.0, -0.08645738172306322, -0.16222078614455715, 1.7300618792100042, 2.0362573842548737, 0.11818065472185141, 5.17592694407377, 2.859581227008977, 2.0120796502306875, 2.054334035657505, 1.9001995881092162, 3.347841778661945, 3.475844538781386, 0.0, 2.006502564725563, 2.048721569378853, 1.8946705667433963, 3.339696410076628]
0<SPLIT>static void standard_row_validate(standard_display *dp, png_const_structp pp, int iImage, int iDisplay, png_uint_32 y) { int where; png_byte std[STANDARD_ROWMAX]; memset(std, 178, sizeof std); standard_row(pp, std, dp->id, y); if (iImage >= 0 && (where = pixel_cmp(std, store_image_row(dp->ps, pp, iImage, y), dp->bit_width)) != 0) { char msg[64]; sprintf(msg, "PNG image row[%lu][%d] changed from %.2x to %.2x", (unsigned long)y, where-1, std[where-1], store_image_row(dp->ps, pp, iImage, y)[where-1]); png_error(pp, msg); } #if PNG_LIBPNG_VER < 10506 #endif if (iDisplay >= 0 && (where = pixel_cmp(std, store_image_row(dp->ps, pp, iDisplay, y), dp->bit_width)) != 0) { char msg[64]; sprintf(msg, "display row[%lu][%d] changed from %.2x to %.2x", (unsigned long)y, where-1, std[where-1], store_image_row(dp->ps, pp, iDisplay, y)[where-1]); png_error(pp, msg); } }<SPLIT>[2.9938366455468772, 0.023913430722281605, 0.0, 2.9287600467940615, -0.044735251176698444, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.40844599748657096, 3.0504334461658287, -0.0006602620976677653, 0.0, 0.0, 0.30852482215402843, 0.3321475257113004, 2.9828110364217464, -0.06870780348722379, 0.37651940477529405, -0.1892664641018488, 0.0, -0.08645738172306322, 0.9973611507722091, -0.3427350002065907, -0.08904460951967552, 0.23107402248845843, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static png_structp set_store_for_read(png_store *ps, png_infopp ppi, png_uint_32 id, PNG_CONST char *name) { safecat(ps->test, sizeof ps->test, 0, name); if (ps->pread != NULL) png_error(ps->pread, "read store already in use"); store_read_reset(ps); #ifdef PNG_USER_MEM_SUPPORTED if (!ps->speed) ps->pread = png_create_read_struct_2(PNG_LIBPNG_VER_STRING, ps, store_error, store_warning, &ps->read_memory_pool, store_malloc, store_free); else #endif ps->pread = png_create_read_struct(PNG_LIBPNG_VER_STRING, ps, store_error, store_warning); if (ps->pread == NULL) { struct exception_context *the_exception_context = &ps->exception_context; store_log(ps, NULL, "png_create_read_struct returned NULL (unexpected)", 1); Throw ps; } #ifdef PNG_SET_OPTION_SUPPORTED { int opt; for (opt=0; opt<ps->noptions; ++opt) if (png_set_option(ps->pread, ps->options[opt].option, ps->options[opt].setting) == PNG_OPTION_INVALID) png_error(ps->pread, "png option invalid"); } #endif store_read_set(ps, id); if (ppi != NULL) *ppi = ps->piread = png_create_info_struct(ps->pread); return ps->pread; }<SPLIT>[0.8288449722760078, 0.1781695843024727, 0.0, 0.798575186639703, 0.10421615651601342, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.268593816248222, 0.8481642417358589, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, 0.19653218530153962, 0.8171382968447365, -0.22331377035055117, 0.24712242304476825, -0.4084991676475909, 0.0, 1.2365069331633587, 2.1569430876889752, -0.1670742477136589, -0.14353953243697165, 0.23107402248845843, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_background_mod(PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp, PNG_CONST transform_display *display) { if (that->have_tRNS && that->colour_type != PNG_COLOR_TYPE_PALETTE) image_pixel_add_alpha(that, &display->this); if (that->alphaf < 1) { if (that->alphaf <= 0) { that->redf = data.redf; that->greenf = data.greenf; that->bluef = data.bluef; that->rede = data.rede; that->greene = data.greene; that->bluee = data.bluee; that->red_sBIT= data.red_sBIT; that->green_sBIT= data.green_sBIT; that->blue_sBIT= data.blue_sBIT; } else { double alf = 1 - that->alphaf; that->redf = that->redf * that->alphaf + data.redf * alf; that->rede = that->rede * that->alphaf + data.rede * alf + DBL_EPSILON; that->greenf = that->greenf * that->alphaf + data.greenf * alf; that->greene = that->greene * that->alphaf + data.greene * alf + DBL_EPSILON; that->bluef = that->bluef * that->alphaf + data.bluef * alf; that->bluee = that->bluee * that->alphaf + data.bluee * alf + DBL_EPSILON; } that->alphaf = 1; that->alphae = 0; if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA) that->colour_type = PNG_COLOR_TYPE_RGB; else if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA) that->colour_type = PNG_COLOR_TYPE_GRAY; } this->next->mod(this->next, that, pp, display); }<SPLIT>[0.5195604475230265, 0.2883525511454664, 0.0, 0.4942630637605089, 0.21061001915366473, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.3285304653503715, 0.5335543553887203, 0.3184400606733766, 0.0, 0.0, 0.30852482215402843, 0.2546530454771514, 0.5077564769051636, 0.24050413023943099, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.07885080577644558, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void store_freenew(png_store *ps) { store_freebuffer(&ps->new); ps->writepos = 0; if (ps->palette != NULL) { free(ps->palette); ps->palette = NULL; ps->npalette = 0; } }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void PNGCBAPI png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length) { png_size_t check; if (png_ptr == NULL) return; check = fread(data, 1, length, png_voidcast(png_FILE_p, png_ptr->io_ptr)); if (check != length) png_error(png_ptr, "Read Error"); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.18995094088131478, -0.491589474254834, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4234236565716526, 0.19837465696559078, -0.48835257068768384, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void gpc_bckg(Pixel *out, const Pixel *in, const Background *back) { if (in->a <= 0) out->r = out->g = out->b = back->ig; else if (in->a >= 255) out->r = out->g = out->b = in->g; else { double a = in->a / 255.; out->r = out->g = out->b = sRGB(sRGB_to_d[in->g] * a + back->dg * (1-a)); } out->a = 255; }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.3615192241061562, -0.5591795518777907, 1.5806237532086234, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int test_size(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type, int bdlo, int PNG_CONST bdhi) { static PNG_CONST png_byte hinc[] = {1, 3, 11, 1, 5}; static PNG_CONST png_byte winc[] = {1, 9, 5, 7, 1}; for (; bdlo <= bdhi; ++bdlo) { png_uint_32 h, w; for (h=1; h<=16; h+=hinc[bdlo]) for (w=1; w<=16; w+=winc[bdlo]) { standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0, PNG_INTERLACE_NONE, w, h, 0), 0, pm->use_update_info); if (fail(pm)) return 0; standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0, PNG_INTERLACE_NONE, w, h, 1), 0, pm->use_update_info); if (fail(pm)) return 0; #ifdef PNG_WRITE_INTERLACING_SUPPORTED standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0, PNG_INTERLACE_ADAM7, w, h, 0), 0, pm->use_update_info); if (fail(pm)) return 0; standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0, PNG_INTERLACE_ADAM7, w, h, 1), 0, pm->use_update_info); if (fail(pm)) return 0; #endif standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0, PNG_INTERLACE_NONE, w, h, 0), 1, pm->use_update_info); if (fail(pm)) return 0; #ifdef PNG_WRITE_INTERLACING_SUPPORTED standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0, PNG_INTERLACE_ADAM7, w, h, 0), 1, pm->use_update_info); if (fail(pm)) return 0; #endif } } return 1; }<SPLIT>[2.2206253336644237, 0.42057211135705874, 0.0, 2.167979739596076, 0.33828265431884635, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.668171476929219, 2.2639087302979823, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, 0.5840045864722848, 2.2093564865728146, -0.04662123679246273, -0.14106852214680915, -0.4084991676475909, 0.0, 1.5672480118849643, 2.1569430876889752, 0.07885080577644558, -0.3070243011888601, -0.10760608081136262, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static png_uint_32 standard_width(png_const_structp pp, png_uint_32 id) { png_uint_32 width = WIDTH_FROM_ID(id); UNUSED(pp) if (width == 0) width = transform_width(pp, COL_FROM_ID(id), DEPTH_FROM_ID(id)); return width; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI transform_info(png_structp pp, png_infop pi) { transform_info_imp(voidcast(transform_display*, png_get_progressive_ptr(pp)), pp, pi); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void image_transform_set_end(PNG_CONST image_transform *this, transform_display *that, png_structp pp, png_infop pi) { UNUSED(this) UNUSED(that) UNUSED(pp) UNUSED(pi) }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6940565051924542, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int rpng2_x_load_bg_image(void) { uch *src; char *dest; uch r1, r2, g1, g2, b1, b2; uch r1_inv, r2_inv, g1_inv, g2_inv, b1_inv, b2_inv; int k, hmax, max; int xidx, yidx, yidx_max; int even_odd_vert, even_odd_horiz, even_odd; int invert_gradient2 = (bg[pat].type & 0x08); int invert_column; int ximage_rowbytes = ximage->bytes_per_line; ulg i, row; ulg pixel; bg_rowbytes = 3 * rpng2_info.width; bg_data = (uch *)malloc(bg_rowbytes * rpng2_info.height); if (!bg_data) { fprintf(stderr, PROGNAME ": unable to allocate memory for background image\n"); bg_image = 0; return 1; } bgscale = (pat == 0)? 8 : bgscale_default; yidx_max = bgscale - 1; if ((bg[pat].type & 0x07) == 0) { uch r1_min = rgb[bg[pat].rgb1_min].r; uch g1_min = rgb[bg[pat].rgb1_min].g; uch b1_min = rgb[bg[pat].rgb1_min].b; uch r2_min = rgb[bg[pat].rgb2_min].r; uch g2_min = rgb[bg[pat].rgb2_min].g; uch b2_min = rgb[bg[pat].rgb2_min].b; int r1_diff = rgb[bg[pat].rgb1_max].r - r1_min; int g1_diff = rgb[bg[pat].rgb1_max].g - g1_min; int b1_diff = rgb[bg[pat].rgb1_max].b - b1_min; int r2_diff = rgb[bg[pat].rgb2_max].r - r2_min; int g2_diff = rgb[bg[pat].rgb2_max].g - g2_min; int b2_diff = rgb[bg[pat].rgb2_max].b - b2_min; for (row = 0; row < rpng2_info.height; ++row) { yidx = (int)(row % bgscale); even_odd_vert = (int)((row / bgscale) & 1); r1 = r1_min + (r1_diff * yidx) / yidx_max; g1 = g1_min + (g1_diff * yidx) / yidx_max; b1 = b1_min + (b1_diff * yidx) / yidx_max; r1_inv = r1_min + (r1_diff * (yidx_max-yidx)) / yidx_max; g1_inv = g1_min + (g1_diff * (yidx_max-yidx)) / yidx_max; b1_inv = b1_min + (b1_diff * (yidx_max-yidx)) / yidx_max; r2 = r2_min + (r2_diff * yidx) / yidx_max; g2 = g2_min + (g2_diff * yidx) / yidx_max; b2 = b2_min + (b2_diff * yidx) / yidx_max; r2_inv = r2_min + (r2_diff * (yidx_max-yidx)) / yidx_max; g2_inv = g2_min + (g2_diff * (yidx_max-yidx)) / yidx_max; b2_inv = b2_min + (b2_diff * (yidx_max-yidx)) / yidx_max; dest = (char *)bg_data + row*bg_rowbytes; for (i = 0; i < rpng2_info.width; ++i) { even_odd_horiz = (int)((i / bgscale) & 1); even_odd = even_odd_vert ^ even_odd_horiz; invert_column = (even_odd_horiz && (bg[pat].type & 0x10)); if (even_odd == 0) { if (invert_column) { *dest++ = r1_inv; *dest++ = g1_inv; *dest++ = b1_inv; } else { *dest++ = r1; *dest++ = g1; *dest++ = b1; } } else { if ((invert_column && invert_gradient2) || (!invert_column && !invert_gradient2)) { *dest++ = r2; *dest++ = g2; *dest++ = b2; } else { *dest++ = r2_inv; *dest++ = g2_inv; *dest++ = b2_inv; } } } } } else if ((bg[pat].type & 0x07) == 1) { hmax = (bgscale-1)/2; max = 2*hmax; r1 = rgb[bg[pat].rgb1_max].r; g1 = rgb[bg[pat].rgb1_max].g; b1 = rgb[bg[pat].rgb1_max].b; r2 = rgb[bg[pat].rgb2_max].r; g2 = rgb[bg[pat].rgb2_max].g; b2 = rgb[bg[pat].rgb2_max].b; for (row = 0; row < rpng2_info.height; ++row) { yidx = (int)(row % bgscale); if (yidx > hmax) yidx = bgscale-1 - yidx; dest = (char *)bg_data + row*bg_rowbytes; for (i = 0; i < rpng2_info.width; ++i) { xidx = (int)(i % bgscale); if (xidx > hmax) xidx = bgscale-1 - xidx; k = xidx + yidx; *dest++ = (k*r1 + (max-k)*r2) / max; *dest++ = (k*g1 + (max-k)*g2) / max; *dest++ = (k*b1 + (max-k)*b2) / max; } } } else if ((bg[pat].type & 0x07) == 2) { uch ch; int ii, x, y, hw, hh, grayspot; double freq, rotate, saturate, gray, intensity; double angle=0.0, aoffset=0.0, maxDist, dist; double red=0.0, green=0.0, blue=0.0, hue, s, v, f, p, q, t; fprintf(stderr, "%s: computing radial background...", PROGNAME); fflush(stderr); hh = (int)(rpng2_info.height / 2); hw = (int)(rpng2_info.width / 2); angle = CLIP(angle, 0.0, 360.0); grayspot = CLIP(bg[pat].bg_gray, 1, (hh + hw)); freq = MAX((double)bg[pat].bg_freq, 0.0); saturate = (double)bg[pat].bg_bsat * 0.1; rotate = (double)bg[pat].bg_brot * 0.1; gray = 0.0; intensity = 0.0; maxDist = (double)((hw*hw) + (hh*hh)); for (row = 0; row < rpng2_info.height; ++row) { y = (int)(row - hh); dest = (char *)bg_data + row*bg_rowbytes; for (i = 0; i < rpng2_info.width; ++i) { x = (int)(i - hw); angle = (x == 0)? PI_2 : atan((double)y / (double)x); gray = (double)MAX(ABS(y), ABS(x)) / grayspot; gray = MIN(1.0, gray); dist = (double)((x*x) + (y*y)) / maxDist; intensity = cos((angle+(rotate*dist*PI)) * freq) * gray * saturate; intensity = (MAX(MIN(intensity,1.0),-1.0) + 1.0) * 0.5; hue = (angle + PI) * INV_PI_360 + aoffset; s = gray * ((double)(ABS(x)+ABS(y)) / (double)(hw + hh)); s = MIN(MAX(s,0.0), 1.0); v = MIN(MAX(intensity,0.0), 1.0); if (s == 0.0) { ch = (uch)(v * 255.0); *dest++ = ch; *dest++ = ch; *dest++ = ch; } else { if ((hue < 0.0) || (hue >= 360.0)) hue -= (((int)(hue / 360.0)) * 360.0); hue /= 60.0; ii = (int)hue; f = hue - (double)ii; p = (1.0 - s) * v; q = (1.0 - (s * f)) * v; t = (1.0 - (s * (1.0 - f))) * v; if (ii == 0) { red = v; green = t; blue = p; } else if (ii == 1) { red = q; green = v; blue = p; } else if (ii == 2) { red = p; green = v; blue = t; } else if (ii == 3) { red = p; green = q; blue = v; } else if (ii == 4) { red = t; green = p; blue = v; } else if (ii == 5) { red = v; green = p; blue = q; } *dest++ = (uch)(red * 255.0); *dest++ = (uch)(green * 255.0); *dest++ = (uch)(blue * 255.0); } } } fprintf(stderr, "done.\n"); fflush(stderr); } if (depth == 24 || depth == 32) { ulg red, green, blue; int bpp = ximage->bits_per_pixel; for (row = 0; row < rpng2_info.height; ++row) { src = bg_data + row*bg_rowbytes; dest = ximage->data + row*ximage_rowbytes; if (bpp == 32) { for (i = rpng2_info.width; i > 0; --i) { red = *src++; green = *src++; blue = *src++; pixel = (red << RShift) | (green << GShift) | (blue << BShift); *dest++ = (char)((pixel >> 24) & 0xff); *dest++ = (char)((pixel >> 16) & 0xff); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } } else { for (i = rpng2_info.width; i > 0; --i) { red = *src++; green = *src++; blue = *src++; pixel = (red << RShift) | (green << GShift) | (blue << BShift); *dest++ = (char)((pixel >> 16) & 0xff); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } } } } else if (depth == 16) { ush red, green, blue; for (row = 0; row < rpng2_info.height; ++row) { src = bg_data + row*bg_rowbytes; dest = ximage->data + row*ximage_rowbytes; for (i = rpng2_info.width; i > 0; --i) { red = ((ush)(*src) << 8); ++src; green = ((ush)(*src) << 8); ++src; blue = ((ush)(*src) << 8); ++src; pixel = ((red >> RShift) & RMask) | ((green >> GShift) & GMask) | ((blue >> BShift) & BMask); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } } } else { } XPutImage(display, window, gc, ximage, 0, 0, 0, 0, rpng2_info.width, rpng2_info.height); return 0; }<SPLIT>[4.849543794064766, 4.321049137599034, 0.0, 4.7546327840692255, 4.125904164219234, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, -0.27925050329511203, 4.54407478553489, 4.938092764248659, 4.489537136894885, 0.0, 0.0, 0.30852482215402843, 4.36186049788705, 4.839101956059183, 4.304432402075465, 2.7056650759247582, 1.0165134053997327, 0.0, -0.08645738172306322, -0.16222078614455715, 6.226977143029058, 2.962671073848908, 5.3112755719857745, -0.21702784222394986, 0.7074534682410251, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, -0.27935383381430245, 0.04889276383167627, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, -0.28182971586402455]
0<SPLIT>static void insert_hIST(png_structp png_ptr, png_infop info_ptr, int nparams, png_charpp params) { int i; png_uint_16 freq[256]; memset(freq, 0, sizeof freq); for (i=0; i<nparams; ++i) { char *endptr = NULL; unsigned long int l = strtoul(params[i], &endptr, 0); if (params[i][0] && *endptr == 0 && l <= 65535) freq[i] = (png_uint_16)l; else { fprintf(stderr, "hIST[%d]: %s: invalid frequency\n", i, params[i]); exit(1); } } png_set_hIST(png_ptr, info_ptr, freq); }<SPLIT>[0.21027592277004517, -0.21848909633230443, 0.0, 0.18995094088131478, -0.27880174897953136, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.17094161050087475, 0.21894446904158188, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, 0.19837465696559078, -0.2674869037400733, 0.11772544131424245, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, 0.0744401592322129, 0.11818065472185141, 0.6817979554923368, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) { static HINSTANCE hInstance ; static HDC hdc; static PAINTSTRUCT ps; static HMENU hMenu; static BITMAPFILEHEADER *pbmfh; static BITMAPINFOHEADER *pbmih; static BYTE *pbImage; static int cxWinSize, cyWinSize; static int cxImgSize, cyImgSize; static int cImgChannels; static png_color bkgColor = {127, 127, 127}; static BOOL bStretched = TRUE; static BYTE *pDib = NULL; static BYTE *pDiData = NULL; static TCHAR szImgPathName [MAX_PATH]; static TCHAR szTitleName [MAX_PATH]; static TCHAR *pPngFileList = NULL; static int iPngFileCount; static int iPngFileIndex; BOOL bOk; switch (message) { case WM_CREATE: hInstance = ((LPCREATESTRUCT) lParam)->hInstance ; PngFileInitialize (hwnd); strcpy (szImgPathName, ""); if (szCmdFileName[0] != '\0') { strcpy (szImgPathName, szCmdFileName); BuildPngList (szImgPathName, &pPngFileList, &iPngFileCount, &iPngFileIndex); if (!LoadImageFile (hwnd, szImgPathName, &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor)) return 0; InvalidateRect (hwnd, NULL, TRUE); DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize, pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched); } return 0; case WM_SIZE: cxWinSize = LOWORD (lParam); cyWinSize = HIWORD (lParam); InvalidateRect (hwnd, NULL, TRUE); DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize, pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched); return 0; case WM_INITMENUPOPUP: hMenu = GetMenu (hwnd); if (pbImage) EnableMenuItem (hMenu, IDM_FILE_SAVE, MF_ENABLED); else EnableMenuItem (hMenu, IDM_FILE_SAVE, MF_GRAYED); return 0; case WM_COMMAND: hMenu = GetMenu (hwnd); switch (LOWORD (wParam)) { case IDM_FILE_OPEN: if (!PngFileOpenDlg (hwnd, szImgPathName, szTitleName)) return 0; BuildPngList (szImgPathName, &pPngFileList, &iPngFileCount, &iPngFileIndex); if (!LoadImageFile (hwnd, szImgPathName, &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor)) return 0; InvalidateRect (hwnd, NULL, TRUE); DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize, pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched); return 0; case IDM_FILE_SAVE: if (!PngFileSaveDlg (hwnd, szImgPathName, szTitleName)) return 0; SetCursor (LoadCursor (NULL, IDC_WAIT)); ShowCursor (TRUE); bOk = PngSaveImage (szImgPathName, pDiData, cxWinSize, cyWinSize, bkgColor); ShowCursor (FALSE); SetCursor (LoadCursor (NULL, IDC_ARROW)); if (!bOk) MessageBox (hwnd, TEXT ("Error in saving the PNG image"), szProgName, MB_ICONEXCLAMATION | MB_OK); return 0; case IDM_FILE_NEXT: if (SearchPngList (pPngFileList, iPngFileCount, &iPngFileIndex, NULL, szImgPathName)) { if (strcmp (szImgPathName, "") == 0) return 0; if (!LoadImageFile (hwnd, szImgPathName, &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor)) return 0; InvalidateRect (hwnd, NULL, TRUE); DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize, pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched); } return 0; case IDM_FILE_PREVIOUS: if (SearchPngList (pPngFileList, iPngFileCount, &iPngFileIndex, szImgPathName, NULL)) { if (strcmp (szImgPathName, "") == 0) return 0; if (!LoadImageFile (hwnd, szImgPathName, &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor)) return 0; InvalidateRect (hwnd, NULL, TRUE); DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize, pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched); } return 0; case IDM_FILE_EXIT: if (pDib != NULL) { free (pDib); pDib = NULL; } if (pPngFileList != NULL) { free (pPngFileList); pPngFileList = NULL; } exit (0); return 0; case IDM_OPTIONS_STRETCH: bStretched = !bStretched; if (bStretched) CheckMenuItem (hMenu, IDM_OPTIONS_STRETCH, MF_CHECKED); else CheckMenuItem (hMenu, IDM_OPTIONS_STRETCH, MF_UNCHECKED); InvalidateRect (hwnd, NULL, TRUE); DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize, pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched); return 0; case IDM_HELP_ABOUT: DialogBox (hInstance, TEXT ("AboutBox"), hwnd, AboutDlgProc) ; return 0; } break; case WM_PAINT: hdc = BeginPaint (hwnd, &ps); if (pDib) SetDIBitsToDevice (hdc, 0, 0, cxWinSize, cyWinSize, 0, 0, 0, cyWinSize, pDiData, (BITMAPINFO *) pDib, DIB_RGB_COLORS); EndPaint (hwnd, &ps); return 0; case WM_DESTROY: if (pbmfh) { free (pbmfh); pbmfh = NULL; } PostQuitMessage (0); return 0; } return DefWindowProc (hwnd, message, wParam, lParam); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 4.298164599750434, 2.700226404874706, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 3.005707093789442, 4.375029226149825, 2.8246324335264745, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 2.3624405881845587, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static png_uint_16 png_exp16bit(png_uint_32 log) { return (png_uint_16)floor(.5 + exp(log * -LN2) * 65535); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int read_palette(store_palette palette, int *npalette, png_const_structp pp, png_infop pi) { png_colorp pal; png_bytep trans_alpha; int num; pal = 0; *npalette = -1; if (png_get_PLTE(pp, pi, &pal, npalette) & PNG_INFO_PLTE) { int i = *npalette; if (i <= 0 || i > 256) png_error(pp, "validate: invalid PLTE count"); while (--i >= 0) { palette[i].red = pal[i].red; palette[i].green = pal[i].green; palette[i].blue = pal[i].blue; } memset(palette + *npalette, 126, (256-*npalette) * sizeof *palette); } else { if (*npalette != (-1)) png_error(pp, "validate: invalid PLTE result"); *npalette = 0; memset(palette, 113, sizeof (store_palette)); } trans_alpha = 0; num = 2; if ((png_get_tRNS(pp, pi, &trans_alpha, &num, 0) & PNG_INFO_tRNS) != 0 && (trans_alpha != NULL || num != 1) && !(trans_alpha != NULL && num == 0)) { int i; if (trans_alpha == NULL || num <= 0 || num > 256 || num > *npalette) png_error(pp, "validate: unexpected png_get_tRNS (palette) result"); for (i=0; i<num; ++i) palette[i].alpha = trans_alpha[i]; for (num=*npalette; i<num; ++i) palette[i].alpha = 255; for (; i<256; ++i) palette[i].alpha = 33; return 1; } else { int i; for (i=0, num=*npalette; i<num; ++i) palette[i].alpha = 255; for (; i<256; ++i) palette[i].alpha = 55; return 0; } }<SPLIT>[2.2206253336644237, 0.5748282649372498, 0.0, 2.167979739596076, 0.48723406201155817, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.8080236581675679, 2.2639087302979823, 0.6147475032464892, 0.0, 0.0, 0.30852482215402843, 0.7196199268820456, 2.2093564865728146, 0.5276294972713247, 0.37651940477529405, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5707009127566546, 0.18343000506680518, 0.11818065472185141, -0.21702784222394986, 0.23959960763929639, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static unsigned int component(png_const_bytep row, png_uint_32 x, unsigned int c, unsigned int bit_depth, unsigned int channels) { png_uint_32 bit_offset_hi = bit_depth * ((x >> 6) * channels); png_uint_32 bit_offset_lo = bit_depth * ((x & 0x3f) * channels + c); row = (png_const_bytep)(((PNG_CONST png_byte (*)[8])row) + bit_offset_hi); row += bit_offset_lo >> 3; bit_offset_lo &= 0x07; switch (bit_depth) { case 1: return (row[0] >> (7-bit_offset_lo)) & 0x01; case 2: return (row[0] >> (6-bit_offset_lo)) & 0x03; case 4: return (row[0] >> (4-bit_offset_lo)) & 0x0f; case 8: return row[0]; case 16: return (row[0] << 8) + row[1]; default: fprintf(stderr, "pngpixel: invalid bit depth %u\n", bit_depth); exit(1); } }<SPLIT>[1.6020562841584611, -0.1964525029637057, 0.0, 1.559355493837688, -0.2575229764520011, 0.0, 0.44878749675400254, -0.2425966915157195, 0.4084056692221168, 1.3698779043020206, 0.02884721983962376, 1.6346889576037051, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.03595125540090747, 1.5905928466936687, -0.24540033704531222, -0.39986248560786075, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, 0.18343000506680518, -0.5591795518777907, 5.17592694407377, 0.23959960763929639, 0.4483410505659248, -0.24285292239137013, 0.40798885073507796, 1.3693714445839917, 0.04889276383167627, 0.0, 0.4447356044677496, -0.24561270062351, 0.4044334392007059, 1.3643185231999084]
0<SPLIT>static void perform_standard_test(png_modifier *pm) { if (!test_standard(pm, 0, 0, READ_BDHI)) return; if (!test_standard(pm, 2, 3, READ_BDHI)) return; if (!test_standard(pm, 3, 0, 3)) return; if (!test_standard(pm, 4, 3, READ_BDHI)) return; if (!test_standard(pm, 6, 3, READ_BDHI)) return; }<SPLIT>[0.21027592277004517, -0.3507086565438968, 0.0, 0.18995094088131478, -0.406474384144713, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, 1.3698779043020206, -0.29081490870517385, 0.21894446904158188, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, 0.19837465696559078, -0.4000063039086396, -0.6586564490689124, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.08904460951967552, -0.6720729196443977, -0.21702784222394986, 0.42674115187998785, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, 1.3693714445839917, 0.04889276383167627, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 1.3643185231999084]
0<SPLIT>static size_t store_read_buffer_size(png_store *ps) { if (ps->next != &ps->current->data) return STORE_BUFFER_SIZE; return ps->current->datacount; }<SPLIT>[-0.09900860198293619, -0.5049648101240879, 0.0, -0.11436118199787926, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.09566541730555662, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.11100716297398205, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int readpng2_init(mainprog_info *mainprog_ptr) { png_structp png_ptr; png_infop info_ptr; png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr, readpng2_error_handler, NULL); if (!png_ptr) return 4; info_ptr = png_create_info_struct(png_ptr); if (!info_ptr) { png_destroy_read_struct(&png_ptr, NULL, NULL); return 4; } if (setjmp(mainprog_ptr->jmpbuf)) { png_destroy_read_struct(&png_ptr, &info_ptr, NULL); return 2; } #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED { static PNG_CONST png_byte chunks_to_process[] = {98, 75, 71, 68, '\0', 103, 65, 77, 65, '\0', 115, 82, 71, 66, '\0', }; png_set_keep_unknown_chunks(png_ptr, -1 , NULL, -1); png_set_keep_unknown_chunks(png_ptr, 0 , chunks_to_process, sizeof(chunks_to_process)/5); } #endif png_set_progressive_read_fn(png_ptr, mainprog_ptr, readpng2_info_callback, readpng2_row_callback, readpng2_end_callback); mainprog_ptr->png_ptr = png_ptr; mainprog_ptr->info_ptr = info_ptr; return 0; }<SPLIT>[2.8391943831703865, 0.15613299093387398, 0.0, 2.7766039853544644, 0.08293738398848315, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, 0.5083404126568202, 1.6346889576037051, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, 0.4290156260039867, 1.5905928466936687, -0.2012272036557901, -0.14106852214680915, 0.029966239443893296, 0.0, 2.11848314308764, 0.9973611507722091, -0.13194209721507255, -0.03454968660237938, -0.22049944857796966, -0.21702784222394986, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static void PNGCBAPI modifier_read(png_structp ppIn, png_bytep pb, png_size_t st) { png_const_structp pp = ppIn; png_modifier *pm = voidcast(png_modifier*, png_get_io_ptr(pp)); if (pm == NULL || pm->this.pread != pp) png_error(pp, "bad modifier_read call"); modifier_read_imp(pm, pb, st); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void deinterlace_row(png_bytep buffer, png_const_bytep row, unsigned int pixel_size, png_uint_32 w, int pass) { png_uint_32 xin, xout, xstep; xout = PNG_PASS_START_COL(pass); xstep = 1U<<PNG_PASS_COL_SHIFT(pass); for (xin=0; xout<w; xout+=xstep) { pixel_copy(buffer, xout, row, xin, pixel_size); ++xin; } }<SPLIT>[0.5195604475230265, -0.3727452499124955, 0.0, 0.4942630637605089, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.270836025671124, 0.5335543553887203, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, 0.5077564769051636, -0.42209287060340067, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>PNG_FUNCTION(void,PNGAPI png_err,(png_structp png_ptr),PNG_NORETURN) { if (png_ptr != NULL && png_ptr->error_fn != NULL) (*(png_ptr->error_fn))(png_ptr, '\0'); png_default_error(png_ptr, '\0'); }<SPLIT>[0.21027592277004517, -0.5049648101240879, 0.0, 0.18995094088131478, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, 0.21894446904158188, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, 0.19837465696559078, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void insert_iCCP(png_structp png_ptr, png_infop info_ptr, int nparams, png_charpp params) { png_bytep profile = NULL; png_uint_32 proflen = 0; int result; check_param_count(nparams, 2); switch (params[1][0]) { case '<': { png_size_t filelen = load_file(params[1]+1, &profile); if (filelen > 0xfffffffc) { fprintf(stderr, "%s: file too long (%lu) for an ICC profile\n", params[1]+1, (unsigned long)filelen); exit(1); } proflen = (png_uint_32)filelen; } break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': { png_size_t fake_len = load_fake(params[1], &profile); if (fake_len > 0) { if (fake_len > 0xffffffff) { fprintf(stderr, "%s: fake data too long (%lu) for an ICC profile\n", params[1], (unsigned long)fake_len); exit(1); } proflen = (png_uint_32)(fake_len & ~3U); png_save_uint_32(profile, proflen); break; } } default: fprintf(stderr, "--insert iCCP \"%s\": unrecognized\n", params[1]); fprintf(stderr, " use '<' to read a file: \"<filename\"\n"); exit(1); } result = 1; if (proflen & 3) { fprintf(stderr, "makepng: --insert iCCP %s: profile length made a multiple of 4\n", params[1]); while (proflen & 3) profile[proflen++] = 0; } if (profile != NULL && proflen > 3) { png_uint_32 prof_header = png_get_uint_32(profile); if (prof_header != proflen) { fprintf(stderr, "--insert iCCP %s: profile length field wrong:\n", params[1]); fprintf(stderr, " actual %lu, recorded value %lu (corrected)\n", (unsigned long)proflen, (unsigned long)prof_header); png_save_uint_32(profile, proflen); } } if (result && profile != NULL && proflen >=4) png_set_iCCP(png_ptr, info_ptr, params[0], PNG_COMPRESSION_TYPE_BASE, profile, proflen); if (profile) free(profile); if (!result) exit(1); }<SPLIT>[0.36491818514653585, 0.971486945572027, 0.0, 0.34210700232091185, 0.870251967507103, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 0.9278969563718671, 0.3762494122151511, 1.0250193468092605, 0.0, 0.0, 0.30852482215402843, 0.8358616472332691, 0.35306556693537716, 0.9251876977770237, 0.24712242304476825, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2896437087679637, 0.0744401592322129, 0.005287286955244392, -0.21702784222394986, 0.14602883551895066, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static double YfromRGBint(int ir, int ig, int ib) { double r = ir; double g = ig; double b = ib; return YfromRGB(r, g, b); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.270465503877335, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void global_init(struct global *global) { CLEAR(*global); global->errors = 0; global->warnings = 0; global->quiet = 0; global->verbose = 0; global->idat_max = 0; global->optimize_zlib = 0; global->skip = SKIP_NONE; global->status_code = 0; IDAT_list_init(&global->idat_cache); }<SPLIT>[0.05563366039355449, -0.3507086565438968, 0.0, 0.037794879441717756, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3107937917392237, 0.061639525868012635, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, 0.04368374699580437, -0.4000063039086396, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void transform_image_validate(transform_display *dp, png_const_structp pp, png_infop pi) { PNG_CONST png_store* PNG_CONST ps = dp->this.ps; PNG_CONST png_byte in_ct = dp->this.colour_type; PNG_CONST png_byte in_bd = dp->this.bit_depth; PNG_CONST png_uint_32 w = dp->this.w; PNG_CONST png_uint_32 h = dp->this.h; PNG_CONST png_byte out_ct = dp->output_colour_type; PNG_CONST png_byte out_bd = dp->output_bit_depth; PNG_CONST png_byte sample_depth = (png_byte)(out_ct == PNG_COLOR_TYPE_PALETTE ? 8 : out_bd); PNG_CONST png_byte red_sBIT = dp->this.red_sBIT; PNG_CONST png_byte green_sBIT = dp->this.green_sBIT; PNG_CONST png_byte blue_sBIT = dp->this.blue_sBIT; PNG_CONST png_byte alpha_sBIT = dp->this.alpha_sBIT; PNG_CONST int have_tRNS = dp->this.is_transparent; double digitization_error; store_palette out_palette; png_uint_32 y; UNUSED(pi) store_image_check(dp->this.ps, pp, 0); if (out_ct == PNG_COLOR_TYPE_PALETTE) { int npalette = (-1); (void)read_palette(out_palette, &npalette, pp, pi); if (npalette != dp->this.npalette) png_error(pp, "unexpected change in palette size"); digitization_error = .5; } else { png_byte in_sample_depth; memset(out_palette, 0x5e, sizeof out_palette); if (in_ct == PNG_COLOR_TYPE_PALETTE || in_bd < 16) in_sample_depth = 8; else in_sample_depth = in_bd; if (sample_depth != 16 || in_sample_depth > 8 || !dp->pm->calculations_use_input_precision) digitization_error = .5; else digitization_error = .5 * 257; } for (y=0; y<h; ++y) { png_const_bytep PNG_CONST pRow = store_image_row(ps, pp, 0, y); png_uint_32 x; png_byte std[STANDARD_ROWMAX]; transform_row(pp, std, in_ct, in_bd, y); for (x=0; x<w; ++x) { image_pixel in_pixel, out_pixel; unsigned int r, g, b, a; image_pixel_init(&in_pixel, std, in_ct, in_bd, x, dp->this.palette); in_pixel.red_sBIT = red_sBIT; in_pixel.green_sBIT = green_sBIT; in_pixel.blue_sBIT = blue_sBIT; in_pixel.alpha_sBIT = alpha_sBIT; in_pixel.have_tRNS = have_tRNS; r = in_pixel.red; g = in_pixel.green; b = in_pixel.blue; a = in_pixel.alpha; dp->transform_list->mod(dp->transform_list, &in_pixel, pp, dp); image_pixel_init(&out_pixel, pRow, out_ct, out_bd, x, out_palette); if (in_ct == PNG_COLOR_TYPE_PALETTE && out_ct == PNG_COLOR_TYPE_PALETTE) { if (in_pixel.palette_index != out_pixel.palette_index) png_error(pp, "unexpected transformed palette index"); } if (in_pixel.red != out_pixel.red) transform_range_check(pp, r, g, b, a, in_pixel.red, in_pixel.redf, out_pixel.red, sample_depth, in_pixel.rede, dp->pm->limit + 1./(2*((1U<<in_pixel.red_sBIT)-1)), "red/gray", digitization_error); if ((out_ct & PNG_COLOR_MASK_COLOR) != 0 && in_pixel.green != out_pixel.green) transform_range_check(pp, r, g, b, a, in_pixel.green, in_pixel.greenf, out_pixel.green, sample_depth, in_pixel.greene, dp->pm->limit + 1./(2*((1U<<in_pixel.green_sBIT)-1)), "green", digitization_error); if ((out_ct & PNG_COLOR_MASK_COLOR) != 0 && in_pixel.blue != out_pixel.blue) transform_range_check(pp, r, g, b, a, in_pixel.blue, in_pixel.bluef, out_pixel.blue, sample_depth, in_pixel.bluee, dp->pm->limit + 1./(2*((1U<<in_pixel.blue_sBIT)-1)), "blue", digitization_error); if ((out_ct & PNG_COLOR_MASK_ALPHA) != 0 && in_pixel.alpha != out_pixel.alpha) transform_range_check(pp, r, g, b, a, in_pixel.alpha, in_pixel.alphaf, out_pixel.alpha, sample_depth, in_pixel.alphae, dp->pm->limit + 1./(2*((1U<<in_pixel.alpha_sBIT)-1)), "alpha", digitization_error); } } dp->this.ps->validated = 1; }<SPLIT>[4.540259269311784, 1.5444383731555937, 0.0, 4.450320661190031, 1.4235000532228899, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 1.986777757176509, 4.623482877901521, 1.617634231955486, 0.0, 0.0, 0.30852482215402843, 1.8626635103357438, 4.529720136119611, 1.4994384318408112, 0.6353133682363457, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, 1.2382117722297952, 0.29241985090139744, 0.6826474935548865, -0.21702784222394986, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>void put_chunk(const unsigned char *chunk, uInt length) { uLong crc; put_uLong(length-4); fwrite(chunk, length, 1, stdout); crc = crc32(0, Z_NULL, 0); put_uLong(crc32(crc, chunk, length)); }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gp_argb16(Pixel *p, png_const_voidp pb) { png_const_uint_16p pp = voidcast(png_const_uint_16p, pb); p->r = pp[1]; p->g = pp[2]; p->b = pp[3]; p->a = pp[0]; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void image_pixel_convert_PLTE(image_pixel *this) { if (this->colour_type == PNG_COLOR_TYPE_PALETTE) { if (this->have_tRNS) { this->colour_type = PNG_COLOR_TYPE_RGB_ALPHA; this->have_tRNS = 0; } else this->colour_type = PNG_COLOR_TYPE_RGB; this->bit_depth = 8; } }<SPLIT>[0.21027592277004517, -0.32867206317529807, 0.0, 0.18995094088131478, -0.3851956116171827, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.270836025671124, 0.21894446904158188, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, 0.19837465696559078, -0.37791973721387856, -0.7880534307994381, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5250039928580447, -0.7849662874110047, 0.6817979554923368, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void format_init(format_list *pf) { int i; for (i=0; i<FORMAT_SET_COUNT; ++i) pf->bits[i] = 0; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void modification_reset(png_modification *pmm) { if (pmm != NULL) { pmm->modified = 0; pmm->added = 0; pmm->removed = 0; modification_reset(pmm->next); } }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.7880534307994381, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void clean_display(display *d) { png_destroy_read_struct(&d->png_ptr, &d->info_ptr, &d->end_ptr); if (d->png_ptr != NULL || d->info_ptr != NULL || d->end_ptr != NULL) { fprintf(stderr, "%s(%s): png_destroy_read_struct error\n", d->file, d->test); exit(1); } }<SPLIT>[-0.09900860198293619, -0.416818436649693, 0.0, -0.11436118199787926, -0.47031070172730377, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.09566541730555662, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.11100716297398205, -0.4662660039929228, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.41601414702345235, -0.4462861841111837, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_expand_set(PNG_CONST image_transform *this, transform_display *that, png_structp pp, png_infop pi) { png_set_expand(pp); this->next->set(this->next, that, pp, pi); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static png_byte u8d(double d) { d = closestinteger(d); return (png_byte)d; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_expand_16_mod(PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp, PNG_CONST transform_display *display) { if (that->colour_type == PNG_COLOR_TYPE_PALETTE) image_pixel_convert_PLTE(that); if (that->have_tRNS) image_pixel_add_alpha(that, &display->this); if (that->bit_depth < 16) that->sample_depth = that->bit_depth = 16; this->next->mod(this->next, that, pp, display); }<SPLIT>[0.21027592277004517, -0.3727452499124955, 0.0, 0.18995094088131478, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3107937917392237, 0.21894446904158188, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, 0.19837465696559078, -0.42209287060340067, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gp_bgr8(Pixel *p, png_const_voidp pb) { png_const_bytep pp = voidcast(png_const_bytep, pb); p->r = pp[2]; p->g = pp[1]; p->b = pp[0]; p->a = 255; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gp_rgb8(Pixel *p, png_const_voidp pb) { png_const_bytep pp = voidcast(png_const_bytep, pb); p->r = pp[0]; p->g = pp[1]; p->b = pp[2]; p->a = 255; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI standard_end(png_structp ppIn, png_infop pi) { png_const_structp pp = ppIn; standard_display *dp = voidcast(standard_display*, png_get_progressive_ptr(pp)); UNUSED(pi) standard_text_validate(dp, pp, pi, PNG_LIBPNG_VER >= 10518); standard_image_validate(dp, pp, 0, -1); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.18995094088131478, -0.47031070172730377, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4040500365131154, 0.19837465696559078, -0.4662660039929228, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static png_byte component_loc(png_byte loc[4], png_uint_32 format) { png_byte channels; if (format & PNG_FORMAT_FLAG_COLOR) { channels = 3; loc[2] = 1; #ifdef PNG_FORMAT_BGR_SUPPORTED if (format & PNG_FORMAT_FLAG_BGR) { loc[1] = 2; loc[3] = 0; } else #endif { loc[1] = 0; loc[3] = 2; } } else { channels = 1; loc[1] = loc[2] = loc[3] = 0; } if (format & PNG_FORMAT_FLAG_ALPHA) { #ifdef PNG_FORMAT_AFIRST_SUPPORTED if (format & PNG_FORMAT_FLAG_AFIRST) { loc[0] = 0; ++loc[1]; ++loc[2]; ++loc[3]; } else #endif loc[0] = channels; ++channels; } else loc[0] = 4; return channels; }<SPLIT>[1.6020562841584611, 0.33242573788266383, 0.0, 1.559355493837688, 0.25316756420872527, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.5083404126568202, 1.6346889576037051, -0.04624602249353125, 0.0, 0.0, 0.30852482215402843, 0.4290156260039867, 1.5905928466936687, -0.1128809368767459, -0.7880534307994381, -0.1892664641018488, 0.0, 1.457000985644429, 2.1569430876889752, -0.0968099467164862, -0.5250039928580447, -0.7849662874110047, 0.6817979554923368, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int pixel_depth_of_type(int color_type, int bit_depth) { return channels_of_type(color_type) * bit_depth; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void get_token(FILE *pnm_file, char *token) { int i = 0; int ret; do { ret = fgetc(pnm_file); if (ret == '#') { do { ret = fgetc(pnm_file); } while ((ret != '\n') && (ret != '\r') && (ret != EOF)); } if (ret == EOF) break; token[i] = (unsigned char) ret; } while ((token[i] == '\n') || (token[i] == '\r') || (token[i] == ' ')); do { ret = fgetc(pnm_file); if (ret == EOF) break; i++; token[i] = (unsigned char) ret; } while ((token[i] != '\n') && (token[i] != '\r') && (token[i] != ' ')); token[i] = '\0'; return; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.18995094088131478, -0.06601402370422871, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.03595125540090747, 0.19837465696559078, -0.04662123679246273, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void set_value(png_bytep row, size_t rowbytes, png_uint_32 x, unsigned int bit_depth, png_uint_32 value, png_const_bytep gamma_table, double conv) { unsigned int mask = (1U << bit_depth)-1; x *= bit_depth; if (value <= mask) { png_uint_32 offset = x >> 3; if (offset < rowbytes && (bit_depth < 16 || offset+1 < rowbytes)) { row += offset; switch (bit_depth) { case 1: case 2: case 4: { unsigned int shift = (8 - bit_depth) - (x & 0x7U); mask <<= shift; value = (value << shift) & mask; *row = (png_byte)((*row & ~mask) | value); } return; default: fprintf(stderr, "makepng: bad bit depth (internal error)\n"); exit(1); case 16: value = (unsigned int)floor(65535*pow(value/65535.,conv)+.5); *row++ = (png_byte)(value >> 8); *row = (png_byte)value; return; case 8: *row = gamma_table[value]; return; } } else { fprintf(stderr, "makepng: row buffer overflow (internal error)\n"); exit(1); } } else { fprintf(stderr, "makepng: component overflow (internal error)\n"); exit(1); } }<SPLIT>[-0.09900860198293619, 0.42057211135705874, 0.0, -0.11436118199787926, 0.33828265431884635, 0.0, 0.7963739706959416, 0.11088995743869048, 0.7400896423242515, 1.3698779043020206, 0.3684882314184712, -0.09566541730555662, 0.45519734186096705, 0.0, 0.0, 0.30852482215402843, 0.29340028559422593, -0.11100716297398205, 0.3730235304079973, -0.011671540416283347, 1.454978812491217, 0.0, -0.08645738172306322, -0.16222078614455715, 0.043718655277859224, 0.6738843113224704, -0.10760608081136262, 2.47944955092491, 0.9881657846020622, 0.7958385171580944, 0.11056045576999526, 0.7395912368182198, 1.3693714445839917, 1.7623686513065309, 0.0, 0.791794928969486, 0.10736180245377658, 0.7355972453213037, 1.3643185231999084]
1<SPLIT>void png_push_read_chunk(png_structrp png_ptr, png_inforp info_ptr) { png_uint_32 chunk_name; #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED int keep; #endif if (!(png_ptr->mode & PNG_HAVE_CHUNK_HEADER)) { png_byte chunk_length[4]; png_byte chunk_tag[4]; if (png_ptr->buffer_size < 8) { png_push_save_buffer(png_ptr); return; } png_push_fill_buffer(png_ptr, chunk_length, 4); png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length); png_reset_crc(png_ptr); png_crc_read(png_ptr, chunk_tag, 4); png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(chunk_tag); png_check_chunk_name(png_ptr, png_ptr->chunk_name); png_ptr->mode |= PNG_HAVE_CHUNK_HEADER; } chunk_name = png_ptr->chunk_name; if (chunk_name == png_IDAT) { if (png_ptr->mode & PNG_AFTER_IDAT) png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT; if (!(png_ptr->mode & PNG_HAVE_IHDR)) png_error(png_ptr, "Missing IHDR before IDAT"); else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE && !(png_ptr->mode & PNG_HAVE_PLTE)) png_error(png_ptr, "Missing PLTE before IDAT"); png_ptr->mode |= PNG_HAVE_IDAT; if (!(png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT)) if (png_ptr->push_length == 0) return; if (png_ptr->mode & PNG_AFTER_IDAT) png_benign_error(png_ptr, "Too many IDATs found"); } if (chunk_name == png_IHDR) { if (png_ptr->push_length != 13) png_error(png_ptr, "Invalid IHDR length"); if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_IHDR(png_ptr, info_ptr, png_ptr->push_length); } else if (chunk_name == png_IEND) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_IEND(png_ptr, info_ptr, png_ptr->push_length); png_ptr->process_mode = PNG_READ_DONE_MODE; png_push_have_end(png_ptr, info_ptr); } #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED else if ((keep = png_chunk_unknown_handling(png_ptr, chunk_name)) != 0) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length, keep); if (chunk_name == png_PLTE) png_ptr->mode |= PNG_HAVE_PLTE; } #endif else if (chunk_name == png_PLTE) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_PLTE(png_ptr, info_ptr, png_ptr->push_length); } else if (chunk_name == png_IDAT) { png_ptr->idat_size = png_ptr->push_length; png_ptr->process_mode = PNG_READ_IDAT_MODE; png_push_have_info(png_ptr, info_ptr); png_ptr->zstream.avail_out = (uInt) PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->iwidth) + 1; png_ptr->zstream.next_out = png_ptr->row_buf; return; } #ifdef PNG_READ_gAMA_SUPPORTED else if (png_ptr->chunk_name == png_gAMA) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_gAMA(png_ptr, info_ptr, png_ptr->push_length); } #endif #ifdef PNG_READ_sBIT_SUPPORTED else if (png_ptr->chunk_name == png_sBIT) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_sBIT(png_ptr, info_ptr, png_ptr->push_length); } #endif #ifdef PNG_READ_cHRM_SUPPORTED else if (png_ptr->chunk_name == png_cHRM) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_cHRM(png_ptr, info_ptr, png_ptr->push_length); } #endif #ifdef PNG_READ_sRGB_SUPPORTED else if (chunk_name == png_sRGB) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_sRGB(png_ptr, info_ptr, png_ptr->push_length); } #endif #ifdef PNG_READ_iCCP_SUPPORTED else if (png_ptr->chunk_name == png_iCCP) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_iCCP(png_ptr, info_ptr, png_ptr->push_length); } #endif #ifdef PNG_READ_sPLT_SUPPORTED else if (chunk_name == png_sPLT) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_sPLT(png_ptr, info_ptr, png_ptr->push_length); } #endif #ifdef PNG_READ_tRNS_SUPPORTED else if (chunk_name == png_tRNS) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_tRNS(png_ptr, info_ptr, png_ptr->push_length); } #endif #ifdef PNG_READ_bKGD_SUPPORTED else if (chunk_name == png_bKGD) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_bKGD(png_ptr, info_ptr, png_ptr->push_length); } #endif #ifdef PNG_READ_hIST_SUPPORTED else if (chunk_name == png_hIST) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_hIST(png_ptr, info_ptr, png_ptr->push_length); } #endif #ifdef PNG_READ_pHYs_SUPPORTED else if (chunk_name == png_pHYs) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_pHYs(png_ptr, info_ptr, png_ptr->push_length); } #endif #ifdef PNG_READ_oFFs_SUPPORTED else if (chunk_name == png_oFFs) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_oFFs(png_ptr, info_ptr, png_ptr->push_length); } #endif #ifdef PNG_READ_pCAL_SUPPORTED else if (chunk_name == png_pCAL) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_pCAL(png_ptr, info_ptr, png_ptr->push_length); } #endif #ifdef PNG_READ_sCAL_SUPPORTED else if (chunk_name == png_sCAL) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_sCAL(png_ptr, info_ptr, png_ptr->push_length); } #endif #ifdef PNG_READ_tIME_SUPPORTED else if (chunk_name == png_tIME) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_tIME(png_ptr, info_ptr, png_ptr->push_length); } #endif #ifdef PNG_READ_tEXt_SUPPORTED else if (chunk_name == png_tEXt) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length); } #endif #ifdef PNG_READ_zTXt_SUPPORTED else if (chunk_name == png_zTXt) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length); } #endif #ifdef PNG_READ_iTXt_SUPPORTED else if (chunk_name == png_iTXt) { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length); } #endif else { if (png_ptr->push_length + 4 > png_ptr->buffer_size) { png_push_save_buffer(png_ptr); return; } png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length, PNG_HANDLE_CHUNK_AS_DEFAULT); } png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER; }<SPLIT>[10.107380714865448, 5.841574080032347, 0.0, 9.927938873015524, 5.572860696091292, 0.0, 1.8391333925217592, 1.8783232022107403, 1.7351415616306558, 4.008483356457433, 6.601899738042024, 4.623482877901521, 1.4352911903720318, 0.0, 0.0, 0.30852482215402843, 6.33796974385785, 4.529720136119611, 1.3227458982827227, 1.1529012951584487, 0.7972807018539907, 0.0, 22.073194892624503, 21.869836015274, 2.713762093170422, 1.2188335404954318, 0.9084342290881006, -0.21702784222394986, 1.3624488730834452, 1.8383309169346027, 1.8776273465768223, 1.7343983950676451, 4.007331890021263, 1.7623686513065309, 0.0, 1.832972902474695, 1.8722343178402097, 1.7290886636830973, 3.9981557057022012]
1<SPLIT>void png_read_IDAT_data(png_structrp png_ptr, png_bytep output, png_alloc_size_t avail_out) { png_ptr->zstream.next_out = output; png_ptr->zstream.avail_out = 0; if (output == NULL) avail_out = 0; do { int ret; png_byte tmpbuf[PNG_INFLATE_BUF_SIZE]; if (png_ptr->zstream.avail_in == 0) { uInt avail_in; png_bytep buffer; while (png_ptr->idat_size == 0) { png_crc_finish(png_ptr, 0); png_ptr->idat_size = png_read_chunk_header(png_ptr); if (png_ptr->chunk_name != png_IDAT) png_error(png_ptr, "Not enough image data"); } avail_in = png_ptr->IDAT_read_size; if (avail_in > png_ptr->idat_size) avail_in = (uInt)png_ptr->idat_size; buffer = png_read_buffer(png_ptr, avail_in, 0); png_crc_read(png_ptr, buffer, avail_in); png_ptr->idat_size -= avail_in; png_ptr->zstream.next_in = buffer; png_ptr->zstream.avail_in = avail_in; } if (output != NULL) { uInt out = ZLIB_IO_MAX; if (out > avail_out) out = (uInt)avail_out; avail_out -= out; png_ptr->zstream.avail_out = out; } else { png_ptr->zstream.next_out = tmpbuf; png_ptr->zstream.avail_out = (sizeof tmpbuf); } ret = inflate(&png_ptr->zstream, Z_NO_FLUSH); if (output != NULL) avail_out += png_ptr->zstream.avail_out; else avail_out += (sizeof tmpbuf) - png_ptr->zstream.avail_out; png_ptr->zstream.avail_out = 0; if (ret == Z_STREAM_END) { png_ptr->zstream.next_out = NULL; png_ptr->mode |= PNG_AFTER_IDAT; png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED; if (png_ptr->zstream.avail_in > 0 || png_ptr->idat_size > 0) png_chunk_benign_error(png_ptr, "Extra compressed data"); break; } if (ret != Z_OK) { png_zstream_error(png_ptr, ret); if (output != NULL) png_chunk_error(png_ptr, png_ptr->zstream.msg); else { png_chunk_benign_error(png_ptr, png_ptr->zstream.msg); return; } } } while (avail_out > 0); if (avail_out > 0) { if (output != NULL) png_error(png_ptr, "Not enough image data"); else png_chunk_benign_error(png_ptr, "Too much image data"); } }<SPLIT>[7.169177729712126, 1.1037065057836193, 0.0, 7.036973705663181, 0.9979246026722846, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 1.9268411080743597, 7.297666911852199, 1.1617766279968509, 0.0, 0.0, 0.30852482215402843, 1.804542650160132, 7.1594656056059796, 1.05770709794559, 0.6353133682363457, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 0.6760973642524136, -0.08904460951967552, 0.34396739025506545, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int writepng_encode_image(mainprog_info *mainprog_ptr) { png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr; png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr; if (setjmp(mainprog_ptr->jmpbuf)) { png_destroy_write_struct(&png_ptr, &info_ptr); mainprog_ptr->png_ptr = NULL; mainprog_ptr->info_ptr = NULL; return 2; } png_write_image(png_ptr, mainprog_ptr->row_pointers); png_write_end(png_ptr, NULL); return 0; }<SPLIT>[0.8288449722760078, -0.3507086565438968, 0.0, 0.798575186639703, -0.406474384144713, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.21089937656897445, 0.8481642417358589, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, 0.8171382968447365, -0.4000063039086396, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.3070243011888601, -0.3333928163445767, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static double gamma_component_validate(PNG_CONST char *name, PNG_CONST validate_info *vi, PNG_CONST unsigned int id, PNG_CONST unsigned int od, PNG_CONST double alpha , PNG_CONST double background) { PNG_CONST unsigned int isbit = id >> vi->isbit_shift; PNG_CONST unsigned int sbit_max = vi->sbit_max; PNG_CONST unsigned int outmax = vi->outmax; PNG_CONST int do_background = vi->do_background; double i; i = isbit; i /= sbit_max; if (alpha == 1 || !do_background #ifdef PNG_READ_ALPHA_MODE_SUPPORTED || do_background == ALPHA_MODE_OFFSET + PNG_ALPHA_PNG #endif || (alpha < 0 #ifdef PNG_READ_ALPHA_MODE_SUPPORTED && do_background != ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN #endif )) { double encoded_sample = i; double encoded_error; if (alpha >= 0 && vi->gamma_correction > 0) encoded_sample = pow(encoded_sample, vi->gamma_correction); encoded_sample *= outmax; encoded_error = fabs(od-encoded_sample); if (encoded_error > vi->dp->maxerrout) vi->dp->maxerrout = encoded_error; if (encoded_error < vi->maxout_total && encoded_error < vi->outlog) return i; } { double input_sample = i; double output, error, encoded_sample, encoded_error; double es_lo, es_hi; int compose = 0; int output_is_encoded; int log_max_error = 1; png_const_charp pass = 0; if (alpha >= 0) { int tcompose; if (vi->file_inverse > 0) input_sample = pow(input_sample, vi->file_inverse); tcompose = 0; input_sample = gamma_component_compose(do_background, input_sample, alpha, background, &tcompose); if (tcompose) compose = 1; } output = od; output /= outmax; output_is_encoded = vi->screen_gamma > 0; if (alpha < 0) { #ifdef PNG_READ_ALPHA_MODE_SUPPORTED if (do_background != ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN) #endif { output_is_encoded = 0; log_max_error = 0; } } #ifdef PNG_READ_ALPHA_MODE_SUPPORTED else { if (do_background == ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED && alpha < 1) { if (alpha > 0) log_max_error = 0; output_is_encoded = 0; } } #endif if (output_is_encoded) output = pow(output, vi->screen_gamma); encoded_sample = input_sample; if (output_is_encoded) encoded_sample = pow(encoded_sample, vi->screen_inverse); encoded_sample *= outmax; encoded_error = fabs(od-encoded_sample); if (log_max_error && encoded_error > vi->dp->maxerrout) vi->dp->maxerrout = encoded_error; if (encoded_error < vi->maxout_total) { if (encoded_error < vi->outlog) return i; pass = "less than maxout:\n"; } error = fabs(input_sample-output); if (log_max_error && error > vi->dp->maxerrabs) vi->dp->maxerrabs = error; if (log_max_error && input_sample > .5) { double percentage_error = error/input_sample; if (percentage_error > vi->dp->maxerrpc) vi->dp->maxerrpc = percentage_error; } { double tmp = input_sample * vi->maxpc; if (tmp < vi->maxabs) tmp = vi->maxabs; if (compose && tmp < vi->maxcalc) tmp = vi->maxcalc; es_lo = encoded_sample - vi->maxout; if (es_lo > 0 && input_sample-tmp > 0) { double low_value = input_sample-tmp; if (output_is_encoded) low_value = pow(low_value, vi->screen_inverse); low_value *= outmax; if (low_value < es_lo) es_lo = low_value; es_lo = ceil(es_lo / vi->outquant - .5) * vi->outquant; } else es_lo = 0; es_hi = encoded_sample + vi->maxout; if (es_hi < outmax && input_sample+tmp < 1) { double high_value = input_sample+tmp; if (output_is_encoded) high_value = pow(high_value, vi->screen_inverse); high_value *= outmax; if (high_value > es_hi) es_hi = high_value; es_hi = floor(es_hi / vi->outquant + .5) * vi->outquant; } else es_hi = outmax; } if (od >= es_lo && od <= es_hi) { if (encoded_error < vi->outlog) return i; if (pass == 0) pass = "within digitization limits:\n"; } { double is_lo, is_hi; if (pass == 0 && vi->use_input_precision && vi->dp->sbit) { #if PNG_LIBPNG_VER < 10700 #define SBIT_ERROR .5 #else #define SBIT_ERROR 1. #endif double tmp = (isbit - SBIT_ERROR)/sbit_max; if (tmp <= 0) tmp = 0; else if (alpha >= 0 && vi->file_inverse > 0 && tmp < 1) tmp = pow(tmp, vi->file_inverse); tmp = gamma_component_compose(do_background, tmp, alpha, background, NULL); if (output_is_encoded && tmp > 0 && tmp < 1) tmp = pow(tmp, vi->screen_inverse); is_lo = ceil(outmax * tmp - vi->maxout_total); if (is_lo < 0) is_lo = 0; tmp = (isbit + SBIT_ERROR)/sbit_max; if (tmp >= 1) tmp = 1; else if (alpha >= 0 && vi->file_inverse > 0 && tmp < 1) tmp = pow(tmp, vi->file_inverse); tmp = gamma_component_compose(do_background, tmp, alpha, background, NULL); if (output_is_encoded && tmp > 0 && tmp < 1) tmp = pow(tmp, vi->screen_inverse); is_hi = floor(outmax * tmp + vi->maxout_total); if (is_hi > outmax) is_hi = outmax; if (!(od < is_lo || od > is_hi)) { if (encoded_error < vi->outlog) return i; pass = "within input precision limits:\n"; } #ifndef PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED #if PNG_LIBPNG_VER < 10504 if (pass == 0 && alpha < 0 && vi->scale16 && vi->sbit > 8 && vi->sbit + vi->isbit_shift == 16) { tmp = ((id >> 8) - .5)/255; if (tmp > 0) { is_lo = ceil(outmax * tmp - vi->maxout_total); if (is_lo < 0) is_lo = 0; } else is_lo = 0; tmp = ((id >> 8) + .5)/255; if (tmp < 1) { is_hi = floor(outmax * tmp + vi->maxout_total); if (is_hi > outmax) is_hi = outmax; } else is_hi = outmax; if (!(od < is_lo || od > is_hi)) { if (encoded_error < vi->outlog) return i; pass = "within 8 bit limits:\n"; } } #endif #endif } else is_lo = es_lo, is_hi = es_hi; { size_t pos = 0; int precision = (outmax >= 1000 ? 6 : 3); int use_input=1, use_background=0, do_compose=0; char msg[256]; if (pass != 0) pos = safecat(msg, sizeof msg, pos, "\n\t"); switch (do_background) { #ifdef PNG_READ_BACKGROUND_SUPPORTED case PNG_BACKGROUND_GAMMA_SCREEN: case PNG_BACKGROUND_GAMMA_FILE: case PNG_BACKGROUND_GAMMA_UNIQUE: use_background = (alpha >= 0 && alpha < 1); #endif #ifdef PNG_READ_ALPHA_MODE_SUPPORTED case ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD: case ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN: case ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED: #endif do_compose = (alpha > 0 && alpha < 1); use_input = (alpha != 0); break; default: break; } if (compose != do_compose) png_error(vi->pp, "internal error (compose)"); pos = safecat(msg, sizeof msg, pos, name); pos = safecat(msg, sizeof msg, pos, "("); pos = safecatn(msg, sizeof msg, pos, id); if (use_input || pass != 0) { if (isbit != id) { pos = safecat(msg, sizeof msg, pos, ", sbit("); pos = safecatn(msg, sizeof msg, pos, vi->sbit); pos = safecat(msg, sizeof msg, pos, "): "); pos = safecatn(msg, sizeof msg, pos, isbit); } pos = safecat(msg, sizeof msg, pos, "/"); pos = safecatn(msg, sizeof msg, pos, vi->sbit_max); } pos = safecat(msg, sizeof msg, pos, ")"); if (compose || pass != 0) { if (use_input || pass != 0) { if (vi->file_inverse > 0) { pos = safecat(msg, sizeof msg, pos, "^"); pos = safecatd(msg, sizeof msg, pos, vi->file_inverse, 2); } else pos = safecat(msg, sizeof msg, pos, "[linear]"); pos = safecat(msg, sizeof msg, pos, "*(alpha)"); pos = safecatd(msg, sizeof msg, pos, alpha, precision); } if (use_background) { pos = safecat(msg, sizeof msg, pos, use_input ? "+" : " "); pos = safecat(msg, sizeof msg, pos, "(background)"); pos = safecatd(msg, sizeof msg, pos, background, precision); pos = safecat(msg, sizeof msg, pos, "*"); pos = safecatd(msg, sizeof msg, pos, 1-alpha, precision); } } if (compose || alpha < 0 || pass != 0) { pos = safecat(msg, sizeof msg, pos, pass != 0 ? " =\n\t" : " = "); pos = safecatd(msg, sizeof msg, pos, input_sample, precision); pos = safecat(msg, sizeof msg, pos, " (libpng: "); pos = safecatd(msg, sizeof msg, pos, output, precision); pos = safecat(msg, sizeof msg, pos, ")"); if (output_is_encoded) { pos = safecat(msg, sizeof msg, pos, " ^"); pos = safecatd(msg, sizeof msg, pos, vi->screen_inverse, 2); pos = safecat(msg, sizeof msg, pos, "(to screen) ="); } else pos = safecat(msg, sizeof msg, pos, " [screen is linear] ="); } if ((!compose && alpha >= 0) || pass != 0) { if (pass != 0) pos = safecat(msg, sizeof msg, pos, "\n\t[overall:"); if (vi->gamma_correction > 0) { pos = safecat(msg, sizeof msg, pos, " ^"); pos = safecatd(msg, sizeof msg, pos, vi->gamma_correction, 2); pos = safecat(msg, sizeof msg, pos, "(gamma correction) ="); } else pos = safecat(msg, sizeof msg, pos, " [no gamma correction] ="); if (pass != 0) pos = safecat(msg, sizeof msg, pos, "]"); } pos = safecat(msg, sizeof msg, pos, pass != 0 ? "\n\t" : " "); pos = safecatd(msg, sizeof msg, pos, is_lo, 1); pos = safecat(msg, sizeof msg, pos, " < "); pos = safecatd(msg, sizeof msg, pos, encoded_sample, 1); pos = safecat(msg, sizeof msg, pos, " (libpng: "); pos = safecatn(msg, sizeof msg, pos, od); pos = safecat(msg, sizeof msg, pos, ")"); pos = safecat(msg, sizeof msg, pos, "/"); pos = safecatn(msg, sizeof msg, pos, outmax); pos = safecat(msg, sizeof msg, pos, " < "); pos = safecatd(msg, sizeof msg, pos, is_hi, 1); if (pass == 0) { #ifdef PNG_WARNINGS_SUPPORTED png_warning(vi->pp, msg); #else store_warning(vi->pp, msg); #endif } else store_verbose(&vi->dp->pm->this, vi->pp, pass, msg); } } } return i; }<SPLIT>[23.097330754490667, 6.701001221407696, 0.0, 22.709048033941674, 6.402732824664972, 0.0, 6.705344027708907, 6.827136287572481, 6.710401158162677, 3.6786576749380067, 9.059302351230157, 23.34277111555626, 5.948281469562516, 0.0, 0.0, 0.30852482215402843, 8.720925011057933, 22.937938422524194, 5.695886103845411, 3.611443948038439, 8.908890733046448, 0.0, 2.33897719556871, 13.752762456856638, 4.681162521091258, 6.722820755142342, 3.5049816877200617, 4.277101146357483, 8.193115237868684, 6.703295449224975, 6.8254146408359375, 6.708434186314772, 3.6775868343416036, 2.6191065950439585, 0.0, 6.691803445499003, 6.8138773609222225, 6.696545755492066, 3.6689260578894145]
0<SPLIT>static png_bytep extract(FILE *fp, png_uint_32 *proflen) { png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,0,0,0); png_infop info_ptr = NULL; png_bytep result = NULL; *proflen = 0; if (png_ptr == NULL) { fprintf(stderr, "iccfrompng: version library mismatch?\n"); return 0; } if (setjmp(png_jmpbuf(png_ptr))) { png_destroy_read_struct(&png_ptr, &info_ptr, NULL); return 0; } png_init_io(png_ptr, fp); info_ptr = png_create_info_struct(png_ptr); if (info_ptr == NULL) png_error(png_ptr, "OOM allocating info structure"); png_read_info(png_ptr, info_ptr); { png_charp name; int compression_type; png_bytep profile; if (png_get_iCCP(png_ptr, info_ptr, &name, &compression_type, &profile, proflen) & PNG_INFO_iCCP) { result = malloc(*proflen); if (result != NULL) memcpy(result, profile, *proflen); else png_error(png_ptr, "OOM allocating profile buffer"); } else result = no_profile; } png_destroy_read_struct(&png_ptr, &info_ptr, NULL); return result; }<SPLIT>[-0.09900860198293619, 0.24427936440826892, 0.0, -0.11436118199787926, 0.16805247409860422, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.380400859743741, 0.2086571671460724, -0.09566541730555662, 0.2728543002775131, 0.0, 0.0, 0.30852482215402843, 0.13841132512592785, -0.11100716297398205, 0.19633099684990887, 0.6353133682363457, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 0.043718655277859224, 0.29241985090139744, 0.5697541257882794, 0.6817979554923368, -0.04111270872174079, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.3801362775450152, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.3766295797615486]
0<SPLIT>static void print_opts(png_uint_32 opts) { if (opts & READ_FILE) printf(" --file"); if (opts & USE_STDIO) printf(" --stdio"); if (opts & STRICT) printf(" --strict"); if (opts & VERBOSE) printf(" --verbose"); if (opts & KEEP_TMPFILES) printf(" --preserve"); if (opts & KEEP_GOING) printf(" --keep-going"); if (opts & ACCUMULATE) printf(" --accumulate"); if (!(opts & FAST_WRITE)) printf(" --slow"); if (opts & sRGB_16BIT) printf(" --sRGB-16bit"); }<SPLIT>[-0.25365086435942685, -0.17441590959510697, 0.0, -0.2665172434374763, -0.23624420392447085, 0.0, 1.1439604446378808, 1.1713499043019204, 1.0717736154263862, -0.27925050329511203, -0.1909204935349246, -0.25297036047912586, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.26569807294376846, -0.22331377035055117, -0.6586564490689124, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, 0.3469147738186936, -0.6720729196443977, -0.21702784222394986, 1.1753073288427536, 1.143335983750264, 1.1708005902540914, 1.0711936229013617, -0.27935383381430245, 0.04889276383167627, 0.0, 1.1388542534712223, 1.1662853116856364, 1.0667610514419015, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_scale_16_set(PNG_CONST image_transform *this, transform_display *that, png_structp pp, png_infop pi) { png_set_scale_16(pp); this->next->set(this->next, that, pp, pi); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void rpng2_x_reload_bg_image(void) { char *dest; uch r1, r2, g1, g2, b1, b2; uch r1_inv, r2_inv, g1_inv, g2_inv, b1_inv, b2_inv; int k, hmax, max; int xidx, yidx, yidx_max; int even_odd_vert, even_odd_horiz, even_odd; int invert_gradient2 = (bg[pat].type & 0x08); int invert_column; ulg i, row; bgscale = (pat == 0)? 8 : bgscale_default; yidx_max = bgscale - 1; if ((bg[pat].type & 0x07) == 0) { uch r1_min = rgb[bg[pat].rgb1_min].r; uch g1_min = rgb[bg[pat].rgb1_min].g; uch b1_min = rgb[bg[pat].rgb1_min].b; uch r2_min = rgb[bg[pat].rgb2_min].r; uch g2_min = rgb[bg[pat].rgb2_min].g; uch b2_min = rgb[bg[pat].rgb2_min].b; int r1_diff = rgb[bg[pat].rgb1_max].r - r1_min; int g1_diff = rgb[bg[pat].rgb1_max].g - g1_min; int b1_diff = rgb[bg[pat].rgb1_max].b - b1_min; int r2_diff = rgb[bg[pat].rgb2_max].r - r2_min; int g2_diff = rgb[bg[pat].rgb2_max].g - g2_min; int b2_diff = rgb[bg[pat].rgb2_max].b - b2_min; for (row = 0; row < rpng2_info.height; ++row) { yidx = (int)(row % bgscale); even_odd_vert = (int)((row / bgscale) & 1); r1 = r1_min + (r1_diff * yidx) / yidx_max; g1 = g1_min + (g1_diff * yidx) / yidx_max; b1 = b1_min + (b1_diff * yidx) / yidx_max; r1_inv = r1_min + (r1_diff * (yidx_max-yidx)) / yidx_max; g1_inv = g1_min + (g1_diff * (yidx_max-yidx)) / yidx_max; b1_inv = b1_min + (b1_diff * (yidx_max-yidx)) / yidx_max; r2 = r2_min + (r2_diff * yidx) / yidx_max; g2 = g2_min + (g2_diff * yidx) / yidx_max; b2 = b2_min + (b2_diff * yidx) / yidx_max; r2_inv = r2_min + (r2_diff * (yidx_max-yidx)) / yidx_max; g2_inv = g2_min + (g2_diff * (yidx_max-yidx)) / yidx_max; b2_inv = b2_min + (b2_diff * (yidx_max-yidx)) / yidx_max; dest = (char *)bg_data + row*bg_rowbytes; for (i = 0; i < rpng2_info.width; ++i) { even_odd_horiz = (int)((i / bgscale) & 1); even_odd = even_odd_vert ^ even_odd_horiz; invert_column = (even_odd_horiz && (bg[pat].type & 0x10)); if (even_odd == 0) { if (invert_column) { *dest++ = r1_inv; *dest++ = g1_inv; *dest++ = b1_inv; } else { *dest++ = r1; *dest++ = g1; *dest++ = b1; } } else { if ((invert_column && invert_gradient2) || (!invert_column && !invert_gradient2)) { *dest++ = r2; *dest++ = g2; *dest++ = b2; } else { *dest++ = r2_inv; *dest++ = g2_inv; *dest++ = b2_inv; } } } } } else if ((bg[pat].type & 0x07) == 1) { hmax = (bgscale-1)/2; max = 2*hmax; r1 = rgb[bg[pat].rgb1_max].r; g1 = rgb[bg[pat].rgb1_max].g; b1 = rgb[bg[pat].rgb1_max].b; r2 = rgb[bg[pat].rgb2_max].r; g2 = rgb[bg[pat].rgb2_max].g; b2 = rgb[bg[pat].rgb2_max].b; for (row = 0; row < rpng2_info.height; ++row) { yidx = (int)(row % bgscale); if (yidx > hmax) yidx = bgscale-1 - yidx; dest = (char *)bg_data + row*bg_rowbytes; for (i = 0; i < rpng2_info.width; ++i) { xidx = (int)(i % bgscale); if (xidx > hmax) xidx = bgscale-1 - xidx; k = xidx + yidx; *dest++ = (k*r1 + (max-k)*r2) / max; *dest++ = (k*g1 + (max-k)*g2) / max; *dest++ = (k*b1 + (max-k)*b2) / max; } } } else if ((bg[pat].type & 0x07) == 2) { uch ch; int ii, x, y, hw, hh, grayspot; double freq, rotate, saturate, gray, intensity; double angle=0.0, aoffset=0.0, maxDist, dist; double red=0.0, green=0.0, blue=0.0, hue, s, v, f, p, q, t; hh = (int)(rpng2_info.height / 2); hw = (int)(rpng2_info.width / 2); angle = CLIP(angle, 0.0, 360.0); grayspot = CLIP(bg[pat].bg_gray, 1, (hh + hw)); freq = MAX((double)bg[pat].bg_freq, 0.0); saturate = (double)bg[pat].bg_bsat * 0.1; rotate = (double)bg[pat].bg_brot * 0.1; gray = 0.0; intensity = 0.0; maxDist = (double)((hw*hw) + (hh*hh)); for (row = 0; row < rpng2_info.height; ++row) { y = (int)(row - hh); dest = (char *)bg_data + row*bg_rowbytes; for (i = 0; i < rpng2_info.width; ++i) { x = (int)(i - hw); angle = (x == 0)? PI_2 : atan((double)y / (double)x); gray = (double)MAX(ABS(y), ABS(x)) / grayspot; gray = MIN(1.0, gray); dist = (double)((x*x) + (y*y)) / maxDist; intensity = cos((angle+(rotate*dist*PI)) * freq) * gray * saturate; intensity = (MAX(MIN(intensity,1.0),-1.0) + 1.0) * 0.5; hue = (angle + PI) * INV_PI_360 + aoffset; s = gray * ((double)(ABS(x)+ABS(y)) / (double)(hw + hh)); s = MIN(MAX(s,0.0), 1.0); v = MIN(MAX(intensity,0.0), 1.0); if (s == 0.0) { ch = (uch)(v * 255.0); *dest++ = ch; *dest++ = ch; *dest++ = ch; } else { if ((hue < 0.0) || (hue >= 360.0)) hue -= (((int)(hue / 360.0)) * 360.0); hue /= 60.0; ii = (int)hue; f = hue - (double)ii; p = (1.0 - s) * v; q = (1.0 - (s * f)) * v; t = (1.0 - (s * (1.0 - f))) * v; if (ii == 0) { red = v; green = t; blue = p; } else if (ii == 1) { red = q; green = v; blue = p; } else if (ii == 2) { red = p; green = v; blue = t; } else if (ii == 3) { red = p; green = q; blue = v; } else if (ii == 4) { red = t; green = p; blue = v; } else if (ii == 5) { red = v; green = p; blue = q; } *dest++ = (uch)(red * 255.0); *dest++ = (uch)(green * 255.0); *dest++ = (uch)(blue * 255.0); } } } } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 2.7766039853544644, 2.636390087292115, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 2.7538500330284577, -0.26569807294376846, -0.7092182376352943, -0.917450412529964, -0.518115519420462, 0.0, 19.317019236611124, 0.417570182313826, 4.294708865606808, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void gp_rgba16(Pixel *p, png_const_voidp pb) { png_const_uint_16p pp = voidcast(png_const_uint_16p, pb); p->r = pp[0]; p->g = pp[1]; p->b = pp[2]; p->a = pp[3]; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void PNGCBAPI png_debug_free(png_structp png_ptr, png_voidp ptr) { if (png_ptr == NULL) fprintf(STDERR, "NULL pointer to png_debug_free.\n"); if (ptr == 0) { #if 0 fprintf(STDERR, "WARNING: freeing NULL pointer\n"); #endif return; } { memory_infop FAR *ppinfo = &pinformation; for (;;) { memory_infop pinfo = *ppinfo; if (pinfo->pointer == ptr) { *ppinfo = pinfo->next; current_allocation -= pinfo->size; if (current_allocation < 0) fprintf(STDERR, "Duplicate free of memory\n"); png_memset(ptr, 0x55, pinfo->size); png_free_default(png_ptr, pinfo); pinfo = NULL; break; } if (pinfo->next == NULL) { fprintf(STDERR, "Pointer %x not found\n", (unsigned int)ptr); break; } ppinfo = &pinfo->next; } } if (verbose) printf("Freeing %p\n", ptr); png_free_default(png_ptr, ptr); ptr = NULL; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.34210700232091185, 0.16805247409860422, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.19653218530153962, 0.35306556693537716, 0.1300712967656257, -0.7880534307994381, -0.518115519420462, 0.0, 0.02378964451747194, 0.9973611507722091, 0.00858650477927287, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, PSTR cmd, int showmode) { char *args[1024]; char *p, *q, **argv = args; int argc = 0; int rc, alen, flen; int error = 0; int have_bg = FALSE; double LUT_exponent; double CRT_exponent = 2.2; double default_display_exponent; MSG msg; filename = (char *)NULL; #ifndef __CYGWIN__ AllocConsole(); freopen("CONOUT$", "a", stderr); freopen("CONOUT$", "a", stdout); #endif #if defined(NeXT) LUT_exponent = 1.0 / 2.2; #elif defined(sgi) LUT_exponent = 1.0 / 1.7; infile = fopen("/etc/config/system.glGammaVal", "r"); if (infile) { double sgi_gamma; fgets(tmpline, 80, infile); fclose(infile); sgi_gamma = atof(tmpline); if (sgi_gamma > 0.0) LUT_exponent = 1.0 / sgi_gamma; } #elif defined(Macintosh) LUT_exponent = 1.8 / 2.61; #else LUT_exponent = 1.0; #endif default_display_exponent = LUT_exponent * CRT_exponent; if ((p = getenv("SCREEN_GAMMA")) != NULL) display_exponent = atof(p); else display_exponent = default_display_exponent; argv[argc++] = PROGNAME; p = cmd; for (;;) { if (*p == ' ') while (*++p == ' ') ; if (*p == '\0') break; argv[argc++] = q = p; while (*q && *q != ' ') ++q; if (*q == '\0') break; *q = '\0'; p = q + 1; } argv[argc] = NULL; while (*++argv && !error) { if (!strncmp(*argv, "-gamma", 2)) { if (!*++argv) ++error; else { display_exponent = atof(*argv); if (display_exponent <= 0.0) ++error; } } else if (!strncmp(*argv, "-bgcolor", 2)) { if (!*++argv) ++error; else { bgstr = *argv; if (strlen(bgstr) != 7 || bgstr[0] != '#') ++error; else have_bg = TRUE; } } else { if (**argv != '-') { filename = *argv; if (argv[1]) ++error; } else ++error; } } if (!filename) ++error; if (error) { #ifndef __CYGWIN__ int ch; #endif fprintf(stderr, "\n%s %s: %s\n\n", PROGNAME, VERSION, appname); readpng_version_info(); fprintf(stderr, "\n" "Usage: %s [-gamma exp] [-bgcolor bg] file.png\n" " exp \ttransfer-function exponent (``gamma'') of the display\n" "\t\t system in floating-point format (e.g., ``%.1f''); equal\n" "\t\t to the product of the lookup-table exponent (varies)\n" "\t\t and the CRT exponent (usually 2.2); must be positive\n" " bg \tdesired background color in 7-character hex RGB format\n" "\t\t (e.g., ``#ff7700'' for orange: same as HTML colors);\n" "\t\t used with transparent images\n" "\nPress Q, Esc or mouse button 1 after image is displayed to quit.\n" #ifndef __CYGWIN__ "Press Q or Esc to quit this usage screen.\n" #endif "\n", PROGNAME, default_display_exponent); #ifndef __CYGWIN__ do ch = _getch(); while (ch != 'q' && ch != 'Q' && ch != 0x1B); #endif exit(1); } if (!(infile = fopen(filename, "rb"))) { fprintf(stderr, PROGNAME ": can't open PNG file [%s]\n", filename); ++error; } else { if ((rc = readpng_init(infile, &image_width, &image_height)) != 0) { switch (rc) { case 1: fprintf(stderr, PROGNAME ": [%s] is not a PNG file: incorrect signature\n", filename); break; case 2: fprintf(stderr, PROGNAME ": [%s] has bad IHDR (libpng longjmp)\n", filename); break; case 4: fprintf(stderr, PROGNAME ": insufficient memory\n"); break; default: fprintf(stderr, PROGNAME ": unknown readpng_init() error\n"); break; } ++error; } if (error) fclose(infile); } if (error) { #ifndef __CYGWIN__ int ch; #endif fprintf(stderr, PROGNAME ": aborting.\n"); #ifndef __CYGWIN__ do ch = _getch(); while (ch != 'q' && ch != 'Q' && ch != 0x1B); #endif exit(2); } else { fprintf(stderr, "\n%s %s: %s\n", PROGNAME, VERSION, appname); #ifndef __CYGWIN__ fprintf(stderr, "\n [console window: closing this window will terminate %s]\n\n", PROGNAME); #endif } alen = strlen(appname); flen = strlen(filename); if (alen + flen + 3 > 1023) sprintf(titlebar, "%s: ...%s", appname, filename+(alen+flen+6-1023)); else sprintf(titlebar, "%s: %s", appname, filename); if (have_bg) { unsigned r, g, b; sscanf(bgstr+1, "%2x%2x%2x", &r, &g, &b); bg_red = (uch)r; bg_green = (uch)g; bg_blue = (uch)b; } else if (readpng_get_bgcolor(&bg_red, &bg_green, &bg_blue) > 1) { readpng_cleanup(TRUE); fprintf(stderr, PROGNAME ": libpng error while checking for background color\n"); exit(2); } if (rpng_win_create_window(hInst, showmode)) exit(2); Trace((stderr, "calling readpng_get_image()\n")) image_data = readpng_get_image(display_exponent, &image_channels, &image_rowbytes); Trace((stderr, "done with readpng_get_image()\n")) readpng_cleanup(FALSE); fclose(infile); if (!image_data) { fprintf(stderr, PROGNAME ": unable to decode PNG image\n"); exit(3); } Trace((stderr, "calling rpng_win_display_image()\n")) if (rpng_win_display_image()) { free(image_data); exit(4); } Trace((stderr, "done with rpng_win_display_image()\n")) printf( #ifndef __CYGWIN__ "Done. Press Q, Esc or mouse button 1 (within image window) to quit.\n" #else "Done. Press mouse button 1 (within image window) to quit.\n" #endif ); fflush(stdout); while (GetMessage(&msg, NULL, 0, 0)) { TranslateMessage(&msg); DispatchMessage(&msg); } rpng_win_cleanup(); return msg.wParam; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 6.428349459904793, 3.82800134883381, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 4.323113257769975, 4.99379286602897, 3.2221906340321733, -0.6586564490689124, -0.518115519420462, 0.0, 2.669718274290316, 12.593180519939871, 2.92455499616194, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void buffer_destroy(struct buffer *buffer) { struct buffer_list *list = buffer->first.next; buffer_init(buffer); buffer_destroy_list(list); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.3070243011888601, -0.22049944857796966, -0.21702784222394986, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_palette_to_rgb_mod(PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp, PNG_CONST transform_display *display) { if (that->colour_type == PNG_COLOR_TYPE_PALETTE) image_pixel_convert_PLTE(that); this->next->mod(this->next, that, pp, display); }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>void PNGAPI png_set_unknown_chunks(png_structp png_ptr, png_infop info_ptr, png_const_unknown_chunkp unknowns, int num_unknowns) { png_unknown_chunkp np; int i; if (png_ptr == NULL || info_ptr == NULL || num_unknowns == 0) return; np = (png_unknown_chunkp)png_malloc_warn(png_ptr, (png_size_t)(info_ptr->unknown_chunks_num + num_unknowns) * png_sizeof(png_unknown_chunk)); if (np == NULL) { png_warning(png_ptr, "Out of memory while processing unknown chunk"); return; } png_memcpy(np, info_ptr->unknown_chunks, (png_size_t)info_ptr->unknown_chunks_num * png_sizeof(png_unknown_chunk)); png_free(png_ptr, info_ptr->unknown_chunks); info_ptr->unknown_chunks = NULL; for (i = 0; i < num_unknowns; i++) { png_unknown_chunkp to = np + info_ptr->unknown_chunks_num + i; png_const_unknown_chunkp from = unknowns + i; png_memcpy(to->name, from->name, png_sizeof(from->name)); to->name[png_sizeof(to->name)-1] = '\0'; to->size = from->size; to->location = (png_byte)(png_ptr->mode & 0xff); if (from->size == 0) to->data=NULL; else { to->data = (png_bytep)png_malloc_warn(png_ptr, (png_size_t)from->size); if (to->data == NULL) { png_warning(png_ptr, "Out of memory while processing unknown chunk"); to->size = 0; } else png_memcpy(to->data, from->data, from->size); } } info_ptr->unknown_chunks = np; info_ptr->unknown_chunks_num += num_unknowns; info_ptr->free_me |= PNG_FREE_UNKN; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 1.863667616716882, 0.3595614268463766, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.5646309664137475, 1.8999746666332415, 0.39511009710275835, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.18424725727220465, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>BOOL png2pnm (FILE *png_file, FILE *pnm_file, FILE *alpha_file, volatile BOOL raw, BOOL alpha) { png_struct *png_ptr = NULL; png_info *info_ptr = NULL; png_byte buf[8]; png_byte *png_pixels = NULL; png_byte **row_pointers = NULL; png_byte *pix_ptr = NULL; png_uint_32 row_bytes; png_uint_32 width; png_uint_32 height; int bit_depth; int channels; int color_type; int alpha_present; int row, col; int ret; int i; long dep_16; ret = fread (buf, 1, 8, png_file); if (ret != 8) return FALSE; ret = png_sig_cmp (buf, 0, 8); if (ret) return FALSE; png_ptr = png_create_read_struct (png_get_libpng_ver(NULL), NULL, NULL, NULL); if (!png_ptr) return FALSE; info_ptr = png_create_info_struct (png_ptr); if (!info_ptr) { png_destroy_read_struct (&png_ptr, NULL, NULL); return FALSE; } if (setjmp (png_jmpbuf(png_ptr))) { png_destroy_read_struct (&png_ptr, &info_ptr, NULL); return FALSE; } png_init_io (png_ptr, png_file); png_set_sig_bytes (png_ptr, 8); png_read_info (png_ptr, info_ptr); png_get_IHDR (png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, NULL, NULL, NULL); if (color_type == PNG_COLOR_TYPE_PALETTE) png_set_expand (png_ptr); if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8) png_set_expand (png_ptr); if (png_get_valid (png_ptr, info_ptr, PNG_INFO_tRNS)) png_set_expand (png_ptr); #ifdef NJET if (bit_depth == 16) png_set_strip_16 (png_ptr); if (color_type == PNG_COLOR_TYPE_GRAY || color_type == PNG_COLOR_TYPE_GRAY_ALPHA) png_set_gray_to_rgb (png_ptr); if (png_get_gAMA (png_ptr, info_ptr, &file_gamma)) png_set_gamma (png_ptr, (double) 2.2, file_gamma); #endif png_read_update_info (png_ptr, info_ptr); png_get_IHDR (png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, NULL, NULL, NULL); if (bit_depth == 16) { raw = FALSE; #ifdef __TURBOC__ pnm_file->flags &= ~((unsigned) _F_BIN); #endif } if (color_type == PNG_COLOR_TYPE_GRAY) channels = 1; else if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA) channels = 2; else if (color_type == PNG_COLOR_TYPE_RGB) channels = 3; else if (color_type == PNG_COLOR_TYPE_RGB_ALPHA) channels = 4; else channels = 0; alpha_present = (channels - 1) % 2; if (alpha && !alpha_present) { fprintf (stderr, "PNG2PNM\n"); fprintf (stderr, "Error: PNG-file doesn't contain alpha channel\n"); exit (1); } row_bytes = png_get_rowbytes (png_ptr, info_ptr); if ((png_pixels = (png_byte *) malloc (row_bytes * height * sizeof (png_byte))) == NULL) { png_destroy_read_struct (&png_ptr, &info_ptr, NULL); return FALSE; } if ((row_pointers = (png_byte **) malloc (height * sizeof (png_bytep))) == NULL) { png_destroy_read_struct (&png_ptr, &info_ptr, NULL); free (png_pixels); png_pixels = NULL; return FALSE; } for (i = 0; i < ((int) height); i++) row_pointers[i] = png_pixels + i * row_bytes; png_read_image (png_ptr, row_pointers); png_read_end (png_ptr, info_ptr); png_destroy_read_struct (&png_ptr, &info_ptr, (png_infopp) NULL); if ((color_type == PNG_COLOR_TYPE_GRAY) || (color_type == PNG_COLOR_TYPE_GRAY_ALPHA)) { fprintf (pnm_file, "%s\n", (raw) ? "P5" : "P2"); fprintf (pnm_file, "%d %d\n", (int) width, (int) height); fprintf (pnm_file, "%ld\n", ((1L << (int) bit_depth) - 1L)); } else if ((color_type == PNG_COLOR_TYPE_RGB) || (color_type == PNG_COLOR_TYPE_RGB_ALPHA)) { fprintf (pnm_file, "%s\n", (raw) ? "P6" : "P3"); fprintf (pnm_file, "%d %d\n", (int) width, (int) height); fprintf (pnm_file, "%ld\n", ((1L << (int) bit_depth) - 1L)); } if ((alpha) && ((color_type == PNG_COLOR_TYPE_GRAY_ALPHA) || (color_type == PNG_COLOR_TYPE_RGB_ALPHA))) { fprintf (alpha_file, "%s\n", (raw) ? "P5" : "P2"); fprintf (alpha_file, "%d %d\n", (int) width, (int) height); fprintf (alpha_file, "%ld\n", ((1L << (int) bit_depth) - 1L)); } pix_ptr = png_pixels; for (row = 0; row < (int) height; row++) { for (col = 0; col < (int) width; col++) { for (i = 0; i < (channels - alpha_present); i++) { if (raw) fputc ((int) *pix_ptr++ , pnm_file); else if (bit_depth == 16){ dep_16 = (long) *pix_ptr++; fprintf (pnm_file, "%ld ", (dep_16 << 8) + ((long) *pix_ptr++)); } else fprintf (pnm_file, "%ld ", (long) *pix_ptr++); } if (alpha_present) { if (!alpha) { pix_ptr++; if (bit_depth == 16) pix_ptr++; } else { if (raw) fputc ((int) *pix_ptr++ , alpha_file); else if (bit_depth == 16){ dep_16 = (long) *pix_ptr++; fprintf (alpha_file, "%ld ", (dep_16 << 8) + (long) *pix_ptr++); } else fprintf (alpha_file, "%ld ", (long) *pix_ptr++); } } if (!raw) if (col % 4 == 3) fprintf (pnm_file, "\n"); } if (!raw) if (col % 4 != 0) fprintf (pnm_file, "\n"); } if (row_pointers != (unsigned char**) NULL) free (row_pointers); if (png_pixels != (unsigned char*) NULL) free (png_pixels); return TRUE; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 3.6895403539920464, 3.1896381730079018, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 3.3738058749016497, 3.292192856361319, 3.067584667168846, -0.917450412529964, -0.518115519420462, 0.0, 1.1262599069228236, 2.1569430876889752, 2.6434977921732496, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
1<SPLIT>png_charp png_decompress_chunk(png_structp png_ptr, int comp_type, png_charp chunkdata, png_size_t chunklength, png_size_t prefix_size, png_size_t *newlength) { static char msg[] = "Error decoding compressed text"; png_charp text; png_size_t text_size; if (comp_type == PNG_COMPRESSION_TYPE_BASE) { int ret = Z_OK; png_ptr->zstream.next_in = (png_bytep)(chunkdata + prefix_size); png_ptr->zstream.avail_in = (uInt)(chunklength - prefix_size); png_ptr->zstream.next_out = png_ptr->zbuf; png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size; text_size = 0; text = NULL; while (png_ptr->zstream.avail_in) { ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH); if (ret != Z_OK && ret != Z_STREAM_END) { if (png_ptr->zstream.msg != NULL) png_warning(png_ptr, png_ptr->zstream.msg); else png_warning(png_ptr, msg); inflateReset(&png_ptr->zstream); png_ptr->zstream.avail_in = 0; if (text == NULL) { text_size = prefix_size + png_sizeof(msg) + 1; text = (png_charp)png_malloc_warn(png_ptr, text_size); if (text == NULL) { png_free(png_ptr,chunkdata); png_error(png_ptr,"Not enough memory to decompress chunk"); } png_memcpy(text, chunkdata, prefix_size); } text[text_size - 1] = 0x00; text_size = (png_size_t)(chunklength - (text - chunkdata) - 1); text_size = png_sizeof(msg) > text_size ? text_size : png_sizeof(msg); png_memcpy(text + prefix_size, msg, text_size + 1); break; } if (!png_ptr->zstream.avail_out || ret == Z_STREAM_END) { if (text == NULL) { text_size = prefix_size + png_ptr->zbuf_size - png_ptr->zstream.avail_out; text = (png_charp)png_malloc_warn(png_ptr, text_size + 1); if (text == NULL) { png_free(png_ptr,chunkdata); png_error(png_ptr,"Not enough memory to decompress chunk."); } png_memcpy(text + prefix_size, png_ptr->zbuf, text_size - prefix_size); png_memcpy(text, chunkdata, prefix_size); *(text + text_size) = 0x00; } else { png_charp tmp; tmp = text; text = (png_charp)png_malloc_warn(png_ptr, (png_uint_32)(text_size + png_ptr->zbuf_size - png_ptr->zstream.avail_out + 1)); if (text == NULL) { png_free(png_ptr, tmp); png_free(png_ptr, chunkdata); png_error(png_ptr,"Not enough memory to decompress chunk.."); } png_memcpy(text, tmp, text_size); png_free(png_ptr, tmp); png_memcpy(text + text_size, png_ptr->zbuf, (png_ptr->zbuf_size - png_ptr->zstream.avail_out)); text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out; *(text + text_size) = 0x00; } if (ret == Z_STREAM_END) break; else { png_ptr->zstream.next_out = png_ptr->zbuf; png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size; } } } if (ret != Z_STREAM_END) { #if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE) char umsg[50]; if (ret == Z_BUF_ERROR) sprintf(umsg,"Buffer error in compressed datastream in %s chunk", png_ptr->chunk_name); else if (ret == Z_DATA_ERROR) sprintf(umsg,"Data error in compressed datastream in %s chunk", png_ptr->chunk_name); else sprintf(umsg,"Incomplete compressed datastream in %s chunk", png_ptr->chunk_name); png_warning(png_ptr, umsg); #else png_warning(png_ptr, "Incomplete compressed datastream in chunk other than IDAT"); #endif text_size=prefix_size; if (text == NULL) { text = (png_charp)png_malloc_warn(png_ptr, text_size+1); if (text == NULL) { png_free(png_ptr, chunkdata); png_error(png_ptr,"Not enough memory for text."); } png_memcpy(text, chunkdata, prefix_size); } *(text + text_size) = 0x00; } inflateReset(&png_ptr->zstream); png_ptr->zstream.avail_in = 0; png_free(png_ptr, chunkdata); chunkdata = text; *newlength=text_size; } else { #if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE) char umsg[50]; sprintf(umsg, "Unknown zTXt compression type %d", comp_type); png_warning(png_ptr, umsg); #else png_warning(png_ptr, "Unknown zTXt compression type"); #endif *(chunkdata + prefix_size) = 0x00; *newlength=prefix_size; } return chunkdata; }<SPLIT>[1.9113408089114425, 2.4920118880053392, 0.0, 1.863667616716882, 2.3597660444342217, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 2.506228716061805, 1.9492988439508436, 2.392592158685165, 0.0, 0.0, 0.30852482215402843, 2.38575125191625, 1.8999746666332415, 2.250381699462687, 0.7647103499668715, 0.13958259121676436, 0.0, 0.24428369699854227, 3.8963159930641242, 1.7651940297085906, 0.23792492798410134, 0.5697541257882794, -0.21702784222394986, -0.04111270872174079, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 2.6191065950439585, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static int process_iTXt(struct file *file) { struct chunk *chunk = file->chunk; png_uint_32 length; png_uint_32 index = 0; assert(chunk != NULL && file->idat == NULL); length = chunk->chunk_length; setpos(chunk); while (length >= 5) { --length; ++index; if (reread_byte(file) == 0) { --length; ++index; if (reread_byte(file) == 0) return 1; --length; ++index; (void)reread_byte(file); while (length >= 9) { --length; ++index; if (reread_byte(file) == 0) { while (length >= 8) { --length; ++index; if (reread_byte(file) == 0) return zlib_check(file, index); } } } break; } } log_error(file, INVALID_ERROR_CODE, "iTXt chunk length"); return 0; }<SPLIT>[0.36491818514653585, 0.2883525511454664, 0.0, 0.34210700232091185, 0.21061001915366473, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.3085515823163217, 0.3762494122151511, 0.3184400606733766, 0.0, 0.0, 0.30852482215402843, 0.23527942541861413, 0.35306556693537716, 0.24050413023943099, 0.11772544131424245, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.07885080577644558, -0.08904460951967552, 0.23107402248845843, -0.21702784222394986, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_scale_16_mod(PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp, PNG_CONST transform_display *display) { if (that->bit_depth == 16) { that->sample_depth = that->bit_depth = 8; if (that->red_sBIT > 8) that->red_sBIT = 8; if (that->green_sBIT > 8) that->green_sBIT = 8; if (that->blue_sBIT > 8) that->blue_sBIT = 8; if (that->alpha_sBIT > 8) that->alpha_sBIT = 8; } this->next->mod(this->next, that, pp, display); }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int test_standard(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type, int bdlo, int PNG_CONST bdhi) { for (; bdlo <= bdhi; ++bdlo) { int interlace_type; for (interlace_type = PNG_INTERLACE_NONE; interlace_type < INTERLACE_LAST; ++interlace_type) { standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0, interlace_type, 0, 0, 0), 0, pm->use_update_info); if (fail(pm)) return 0; } } return 1; }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.3615192241061562, -0.22049944857796966, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static double outerr(PNG_CONST png_modifier *pm, int in_depth, int out_depth) { if (out_depth == 2) return .73182-.5; if (out_depth == 4) return .90644-.5; if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16) return pm->maxout16; else if (out_depth == 16) return pm->maxout8 * 257; else return pm->maxout8; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 1.2550433709584938, -0.406474384144713, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.21031383592774278, 1.281211026754096, -0.4000063039086396, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void PNGCBAPI store_flush(png_structp ppIn) { UNUSED(ppIn) }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6940565051924542, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>LRESULT CALLBACK rpng_win_wndproc(HWND hwnd, UINT iMsg, WPARAM wP, LPARAM lP) { HDC hdc; PAINTSTRUCT ps; int rc; switch (iMsg) { case WM_CREATE: return 0; case WM_PAINT: hdc = BeginPaint(hwnd, &ps); rc = StretchDIBits(hdc, 0, 0, image_width, image_height, 0, 0, image_width, image_height, wimage_data, (BITMAPINFO *)bmih, 0, SRCCOPY); EndPaint(hwnd, &ps); return 0; case WM_CHAR: switch (wP) { case 'q': case 'Q': case 0x1B: PostQuitMessage(0); } return 0; case WM_LBUTTONDOWN: case WM_DESTROY: PostQuitMessage(0); return 0; } return DefWindowProc(hwnd, iMsg, wP, lP); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.4942630637605089, -0.02345647864916818, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.04154322483324156, 0.5077564769051636, -0.0024481034029406237, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>BOOL SearchPngList (TCHAR *pFileList, int FileCount, int *pFileIndex, PTSTR pstrPrevName, PTSTR pstrNextName) { if (FileCount > 0) { if (pstrPrevName != NULL) { if (*pFileIndex > 0) *pFileIndex -= 1; else *pFileIndex = FileCount - 1; strcpy (pstrPrevName, pFileList + (*pFileIndex * MAX_PATH)); } if (pstrNextName != NULL) { if (*pFileIndex < FileCount - 1) *pFileIndex += 1; else *pFileIndex = 0; strcpy (pstrNextName, pFileList + (*pFileIndex * MAX_PATH)); } return TRUE; } else { return FALSE; } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.34210700232091185, 0.4659552894840279, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.4677628661210612, 0.35306556693537716, 0.5055429305765636, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void buffer_read(struct display *dp, struct buffer *bp, png_bytep data, png_size_t size) { struct buffer_list *last = bp->current; size_t read_count = bp->read_count; while (size > 0) { size_t avail; if (last == NULL || (last == bp->last && read_count >= bp->end_count)) { display_log(dp, USER_ERROR, "file truncated (%lu bytes)", (unsigned long)size); break; } else if (read_count >= sizeof last->buffer) { last = last->next; read_count = 0; bp->current = last; if (last == NULL) { display_log(dp, INTERNAL_ERROR, "damaged buffer list"); break; } } avail = (sizeof last->buffer) - read_count; if (avail > size) avail = size; memcpy(data, last->buffer + read_count, avail); read_count += avail; size -= avail; data += avail; } bp->read_count = read_count; }<SPLIT>[0.36491818514653585, 0.15613299093387398, 0.0, 0.34210700232091185, 0.08293738398848315, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.18867828411202256, 0.3762494122151511, 0.18168277948578615, 0.0, 0.0, 0.30852482215402843, 0.11903770506739059, 0.35306556693537716, 0.10798473007086465, -0.011671540416283347, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.25252937827156396, 0.11818065472185141, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void store_pool_mark(png_bytep mark) { static png_uint_32 store_seed[2] = { 0x12345678, 1}; make_four_random_bytes(store_seed, mark); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static size_t load_file(png_const_charp name, png_bytepp result) { FILE *fp = tmpfile(); if (fp != NULL) { FILE *ip = fopen(name, "rb"); if (ip != NULL) { size_t total = 0; int ch; for (;;) { ch = getc(ip); if (ch == EOF) break; putc(ch, fp); ++total; } if (ferror(ip)) { perror(name); fprintf(stderr, "%s: read error\n", name); (void)fclose(ip); } else { (void)fclose(ip); if (ferror(fp)) { perror("temporary file"); fprintf(stderr, "temporary file write error\n"); } else { rewind(fp); if (total > 0) { png_bytep data = malloc((total+3)&~3); if (data != NULL) { size_t new_size = 0; for (;;) { ch = getc(fp); if (ch == EOF) break; data[new_size++] = (png_byte)ch; } if (ferror(fp) || new_size != total) { perror("temporary file"); fprintf(stderr, "temporary file read error\n"); free(data); } else { (void)fclose(fp); *result = data; return total; } } else fprintf(stderr, "%s: out of memory loading file\n", name); } else fprintf(stderr, "%s: empty file\n", name); } } } else { perror(name); fprintf(stderr, "%s: open failed\n", name); } fclose(fp); } else fprintf(stderr, "makepng: %s: could not open temporary file\n", name); exit(1); return 0; }<SPLIT>[0.21027592277004517, 1.1037065057836193, 0.0, 0.18995094088131478, 0.9979246026722846, 0.0, 1.49154691857982, 1.5248365532563304, 1.403457588528521, 3.34883199341858, 1.0277913715421163, 0.21894446904158188, 1.1617766279968509, 0.0, 0.0, 0.30852482215402843, 0.9327297475259554, 0.19837465696559078, 1.05770709794559, 1.0235043134279231, 1.78382786780983, 0.0, -0.08645738172306322, -0.16222078614455715, 0.6409652137538272, 1.4913081550819125, 0.7955408613214935, 7.87240433722263, 1.081736556722408, 1.4908334503424332, 1.524213968415457, 1.4027960089845035, 3.347841778661945, 6.046058369993668, 0.0, 1.4859135779729586, 1.519259814762923, 1.3979248575624994, 3.339696410076628]
0<SPLIT>static png_structp set_store_for_write(png_store *ps, png_infopp ppi, PNG_CONST char * volatile name) { anon_context(ps); Try { if (ps->pwrite != NULL) png_error(ps->pwrite, "write store already in use"); store_write_reset(ps); safecat(ps->wname, sizeof ps->wname, 0, name); #ifdef PNG_USER_MEM_SUPPORTED if (!ps->speed) ps->pwrite = png_create_write_struct_2(PNG_LIBPNG_VER_STRING, ps, store_error, store_warning, &ps->write_memory_pool, store_malloc, store_free); else #endif ps->pwrite = png_create_write_struct(png_get_libpng_ver(NULL), ps, store_error, store_warning); png_set_write_fn(ps->pwrite, ps, store_write, store_flush); #ifdef PNG_SET_OPTION_SUPPORTED { int opt; for (opt=0; opt<ps->noptions; ++opt) if (png_set_option(ps->pwrite, ps->options[opt].option, ps->options[opt].setting) == PNG_OPTION_INVALID) png_error(ps->pwrite, "png option invalid"); } #endif if (ppi != NULL) *ppi = ps->piwrite = png_create_info_struct(ps->pwrite); } Catch_anonymous return NULL; return ps->pwrite; }<SPLIT>[0.21027592277004517, 0.15613299093387398, 0.0, 0.18995094088131478, 0.08293738398848315, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.1686994010779727, 0.21894446904158188, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, 0.09966408500885333, 0.19837465696559078, -0.24540033704531222, -0.6586564490689124, -0.518115519420462, 0.0, 1.2365069331633587, 2.1569430876889752, -0.20220639821224526, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void randomize(void *pv, size_t size) { static png_uint_32 random_seed[2] = {0x56789abc, 0xd}; make_random_bytes(random_seed, pv, size); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void store_delete(png_store *ps) { store_write_reset(ps); store_read_reset(ps); store_freefile(&ps->saved); store_image_free(ps, NULL); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.4705090699407485, -0.3333928163445767, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int png_row_in_interlace_pass(png_uint_32 y, int pass) { int x; y &= 7; ++pass; for (x=0; x<8; ++x) if (adam7[y][x] == pass) return 1; return 0; }<SPLIT>[-0.09900860198293619, -0.43885503001829174, 0.0, -0.11436118199787926, -0.491589474254834, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.41068820690947294, -0.09566541730555662, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.11100716297398205, -0.48835257068768384, -0.6586564490689124, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.25252937827156396, -0.6720729196443977, -0.21702784222394986, 0.14602883551895066, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static chunk_insert * make_insert(png_const_charp what, void (*insert)(png_structp, png_infop, int, png_charpp), int nparams, png_charpp list) { int i; chunk_insert *cip; cip = malloc(offsetof(chunk_insert,parameters) + nparams * sizeof (png_charp)); if (cip == NULL) { fprintf(stderr, "--insert %s: out of memory allocating %d parameters\n", what, nparams); exit(1); } cip->next = NULL; cip->insert = insert; cip->nparams = nparams; for (i=0; i<nparams; ++i) cip->parameters[i] = list[i]; return cip; }<SPLIT>[-0.25365086435942685, -0.17441590959510697, 0.0, -0.2665172434374763, -0.23624420392447085, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1909204935349246, -0.25297036047912586, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.26569807294376846, -0.22331377035055117, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.3070243011888601, -0.22049944857796966, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void image_pixel_init(image_pixel *this, png_const_bytep row, png_byte colour_type, png_byte bit_depth, png_uint_32 x, store_palette palette) { PNG_CONST png_byte sample_depth = (png_byte)(colour_type == PNG_COLOR_TYPE_PALETTE ? 8 : bit_depth); PNG_CONST unsigned int max = (1U<<sample_depth)-1; this->palette_index = this->red = this->green = this->blue = sample(row, colour_type, bit_depth, x, 0); this->alpha = max; this->red_sBIT = this->green_sBIT = this->blue_sBIT = this->alpha_sBIT = sample_depth; if (colour_type == 3) { if (palette != 0) { PNG_CONST unsigned int i = this->palette_index; this->red = palette[i].red; this->green = palette[i].green; this->blue = palette[i].blue; this->alpha = palette[i].alpha; } } else { unsigned int i = 0; if (colour_type & 2) { this->green = sample(row, colour_type, bit_depth, x, 1); this->blue = sample(row, colour_type, bit_depth, x, 2); i = 2; } if (colour_type & 4) this->alpha = sample(row, colour_type, bit_depth, x, ++i); } image_pixel_setf(this, max); this->colour_type = colour_type; this->bit_depth = bit_depth; this->sample_depth = sample_depth; this->have_tRNS = 0; }<SPLIT>[1.7566985465349518, 0.24427936440826892, 0.0, 1.7115115552772848, 0.16805247409860422, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.44840376355467065, 1.7919939007772745, 0.2728543002775131, 0.0, 0.0, 0.30852482215402843, 0.37089476582837494, 1.7452837566634551, 0.19633099684990887, -0.270465503877335, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, -0.3070243011888601, -0.4462861841111837, -0.21702784222394986, -0.13468348084208653, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void rpng2_win_cleanup() { if (bg_image && bg_data) { free(bg_data); bg_data = NULL; } if (rpng2_info.image_data) { free(rpng2_info.image_data); rpng2_info.image_data = NULL; } if (rpng2_info.row_pointers) { free(rpng2_info.row_pointers); rpng2_info.row_pointers = NULL; } if (dib) { free(dib); dib = NULL; } }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.41601414702345235, -0.6720729196443977, -0.21702784222394986, -0.13468348084208653, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static int is_bad_combo(int transforms) { unsigned int i; for (i=0; i<ARRAY_SIZE(known_bad_combos); ++i) { int combo = known_bad_combos[i][0]; if ((combo & transforms) == combo && (transforms & known_bad_combos[i][1]) == 0) return 1; } return 0; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.39986248560786075, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.1980344553542678, -0.4462861841111837, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>int validation_gamma(int argc, char **argv) { double gamma[9] = { 2.2, 1.8, 1.52, 1.45, 1., 1/1.45, 1/1.52, 1/1.8, 1/2.2 }; double maxerr; int i, silent=0, onlygamma=0; while (--argc > 0) if (strcmp(*++argv, "-s") == 0) silent = 1; else if (strcmp(*argv, "-g") == 0) onlygamma = 1; else { fprintf(stderr, "unknown argument %s\n", *argv); return 1; } if (!onlygamma) { maxerr = 0; for (i=0; i<256; ++i) { double correct = -log(i/255.)/log(2.)*65536; double error = png_log8bit(i) - correct; if (i != 0 && fabs(error) > maxerr) maxerr = fabs(error); if (i == 0 && png_log8bit(i) != 0xffffffff || i != 0 && png_log8bit(i) != floor(correct+.5)) { fprintf(stderr, "8 bit log error: %d: got %u, expected %f\n", i, png_log8bit(i), correct); } } if (!silent) printf("maximum 8 bit log error = %f\n", maxerr); maxerr = 0; for (i=0; i<65536; ++i) { double correct = -log(i/65535.)/log(2.)*65536; double error = png_log16bit(i) - correct; if (i != 0 && fabs(error) > maxerr) maxerr = fabs(error); if (i == 0 && png_log16bit(i) != 0xffffffff || i != 0 && png_log16bit(i) != floor(correct+.5)) { if (error > .68) { fprintf(stderr, "16 bit log error: %d: got %u, expected %f" " error: %f\n", i, png_log16bit(i), correct, error); } } } if (!silent) printf("maximum 16 bit log error = %f\n", maxerr); maxerr = 0; for (i=0; i<=0xfffff; ++i) { double correct = exp(-i/65536. * log(2.)) * (65536. * 65536); double error = png_exp(i) - correct; if (fabs(error) > maxerr) maxerr = fabs(error); if (fabs(error) > 1883) { fprintf(stderr, "32 bit exp error: %d: got %u, expected %f" " error: %f\n", i, png_exp(i), correct, error); } } if (!silent) printf("maximum 32 bit exp error = %f\n", maxerr); maxerr = 0; for (i=0; i<=0xfffff; ++i) { double correct = exp(-i/65536. * log(2.)) * 255; double error = png_exp8bit(i) - correct; if (fabs(error) > maxerr) maxerr = fabs(error); if (fabs(error) > .50002) { fprintf(stderr, "8 bit exp error: %d: got %u, expected %f" " error: %f\n", i, png_exp8bit(i), correct, error); } } if (!silent) printf("maximum 8 bit exp error = %f\n", maxerr); maxerr = 0; for (i=0; i<=0xfffff; ++i) { double correct = exp(-i/65536. * log(2.)) * 65535; double error = png_exp16bit(i) - correct; if (fabs(error) > maxerr) maxerr = fabs(error); if (fabs(error) > .524) { fprintf(stderr, "16 bit exp error: %d: got %u, expected %f" " error: %f\n", i, png_exp16bit(i), correct, error); } } if (!silent) printf("maximum 16 bit exp error = %f\n", maxerr); } for (i=0; i<9; ++i) { unsigned j; double g = gamma[i]; png_fixed_point gfp = floor(g * PNG_FP_1 + .5); if (!silent) printf("Test gamma %f\n", g); maxerr = 0; for (j=0; j<256; ++j) { double correct = pow(j/255., g) * 255; png_byte out = png_gamma_8bit_correct(j, gfp); double error = out - correct; if (fabs(error) > maxerr) maxerr = fabs(error); if (out != floor(correct+.5)) { fprintf(stderr, "8bit %d ^ %f: got %d expected %f error %f\n", j, g, out, correct, error); } } if (!silent) printf("gamma %f: maximum 8 bit error %f\n", g, maxerr); maxerr = 0; for (j=0; j<65536; ++j) { double correct = pow(j/65535., g) * 65535; png_uint_16 out = png_gamma_16bit_correct(j, gfp); double error = out - correct; if (fabs(error) > maxerr) maxerr = fabs(error); if (fabs(error) > 1.62) { fprintf(stderr, "16bit %d ^ %f: got %d expected %f error %f\n", j, g, out, correct, error); } } if (!silent) printf("gamma %f: maximum 16 bit error %f\n", g, maxerr); } return 0; }<SPLIT>[0.36491818514653585, 2.425902107899543, 0.0, 0.34210700232091185, 2.2959297268516305, 0.0, 5.66258460588309, 5.7666763407092505, 6.710401158162677, 0.7102265412631674, 2.2465032366191573, 0.3762494122151511, 2.5293494398727554, 0.0, 0.0, 0.30852482215402843, 2.1338941911552656, 0.35306556693537716, 2.3829010996312534, 2.317474130733181, 8.141576270636351, 0.0, -0.08645738172306322, 0.417570182313826, 1.8354583307057633, 5.360447682209938, 3.053408216653634, -0.21702784222394986, 6.695982883943151, 5.660803049448467, 5.765174506351841, 6.708434186314772, 0.7098813332246741, 2.6191065950439585, 0.0, 5.650625471993795, 5.754953851690363, 6.696545755492066, 0.7058592275743352]
0<SPLIT>static void image_transform_ini_end(PNG_CONST image_transform *this, transform_display *that) { UNUSED(this) UNUSED(that) }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6940565051924542, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>BOOL BuildPngList (PTSTR pstrPathName, TCHAR **ppFileList, int *pFileCount, int *pFileIndex) { static TCHAR szImgPathName [MAX_PATH]; static TCHAR szImgFileName [MAX_PATH]; static TCHAR szImgFindName [MAX_PATH]; WIN32_FIND_DATA finddata; HANDLE hFind; static TCHAR szTmp [MAX_PATH]; BOOL bOk; int i, ii; int j, jj; if (*ppFileList != NULL) { free (*ppFileList); *ppFileList = NULL; } strcpy (szImgPathName, pstrPathName); strcpy (szImgFileName, strrchr (pstrPathName, '\\') + 1); strcpy (szImgFindName, szImgPathName); *(strrchr (szImgFindName, '\\') + 1) = '\0'; strcat (szImgFindName, "*.png"); *pFileCount = 0; hFind = FindFirstFile(szImgFindName, &finddata); bOk = (hFind != (HANDLE) -1); while (bOk) { *pFileCount += 1; bOk = FindNextFile(hFind, &finddata); } FindClose(hFind); *ppFileList = (TCHAR *) malloc (*pFileCount * MAX_PATH); hFind = FindFirstFile(szImgFindName, &finddata); bOk = (hFind != (HANDLE) -1); i = 0; ii = 0; while (bOk) { strcpy (*ppFileList + ii, szImgPathName); strcpy (strrchr(*ppFileList + ii, '\\') + 1, finddata.cFileName); if (strcmp(pstrPathName, *ppFileList + ii) == 0) *pFileIndex = i; ii += MAX_PATH; i++; bOk = FindNextFile(hFind, &finddata); } FindClose(hFind); for (i = 0; i < *pFileCount - 1; i++) { ii = i * MAX_PATH; for (j = i+1; j < *pFileCount; j++) { jj = j * MAX_PATH; if (strcmp (*ppFileList + ii, *ppFileList + jj) > 0) { strcpy (szTmp, *ppFileList + jj); strcpy (*ppFileList + jj, *ppFileList + ii); strcpy (*ppFileList + ii, szTmp); if (*pFileIndex == i) *pFileIndex = j; else if (*pFileIndex == j) *pFileIndex = i; } } } return TRUE; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.798575186639703, 0.7638581048694516, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.7971144071161946, 0.8171382968447365, 0.8147548643032184, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.9220224177425181, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void check_interlace_type(int PNG_CONST interlace_type) { if (interlace_type != PNG_INTERLACE_NONE) { fprintf(stderr, "pngvalid: no interlace support\n"); exit(99); } }<SPLIT>[0.21027592277004517, -0.46089162338689044, 0.0, 0.18995094088131478, -0.5128682467823643, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, 0.21894446904158188, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, 0.19837465696559078, -0.5104391373824448, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static double outlog(PNG_CONST png_modifier *pm, int in_depth, int out_depth) { if (out_depth <= 8) { if (pm->log8 == 0) return 256; if (out_depth < 8) return pm->log8 / 255 * ((1<<out_depth)-1); return pm->log8; } if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16) { if (pm->log16 == 0) return 65536; return pm->log16; } if (pm->log8 == 0) return 65536; return pm->log8 * 257; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.6464191252001059, -0.2575229764520011, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.152192975752131, 0.66244738687495, -0.24540033704531222, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int logerror(Image *image, const char *a1, const char *a2, const char *a3) { fflush(stdout); if (image->image.warning_or_error) fprintf(stderr, "%s%s%s: %s\n", a1, a2, a3, image->image.message); else fprintf(stderr, "%s%s%s\n", a1, a2, a3); if (image->image.opaque != NULL) { fprintf(stderr, "%s: image opaque pointer non-NULL on error\n", image->file_name); png_image_free(&image->image); } return 0; }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.41601414702345235, -0.4462861841111837, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int image_transform_png_set_palette_to_rgb_add(image_transform *this, PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth) { UNUSED(bit_depth) this->next = *that; *that = this; return colour_type == PNG_COLOR_TYPE_PALETTE; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void modifier_set_encoding(png_modifier *pm) { pm->current_gamma = 0; pm->current_encoding = 0; pm->encoding_ignored = 0; if (pm->encoding_counter > 0) { if (pm->encoding_counter <= pm->ngammas) pm->current_gamma = 1/pm->gammas[pm->encoding_counter-1]; else { unsigned int i = pm->encoding_counter - pm->ngammas; if (i >= pm->nencodings) { i %= pm->nencodings; pm->current_gamma = 1; } else pm->current_gamma = pm->encodings[i].gamma; pm->current_encoding = pm->encodings + i; } } }<SPLIT>[0.9834872346524985, -0.13034272285790952, 0.0, 0.9507312480792999, -0.1936866588694103, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.008868336805573909, 1.0054691849094282, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.05532487545944473, 0.9718292068145229, -0.17914063696102905, -0.6586564490689124, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.3615192241061562, -0.6720729196443977, 1.5806237532086234, -0.22825425296243224, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 1.7623686513065309, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static int perform_one_test(FILE *fp, int nfiles) { int i; struct timespec before, after; rewind(fp); if (mytime(&before)) { for (i=0; i<nfiles; ++i) { if (read_png(fp)) { if (ferror(fp)) { perror("temporary file"); fprintf(stderr, "file %d: error reading PNG data\n", i); return 0; } } else { perror("temporary file"); fprintf(stderr, "file %d: error from libpng\n", i); return 0; } } } else return 0; if (mytime(&after)) { unsigned long s = after.tv_sec - before.tv_sec; long ns = after.tv_nsec - before.tv_nsec; if (ns < 0) { --s; ns += 1000000000; if (ns < 0) { fprintf(stderr, "timepng: bad clock from kernel\n"); return 0; } } printf("%lu.%.9ld\n", s, ns); fflush(stdout); if (ferror(stdout)) { fprintf(stderr, "timepng: error writing output\n"); return 0; } return 1; } else return 0; }<SPLIT>[0.5195604475230265, 0.5307550782000524, 0.0, 0.4942630637605089, 0.4659552894840279, 0.0, 0.9701672076669112, 0.9946065798247155, 0.9059316288753189, 2.3593549488603003, 0.5482981787249199, 0.5335543553887203, 0.5691617428506257, 0.0, 0.0, 0.30852482215402843, 0.4871364861795985, 0.5077564769051636, 0.5055429305765636, 0.7647103499668715, 1.564595164264088, 0.0, -0.08645738172306322, -0.16222078614455715, 0.14911510677361828, 1.273328463412728, 0.7955408613214935, -0.21702784222394986, 1.5495904173241366, 0.969587250454179, 0.9940939011734088, 0.9053924298597907, 2.3586066116229683, 2.6191065950439585, 0.0, 0.9653245912203542, 0.9897980601469931, 0.9011791483816026, 2.352007466638268]
0<SPLIT>static void gama_modification_init(gama_modification *me, png_modifier *pm, double gammad) { double g; modification_init(&me->this); me->this.chunk = CHUNK_gAMA; me->this.modify_fn = gama_modify; me->this.add = CHUNK_PLTE; g = fix(gammad); me->gamma = (png_fixed_point)g; me->this.next = pm->modifications; pm->modifications = &me->this; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void freebuffer(Image *image) { if (image->buffer) free(image->buffer); image->buffer = NULL; image->bufsize = 0; image->allocsize = 0; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static PNG_NORETURN void usage(const char *program, const char *reason) { fprintf(stderr, "pngunknown: %s: usage:\n %s [--strict] --default|{(CHNK|default|all)=(default|discard|if-safe|save)} testfile.png\n", reason, program); exit(99); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void gpc_unpg(Pixel *out, const Pixel *in, const Background *back) { (void)back; if (in->a <= 128) { out->r = out->g = out->b = 255; out->a = 0; } else { out->r = out->g = out->b = sRGB((double)in->g / in->a); out->a = u8d(in->a / 257.); } }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int main(int argc, char *argv[]) { int multiple = 0; int ierror = 0; fprintf(STDERR, "\n Testing libpng version %s\n", PNG_LIBPNG_VER_STRING); fprintf(STDERR, " with zlib version %s\n", ZLIB_VERSION); fprintf(STDERR, "%s", png_get_copyright(NULL)); fprintf(STDERR, " library (%lu):%s", (unsigned long)png_access_version_number(), png_get_header_version(NULL)); fprintf(STDERR, " pngtest (%lu):%s", (unsigned long)PNG_LIBPNG_VER, PNG_HEADER_VERSION_STRING); #if defined(MAXSEG_64K) && !defined(PNG_MAX_MALLOC_64K) fprintf(STDERR, " NOTE: Zlib compiled for max 64k, libpng not\n"); #endif #if !defined(MAXSEG_64K) && defined(PNG_MAX_MALLOC_64K) fprintf(STDERR, " NOTE: libpng compiled for max 64k, zlib not\n"); #endif if (strcmp(png_libpng_ver, PNG_LIBPNG_VER_STRING)) { fprintf(STDERR, "Warning: versions are different between png.h and png.c\n"); fprintf(STDERR, " png.h version: %s\n", PNG_LIBPNG_VER_STRING); fprintf(STDERR, " png.c version: %s\n\n", png_libpng_ver); ++ierror; } if (argc > 1) { if (strcmp(argv[1], "-m") == 0) { multiple = 1; status_dots_requested = 0; } else if (strcmp(argv[1], "-mv") == 0 || strcmp(argv[1], "-vm") == 0 ) { multiple = 1; verbose = 1; status_dots_requested = 1; } else if (strcmp(argv[1], "-v") == 0) { verbose = 1; status_dots_requested = 1; inname = argv[2]; } else { inname = argv[1]; status_dots_requested = 0; } } if (!multiple && argc == 3 + verbose) outname = argv[2 + verbose]; if ((!multiple && argc > 3 + verbose) || (multiple && argc < 2)) { fprintf(STDERR, "usage: %s [infile.png] [outfile.png]\n\t%s -m {infile.png}\n", argv[0], argv[0]); fprintf(STDERR, "reads/writes one PNG file (without -m) or multiple files (-m)\n"); fprintf(STDERR, "with -m %s is used as a temporary file\n", outname); exit(1); } if (multiple) { int i; #if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG int allocation_now = current_allocation; #endif for (i=2; i<argc; ++i) { int kerror; fprintf(STDERR, "\n Testing %s:", argv[i]); kerror = test_one_file(argv[i], outname); if (kerror == 0) { #ifdef PNG_READ_USER_TRANSFORM_SUPPORTED int k; #endif #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED fprintf(STDERR, "\n PASS (%lu zero samples)\n", (unsigned long)zero_samples); #else fprintf(STDERR, " PASS\n"); #endif #ifdef PNG_READ_USER_TRANSFORM_SUPPORTED for (k = 0; k<256; k++) if (filters_used[k]) fprintf(STDERR, " Filter %d was used %lu times\n", k, (unsigned long)filters_used[k]); #endif #ifdef PNG_TIME_RFC1123_SUPPORTED if (tIME_chunk_present != 0) fprintf(STDERR, " tIME = %s\n", tIME_string); tIME_chunk_present = 0; #endif } else { fprintf(STDERR, " FAIL\n"); ierror += kerror; } #if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG if (allocation_now != current_allocation) fprintf(STDERR, "MEMORY ERROR: %d bytes lost\n", current_allocation - allocation_now); if (current_allocation != 0) { memory_infop pinfo = pinformation; fprintf(STDERR, "MEMORY ERROR: %d bytes still allocated\n", current_allocation); while (pinfo != NULL) { fprintf(STDERR, " %lu bytes at %x\n", (unsigned long)pinfo->size, (unsigned int)pinfo->pointer); pinfo = pinfo->next; } } #endif } #if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG fprintf(STDERR, "Current memory allocation: %10d bytes\n", current_allocation); fprintf(STDERR, "Maximum memory allocation: %10d bytes\n", maximum_allocation); fprintf(STDERR, "Total memory allocation: %10d bytes\n", total_allocation); fprintf(STDERR, "Number of allocations: %10d\n", num_allocations); #endif } else { int i; for (i = 0; i<3; ++i) { int kerror; #if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG int allocation_now = current_allocation; #endif if (i == 1) status_dots_requested = 1; else if (verbose == 0) status_dots_requested = 0; if (i == 0 || verbose == 1 || ierror != 0) fprintf(STDERR, "\n Testing %s:", inname); kerror = test_one_file(inname, outname); if (kerror == 0) { if (verbose == 1 || i == 2) { #ifdef PNG_READ_USER_TRANSFORM_SUPPORTED int k; #endif #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED fprintf(STDERR, "\n PASS (%lu zero samples)\n", (unsigned long)zero_samples); #else fprintf(STDERR, " PASS\n"); #endif #ifdef PNG_READ_USER_TRANSFORM_SUPPORTED for (k = 0; k<256; k++) if (filters_used[k]) fprintf(STDERR, " Filter %d was used %lu times\n", k, (unsigned long)filters_used[k]); #endif #ifdef PNG_TIME_RFC1123_SUPPORTED if (tIME_chunk_present != 0) fprintf(STDERR, " tIME = %s\n", tIME_string); #endif } } else { if (verbose == 0 && i != 2) fprintf(STDERR, "\n Testing %s:", inname); fprintf(STDERR, " FAIL\n"); ierror += kerror; } #if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG if (allocation_now != current_allocation) fprintf(STDERR, "MEMORY ERROR: %d bytes lost\n", current_allocation - allocation_now); if (current_allocation != 0) { memory_infop pinfo = pinformation; fprintf(STDERR, "MEMORY ERROR: %d bytes still allocated\n", current_allocation); while (pinfo != NULL) { fprintf(STDERR, " %lu bytes at %x\n", (unsigned long)pinfo->size, (unsigned int)pinfo->pointer); pinfo = pinfo->next; } } #endif } #if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG fprintf(STDERR, " Current memory allocation: %10d bytes\n", current_allocation); fprintf(STDERR, " Maximum memory allocation: %10d bytes\n", maximum_allocation); fprintf(STDERR, " Total memory allocation: %10d bytes\n", total_allocation); fprintf(STDERR, " Number of allocations: %10d\n", num_allocations); #endif } #ifdef PNGTEST_TIMING t_stop = (float)clock(); t_misc += (t_stop - t_start); t_start = t_stop; fprintf(STDERR, " CPU time used = %.3f seconds", (t_misc+t_decode+t_encode)/(float)CLOCKS_PER_SEC); fprintf(STDERR, " (decoding %.3f,\n", t_decode/(float)CLOCKS_PER_SEC); fprintf(STDERR, " encoding %.3f ,", t_encode/(float)CLOCKS_PER_SEC); fprintf(STDERR, " other %.3f seconds)\n\n", t_misc/(float)CLOCKS_PER_SEC); #endif if (ierror == 0) fprintf(STDERR, " libpng passes test\n"); else fprintf(STDERR, " libpng FAILS test\n"); return (int)(ierror != 0); }<SPLIT>[0.9834872346524985, 4.431232104442027, 0.0, 0.9507312480792999, 4.211019254329354, 0.0, 1.6653401555507896, 1.7015798777335354, 1.7351415616306558, -0.27925050329511203, 4.144497124853893, 1.0054691849094282, 1.9367345547265302, 0.0, 0.0, 0.30852482215402843, 3.9550144766577677, 0.9718292068145229, 1.808650365567466, 0.8941073316973973, 2.1126769231284435, 0.0, 8.843551743760285, 20.710254078357234, 2.5381013406774904, 1.273328463412728, 0.6826474935548865, -0.21702784222394986, 1.6431611894444824, 1.664582183638518, 1.7009206574961395, 1.7343983950676451, -0.27935383381430245, 2.6191065950439585, 0.0, 1.6594432402238268, 1.6957470663015664, 1.7290886636830973, -0.28182971586402455]
0<SPLIT>static void allocate(struct file *file, int allocate_idat) { struct control *control = png_voidcast(struct control*, file->alloc_ptr); if (allocate_idat) { assert(file->idat == NULL); IDAT_init(&control->idat, file); } else { assert(file->chunk == NULL); chunk_init(&control->chunk, file); } }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.25252937827156396, 0.005287286955244392, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static double abserr(PNG_CONST png_modifier *pm, int in_depth, int out_depth) { if (pm->assume_16_bit_calculations || (pm->calculations_use_input_precision ? in_depth : out_depth) == 16) return pm->maxabs16; else return pm->maxabs8; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.18995094088131478, -0.5128682467823643, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.44279727663018986, -0.26569807294376846, -0.7092182376352943, -0.917450412529964, -0.518115519420462, 0.0, 1.1262599069228236, 0.417570182313826, -0.6237922041952815, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>int main(int argc, const char **argv) { int result = 1; if (argc == 3) { png_image image; memset(&image, 0, sizeof image); image.version = PNG_IMAGE_VERSION; if (png_image_begin_read_from_file(&image, argv[1])) { png_bytep buffer; image.format = PNG_FORMAT_RGBA; buffer = malloc(PNG_IMAGE_SIZE(image)); if (buffer != NULL) { if (png_image_finish_read(&image, NULL, buffer, 0, NULL)) { if (png_image_write_to_file(&image, argv[2], 0, buffer, 0, NULL)) result = 0; else fprintf(stderr, "pngtopng: write %s: %s\n", argv[2], image.message); free(buffer); } else { fprintf(stderr, "pngtopng: read %s: %s\n", argv[1], image.message); png_image_free(&image); } } else fprintf(stderr, "pngtopng: out of memory: %lu bytes\n", (unsigned long)PNG_IMAGE_SIZE(image)); } else fprintf(stderr, "pngtopng: %s: %s\n", argv[1], image.message); } else fprintf(stderr, "pngtopng: usage: pngtopng input-file output-file\n"); return result; }<SPLIT>[1.2927717594054797, 0.33242573788266383, 0.0, 1.2550433709584938, 0.2744463367362555, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, -0.27925050329511203, 0.4683826465887205, 1.3200790712565666, 0.3640258210692401, 0.0, 0.0, 0.30852482215402843, 0.40964200594544947, 1.281211026754096, 0.28467726362895307, 0.37651940477529405, 0.5780479983082486, 0.0, -0.08645738172306322, 0.417570182313826, -0.13194209721507255, 0.4559046196532859, 0.34396739025506545, 3.3782753486411963, 0.14602883551895066, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, -0.27935383381430245, 3.475844538781386, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, -0.28182971586402455]
0<SPLIT>static void chunk_message(struct chunk *chunk, const char *message) { type_message(chunk->file, chunk->chunk_type, message); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int readpng_init(FILE *infile, ulg *pWidth, ulg *pHeight) { uch sig[8]; fread(sig, 1, 8, infile); if (png_sig_cmp(sig, 0, 8)) return 1; png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL); if (!png_ptr) return 4; info_ptr = png_create_info_struct(png_ptr); if (!info_ptr) { png_destroy_read_struct(&png_ptr, NULL, NULL); return 4; } if (setjmp(png_jmpbuf(png_ptr))) { png_destroy_read_struct(&png_ptr, &info_ptr, NULL); return 2; } png_init_io(png_ptr, infile); png_set_sig_bytes(png_ptr, 8); png_read_info(png_ptr, info_ptr); png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, NULL, NULL, NULL); *pWidth = width; *pHeight = height; return 0; }<SPLIT>[1.6020562841584611, -0.06423294275211332, 0.0, 1.559355493837688, -0.12985034128681952, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 1.040052222782594, 0.14872051804392286, 1.6346889576037051, -0.04624602249353125, 0.0, 0.0, 0.30852482215402843, 0.08029046495031608, 1.5905928466936687, -0.1128809368767459, 0.5059163865058198, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, 0.40140969673598975, 0.4568607580216725, -0.21702784222394986, 0.33317037975964214, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 1.039626388904333, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 1.0350888753871217]
1<SPLIT>png_uint_32 PNGAPI png_get_PLTE(png_const_structrp png_ptr, png_inforp info_ptr, png_colorp *palette, int *num_palette) { png_debug1(1, "in %s retrieval function", "PLTE"); if (png_ptr != NULL && info_ptr != NULL && (info_ptr->valid & PNG_INFO_PLTE) && palette != NULL) { *palette = info_ptr->palette; *num_palette = info_ptr->num_palette; png_debug1(3, "num_palette = %d", *num_palette); return (PNG_INFO_PLTE); } return (0); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.037794879441717756, -0.3851956116171827, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.3459291763375036, 0.04368374699580437, -0.37791973721387856, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
1<SPLIT>void PNGAPI png_set_sPLT(png_structp png_ptr, png_infop info_ptr, png_const_sPLT_tp entries, int nentries) { png_sPLT_tp np; int i; if (png_ptr == NULL || info_ptr == NULL) return; np = (png_sPLT_tp)png_malloc_warn(png_ptr, (info_ptr->splt_palettes_num + nentries) * (png_size_t)png_sizeof(png_sPLT_t)); if (np == NULL) { png_warning(png_ptr, "No memory for sPLT palettes"); return; } png_memcpy(np, info_ptr->splt_palettes, info_ptr->splt_palettes_num * png_sizeof(png_sPLT_t)); png_free(png_ptr, info_ptr->splt_palettes); info_ptr->splt_palettes=NULL; for (i = 0; i < nentries; i++) { png_sPLT_tp to = np + info_ptr->splt_palettes_num + i; png_const_sPLT_tp from = entries + i; png_size_t length; length = png_strlen(from->name) + 1; to->name = (png_charp)png_malloc_warn(png_ptr, length); if (to->name == NULL) { png_warning(png_ptr, "Out of memory while processing sPLT chunk"); continue; } png_memcpy(to->name, from->name, length); to->entries = (png_sPLT_entryp)png_malloc_warn(png_ptr, from->nentries * png_sizeof(png_sPLT_entry)); if (to->entries == NULL) { png_warning(png_ptr, "Out of memory while processing sPLT chunk"); png_free(png_ptr, to->name); to->name = NULL; continue; } png_memcpy(to->entries, from->entries, from->nentries * png_sizeof(png_sPLT_entry)); to->nentries = from->nentries; to->depth = from->depth; } info_ptr->splt_palettes = np; info_ptr->splt_palettes_num += nentries; info_ptr->valid |= PNG_INFO_sPLT; info_ptr->free_me |= PNG_FREE_SPLT; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 2.9287600467940615, 0.4659552894840279, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.7971144071161946, 2.9828110364217464, 0.4834563638818026, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, 0.417570182313826, 0.3950401602637228, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void store_storefile(png_store *ps, png_uint_32 id) { png_store_file *pf = voidcast(png_store_file*, malloc(sizeof *pf)); if (pf == NULL) png_error(ps->pwrite, "storefile: OOM"); safecat(pf->name, sizeof pf->name, 0, ps->wname); pf->id = id; pf->data = ps->new; pf->datacount = ps->writepos; ps->new.prev = NULL; ps->writepos = 0; pf->palette = ps->palette; pf->npalette = ps->npalette; ps->palette = 0; ps->npalette = 0; pf->next = ps->saved; ps->saved = pf; }<SPLIT>[-0.09900860198293619, -0.24052568970090316, 0.0, -0.11436118199787926, -0.30008052150706166, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.2308782596030243, -0.09566541730555662, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.11100716297398205, -0.28957347043483433, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.4705090699407485, -0.3333928163445767, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static double pcerr(PNG_CONST png_modifier *pm, int in_depth, int out_depth) { if (pm->assume_16_bit_calculations || (pm->calculations_use_input_precision ? in_depth : out_depth) == 16) return pm->maxpc16 * .01; else return pm->maxpc8 * .01; }<SPLIT>[0.21027592277004517, -0.4829282167554892, 0.0, 0.18995094088131478, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, 0.21894446904158188, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, 0.19837465696559078, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>void PNGAPI png_set_PLTE(png_structrp png_ptr, png_inforp info_ptr, png_const_colorp palette, int num_palette) { png_debug1(1, "in %s storage function", "PLTE"); if (png_ptr == NULL || info_ptr == NULL) return; if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH) { if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) png_error(png_ptr, "Invalid palette length"); else { png_warning(png_ptr, "Invalid palette length"); return; } } if ((num_palette > 0 && palette == NULL) || (num_palette == 0 #ifdef PNG_MNG_FEATURES_SUPPORTED && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0 #endif )) { png_chunk_report(png_ptr, "Invalid palette", PNG_CHUNK_ERROR); return; } png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0); png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr, PNG_MAX_PALETTE_LENGTH * (sizeof (png_color)))); if (num_palette > 0) memcpy(png_ptr->palette, palette, num_palette * (sizeof (png_color))); info_ptr->palette = png_ptr->palette; info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette; info_ptr->free_me |= PNG_FREE_PLTE; info_ptr->valid |= PNG_INFO_PLTE; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 2.9287600467940615, 0.08293738398848315, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.44838924606252395, 2.9828110364217464, 0.04172502998658149, -0.7880534307994381, -0.518115519420462, 0.0, 0.02378964451747194, 0.9973611507722091, -0.20220639821224526, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>uch *readpng_get_image(double display_exponent, int *pChannels, ulg *pRowbytes) { double gamma; png_uint_32 i, rowbytes; png_bytepp row_pointers = NULL; if (setjmp(png_jmpbuf(png_ptr))) { free(image_data); image_data = NULL; free(row_pointers); row_pointers = NULL; png_destroy_read_struct(&png_ptr, &info_ptr, NULL); return NULL; } if (color_type == PNG_COLOR_TYPE_PALETTE) png_set_expand(png_ptr); if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8) png_set_expand(png_ptr); if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)) png_set_expand(png_ptr); #ifdef PNG_READ_16_TO_8_SUPPORTED if (bit_depth == 16) #ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED png_set_scale_16(png_ptr); #else png_set_strip_16(png_ptr); #endif #endif if (color_type == PNG_COLOR_TYPE_GRAY || color_type == PNG_COLOR_TYPE_GRAY_ALPHA) png_set_gray_to_rgb(png_ptr); if (png_get_gAMA(png_ptr, info_ptr, &gamma)) png_set_gamma(png_ptr, display_exponent, gamma); png_read_update_info(png_ptr, info_ptr); *pRowbytes = rowbytes = png_get_rowbytes(png_ptr, info_ptr); *pChannels = (int)png_get_channels(png_ptr, info_ptr); if ((image_data = (uch *)malloc(rowbytes*height)) == NULL) { png_destroy_read_struct(&png_ptr, &info_ptr, NULL); return NULL; } if ((row_pointers = (png_bytepp)malloc(height*sizeof(png_bytep))) == NULL) { png_destroy_read_struct(&png_ptr, &info_ptr, NULL); free(image_data); image_data = NULL; return NULL; } Trace((stderr, "readpng_get_image: channels = %d, rowbytes = %ld, height = %ld\n", *pChannels, rowbytes, height)); for (i = 0; i < height; ++i) row_pointers[i] = image_data + i*rowbytes; png_read_image(png_ptr, row_pointers); free(row_pointers); row_pointers = NULL; png_read_end(png_ptr, NULL); return image_data; }<SPLIT>[1.9113408089114425, 0.5527916715686512, 0.0, 1.863667616716882, 0.4659552894840279, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.7480870090654184, 1.9492988439508436, 0.40961158146510357, 0.0, 0.0, 0.30852482215402843, 0.6614990667064338, 1.8999746666332415, 0.3288503970184752, 1.1529012951584487, -0.4084991676475909, 0.0, 0.5750247757201478, 2.736734056147358, 0.5004366117594818, 0.3469147738186936, 1.0213275968547075, -0.21702784222394986, -0.22825425296243224, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static png_uint_32 get_valid(display *d, png_infop info_ptr) { png_uint_32 flags = png_get_valid(d->png_ptr, info_ptr, (png_uint_32)~0); { png_textp text; png_uint_32 ntext = png_get_text(d->png_ptr, info_ptr, &text, NULL); while (ntext-- > 0) switch (text[ntext].compression) { case -1: flags |= PNG_INFO_tEXt; break; case 0: flags |= PNG_INFO_zTXt; break; case 1: case 2: flags |= PNG_INFO_iTXt; break; default: fprintf(stderr, "%s(%s): unknown text compression %d\n", d->file, d->test, text[ntext].compression); display_exit(d); } } return flags; }<SPLIT>[-0.09900860198293619, -0.06423294275211332, 0.0, -0.11436118199787926, -0.12985034128681952, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.07104719533062549, -0.09566541730555662, -0.04624602249353125, 0.0, 0.0, 0.30852482215402843, -0.13281935569359377, -0.11100716297398205, -0.1128809368767459, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void init_standard_palette(png_store *ps, png_structp pp, png_infop pi, int npalette, int do_tRNS) { store_palette_entry *ppal = make_standard_palette(ps, npalette, do_tRNS); { int i; png_color palette[256]; for (i=0; i<npalette; ++i) { palette[i].red = ppal[i].red; palette[i].green = ppal[i].green; palette[i].blue = ppal[i].blue; } for (; i<256; ++i) palette[i].red = palette[i].green = palette[i].blue = 42; png_set_PLTE(pp, pi, palette, npalette); } if (do_tRNS) { int i, j; png_byte tRNS[256]; for (i=j=0; i<npalette; ++i) if ((tRNS[i] = ppal[i].alpha) < 255) j = i+1; for (; i<256; ++i) tRNS[i] = 24; #ifdef PNG_WRITE_tRNS_SUPPORTED if (j > 0) png_set_tRNS(pp, pi, tRNS, j, 0); #endif } }<SPLIT>[0.36491818514653585, 0.06798661745947907, 0.0, 0.34210700232091185, -0.0021777061216379156, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 0.10876275197582316, 0.3762494122151511, -0.0006602620976677653, 0.0, 0.0, 0.30852482215402843, 0.04154322483324156, 0.35306556693537716, -0.06870780348722379, -0.14106852214680915, 0.029966239443893296, 0.0, 0.13403667075800713, 0.9973611507722091, 0.043718655277859224, 0.0744401592322129, -0.22049944857796966, -0.21702784222394986, 0.33317037975964214, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 1.7623686513065309, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static void perform_gamma_sbit_tests(png_modifier *pm) { png_byte sbit; for (sbit=pm->sbitlow; sbit<(1<<READ_BDHI); ++sbit) { png_byte colour_type = 0, bit_depth = 0; unsigned int npalette = 0; while (next_format(&colour_type, &bit_depth, &npalette, 1)) if ((colour_type & PNG_COLOR_MASK_ALPHA) == 0 && ((colour_type == 3 && sbit < 8) || (colour_type != 3 && sbit < bit_depth))) { unsigned int i; for (i=0; i<pm->ngamma_tests; ++i) { unsigned int j; for (j=0; j<pm->ngamma_tests; ++j) if (i != j) { gamma_transform_test(pm, colour_type, bit_depth, npalette, pm->interlace_type, 1/pm->gammas[i], pm->gammas[j], sbit, pm->use_input_precision_sbit, 0 ); if (fail(pm)) return; } } } } }<SPLIT>[0.36491818514653585, -0.04219634938351458, 0.0, 0.34210700232091185, -0.08729279623175898, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.008868336805573909, 0.3762494122151511, -0.023453142295599506, 0.0, 0.0, 0.30852482215402843, -0.03595125540090747, 0.35306556693537716, -0.06870780348722379, -0.011671540416283347, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.3615192241061562, -0.10760608081136262, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gp_g16(Pixel *p, png_const_voidp pb) { png_const_uint_16p pp = voidcast(png_const_uint_16p, pb); p->r = p->g = p->b = pp[0]; p->a = 65535; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gpc_b16g(Pixel *out, const Pixel *in, const Background *back) { if (in->a <= 0) out->r = out->g = out->b = back->ig; else { double a = in->a/65535.; double a1 = 1-a; a /= 65535; out->r = out->g = out->b = sRGB(in->g * a + back->dg * a1); } out->a = 255; }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.39986248560786075, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3615192241061562, -0.4462861841111837, 0.6817979554923368, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void make_random_bytes(png_uint_32* seed, void* pv, size_t size) { png_uint_32 u0 = seed[0], u1 = seed[1]; png_bytep bytes = png_voidcast(png_bytep, pv); size_t i; for (i=0; i<size; ++i) { png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff; u1 <<= 8; u1 |= u0 >> 24; u0 <<= 8; u0 |= u; *bytes++ = (png_byte)u; } seed[0] = u0; seed[1] = u1; }<SPLIT>[0.36491818514653585, -0.2625622830695019, 0.0, 0.34210700232091185, -0.3213592940345919, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1909204935349246, 0.3762494122151511, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, 0.35306556693537716, -0.3116600371295954, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.4705090699407485, -0.6720729196443977, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void store_log(png_store* ps, png_const_structp pp, png_const_charp message, int is_error) { if (is_error ? (ps->nerrors)++ == 0 : (ps->nwarnings)++ == 0 && ps->nerrors == 0) store_message(ps, pp, ps->error, sizeof ps->error, 0, message); if (ps->verbose) store_verbose(ps, pp, is_error ? "error: " : "warning: ", message); }<SPLIT>[0.36491818514653585, -0.43885503001829174, 0.0, 0.34210700232091185, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, 0.3762494122151511, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, 0.35306556693537716, -0.48835257068768384, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int modifier_color_encoding_is_set(PNG_CONST png_modifier *pm) { return pm->current_gamma != 0; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void PNGCBAPI write_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass) { if (png_ptr == NULL || row_number > PNG_UINT_31_MAX || pass > 7) return; fprintf(stdout, "w"); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void transform_range_check(png_const_structp pp, unsigned int r, unsigned int g, unsigned int b, unsigned int a, unsigned int in_digitized, double in, unsigned int out, png_byte sample_depth, double err, double limit, PNG_CONST char *name, double digitization_error) { unsigned int max = (1U<<sample_depth)-1; double in_min = ceil((in-err)*max - digitization_error); double in_max = floor((in+err)*max + digitization_error); if (err > limit || !(out >= in_min && out <= in_max)) { char message[256]; size_t pos; pos = safecat(message, sizeof message, 0, name); pos = safecat(message, sizeof message, pos, " output value error: rgba("); pos = safecatn(message, sizeof message, pos, r); pos = safecat(message, sizeof message, pos, ","); pos = safecatn(message, sizeof message, pos, g); pos = safecat(message, sizeof message, pos, ","); pos = safecatn(message, sizeof message, pos, b); pos = safecat(message, sizeof message, pos, ","); pos = safecatn(message, sizeof message, pos, a); pos = safecat(message, sizeof message, pos, "): "); pos = safecatn(message, sizeof message, pos, out); pos = safecat(message, sizeof message, pos, " expected: "); pos = safecatn(message, sizeof message, pos, in_digitized); pos = safecat(message, sizeof message, pos, " ("); pos = safecatd(message, sizeof message, pos, (in-err)*max, 3); pos = safecat(message, sizeof message, pos, ".."); pos = safecatd(message, sizeof message, pos, (in+err)*max, 3); pos = safecat(message, sizeof message, pos, ")"); png_error(pp, message); } }<SPLIT>[0.6742027098995172, 0.0900232108280778, 0.0, 0.6464191252001059, 0.01910106640589235, 0.0, -0.24638545112987587, -0.2425966915157195, 0.07672169611998206, -0.27925050329511203, 0.1686994010779727, 0.6908592985622897, 0.11330413889199094, 0.0, 0.0, 0.30852482215402843, 0.09966408500885333, 0.66244738687495, 0.04172502998658149, 0.7647103499668715, 1.564595164264088, 0.0, -0.08645738172306322, -0.16222078614455715, 0.14911510677361828, 0.8918640029916549, 0.4568607580216725, -0.21702784222394986, 1.1753073288427536, -0.2466538826184141, -0.24285292239137013, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void gpc_gprq(Pixel *out, const Pixel *in, const Background *back) { (void)back; if (in->r == in->g && in->g == in->b) out->r = out->g = out->b = ilineara(in->g, in->a); else out->r = out->g = out->b = u16d(in->a * 257 * YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b])); out->a = 65535; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void IDAT_end(struct IDAT **idat_var) { struct IDAT *idat = *idat_var; struct file *file = idat->file; *idat_var = NULL; CLEAR(*idat); assert(file->chunk != NULL); chunk_end(&file->chunk); file->state = STATE_CHUNKS; }<SPLIT>[0.36491818514653585, -0.416818436649693, 0.0, 0.34210700232091185, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.33077267477327355, 0.3762494122151511, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, 0.35306556693537716, -0.4662660039929228, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.3070243011888601, 0.005287286955244392, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static double chromaticity_y(CIE_color c) { return c.Y / (c.X + c.Y + c.Z); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void store_freebuffer(png_store_buffer* psb) { if (psb->prev) { store_freebuffer(psb->prev); free(psb->prev); psb->prev = NULL; } }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int main(int argc, const char **argv) { const char *prog = *argv++; int to_linear = 0, to_gray = 0, to_color = 0; int channels = 0; double c[4]; fesetround(FE_TONEAREST); c[3] = c[2] = c[1] = c[0] = 0; while (--argc > 0 && **argv == '-') { const char *arg = 1+*argv++; if (strcmp(arg, "sRGB") == 0) to_linear = 0; else if (strcmp(arg, "linear") == 0) to_linear = 1; else if (strcmp(arg, "gray") == 0) to_gray = 1, to_color = 0; else if (strcmp(arg, "color") == 0) to_gray = 0, to_color = 1; else usage(prog); } switch (argc) { default: usage(prog); break; case 4: c[3] = component(prog, argv[3], to_linear); ++channels; case 3: c[2] = component(prog, argv[2], to_linear); ++channels; case 2: c[1] = component(prog, argv[1], to_linear); ++channels; case 1: c[0] = component(prog, argv[0], to_linear); ++channels; break; } if (to_linear) { int i; int components = channels; if ((components & 1) == 0) --components; for (i=0; i<components; ++i) c[i] = linear_from_sRGB(c[i] / 255); if (components < channels) c[components] = c[components] / 255; } else { int i; for (i=0; i<4; ++i) c[i] /= 65535; if ((channels & 1) == 0) { double alpha = c[channels-1]; if (alpha > 0) for (i=0; i<channels-1; ++i) c[i] /= alpha; else for (i=0; i<channels-1; ++i) c[i] = 1; } } if (to_gray) { if (channels < 3) { fprintf(stderr, "%s: too few channels (%d) for -gray\n", prog, channels); usage(prog); } c[0] = YfromRGB(c[0], c[1], c[2]); channels -= 2; } if (to_color) { if (channels > 2) { fprintf(stderr, "%s: too many channels (%d) for -color\n", prog, channels); usage(prog); } c[3] = c[1]; c[2] = c[1] = c[0]; } if (to_linear) { int i; if ((channels & 1) == 0) { double alpha = c[channels-1]; for (i=0; i<channels-1; ++i) c[i] *= alpha; } for (i=0; i<channels; ++i) c[i] = nearbyint(c[i] * 65535); } else { int i = (channels+1)&~1; while (--i >= 0) c[i] = sRGB_from_linear(c[i]); for (i=0; i<channels; ++i) c[i] = nearbyint(c[i] * 255); } { int i; for (i=0; i<channels; ++i) printf(" %g", c[i]); } printf("\n"); return 0; }<SPLIT>[0.36491818514653585, 1.78684090021018, 0.0, 0.34210700232091185, 1.6575665510257227, 0.0, 4.619825184057273, 4.1759864204144055, 4.554455332998801, 1.040052222782594, 1.6671156286317115, 0.3762494122151511, 1.868355914132735, 0.0, 0.0, 0.30852482215402843, 1.5526855893991478, 0.35306556693537716, 1.7423906654831827, 2.1880771490026554, 7.374261808226253, 0.0, -0.08645738172306322, -0.16222078614455715, 1.6949297287114178, 5.19696291345805, 2.0373679067541706, -0.21702784222394986, 7.257407516665226, 4.618310649671958, 4.174814304625697, 4.55301867677435, 1.039626388904333, 2.6191065950439585, 0.0, 4.609447498488585, 4.166568587842573, 4.543981015708179, 1.0350888753871217]
0<SPLIT>int main(void) { fprintf(stderr, "pngstest: no read support in libpng, test skipped\n"); return 77; }<SPLIT>[-0.09900860198293619, -0.5490379968612854, 0.0, -0.11436118199787926, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.09566541730555662, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.11100716297398205, -0.5987854041614891, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, 0.417570182313826, -0.6237922041952815, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void png_flush(png_structp png_ptr) { FILE *io_ptr; io_ptr = (FILE *)CVT_PTR((png_ptr->io_ptr)); if (io_ptr != NULL) fflush(io_ptr); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void parse_color(char *arg, unsigned int *colors) { unsigned int ncolors = 0; while (*arg && ncolors < 4) { char *ep = arg; unsigned long ul = strtoul(arg, &ep, 0); if (ul > 65535) { fprintf(stderr, "makepng --color=...'%s': too big\n", arg); exit(1); } if (ep == arg) { fprintf(stderr, "makepng --color=...'%s': not a valid color\n", arg); exit(1); } if (*ep) ++ep; arg = ep; colors[++ncolors] = (unsigned int)ul; } if (*arg) { fprintf(stderr, "makepng --color=...'%s': too many values\n", arg); exit(1); } *colors = ncolors; }<SPLIT>[-0.25365086435942685, -0.020159756014915854, 0.0, -0.2665172434374763, -0.08729279623175898, 0.0, 0.44878749675400254, 0.46437660639310047, 0.5742476557731842, 1.040052222782594, -0.051068312296575644, -0.25297036047912586, -0.0006602620976677653, 0.0, 0.0, 0.30852482215402843, -0.1134457356350565, -0.26569807294376846, -0.06870780348722379, -0.14106852214680915, 1.0165134053997327, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, 0.29241985090139744, -0.10760608081136262, -0.21702784222394986, 0.6138826961206794, 0.4483410505659248, 0.46397383393136066, 0.5737900437766489, 1.039626388904333, 0.9056307075691036, 0.0, 0.4447356044677496, 0.4603363055310632, 0.5700153422610048, 1.0350888753871217]
0<SPLIT>double finvsRGB(unsigned int i) { return 65535 * linear_from_sRGB(i/255.); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void generate_row(png_bytep row, size_t rowbytes, unsigned int y, int color_type, int bit_depth, png_const_bytep gamma_table, double conv, unsigned int *colors) { png_uint_32 size_max = image_size_of_type(color_type, bit_depth, colors)-1; png_uint_32 depth_max = (1U << bit_depth)-1; if (colors[0] == 0) switch (channels_of_type(color_type)) { case 1: { png_uint_32 x; png_uint_32 base = 2*size_max - abs(2*y-size_max); for (x=0; x<=size_max; ++x) { png_uint_32 luma = base - abs(2*x-size_max); luma = (luma*depth_max + size_max) / (2*size_max); set_value(row, rowbytes, x, bit_depth, luma, gamma_table, conv); } } break; case 2: { png_uint_32 alpha = (depth_max * y * 2 + size_max) / (2 * size_max); png_uint_32 x; for (x=0; x<=size_max; ++x) { set_value(row, rowbytes, 2*x, bit_depth, (depth_max * x * 2 + size_max) / (2 * size_max), gamma_table, conv); set_value(row, rowbytes, 2*x+1, bit_depth, alpha, gamma_table, conv); } } break; case 3: { png_uint_32 Y = (depth_max * y * 2 + size_max) / (2 * size_max); png_uint_32 x; for (x=0; x<=size_max; ++x) { set_value(row, rowbytes, 3*x+0, bit_depth, Y, gamma_table, conv); set_value(row, rowbytes, 3*x+1, bit_depth, (depth_max * x * 2 + size_max) / (2 * size_max), gamma_table, conv); set_value(row, rowbytes, 3*x+2, bit_depth, (Y * x * 2 + size_max) / (2 * size_max), gamma_table, conv); } } break; case 4: { png_uint_32 Y = (depth_max * y * 2 + size_max) / (2 * size_max); png_uint_32 x; for (x=0; x<=size_max; ++x) { set_value(row, rowbytes, 4*x+0, bit_depth, ((depth_max-Y) * x * 2 + size_max) / (2 * size_max), gamma_table, conv); set_value(row, rowbytes, 4*x+1, bit_depth, (Y * x * 2 + size_max) / (2 * size_max), gamma_table, conv); set_value(row, rowbytes, 4*x+2, bit_depth, Y - (Y * x * 2 + size_max) / (2 * size_max), gamma_table, conv); set_value(row, rowbytes, 4*x+3, bit_depth, Y + ((depth_max-Y) * x * 2 + size_max) / (2 * size_max), gamma_table, conv); } } break; default: fprintf(stderr, "makepng: internal bad channel count\n"); exit(2); } else if (color_type & PNG_COLOR_MASK_PALETTE) { memset(row, 0, rowbytes); } else if (colors[0] == channels_of_type(color_type)) switch (channels_of_type(color_type)) { case 1: { const png_uint_32 luma = colors[1]; png_uint_32 x; for (x=0; x<=size_max; ++x) set_value(row, rowbytes, x, bit_depth, luma, gamma_table, conv); } break; case 2: { const png_uint_32 luma = colors[1]; const png_uint_32 alpha = colors[2]; png_uint_32 x; for (x=0; x<size_max; ++x) { set_value(row, rowbytes, 2*x, bit_depth, luma, gamma_table, conv); set_value(row, rowbytes, 2*x+1, bit_depth, alpha, gamma_table, conv); } } break; case 3: { const png_uint_32 red = colors[1]; const png_uint_32 green = colors[2]; const png_uint_32 blue = colors[3]; png_uint_32 x; for (x=0; x<=size_max; ++x) { set_value(row, rowbytes, 3*x+0, bit_depth, red, gamma_table, conv); set_value(row, rowbytes, 3*x+1, bit_depth, green, gamma_table, conv); set_value(row, rowbytes, 3*x+2, bit_depth, blue, gamma_table, conv); } } break; case 4: { const png_uint_32 red = colors[1]; const png_uint_32 green = colors[2]; const png_uint_32 blue = colors[3]; const png_uint_32 alpha = colors[4]; png_uint_32 x; for (x=0; x<=size_max; ++x) { set_value(row, rowbytes, 4*x+0, bit_depth, red, gamma_table, conv); set_value(row, rowbytes, 4*x+1, bit_depth, green, gamma_table, conv); set_value(row, rowbytes, 4*x+2, bit_depth, blue, gamma_table, conv); set_value(row, rowbytes, 4*x+3, bit_depth, alpha, gamma_table, conv); } } break; default: fprintf(stderr, "makepng: internal bad channel count\n"); exit(2); } else { fprintf(stderr, "makepng: --color: count(%u) does not match channels(%u)\n", colors[0], channels_of_type(color_type)); exit(1); } }<SPLIT>[6.550608680206163, 2.7784876017971225, 0.0, 6.428349459904793, 2.615111314764585, 0.0, 1.49154691857982, 0.46437660639310047, 1.403457588528521, 3.34883199341858, 3.365320686525949, 6.668447139157921, 2.8940355230396633, 0.0, 0.0, 0.30852482215402843, 3.199443294374815, 6.540701965726834, 2.7362861667474303, 1.4116952586195004, 2.4415259784470567, 0.0, -0.08645738172306322, -0.16222078614455715, 2.011119083198695, 1.6547929238338008, 0.9084342290881006, 1.5806237532086234, 1.9238735058055194, 1.4908334503424332, 0.46397383393136066, 1.4027960089845035, 3.347841778661945, 0.9056307075691036, 0.0, 1.4859135779729586, 0.4603363055310632, 1.3979248575624994, 3.339696410076628]
1<SPLIT>void PNGAPI png_set_PLTE(png_structrp png_ptr, png_inforp info_ptr, png_const_colorp palette, int num_palette) { png_debug1(1, "in %s storage function", "PLTE"); if (png_ptr == NULL || info_ptr == NULL) return; if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH) { if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) png_error(png_ptr, "Invalid palette length"); else { png_warning(png_ptr, "Invalid palette length"); return; } } if ((num_palette > 0 && palette == NULL) || (num_palette == 0 #ifdef PNG_MNG_FEATURES_SUPPORTED && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0 #endif )) { png_error(png_ptr, "Invalid palette"); return; } png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0); png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr, PNG_MAX_PALETTE_LENGTH * (sizeof (png_color)))); if (num_palette > 0) memcpy(png_ptr->palette, palette, num_palette * (sizeof (png_color))); info_ptr->palette = png_ptr->palette; info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette; info_ptr->free_me |= PNG_FREE_PLTE; info_ptr->valid |= PNG_INFO_PLTE; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 2.9287600467940615, 0.08293738398848315, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.44838924606252395, 2.9828110364217464, 0.04172502998658149, -0.7880534307994381, -0.518115519420462, 0.0, 0.02378964451747194, 0.9973611507722091, -0.20220639821224526, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void PNGCBAPI transform_end(png_structp ppIn, png_infop pi) { png_const_structp pp = ppIn; transform_display *dp = voidcast(transform_display*, png_get_progressive_ptr(pp)); if (!dp->this.speed) transform_image_validate(dp, pp, pi); else dp->this.ps->validated = 1; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void perform_transform_test(png_modifier *pm) { png_byte colour_type = 0; png_byte bit_depth = 0; unsigned int palette_number = 0; while (next_format(&colour_type, &bit_depth, &palette_number, 0)) { png_uint_32 counter = 0; size_t base_pos; char name[64]; base_pos = safecat(name, sizeof name, 0, "transform:"); for (;;) { size_t pos = base_pos; PNG_CONST image_transform *list = 0; counter = image_transform_add(&list, 1, counter, name, sizeof name, &pos, colour_type, bit_depth); if (counter == 0) break; do { pm->repeat = 0; transform_test(pm, FILEID(colour_type, bit_depth, palette_number, pm->interlace_type, 0, 0, 0), list, name); if (fail(pm)) return; } while (pm->repeat); } } }<SPLIT>[0.36491818514653585, 0.04595002409088034, 0.0, 0.34210700232091185, -0.02345647864916818, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.08878386894177331, 0.3762494122151511, 0.06771837849612745, 0.0, 0.0, 0.30852482215402843, 0.022169604774704303, 0.35306556693537716, -0.0024481034029406237, 0.37651940477529405, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.14353953243697165, 0.34396739025506545, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void wpng_cleanup(void) { if (wpng_info.outfile) { fclose(wpng_info.outfile); wpng_info.outfile = NULL; } if (wpng_info.infile) { fclose(wpng_info.infile); wpng_info.infile = NULL; } if (wpng_info.image_data) { free(wpng_info.image_data); wpng_info.image_data = NULL; } if (wpng_info.row_pointers) { free(wpng_info.row_pointers); wpng_info.row_pointers = NULL; } }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.3615192241061562, -0.5591795518777907, -0.21702784222394986, -0.13468348084208653, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>int main(void) { fprintf(stderr, "pngvalid: no low level write support in libpng, all tests skipped\n"); return SKIP; }<SPLIT>[-0.09900860198293619, -0.5270014034926866, 0.0, -0.11436118199787926, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.09566541730555662, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.11100716297398205, -0.576698837466728, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, 0.417570182313826, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int readpng2_decode_data(mainprog_info *mainprog_ptr, uch *rawbuf, ulg length) { png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr; png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr; if (setjmp(mainprog_ptr->jmpbuf)) { png_destroy_read_struct(&png_ptr, &info_ptr, NULL); mainprog_ptr->png_ptr = NULL; mainprog_ptr->info_ptr = NULL; return 2; } png_process_data(png_ptr, info_ptr, rawbuf, length); return 0; }<SPLIT>[0.21027592277004517, -0.3727452499124955, 0.0, 0.18995094088131478, -0.42775315667224323, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3107937917392237, 0.21894446904158188, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, 0.19837465696559078, -0.42209287060340067, -0.39986248560786075, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.3615192241061562, -0.4462861841111837, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void init_sRGB_to_d(void) { int i; sRGB_to_d[0] = 0; for (i=1; i<255; ++i) sRGB_to_d[i] = linear_from_sRGB(i/255.); sRGB_to_d[255] = 1; g22_to_d[0] = 0; for (i=1; i<255; ++i) g22_to_d[i] = pow(i/255., 1/.45455); g22_to_d[255] = 1; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static unsigned int image_size_of_type(int color_type, int bit_depth, unsigned int *colors) { if (*colors) return 16; else { int pixel_depth = pixel_depth_of_type(color_type, bit_depth); if (pixel_depth < 8) return 64; else if (pixel_depth > 16) return 1024; else return 256; } }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.6586564490689124, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.1980344553542678, -0.5591795518777907, -0.21702784222394986, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static void rpng2_win_display_row(ulg row) { uch bg_red = rpng2_info.bg_red; uch bg_green = rpng2_info.bg_green; uch bg_blue = rpng2_info.bg_blue; uch *src, *src2=NULL, *dest; uch r, g, b, a; ulg i; static int rows=0; static ulg firstrow; Trace((stderr, "beginning rpng2_win_display_row()\n")) if (rows == 0) firstrow = row; ++rows; src = rpng2_info.image_data + row*rpng2_info.rowbytes; if (bg_image) src2 = bg_data + row*bg_rowbytes; dest = wimage_data + row*wimage_rowbytes; if (rpng2_info.channels == 3) { for (i = rpng2_info.width; i > 0; --i) { r = *src++; g = *src++; b = *src++; *dest++ = b; *dest++ = g; *dest++ = r; } } else { for (i = rpng2_info.width; i > 0; --i) { r = *src++; g = *src++; b = *src++; a = *src++; if (bg_image) { bg_red = *src2++; bg_green = *src2++; bg_blue = *src2++; } if (a == 255) { *dest++ = b; *dest++ = g; *dest++ = r; } else if (a == 0) { *dest++ = bg_blue; *dest++ = bg_green; *dest++ = bg_red; } else { alpha_composite(*dest++, b, a, bg_blue); alpha_composite(*dest++, g, a, bg_green); alpha_composite(*dest++, r, a, bg_red); } } } if ((rows & 0xf) == 0 || row == rpng2_info.height-1) { RECT rect; rect.left = 0L; rect.top = (LONG)firstrow; rect.right = (LONG)rpng2_info.width; rect.bottom = (LONG)row + 1L; InvalidateRect(global_hwnd, &rect, FALSE); UpdateWindow(global_hwnd); rows = 0; } }<SPLIT>[2.529909858417405, 0.7511210118860397, 0.0, 2.47229186247527, 0.6787430147593306, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 1.0078124885080664, 2.5785186166451206, 0.7970905448299431, 0.0, 0.0, 0.30852482215402843, 0.9327297475259554, 2.5187383065123874, 0.7264085975241742, -0.011671540416283347, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, 0.9571545682411045, -0.14353953243697165, -0.10760608081136262, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void modifier_encoding_iterate(png_modifier *pm) { if (!pm->repeat && pm->test_uses_encoding) { if (pm->test_exhaustive) { if (++pm->encoding_counter >= modifier_total_encodings(pm)) pm->encoding_counter = 0; } else { if (pm->encoding_counter == 0) pm->encoding_counter = random_mod(modifier_total_encodings(pm)-1)+1; else pm->encoding_counter = 0; } if (pm->encoding_counter > 0) pm->repeat = 1; } else if (!pm->repeat) pm->encoding_counter = 0; }<SPLIT>[0.21027592277004517, -0.13034272285790952, 0.0, 0.18995094088131478, -0.1936866588694103, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.09102607836467534, 0.21894446904158188, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.152192975752131, 0.19837465696559078, -0.17914063696102905, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.41601414702345235, -0.5591795518777907, 0.6817979554923368, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static png_uint_32 current_type(struct file *file, int code) { if (file->chunk != NULL) { png_uint_32 type = file->chunk->chunk_type; if (code <= LIBPNG_ERROR_CODE && type == png_IDAT && file->write_count == 8) type = 0; return type; } else return file->type; }<SPLIT>[1.2927717594054797, -0.3507086565438968, 0.0, 1.2550433709584938, -0.406474384144713, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1509627274668249, 1.3200790712565666, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.21031383592774278, 1.281211026754096, -0.4000063039086396, -0.6586564490689124, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5250039928580447, -0.6720729196443977, 0.6817979554923368, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int rpng2_win_create_window() { uch bg_red = rpng2_info.bg_red; uch bg_green = rpng2_info.bg_green; uch bg_blue = rpng2_info.bg_blue; uch *dest; int extra_width, extra_height; ulg i, j; WNDCLASSEX wndclass; RECT rect; wimage_rowbytes = ((3*rpng2_info.width + 3L) >> 2) << 2; if (!(dib = (uch *)malloc(sizeof(BITMAPINFOHEADER) + wimage_rowbytes*rpng2_info.height))) { return 4; } memset(dib, 0, sizeof(BITMAPINFOHEADER)); bmih = (BITMAPINFOHEADER *)dib; bmih->biSize = sizeof(BITMAPINFOHEADER); bmih->biWidth = rpng2_info.width; bmih->biHeight = -((long)rpng2_info.height); bmih->biPlanes = 1; bmih->biBitCount = 24; bmih->biCompression = 0; wimage_data = dib + sizeof(BITMAPINFOHEADER); if (bg_image) { memset(wimage_data, 0, wimage_rowbytes*rpng2_info.height); } else { for (j = 0; j < rpng2_info.height; ++j) { dest = wimage_data + j*wimage_rowbytes; for (i = rpng2_info.width; i > 0; --i) { *dest++ = bg_blue; *dest++ = bg_green; *dest++ = bg_red; } } } memset(&wndclass, 0, sizeof(wndclass)); wndclass.cbSize = sizeof(wndclass); wndclass.style = CS_HREDRAW | CS_VREDRAW; wndclass.lpfnWndProc = rpng2_win_wndproc; wndclass.hInstance = global_hInst; wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION); wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); wndclass.hbrBackground = (HBRUSH)GetStockObject(DKGRAY_BRUSH); wndclass.lpszMenuName = NULL; wndclass.lpszClassName = progname; wndclass.hIconSm = LoadIcon(NULL, IDI_APPLICATION); RegisterClassEx(&wndclass); extra_width = 2*(GetSystemMetrics(SM_CXBORDER) + GetSystemMetrics(SM_CXDLGFRAME)); extra_height = 2*(GetSystemMetrics(SM_CYBORDER) + GetSystemMetrics(SM_CYDLGFRAME)) + GetSystemMetrics(SM_CYCAPTION); global_hwnd = CreateWindow(progname, titlebar, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, rpng2_info.width+extra_width, rpng2_info.height+extra_height, NULL, NULL, global_hInst, NULL); ShowWindow(global_hwnd, global_showmode); UpdateWindow(global_hwnd); if (bg_image) { static const char *msg = "Computing background image..."; int x, y, len = strlen(msg); HDC hdc = GetDC(global_hwnd); TEXTMETRIC tm; GetTextMetrics(hdc, &tm); x = (rpng2_info.width - len*tm.tmAveCharWidth)/2; y = (rpng2_info.height - tm.tmHeight)/2; SetBkMode(hdc, TRANSPARENT); SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT)); TextOut(hdc, ((x < 0)? 0 : x), ((y < 0)? 0 : y), msg, len); ReleaseDC(global_hwnd, hdc); rpng2_win_load_bg_image(); } if (!bg_image) { for (j = 0; j < rpng2_info.height; ++j) { dest = wimage_data + j*wimage_rowbytes; for (i = rpng2_info.width; i > 0; --i) { *dest++ = bg_blue; *dest++ = bg_green; *dest++ = bg_red; } } } rect.left = 0L; rect.top = 0L; rect.right = (LONG)rpng2_info.width; rect.bottom = (LONG)rpng2_info.height; InvalidateRect(global_hwnd, &rect, FALSE); UpdateWindow(global_hwnd); return 0; }<SPLIT>[3.7670479574293307, 1.3461090328382055, 0.0, 3.6895403539920464, 1.2532698730026477, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 1.7070733946998113, 3.8369581620336746, 1.4124983101741002, 0.0, 0.0, 0.30852482215402843, 1.6108064495747596, 3.7562655862706786, 1.3227458982827227, 1.5410922403500262, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, 1.8354583307057633, 0.9463589259089511, 1.8115811712209564, -0.21702784222394986, 0.14602883551895066, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static png_uint_32 standard_rowsize(png_const_structp pp, png_uint_32 id) { png_uint_32 width = standard_width(pp, id); width *= bit_size(pp, COL_FROM_ID(id), DEPTH_FROM_ID(id)); return (width + 7) / 8; }<SPLIT>[-0.09900860198293619, -0.5049648101240879, 0.0, -0.11436118199787926, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.09566541730555662, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.11100716297398205, -0.554612270771967, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int logclose(Image *image, FILE *f, const char *name, const char *operation) { int e = errno; fclose(f); return logerror(image, name, operation, strerror(e)); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.4705090699407485, -0.3333928163445767, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>void png_do_strip_filler(png_row_infop row_info, png_bytep row, png_uint_32 flags) { png_debug(1, "in png_do_strip_filler\n"); #if defined(PNG_USELESS_TESTS_SUPPORTED) if (row != NULL && row_info != NULL) #endif { png_bytep sp=row; png_bytep dp=row; png_uint_32 row_width=row_info->width; png_uint_32 i; if (row_info->color_type == PNG_COLOR_TYPE_RGB && row_info->channels == 4) { if (row_info->bit_depth == 8) { if (flags & PNG_FLAG_FILLER_AFTER) { dp+=3; sp+=4; for (i = 1; i < row_width; i++) { *dp++ = *sp++; *dp++ = *sp++; *dp++ = *sp++; sp++; } } else { for (i = 0; i < row_width; i++) { sp++; *dp++ = *sp++; *dp++ = *sp++; *dp++ = *sp++; } } row_info->pixel_depth = 24; row_info->rowbytes = row_width * 3; } else { if (flags & PNG_FLAG_FILLER_AFTER) { sp += 8; dp += 6; for (i = 1; i < row_width; i++) { *dp++ = *sp++; *dp++ = *sp++; *dp++ = *sp++; *dp++ = *sp++; *dp++ = *sp++; *dp++ = *sp++; sp += 2; } } else { for (i = 0; i < row_width; i++) { sp+=2; *dp++ = *sp++; *dp++ = *sp++; *dp++ = *sp++; *dp++ = *sp++; *dp++ = *sp++; *dp++ = *sp++; } } row_info->pixel_depth = 48; row_info->rowbytes = row_width * 6; } row_info->channels = 3; } else if (row_info->color_type == PNG_COLOR_TYPE_GRAY && row_info->channels == 2) { if (row_info->bit_depth == 8) { if (flags & PNG_FLAG_FILLER_AFTER) { for (i = 0; i < row_width; i++) { *dp++ = *sp++; sp++; } } else { for (i = 0; i < row_width; i++) { sp++; *dp++ = *sp++; } } row_info->pixel_depth = 8; row_info->rowbytes = row_width; } else { if (flags & PNG_FLAG_FILLER_AFTER) { sp += 4; dp += 2; for (i = 1; i < row_width; i++) { *dp++ = *sp++; *dp++ = *sp++; sp += 2; } } else { for (i = 0; i < row_width; i++) { sp += 2; *dp++ = *sp++; *dp++ = *sp++; } } row_info->pixel_depth = 16; row_info->rowbytes = row_width * 2; } row_info->channels = 1; } } }<SPLIT>[2.9938366455468772, 2.1394263941077596, 0.0, 2.9287600467940615, 1.998026911466207, 0.0, 0.9701672076669112, 0.9946065798247155, 0.9059316288753189, -0.27925050329511203, 2.3264187687553566, 3.0504334461658287, 2.1646633567058475, 0.0, 0.0, 0.30852482215402843, 2.1920150513308774, 2.9828110364217464, 2.0295160325150765, -0.6586564490689124, 0.4684316465353775, 0.0, 0.02378964451747194, 0.9973611507722091, 1.7300618792100042, -0.14353953243697165, -0.6720729196443977, -0.21702784222394986, 0.33317037975964214, 0.969587250454179, 0.9940939011734088, 0.9053924298597907, -0.27935383381430245, 1.7623686513065309, 0.0, 0.9653245912203542, 0.9897980601469931, 0.9011791483816026, -0.28182971586402455]
0<SPLIT>static void png_cexcept_error(png_structp png_ptr, png_const_charp msg) { if(png_ptr) ; #ifdef PNG_CONSOLE_IO_SUPPORTED fprintf(stderr, "libpng error: %s\n", msg); #endif { Throw msg; } }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.5325257040772059, -0.7880534307994381, -0.4084991676475909, 0.0, 0.02378964451747194, 0.9973611507722091, -0.5886600536966952, -0.5794989157753407, -0.7849662874110047, 0.6817979554923368, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int wpng_isvalid_latin1(uch *p, int len) { int i, result = -1; for (i = 0; i < len; ++i) { if (p[i] == 10 || (p[i] > 31 && p[i] < 127) || p[i] > 160) continue; if (result < 0 || (p[result] != 27 && p[i] == 27)) result = i; } return result; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.380400859743741, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.6586564490689124, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.14353953243697165, -0.5591795518777907, -0.21702784222394986, 0.23959960763929639, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.3801362775450152, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.3766295797615486]
0<SPLIT>static void standard_info_imp(standard_display *dp, png_structp pp, png_infop pi, int nImages) { standard_info_part1(dp, pp, pi); if (dp->use_update_info) { int i = dp->use_update_info; while (i-- > 0) png_read_update_info(pp, pi); } else png_start_read_image(pp); standard_info_part2(dp, pp, pi, nImages); }<SPLIT>[1.2927717594054797, -0.32867206317529807, 0.0, 1.2550433709584938, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.13098384443277505, 1.3200790712565666, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, 1.281211026754096, -0.37791973721387856, -0.011671540416283347, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.3070243011888601, -0.22049944857796966, 0.6817979554923368, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static png_uint_32 png_pass_start_row(int pass) { int x, y; ++pass; for (y=0; y<8; ++y) for (x=0; x<8; ++x) if (adam7[y][x] == pass) return y; return 0xf; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.6586564490689124, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.03454968660237938, -0.5591795518777907, -0.21702784222394986, 0.42674115187998785, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 1.7623686513065309, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static int PNGCBAPI read_callback(png_structp pp, png_unknown_chunkp pc) { display *d = voidcast(display*, png_get_user_chunk_ptr(pp)); int chunk = findb(pc->name); int keep, discard; if (chunk < 0) keep = d->keep; else { keep = chunk_info[chunk].keep; if (keep == PNG_HANDLE_CHUNK_AS_DEFAULT) { if (chunk_info[chunk].unknown) keep = d->keep; else keep = PNG_HANDLE_CHUNK_NEVER; } } switch (keep) { default: fprintf(stderr, "%s(%s): %d: unrecognized chunk option\n", d->file, d->test, chunk_info[chunk].keep); display_exit(d); case PNG_HANDLE_CHUNK_AS_DEFAULT: case PNG_HANDLE_CHUNK_NEVER: discard = 1; break; case PNG_HANDLE_CHUNK_IF_SAFE: case PNG_HANDLE_CHUNK_ALWAYS: discard = 0; break; } if (chunk >= 0) if (!discard) { png_uint_32 flag = chunk_info[chunk].flag; if (pc->location & PNG_AFTER_IDAT) d->after_IDAT |= flag; else d->before_IDAT |= flag; } #ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED return discard; #else return 1; #endif }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 1.559355493837688, 0.31700388179131606, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.4871364861795985, 1.5905928466936687, 0.262590696934192, -0.7880534307994381, -0.518115519420462, 0.0, 0.02378964451747194, 1.5771521192305922, -0.06167779621789984, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void gp_ag16(Pixel *p, png_const_voidp pb) { png_const_uint_16p pp = voidcast(png_const_uint_16p, pb); p->r = p->g = p->b = pp[1]; p->a = pp[0]; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>LRESULT CALLBACK rpng2_win_wndproc(HWND hwnd, UINT iMsg, WPARAM wP, LPARAM lP) { HDC hdc; PAINTSTRUCT ps; int rc; switch (iMsg) { case WM_CREATE: return 0; case WM_PAINT: hdc = BeginPaint(hwnd, &ps); rc = StretchDIBits(hdc, 0, 0, rpng2_info.width, rpng2_info.height, 0, 0, rpng2_info.width, rpng2_info.height, wimage_data, (BITMAPINFO *)bmih, 0, SRCCOPY); EndPaint(hwnd, &ps); return 0; case WM_CHAR: switch (wP) { case 'q': case 'Q': case 0x1B: PostQuitMessage(0); } return 0; case WM_LBUTTONDOWN: case WM_DESTROY: PostQuitMessage(0); return 0; } return DefWindowProc(hwnd, iMsg, wP, lP); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.037794879441717756, -0.02345647864916818, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.016577635342370212, 0.04368374699580437, -0.0024481034029406237, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>uch *readpng_get_image(double display_exponent, int *pChannels, ulg *pRowbytes) { ulg rowbytes; *pRowbytes = rowbytes = channels*width; *pChannels = channels; if ((image_data = (uch *)malloc(rowbytes*height)) == NULL) { return NULL; } Trace((stderr, "readpng_get_image: rowbytes = %ld, height = %ld\n", rowbytes, height)); fread(image_data, 1L, rowbytes*height, saved_infile); return image_data; }<SPLIT>[0.5195604475230265, -0.3947818432810943, 0.0, 0.4942630637605089, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.29081490870517385, 0.5335543553887203, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, 0.5077564769051636, -0.44417943729816173, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
1<SPLIT>void png_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length) { png_textp text_ptr; png_charp key; png_charp text; png_uint_32 skip = 0; png_size_t slength; int ret; png_debug(1, "in png_handle_tEXt\n"); if (!(png_ptr->mode & PNG_HAVE_IHDR)) png_error(png_ptr, "Missing IHDR before tEXt"); if (png_ptr->mode & PNG_HAVE_IDAT) png_ptr->mode |= PNG_AFTER_IDAT; #ifdef PNG_MAX_MALLOC_64K if (length > (png_uint_32)65535L) { png_warning(png_ptr, "tEXt chunk too large to fit in memory"); skip = length - (png_uint_32)65535L; length = (png_uint_32)65535L; } #endif key = (png_charp)png_malloc_warn(png_ptr, length + 1); if (key == NULL) { png_warning(png_ptr, "No memory to process text chunk."); return; } slength = (png_size_t)length; png_crc_read(png_ptr, (png_bytep)key, slength); if (png_crc_finish(png_ptr, skip)) { png_free(png_ptr, key); return; } key[slength] = 0x00; for (text = key; *text; text++) ; if (text != key + slength) text++; text_ptr = (png_textp)png_malloc_warn(png_ptr, (png_uint_32)png_sizeof(png_text)); if (text_ptr == NULL) { png_warning(png_ptr, "Not enough memory to process text chunk."); png_free(png_ptr, key); return; } text_ptr->compression = PNG_TEXT_COMPRESSION_NONE; text_ptr->key = key; #ifdef PNG_iTXt_SUPPORTED text_ptr->lang = NULL; text_ptr->lang_key = NULL; text_ptr->itxt_length = 0; #endif text_ptr->text = text; text_ptr->text_length = png_strlen(text); ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1); png_free(png_ptr, key); png_free(png_ptr, text_ptr); if (ret) png_warning(png_ptr, "Insufficient memory to process text chunk."); }<SPLIT>[1.6020562841584611, 0.7070478251488422, 0.0, 1.559355493837688, 0.63618546970427, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, 0.8679603072697175, 1.6346889576037051, 0.45519734186096705, 0.0, 0.0, 0.30852482215402843, 0.7971144071161946, 1.5905928466936687, 0.3730235304079973, 0.37651940477529405, 0.029966239443893296, 0.0, 0.9057658544417533, 2.736734056147358, 0.6760973642524136, 0.18343000506680518, 0.23107402248845843, -0.21702784222394986, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static void gp_ag8(Pixel *p, png_const_voidp pb) { png_const_bytep pp = voidcast(png_const_bytep, pb); p->r = p->g = p->b = pp[1]; p->a = pp[0]; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void rpng2_win_finish_display() { Trace((stderr, "beginning rpng2_win_finish_display()\n")) rpng2_info.state = kDone; printf( #ifndef __CYGWIN__ "Done. Press Q, Esc or mouse button 1 (within image window) to quit.\n" #else "Done. Press mouse button 1 (within image window) to quit.\n" #endif ); fflush(stdout); }<SPLIT>[0.21027592277004517, -0.3727452499124955, 0.0, 0.18995094088131478, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3107937917392237, 0.21894446904158188, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, 0.19837465696559078, -0.48835257068768384, -0.39986248560786075, 0.2491989429896354, 0.0, 0.02378964451747194, 1.5771521192305922, -0.5886600536966952, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_expand_16_set(PNG_CONST image_transform *this, transform_display *that, png_structp pp, png_infop pi) { png_set_expand_16(pp); this->next->set(this->next, that, pp, pi); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int rpng2_win_load_bg_image() { uch *src, *dest; uch r1, r2, g1, g2, b1, b2; uch r1_inv, r2_inv, g1_inv, g2_inv, b1_inv, b2_inv; int k, hmax, max; int xidx, yidx, yidx_max = (bgscale-1); int even_odd_vert, even_odd_horiz, even_odd; int invert_gradient2 = (bg[pat].type & 0x08); int invert_column; ulg i, row; bg_rowbytes = 3 * rpng2_info.width; bg_data = (uch *)malloc(bg_rowbytes * rpng2_info.height); if (!bg_data) { fprintf(stderr, PROGNAME ": unable to allocate memory for background image\n"); bg_image = 0; return 1; } if ((bg[pat].type & 0x07) == 0) { uch r1_min = rgb[bg[pat].rgb1_min].r; uch g1_min = rgb[bg[pat].rgb1_min].g; uch b1_min = rgb[bg[pat].rgb1_min].b; uch r2_min = rgb[bg[pat].rgb2_min].r; uch g2_min = rgb[bg[pat].rgb2_min].g; uch b2_min = rgb[bg[pat].rgb2_min].b; int r1_diff = rgb[bg[pat].rgb1_max].r - r1_min; int g1_diff = rgb[bg[pat].rgb1_max].g - g1_min; int b1_diff = rgb[bg[pat].rgb1_max].b - b1_min; int r2_diff = rgb[bg[pat].rgb2_max].r - r2_min; int g2_diff = rgb[bg[pat].rgb2_max].g - g2_min; int b2_diff = rgb[bg[pat].rgb2_max].b - b2_min; for (row = 0; row < rpng2_info.height; ++row) { yidx = row % bgscale; even_odd_vert = (row / bgscale) & 1; r1 = r1_min + (r1_diff * yidx) / yidx_max; g1 = g1_min + (g1_diff * yidx) / yidx_max; b1 = b1_min + (b1_diff * yidx) / yidx_max; r1_inv = r1_min + (r1_diff * (yidx_max-yidx)) / yidx_max; g1_inv = g1_min + (g1_diff * (yidx_max-yidx)) / yidx_max; b1_inv = b1_min + (b1_diff * (yidx_max-yidx)) / yidx_max; r2 = r2_min + (r2_diff * yidx) / yidx_max; g2 = g2_min + (g2_diff * yidx) / yidx_max; b2 = b2_min + (b2_diff * yidx) / yidx_max; r2_inv = r2_min + (r2_diff * (yidx_max-yidx)) / yidx_max; g2_inv = g2_min + (g2_diff * (yidx_max-yidx)) / yidx_max; b2_inv = b2_min + (b2_diff * (yidx_max-yidx)) / yidx_max; dest = bg_data + row*bg_rowbytes; for (i = 0; i < rpng2_info.width; ++i) { even_odd_horiz = (i / bgscale) & 1; even_odd = even_odd_vert ^ even_odd_horiz; invert_column = (even_odd_horiz && (bg[pat].type & 0x10)); if (even_odd == 0) { if (invert_column) { *dest++ = r1_inv; *dest++ = g1_inv; *dest++ = b1_inv; } else { *dest++ = r1; *dest++ = g1; *dest++ = b1; } } else { if ((invert_column && invert_gradient2) || (!invert_column && !invert_gradient2)) { *dest++ = r2; *dest++ = g2; *dest++ = b2; } else { *dest++ = r2_inv; *dest++ = g2_inv; *dest++ = b2_inv; } } } } } else if ((bg[pat].type & 0x07) == 1) { hmax = (bgscale-1)/2; max = 2*hmax; r1 = rgb[bg[pat].rgb1_max].r; g1 = rgb[bg[pat].rgb1_max].g; b1 = rgb[bg[pat].rgb1_max].b; r2 = rgb[bg[pat].rgb2_max].r; g2 = rgb[bg[pat].rgb2_max].g; b2 = rgb[bg[pat].rgb2_max].b; for (row = 0; row < rpng2_info.height; ++row) { yidx = row % bgscale; if (yidx > hmax) yidx = bgscale-1 - yidx; dest = bg_data + row*bg_rowbytes; for (i = 0; i < rpng2_info.width; ++i) { xidx = i % bgscale; if (xidx > hmax) xidx = bgscale-1 - xidx; k = xidx + yidx; *dest++ = (k*r1 + (max-k)*r2) / max; *dest++ = (k*g1 + (max-k)*g2) / max; *dest++ = (k*b1 + (max-k)*b2) / max; } } } else if ((bg[pat].type & 0x07) == 2) { uch ch; int ii, x, y, hw, hh, grayspot; double freq, rotate, saturate, gray, intensity; double angle=0.0, aoffset=0.0, maxDist, dist; double red=0.0, green=0.0, blue=0.0, hue, s, v, f, p, q, t; fprintf(stderr, "%s: computing radial background...", PROGNAME); fflush(stderr); hh = rpng2_info.height / 2; hw = rpng2_info.width / 2; angle = CLIP(angle, 0.0, 360.0); grayspot = CLIP(bg[pat].bg_gray, 1, (hh + hw)); freq = MAX((double)bg[pat].bg_freq, 0.0); saturate = (double)bg[pat].bg_bsat * 0.1; rotate = (double)bg[pat].bg_brot * 0.1; gray = 0.0; intensity = 0.0; maxDist = (double)((hw*hw) + (hh*hh)); for (row = 0; row < rpng2_info.height; ++row) { y = row - hh; dest = bg_data + row*bg_rowbytes; for (i = 0; i < rpng2_info.width; ++i) { x = i - hw; angle = (x == 0)? PI_2 : atan((double)y / (double)x); gray = (double)MAX(ABS(y), ABS(x)) / grayspot; gray = MIN(1.0, gray); dist = (double)((x*x) + (y*y)) / maxDist; intensity = cos((angle+(rotate*dist*PI)) * freq) * gray * saturate; intensity = (MAX(MIN(intensity,1.0),-1.0) + 1.0) * 0.5; hue = (angle + PI) * INV_PI_360 + aoffset; s = gray * ((double)(ABS(x)+ABS(y)) / (double)(hw + hh)); s = MIN(MAX(s,0.0), 1.0); v = MIN(MAX(intensity,0.0), 1.0); if (s == 0.0) { ch = (uch)(v * 255.0); *dest++ = ch; *dest++ = ch; *dest++ = ch; } else { if ((hue < 0.0) || (hue >= 360.0)) hue -= (((int)(hue / 360.0)) * 360.0); hue /= 60.0; ii = (int)hue; f = hue - (double)ii; p = (1.0 - s) * v; q = (1.0 - (s * f)) * v; t = (1.0 - (s * (1.0 - f))) * v; if (ii == 0) { red = v; green = t; blue = p; } else if (ii == 1) { red = q; green = v; blue = p; } else if (ii == 2) { red = p; green = v; blue = t; } else if (ii == 3) { red = p; green = q; blue = v; } else if (ii == 4) { red = t; green = p; blue = v; } else if (ii == 5) { red = v; green = p; blue = q; } *dest++ = (uch)(red * 255.0); *dest++ = (uch)(green * 255.0); *dest++ = (uch)(blue * 255.0); } } } fprintf(stderr, "done.\n"); fflush(stderr); } for (row = 0; row < rpng2_info.height; ++row) { src = bg_data + row*bg_rowbytes; dest = wimage_data + row*wimage_rowbytes; for (i = rpng2_info.width; i > 0; --i) { r1 = *src++; g1 = *src++; b1 = *src++; *dest++ = b1; *dest++ = g1; *dest++ = r1; } } return 0; }<SPLIT>[4.076332482182312, 3.307365842643492, 0.0, 3.9938524768712407, 3.147080627952841, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 3.5251517507983476, 4.151568048380813, 3.441064647790025, 0.0, 0.0, 0.30852482215402843, 3.3738058749016497, 4.0656474062102514, 3.288450334116457, 2.1880771490026554, 0.7972807018539907, 0.0, -0.08645738172306322, -0.16222078614455715, 4.997351875578535, 2.6357015363451315, 4.859702100919346, -0.21702784222394986, 0.5203119240003335, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static double closestinteger(double x) { return floor(x + .5); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int read_one_file(FILE *ip, const char *name) { uLong length = 0; uLong a32 = adler32(0, NULL, 0); uLong c32 = crc32(0, NULL, 0); Byte header[132]; for (;;) { int ch = getc(ip); Byte b; if (ch == EOF) break; b = (Byte)ch; if (length < sizeof header) header[length] = b; ++length; a32 = adler32(a32, &b, 1); c32 = crc32(c32, &b, 1); } if (ferror(ip)) return 0; printf("PNG_ICC_CHECKSUM(0x%8.8lx, 0x%8.8lx,\n PNG_MD5(" "0x%2.2x%2.2x%2.2x%2.2x, 0x%2.2x%2.2x%2.2x%2.2x, 0x%2.2x%2.2x%2.2x%2.2x," " 0x%2.2x%2.2x%2.2x%2.2x), %d,\n" " \"%4.4d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d\", %lu, \"%s\")\n", (unsigned long)a32, (unsigned long)c32, header[84], header[85], header[86], header[87], header[88], header[89], header[90], header[91], header[92], header[93], header[94], header[95], header[96], header[97], header[98], header[99], #define u16(x) (header[x] * 256 + header[x+1]) #define u32(x) (u16(x) * 65536 + u16(x+2)) u32(64), u16(24), u16(26), u16(28), u16(30), u16(32), u16(34), (unsigned long)length, name); return 1; }<SPLIT>[-0.09900860198293619, 0.13409639756527525, 0.0, -0.11436118199787926, 0.06165861146095288, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.380400859743741, 0.10876275197582316, -0.09566541730555662, 0.11330413889199094, 0.0, 0.0, 0.30852482215402843, 0.04154322483324156, -0.11100716297398205, 0.04172502998658149, -0.14106852214680915, 0.029966239443893296, 0.0, -0.08645738172306322, 0.9973611507722091, -0.0968099467164862, 0.0744401592322129, -0.10760608081136262, 2.47944955092491, -0.04111270872174079, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.3801362775450152, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.3766295797615486]
0<SPLIT>static void size_row(png_byte buffer[SIZE_ROWMAX], png_uint_32 bit_width, png_uint_32 y) { y = ((y & 1) << 7) + ((y & 2) << 6) + ((y & 4) << 5) + ((y & 8) << 4); y ^= 0xA5; while (bit_width >= 8) *buffer++ = (png_byte)y++, bit_width -= 8; if (bit_width > 0) { png_uint_32 mask = (1U<<(8-bit_width))-1; *buffer = (png_byte)((*buffer & mask) | (y & ~mask)); } }<SPLIT>[0.5195604475230265, -0.3727452499124955, 0.0, 0.4942630637605089, -0.42775315667224323, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.270836025671124, 0.5335543553887203, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, 0.5077564769051636, -0.42209287060340067, -0.7880534307994381, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void readpng_version_info(void) { fprintf(stderr, " Compiled with libpng %s; using libpng %s.\n", PNG_LIBPNG_VER_STRING, png_libpng_ver); fprintf(stderr, " Compiled with zlib %s; using zlib %s.\n", ZLIB_VERSION, zlib_version); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int make_errors(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type, int bdlo, int PNG_CONST bdhi) { for (; bdlo <= bdhi; ++bdlo) { int interlace_type; for (interlace_type = PNG_INTERLACE_NONE; interlace_type < INTERLACE_LAST; ++interlace_type) { unsigned int test; char name[FILE_NAME_SIZE]; standard_name(name, sizeof name, 0, colour_type, 1<<bdlo, 0, interlace_type, 0, 0, 0); for (test=0; test<ARRAY_SIZE(error_test); ++test) { make_error(&pm->this, colour_type, DEPTH(bdlo), interlace_type, test, name); if (fail(pm)) return 0; } } } return 1; }<SPLIT>[-0.25365086435942685, -0.10830612948931077, 0.0, -0.2665172434374763, -0.17240788634188003, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.13098384443277505, -0.25297036047912586, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, -0.26569807294376846, -0.157054070266268, 0.24712242304476825, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.1980344553542678, 0.11818065472185141, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gp_argb8(Pixel *p, png_const_voidp pb) { png_const_bytep pp = voidcast(png_const_bytep, pb); p->r = pp[1]; p->g = pp[2]; p->b = pp[3]; p->a = pp[0]; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void put_uLong(uLong val) { putchar(val >> 24); putchar(val >> 16); putchar(val >> 8); putchar(val >> 0); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int write_png(const char **name, FILE *fp, int color_type, int bit_depth, volatile png_fixed_point gamma, chunk_insert * volatile insert, unsigned int filters, unsigned int *colors) { png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, name, makepng_error, makepng_warning); volatile png_infop info_ptr = NULL; volatile png_bytep row = NULL; if (png_ptr == NULL) { fprintf(stderr, "makepng: OOM allocating write structure\n"); return 1; } if (setjmp(png_jmpbuf(png_ptr))) { png_structp nv_ptr = png_ptr; png_infop nv_info = info_ptr; png_ptr = NULL; info_ptr = NULL; png_destroy_write_struct(&nv_ptr, &nv_info); if (row != NULL) free(row); return 1; } png_set_benign_errors(png_ptr, 1); png_init_io(png_ptr, fp); info_ptr = png_create_info_struct(png_ptr); if (info_ptr == NULL) png_error(png_ptr, "OOM allocating info structure"); { unsigned int size = image_size_of_type(color_type, bit_depth, colors); png_fixed_point real_gamma = 45455; png_byte gamma_table[256]; double conv; if (gamma == PNG_GAMMA_MAC_18) gamma = 65909; else if (gamma > 0 && gamma < 1000) gamma = PNG_FP_1; if (gamma > 0) real_gamma = gamma; { unsigned int i; if (real_gamma == 45455) for (i=0; i<256; ++i) { gamma_table[i] = (png_byte)i; conv = 1.; } else { conv = real_gamma; conv /= 45455; gamma_table[0] = 0; for (i=1; i<255; ++i) gamma_table[i] = (png_byte)floor(pow(i/255.,conv) * 255 + .5); gamma_table[255] = 255; } } png_set_IHDR(png_ptr, info_ptr, size, size, bit_depth, color_type, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE); if (color_type & PNG_COLOR_MASK_PALETTE) { int npalette; png_color palette[256]; png_byte trans[256]; npalette = generate_palette(palette, trans, bit_depth, gamma_table, colors); png_set_PLTE(png_ptr, info_ptr, palette, npalette); png_set_tRNS(png_ptr, info_ptr, trans, npalette-1, NULL); for (npalette=0; npalette<256; ++npalette) gamma_table[npalette] = (png_byte)npalette; } if (gamma == PNG_DEFAULT_sRGB) png_set_sRGB(png_ptr, info_ptr, PNG_sRGB_INTENT_ABSOLUTE); else if (gamma > 0) { png_set_gAMA_fixed(png_ptr, info_ptr, real_gamma); png_set_cHRM_fixed(png_ptr, info_ptr, 31270, 32900, 64000, 33000, 30000, 60000, 15000, 6000); } while (insert != NULL) { insert->insert(png_ptr, info_ptr, insert->nparams, insert->parameters); insert = insert->next; } png_write_info(png_ptr, info_ptr); png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE, filters); { int passes = png_set_interlace_handling(png_ptr); int pass; png_size_t rowbytes = png_get_rowbytes(png_ptr, info_ptr); row = malloc(rowbytes); if (row == NULL) png_error(png_ptr, "OOM allocating row buffer"); for (pass = 0; pass < passes; ++pass) { unsigned int y; for (y=0; y<size; ++y) { generate_row(row, rowbytes, y, color_type, bit_depth, gamma_table, conv, colors); png_write_row(png_ptr, row); } } } } png_write_end(png_ptr, info_ptr); { png_structp nv_ptr = png_ptr; png_infop nv_info = info_ptr; png_ptr = NULL; info_ptr = NULL; png_destroy_write_struct(&nv_ptr, &nv_info); } free(row); return 0; }<SPLIT>[1.9113408089114425, 2.0072068338961673, 0.0, 1.863667616716882, 1.8703542763010255, 0.0, 1.1439604446378808, 1.1713499043019204, 1.0717736154263862, 0.380400859743741, 2.066693289312709, 1.9492988439508436, 2.0962847161120526, 0.0, 0.0, 0.30852482215402843, 1.940157990569893, 1.8999746666332415, 1.9632563324307932, 3.3526499845773876, 0.9068970536268617, 0.0, -0.08645738172306322, -0.16222078614455715, 1.8354583307057633, 2.3087319988413544, 2.9405148488870267, 0.6817979554923368, 1.4560196452037908, 1.143335983750264, 1.1708005902540914, 1.0711936229013617, 0.3801362775450152, 0.9056307075691036, 0.0, 1.1388542534712223, 1.1662853116856364, 1.0667610514419015, 0.3766295797615486]
0<SPLIT>static void perform_one_test(FILE *fp, int argc, const char **argv, png_uint_32 *default_flags, display *d, int set_callback) { int def; png_uint_32 flags[2][4]; rewind(fp); clear_keep(); memcpy(flags[0], default_flags, sizeof flags[0]); def = check(fp, argc, argv, flags[1], d, set_callback); check_error(d, (flags[0][0]|flags[0][2]) & (flags[0][1]|flags[0][3]), "chunk handled inconsistently in count tests"); check_error(d, (flags[1][0]|flags[1][2]) & (flags[1][1]|flags[1][3]), "chunk handled inconsistently in option tests"); { png_uint_32 test; test = flags[1][0] & ~flags[0][0]; check_error(d, test, "new known chunk before IDAT"); test = flags[1][1] & ~(flags[0][0] | flags[0][1]); check_error(d, test, "new unknown chunk before IDAT"); test = flags[1][2] & ~flags[0][2]; check_error(d, test, "new known chunk after IDAT"); test = flags[1][3] & ~(flags[0][2] | flags[0][3]); check_error(d, test, "new unknown chunk after IDAT"); } check_handling(d, def, flags[0][0] | flags[0][1], flags[1][0], flags[1][1], "before IDAT", set_callback); check_handling(d, def, flags[0][2] | flags[0][3], flags[1][2], flags[1][3], "after IDAT", set_callback); }<SPLIT>[1.9113408089114425, 0.0018768373536828752, 0.0, 1.863667616716882, -0.06601402370422871, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.24861493321417213, 1.9492988439508436, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, 0.17715856524300236, 1.8999746666332415, -0.04662123679246273, 0.24712242304476825, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, -0.25252937827156396, 0.005287286955244392, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gpc_nop8(Pixel *out, const Pixel *in, const Background *back) { (void)back; if (in->a == 0) out->r = out->g = out->b = 255; else { out->r = in->r; out->g = in->g; out->b = in->b; } out->a = in->a; }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.7880534307994381, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5794989157753407, -0.7849662874110047, 0.6817979554923368, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int main(int argc, char **argv) { int count = COUNT; while (argc > 1) { if (argc > 2 && strcmp(argv[1], "-c") == 0) { count = atoi(argv[2]); argc -= 2; argv += 2; } else if (strcmp(argv[1], "-v") == 0) { ++verbose; --argc; ++argv; } else break; } if (count > 0 && argc > 1) { if (strcmp(argv[1], "ascii") == 0) return validation_ascii_to_fp(count, argc-1, argv+1); else if (strcmp(argv[1], "checkfp") == 0) return validation_checkfp(count, argc-1, argv+1); else if (strcmp(argv[1], "muldiv") == 0) return validation_muldiv(count, argc-1, argv+1); else if (strcmp(argv[1], "gamma") == 0) return validation_gamma(argc-1, argv+1); } fprintf(stderr, "usage: tarith [-v] [-c count] {ascii,muldiv,gamma} [args]\n"); fprintf(stderr, " arguments: ascii [-a (all results)] [-e error%%]\n"); fprintf(stderr, " checkfp [-l max-number-chars]\n"); fprintf(stderr, " muldiv\n"); fprintf(stderr, " gamma -s (silent) -g (only gamma; no log)\n"); return 1; }<SPLIT>[-0.09900860198293619, 0.20020617767107143, 0.0, -0.11436118199787926, 0.14677370157107394, 0.0, 0.9701672076669112, 0.9946065798247155, 1.2376156019774536, 2.3593549488603003, 0.1686994010779727, -0.09566541730555662, 0.22726853988164963, 0.0, 0.0, 0.30852482215402843, 0.11903770506739059, -0.11100716297398205, 0.15215786346038676, 0.11772544131424245, 1.78382786780983, 0.0, -0.08645738172306322, 0.417570182313826, -0.06167779621789984, 0.7828741571570628, 0.11818065472185141, -0.21702784222394986, 1.2688781009630994, 0.969587250454179, 0.9940939011734088, 1.2369948159429325, 2.3586066116229683, 0.9056307075691036, 0.0, 0.9653245912203542, 0.9897980601469931, 1.2323429545022004, 2.352007466638268]
0<SPLIT>static void perform_size_test(png_modifier *pm) { if (!test_size(pm, 0, 0, READ_BDHI)) return; if (!test_size(pm, 2, 3, READ_BDHI)) return; #if 0 if (!test_size(pm, 3, 0, 3)) return; #endif if (!test_size(pm, 4, 3, READ_BDHI)) return; if (!test_size(pm, 6, 3, READ_BDHI)) return; }<SPLIT>[0.6742027098995172, -0.30663546980669937, 0.0, 0.6464191252001059, -0.36391683908965244, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 1.040052222782594, -0.1909204935349246, 0.6908592985622897, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, 0.66244738687495, -0.44417943729816173, -0.6586564490689124, 0.029966239443893296, 0.0, 0.13403667075800713, 0.9973611507722091, -0.5183957526995224, -0.1980344553542678, -0.6720729196443977, -0.21702784222394986, 0.23959960763929639, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 1.039626388904333, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 1.0350888753871217]
0<SPLIT>static unsigned int bit_size(png_const_structp pp, png_byte colour_type, png_byte bit_depth) { switch (colour_type) { default: png_error(pp, "invalid color type"); case 0: return bit_depth; case 2: return 3*bit_depth; case 3: return bit_depth; case 4: return 2*bit_depth; case 6: return 4*bit_depth; } }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void store_image_free(png_store *ps, png_const_structp pp) { if (ps->image != NULL) { png_bytep image = ps->image; if (image[-1] != 0xed || image[ps->cb_image] != 0xfe) { if (pp != NULL) png_error(pp, "png_store image overwrite (1)"); else store_log(ps, NULL, "png_store image overwrite (2)", 1); } ps->image = NULL; ps->cb_image = 0; --image; free(image); } }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.41601414702345235, -0.4462861841111837, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void rpng2_x_display_row(ulg row) { uch bg_red = rpng2_info.bg_red; uch bg_green = rpng2_info.bg_green; uch bg_blue = rpng2_info.bg_blue; uch *src, *src2=NULL; char *dest; uch r, g, b, a; int ximage_rowbytes = ximage->bytes_per_line; ulg i, pixel; static int rows=0, prevpass=(-1); static ulg firstrow; Trace((stderr, "beginning rpng2_x_display_row()\n")) if (rpng2_info.pass != prevpass) { if (pause_after_pass && rpng2_info.pass > 0) { XEvent e; KeySym k; fprintf(stderr, "%s: end of pass %d of 7; click in image window to continue\n", PROGNAME, prevpass + 1); do XNextEvent(display, &e); while (!QUIT(e,k)); } fprintf(stderr, "%s: pass %d of 7\r", PROGNAME, rpng2_info.pass + 1); fflush(stderr); prevpass = rpng2_info.pass; } if (rows == 0) firstrow = row; ++rows; if (depth == 24 || depth == 32) { ulg red, green, blue; int bpp = ximage->bits_per_pixel; src = rpng2_info.image_data + row*rpng2_info.rowbytes; if (bg_image) src2 = bg_data + row*bg_rowbytes; dest = ximage->data + row*ximage_rowbytes; if (rpng2_info.channels == 3) { for (i = rpng2_info.width; i > 0; --i) { red = *src++; green = *src++; blue = *src++; pixel = (red << RShift) | (green << GShift) | (blue << BShift); if (bpp == 32) { *dest++ = (char)((pixel >> 24) & 0xff); *dest++ = (char)((pixel >> 16) & 0xff); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } else { *dest++ = (char)((pixel >> 16) & 0xff); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } } } else { for (i = rpng2_info.width; i > 0; --i) { r = *src++; g = *src++; b = *src++; a = *src++; if (bg_image) { bg_red = *src2++; bg_green = *src2++; bg_blue = *src2++; } if (a == 255) { red = r; green = g; blue = b; } else if (a == 0) { red = bg_red; green = bg_green; blue = bg_blue; } else { alpha_composite(red, r, a, bg_red); alpha_composite(green, g, a, bg_green); alpha_composite(blue, b, a, bg_blue); } pixel = (red << RShift) | (green << GShift) | (blue << BShift); if (bpp == 32) { *dest++ = (char)((pixel >> 24) & 0xff); *dest++ = (char)((pixel >> 16) & 0xff); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } else { *dest++ = (char)((pixel >> 16) & 0xff); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } } } } else if (depth == 16) { ush red, green, blue; src = rpng2_info.row_pointers[row]; if (bg_image) src2 = bg_data + row*bg_rowbytes; dest = ximage->data + row*ximage_rowbytes; if (rpng2_info.channels == 3) { for (i = rpng2_info.width; i > 0; --i) { red = ((ush)(*src) << 8); ++src; green = ((ush)(*src) << 8); ++src; blue = ((ush)(*src) << 8); ++src; pixel = ((red >> RShift) & RMask) | ((green >> GShift) & GMask) | ((blue >> BShift) & BMask); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } } else { for (i = rpng2_info.width; i > 0; --i) { r = *src++; g = *src++; b = *src++; a = *src++; if (bg_image) { bg_red = *src2++; bg_green = *src2++; bg_blue = *src2++; } if (a == 255) { red = ((ush)r << 8); green = ((ush)g << 8); blue = ((ush)b << 8); } else if (a == 0) { red = ((ush)bg_red << 8); green = ((ush)bg_green << 8); blue = ((ush)bg_blue << 8); } else { alpha_composite(r, r, a, bg_red); alpha_composite(g, g, a, bg_green); alpha_composite(b, b, a, bg_blue); red = ((ush)r << 8); green = ((ush)g << 8); blue = ((ush)b << 8); } pixel = ((red >> RShift) & RMask) | ((green >> GShift) & GMask) | ((blue >> BShift) & BMask); *dest++ = (char)((pixel >> 8) & 0xff); *dest++ = (char)( pixel & 0xff); } } } else { } if (demo_timing && (row - firstrow >= 16 || row >= rpng2_info.height-2)) { XPutImage(display, window, gc, ximage, 0, (int)firstrow, 0, (int)firstrow, rpng2_info.width, row - firstrow + 1); XFlush(display); rows = 0; usleep(usleep_duration); } else if (!demo_timing && ((rows & 0xf) == 0 || row >= rpng2_info.height-2)) { XPutImage(display, window, gc, ximage, 0, (int)firstrow, 0, (int)firstrow, rpng2_info.width, row - firstrow + 1); XFlush(display); rows = 0; } }<SPLIT>[4.849543794064766, 2.99885353548311, 0.0, 4.7546327840692255, 2.849177812567418, 0.0, 0.6225807337249721, 0.6411199308703055, 0.7400896423242515, -0.27925050329511203, 3.345341803491899, 4.938092764248659, 3.121964325018981, 0.0, 0.0, 0.30852482215402843, 3.199443294374815, 4.839101956059183, 2.979238400389802, 0.5059163865058198, 0.6876643500811196, 0.0, -0.08645738172306322, -0.16222078614455715, 3.1704800496520447, 0.40140969673598975, 0.4568607580216725, -0.21702784222394986, 0.33317037975964214, 0.6220897838620095, 0.6406805230120434, 0.7395912368182198, -0.27935383381430245, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.7355972453213037, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI store_free(png_structp ppIn, png_voidp memory) { png_const_structp pp = ppIn; store_pool *pool = voidcast(store_pool*, png_get_mem_ptr(pp)); store_memory *this = voidcast(store_memory*, memory), **test; if (pp != pool->store->pread && pp != pool->store->pwrite) pp = NULL; --this; for (test = &pool->list; *test != this; test = &(*test)->next) { if (*test == NULL) { store_pool_error(pool->store, pp, "bad pointer to free"); return; } } *test = this->next; this->next = NULL; store_memory_free(pp, pool, this); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 1.102887309518897, -0.2575229764520011, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.09407211557651925, 1.1265201167843093, -0.24540033704531222, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int read_byte(struct file *file) { int ch = getc(file->file); if (ch >= 0 && ch <= 255) { ++(file->read_count); return ch; } else if (ch != EOF) { file->status_code |= INTERNAL_ERROR; file->read_errno = ERANGE; emit_error(file, UNEXPECTED_ERROR_CODE, "file read"); } #ifdef EINTR else if (errno == EINTR) { errno = 0; return read_byte(file); } #endif else { if (ferror(file->file)) file->read_errno = errno; else if (feof(file->file)) file->read_errno = 0; else file->read_errno = EDOM; } file->status_code |= TRUNCATED; return EOF; }<SPLIT>[0.9834872346524985, 0.0900232108280778, 0.0, 0.9507312480792999, 0.01910106640589235, 0.0, -0.07259221415890627, -0.06585336703851451, 0.07672169611998206, -0.27925050329511203, 0.2086571671460724, 1.0054691849094282, -0.04624602249353125, 0.0, 0.0, 0.30852482215402843, 0.13841132512592785, 0.9718292068145229, -0.1128809368767459, -0.270465503877335, 0.029966239443893296, 0.0, 0.4647777494796126, 0.9973611507722091, -0.2373385487108316, -0.1980344553542678, -0.10760608081136262, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_strip_16_mod(PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp, PNG_CONST transform_display *display) { if (that->bit_depth == 16) { that->sample_depth = that->bit_depth = 8; if (that->red_sBIT > 8) that->red_sBIT = 8; if (that->green_sBIT > 8) that->green_sBIT = 8; if (that->blue_sBIT > 8) that->blue_sBIT = 8; if (that->alpha_sBIT > 8) that->alpha_sBIT = 8; #ifdef PNG_READ_ACCURATE_SCALE_SUPPORTED #if PNG_LIBPNG_VER >= 10504 #error PNG_READ_ACCURATE_SCALE should not be set #endif { PNG_CONST double d = (255-128.5)/65535; that->rede += d; that->greene += d; that->bluee += d; that->alphae += d; } #endif } this->next->mod(this->next, that, pp, display); }<SPLIT>[1.1381294970289892, -0.06423294275211332, 0.0, 1.102887309518897, -0.12985034128681952, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.08878386894177331, 0.3762494122151511, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, 0.022169604774704303, 0.35306556693537716, -0.37791973721387856, -0.5292594673383866, -0.4084991676475909, 0.0, 1.5672480118849643, 2.736734056147358, -0.30760284970800433, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int repl_getch(void) { char ch; int fd = fileno(stdin); struct termio old_tty, new_tty; ioctl(fd, TCGETA, &old_tty); new_tty = old_tty; new_tty.c_lflag &= ~(ICANON | ECHO | ISIG); ioctl(fd, TCSETA, &new_tty); fread(&ch, 1, sizeof(ch), stdin); ioctl(fd, TCSETA, &old_tty); return ch; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.42209287060340067, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, 0.417570182313826, -0.3427350002065907, -0.1980344553542678, 0.11818065472185141, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gpc_g16q(Pixel *out, const Pixel *in, const Background *back) { (void)back; out->r = out->g = out->b = u16d(YfromRGBint(in->r, in->g, in->b)); out->a = in->a; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void print_one(const char *leader, double err) { if (err != -1.) printf(" %s %.5f\n", leader, err); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5250039928580447, -0.6720729196443977, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void store_memory_free(png_const_structp pp, store_pool *pool, store_memory *memory) { if (memory->pool != pool) store_pool_error(pool->store, pp, "memory corrupted (pool)"); else if (memcmp(memory->mark, pool->mark, sizeof memory->mark) != 0) store_pool_error(pool->store, pp, "memory corrupted (start)"); else { png_alloc_size_t cb = memory->size; if (cb > pool->max) store_pool_error(pool->store, pp, "memory corrupted (size)"); else if (memcmp((png_bytep)(memory+1)+cb, pool->mark, sizeof pool->mark) != 0) store_pool_error(pool->store, pp, "memory corrupted (end)"); else { pool->current -= cb; free(memory); } } }<SPLIT>[0.6742027098995172, -0.17441590959510697, 0.0, 0.6464191252001059, -0.23624420392447085, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, -0.07104719533062549, 0.6908592985622897, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.13281935569359377, 0.66244738687495, -0.22331377035055117, -0.39986248560786075, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.08904460951967552, -0.4462861841111837, 3.3782753486411963, -0.13468348084208653, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static png_uint_32 png_row_from_pass_row(png_uint_32 yIn, int pass) { switch (pass) { case 0: return yIn * 8; case 1: return yIn * 8; case 2: return yIn * 8 + 4; case 3: return yIn * 4; case 4: return yIn * 4 + 2; case 5: return yIn * 2; case 6: return yIn * 2 + 1; default: break; } return 0xff; }<SPLIT>[-0.09900860198293619, -0.30663546980669937, 0.0, -0.11436118199787926, -0.36391683908965244, 0.0, 0.7963739706959416, -0.2425966915157195, 0.7400896423242515, 2.0295292673408736, -0.29081490870517385, -0.09566541730555662, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.11100716297398205, -0.3558331705191175, -0.7880534307994381, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, 0.29241985090139744, -0.7849662874110047, 6.074752741790056, 0.5203119240003335, 0.7958385171580944, -0.24285292239137013, 0.7395912368182198, 2.0288615559433096, 0.04889276383167627, 0.0, 0.791794928969486, -0.24561270062351, 0.7355972453213037, 2.0227778188254817]
0<SPLIT>BOOL CenterAbout (HWND hwndChild, HWND hwndParent) { RECT rChild, rParent, rWorkArea; int wChild, hChild, wParent, hParent; int xNew, yNew; BOOL bResult; GetWindowRect (hwndChild, &rChild); wChild = rChild.right - rChild.left; hChild = rChild.bottom - rChild.top; GetWindowRect (hwndParent, &rParent); wParent = rParent.right - rParent.left; hParent = rParent.bottom - rParent.top; bResult = SystemParametersInfo(SPI_GETWORKAREA, sizeof(RECT), &rWorkArea, 0); if (!bResult) { rWorkArea.left = rWorkArea.top = 0; rWorkArea.right = GetSystemMetrics(SM_CXSCREEN); rWorkArea.bottom = GetSystemMetrics(SM_CYSCREEN); } xNew = rParent.left + ((wParent - wChild) /2); if (xNew < rWorkArea.left) { xNew = rWorkArea.left; } else if ((xNew+wChild) > rWorkArea.right) { xNew = rWorkArea.right - wChild; } yNew = rParent.top + ((hParent - hChild) /2); if (yNew < rWorkArea.top) { yNew = rWorkArea.top; } else if ((yNew+hChild) > rWorkArea.bottom) { yNew = rWorkArea.bottom - hChild; } return SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.6464191252001059, 0.10421615651601342, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.17715856524300236, 0.66244738687495, 0.1300712967656257, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.043718655277859224, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int control_end(struct control *control) { return file_end(&control->file); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static double calcerr(PNG_CONST png_modifier *pm, int in_depth, int out_depth) { if ((pm->calculations_use_input_precision ? in_depth : out_depth) == 16) return pm->maxcalc16; else if (pm->assume_16_bit_calculations) return pm->maxcalcG; else return pm->maxcalc8; }<SPLIT>[0.21027592277004517, -0.46089162338689044, 0.0, 0.18995094088131478, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3907093238754231, 0.21894446904158188, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, 0.19837465696559078, -0.48835257068768384, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void print_pixel(png_structp png_ptr, png_infop info_ptr, png_const_bytep row, png_uint_32 x) { PNG_CONST unsigned int bit_depth = png_get_bit_depth(png_ptr, info_ptr); switch (png_get_color_type(png_ptr, info_ptr)) { case PNG_COLOR_TYPE_GRAY: printf("GRAY %u\n", component(row, x, 0, bit_depth, 1)); return; case PNG_COLOR_TYPE_PALETTE: { PNG_CONST unsigned int index = component(row, x, 0, bit_depth, 1); png_colorp palette = NULL; int num_palette = 0; if ((png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette) & PNG_INFO_PLTE) && num_palette > 0 && palette != NULL) { png_bytep trans_alpha = NULL; int num_trans = 0; if ((png_get_tRNS(png_ptr, info_ptr, &trans_alpha, &num_trans, NULL) & PNG_INFO_tRNS) && num_trans > 0 && trans_alpha != NULL) printf("INDEXED %u = %d %d %d %d\n", index, palette[index].red, palette[index].green, palette[index].blue, index < num_trans ? trans_alpha[index] : 255); else printf("INDEXED %u = %d %d %d\n", index, palette[index].red, palette[index].green, palette[index].blue); } else printf("INDEXED %u = invalid index\n", index); } return; case PNG_COLOR_TYPE_RGB: printf("RGB %u %u %u\n", component(row, x, 0, bit_depth, 3), component(row, x, 1, bit_depth, 3), component(row, x, 2, bit_depth, 3)); return; case PNG_COLOR_TYPE_GRAY_ALPHA: printf("GRAY+ALPHA %u %u\n", component(row, x, 0, bit_depth, 2), component(row, x, 1, bit_depth, 2)); return; case PNG_COLOR_TYPE_RGB_ALPHA: printf("RGBA %u %u %u %u\n", component(row, x, 0, bit_depth, 4), component(row, x, 1, bit_depth, 4), component(row, x, 2, bit_depth, 4), component(row, x, 3, bit_depth, 4)); return; default: png_error(png_ptr, "invalid color type"); } }<SPLIT>[0.36491818514653585, 0.5527916715686512, 0.0, 0.34210700232091185, 0.4659552894840279, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.5482981787249199, 0.3762494122151511, 0.5919546230485575, 0.0, 0.0, 0.30852482215402843, 0.4677628661210612, 0.35306556693537716, 0.5055429305765636, 0.37651940477529405, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, -0.1980344553542678, 0.23107402248845843, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void PngFileInitialize (HWND hwnd) { static TCHAR szFilter[] = TEXT ("PNG Files (*.PNG)\0*.png\0") TEXT ("All Files (*.*)\0*.*\0\0"); ofn.lStructSize = sizeof (OPENFILENAME); ofn.hwndOwner = hwnd; ofn.hInstance = NULL; ofn.lpstrFilter = szFilter; ofn.lpstrCustomFilter = NULL; ofn.nMaxCustFilter = 0; ofn.nFilterIndex = 0; ofn.lpstrFile = NULL; ofn.nMaxFile = MAX_PATH; ofn.lpstrFileTitle = NULL; ofn.nMaxFileTitle = MAX_PATH; ofn.lpstrInitialDir = NULL; ofn.lpstrTitle = NULL; ofn.Flags = 0; ofn.nFileOffset = 0; ofn.nFileExtension = 0; ofn.lpstrDefExt = TEXT ("png"); ofn.lCustData = 0; ofn.lpfnHook = NULL; ofn.lpTemplateName = NULL; }<SPLIT>[-0.25365086435942685, -0.10830612948931077, 0.0, -0.2665172434374763, -0.17240788634188003, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.13098384443277505, -0.25297036047912586, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, -0.26569807294376846, -0.157054070266268, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.043718655277859224, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static png_size_t load_fake(png_charp param, png_bytepp profile) { char *endptr = NULL; unsigned long long int size = strtoull(param, &endptr, 0); if (endptr != NULL && *endptr == '*') { size_t len = strlen(++endptr); size_t result = (size_t)size; if (len == 0) len = 1; if (result == size && (*profile = malloc(result)) != NULL) { png_bytep out = *profile; if (len == 1) memset(out, *endptr, result); else { while (size >= len) { memcpy(out, endptr, len); out += len; size -= len; } memcpy(out, endptr, size); } return result; } else { fprintf(stderr, "%s: size exceeds system limits\n", param); exit(1); } } return 0; }<SPLIT>[0.05563366039355449, 0.11205980419667652, 0.0, 0.037794879441717756, 0.04037983893342262, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, 0.380400859743741, 0.10876275197582316, 0.061639525868012635, 0.13609701908992267, 0.0, 0.0, 0.30852482215402843, 0.04154322483324156, 0.04368374699580437, 0.06381159668134254, 0.37651940477529405, 0.6876643500811196, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, 0.5103995425705821, 0.4568607580216725, 0.6817979554923368, 0.42674115187998785, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, 0.3801362775450152, 2.6191065950439585, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 0.3766295797615486]
1<SPLIT>int png_set_text_2(png_structp png_ptr, png_infop info_ptr, png_const_textp text_ptr, int num_text) { int i; png_debug1(1, "in %s storage function", ((png_ptr == NULL || png_ptr->chunk_name[0] == '\0') ? "text" : (png_const_charp)png_ptr->chunk_name)); if (png_ptr == NULL || info_ptr == NULL || num_text == 0) return(0); if (info_ptr->num_text + num_text > info_ptr->max_text) { if (info_ptr->text != NULL) { png_textp old_text; int old_max; old_max = info_ptr->max_text; info_ptr->max_text = info_ptr->num_text + num_text + 8; old_text = info_ptr->text; info_ptr->text = (png_textp)png_malloc_warn(png_ptr, (png_size_t)(info_ptr->max_text * png_sizeof(png_text))); if (info_ptr->text == NULL) { png_free(png_ptr, old_text); return(1); } png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max * png_sizeof(png_text))); png_free(png_ptr, old_text); } else { info_ptr->max_text = num_text + 8; info_ptr->num_text = 0; info_ptr->text = (png_textp)png_malloc_warn(png_ptr, (png_size_t)(info_ptr->max_text * png_sizeof(png_text))); if (info_ptr->text == NULL) return(1); info_ptr->free_me |= PNG_FREE_TEXT; } png_debug1(3, "allocated %d entries for info_ptr->text", info_ptr->max_text); } for (i = 0; i < num_text; i++) { png_size_t text_length, key_len; png_size_t lang_len, lang_key_len; png_textp textp = &(info_ptr->text[info_ptr->num_text]); if (text_ptr[i].key == NULL) continue; if (text_ptr[i].compression < PNG_TEXT_COMPRESSION_NONE || text_ptr[i].compression >= PNG_TEXT_COMPRESSION_LAST) { png_warning(png_ptr, "text compression mode is out of range"); continue; } key_len = png_strlen(text_ptr[i].key); if (text_ptr[i].compression <= 0) { lang_len = 0; lang_key_len = 0; } else #ifdef PNG_iTXt_SUPPORTED { if (text_ptr[i].lang != NULL) lang_len = png_strlen(text_ptr[i].lang); else lang_len = 0; if (text_ptr[i].lang_key != NULL) lang_key_len = png_strlen(text_ptr[i].lang_key); else lang_key_len = 0; } #else { png_warning(png_ptr, "iTXt chunk not supported"); continue; } #endif if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\0') { text_length = 0; #ifdef PNG_iTXt_SUPPORTED if (text_ptr[i].compression > 0) textp->compression = PNG_ITXT_COMPRESSION_NONE; else #endif textp->compression = PNG_TEXT_COMPRESSION_NONE; } else { text_length = png_strlen(text_ptr[i].text); textp->compression = text_ptr[i].compression; } textp->key = (png_charp)png_malloc_warn(png_ptr, (png_size_t) (key_len + text_length + lang_len + lang_key_len + 4)); if (textp->key == NULL) return(1); png_debug2(2, "Allocated %lu bytes at %p in png_set_text", (unsigned long)(png_uint_32) (key_len + lang_len + lang_key_len + text_length + 4), textp->key); png_memcpy(textp->key, text_ptr[i].key,(png_size_t)(key_len)); *(textp->key + key_len) = '\0'; if (text_ptr[i].compression > 0) { textp->lang = textp->key + key_len + 1; png_memcpy(textp->lang, text_ptr[i].lang, lang_len); *(textp->lang + lang_len) = '\0'; textp->lang_key = textp->lang + lang_len + 1; png_memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len); *(textp->lang_key + lang_key_len) = '\0'; textp->text = textp->lang_key + lang_key_len + 1; } else { textp->lang=NULL; textp->lang_key=NULL; textp->text = textp->key + key_len + 1; } if (text_length) png_memcpy(textp->text, text_ptr[i].text, (png_size_t)(text_length)); *(textp->text + text_length) = '\0'; #ifdef PNG_iTXt_SUPPORTED if (textp->compression > 0) { textp->text_length = 0; textp->itxt_length = text_length; } else #endif { textp->text_length = text_length; textp->itxt_length = 0; } info_ptr->num_text++; png_debug1(3, "transferred text chunk %d", info_ptr->num_text); } return(0); }<SPLIT>[5.158828318817746, 2.4920118880053392, 0.0, 5.05894490694842, 2.3597660444342217, 0.0, 1.6653401555507896, 1.7015798777335354, 1.5692995750795884, 3.0190063118991532, 2.9257852597768523, 4.151568048380813, 2.0051131953203254, 0.0, 0.0, 0.30852482215402843, 2.792597273145532, 4.0656474062102514, 1.874910065651749, 0.5059163865058198, 1.0165134053997327, 0.0, 2.7799653005308507, 4.4761069615225075, 1.5895332772156587, 1.0008538488262473, 0.23107402248845843, -0.21702784222394986, 1.5495904173241366, 1.664582183638518, 1.7009206574961395, 1.5685972020260743, 3.018096722982286, 1.7623686513065309, 0.0, 1.6594432402238268, 1.6957470663015664, 1.5635067606227984, 3.0104667622638415]
0<SPLIT>static int image_transform_png_set_strip_16_add(image_transform *this, PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth) { UNUSED(colour_type) this->next = *that; *that = this; return bit_depth > 8; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void store_read_set(png_store *ps, png_uint_32 id) { png_store_file *pf = ps->saved; while (pf != NULL) { if (pf->id == id) { ps->current = pf; ps->next = NULL; store_read_buffer_next(ps); return; } pf = pf->next; } { size_t pos; char msg[FILE_NAME_SIZE+64]; pos = standard_name_from_id(msg, sizeof msg, 0, id); pos = safecat(msg, sizeof msg, pos, ": file not found"); png_error(ps->pread, msg); } }<SPLIT>[-0.25365086435942685, -0.15237931622650824, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.17094161050087475, -0.25297036047912586, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, -0.011671540416283347, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.3615192241061562, -0.10760608081136262, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_rgb_to_gray_mod(PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp, PNG_CONST transform_display *display) { if ((that->colour_type & PNG_COLOR_MASK_COLOR) != 0) { double gray, err; if (that->colour_type == PNG_COLOR_TYPE_PALETTE) image_pixel_convert_PLTE(that); #if DIGITIZE { PNG_CONST png_modifier *pm = display->pm; const unsigned int sample_depth = that->sample_depth; const unsigned int calc_depth = (pm->assume_16_bit_calculations ? 16 : sample_depth); const unsigned int gamma_depth = (sample_depth == 16 ? 16 : (pm->assume_16_bit_calculations ? PNG_MAX_GAMMA_8 : sample_depth)); int isgray; double r, g, b; double rlo, rhi, glo, ghi, blo, bhi, graylo, grayhi; r = rlo = rhi = that->redf; rlo -= that->rede; rlo = digitize(rlo, calc_depth, 1); rhi += that->rede; rhi = digitize(rhi, calc_depth, 1); g = glo = ghi = that->greenf; glo -= that->greene; glo = digitize(glo, calc_depth, 1); ghi += that->greene; ghi = digitize(ghi, calc_depth, 1); b = blo = bhi = that->bluef; blo -= that->bluee; blo = digitize(blo, calc_depth, 1); bhi += that->greene; bhi = digitize(bhi, calc_depth, 1); isgray = r==g && g==b; if (data.gamma != 1) { PNG_CONST double power = 1/data.gamma; PNG_CONST double abse = calc_depth == 16 ? .5/65535 : .5/255; r = pow(r, power); rlo = digitize(pow(rlo, power)-abse, calc_depth, 1); rhi = digitize(pow(rhi, power)+abse, calc_depth, 1); g = pow(g, power); glo = digitize(pow(glo, power)-abse, calc_depth, 1); ghi = digitize(pow(ghi, power)+abse, calc_depth, 1); b = pow(b, power); blo = digitize(pow(blo, power)-abse, calc_depth, 1); bhi = digitize(pow(bhi, power)+abse, calc_depth, 1); } gray = r * data.red_coefficient + g * data.green_coefficient + b * data.blue_coefficient; { PNG_CONST int do_round = data.gamma != 1 || calc_depth == 16; PNG_CONST double ce = 1. / 32768; graylo = digitize(rlo * (data.red_coefficient-ce) + glo * (data.green_coefficient-ce) + blo * (data.blue_coefficient-ce), gamma_depth, do_round); if (graylo <= 0) graylo = 0; grayhi = digitize(rhi * (data.red_coefficient+ce) + ghi * (data.green_coefficient+ce) + bhi * (data.blue_coefficient+ce), gamma_depth, do_round); if (grayhi >= 1) grayhi = 1; } if (data.gamma != 1) { PNG_CONST double power = data.gamma; gray = pow(gray, power); graylo = digitize(pow(graylo, power), sample_depth, 1); grayhi = digitize(pow(grayhi, power), sample_depth, 1); } if (isgray) err = (that->rede + that->greene + that->bluee)/3; else { err = fabs(grayhi-gray); if (fabs(gray - graylo) > err) err = fabs(graylo-gray); if (err > pm->limit) { size_t pos = 0; char buffer[128]; pos = safecat(buffer, sizeof buffer, pos, "rgb_to_gray error "); pos = safecatd(buffer, sizeof buffer, pos, err, 6); pos = safecat(buffer, sizeof buffer, pos, " exceeds limit "); pos = safecatd(buffer, sizeof buffer, pos, pm->limit, 6); png_error(pp, buffer); } } } #else { double r = that->redf; double re = that->rede; double g = that->greenf; double ge = that->greene; double b = that->bluef; double be = that->bluee; if (r == g && r == b) { gray = r; err = re; if (err < ge) err = ge; if (err < be) err = be; } else if (data.gamma == 1) { gray = r * data.red_coefficient + g * data.green_coefficient + b * data.blue_coefficient; err = re * data.red_coefficient + ge * data.green_coefficient + be * data.blue_coefficient + 1./32768 + gray * 5 * DBL_EPSILON; } else { PNG_CONST png_modifier *pm = display->pm; double in_qe = (that->sample_depth > 8 ? .5/65535 : .5/255); double out_qe = (that->sample_depth > 8 ? .5/65535 : (pm->assume_16_bit_calculations ? .5/(1<<PNG_MAX_GAMMA_8) : .5/255)); double rhi, ghi, bhi, grayhi; double g1 = 1/data.gamma; rhi = r + re + in_qe; if (rhi > 1) rhi = 1; r -= re + in_qe; if (r < 0) r = 0; ghi = g + ge + in_qe; if (ghi > 1) ghi = 1; g -= ge + in_qe; if (g < 0) g = 0; bhi = b + be + in_qe; if (bhi > 1) bhi = 1; b -= be + in_qe; if (b < 0) b = 0; r = pow(r, g1)*(1-DBL_EPSILON); rhi = pow(rhi, g1)*(1+DBL_EPSILON); g = pow(g, g1)*(1-DBL_EPSILON); ghi = pow(ghi, g1)*(1+DBL_EPSILON); b = pow(b, g1)*(1-DBL_EPSILON); bhi = pow(bhi, g1)*(1+DBL_EPSILON); gray = r * data.red_coefficient + g * data.green_coefficient + b * data.blue_coefficient - 1./32768 - out_qe; if (gray <= 0) gray = 0; else { gray *= (1 - 6 * DBL_EPSILON); gray = pow(gray, data.gamma) * (1-DBL_EPSILON); } grayhi = rhi * data.red_coefficient + ghi * data.green_coefficient + bhi * data.blue_coefficient + 1./32768 + out_qe; grayhi *= (1 + 6 * DBL_EPSILON); if (grayhi >= 1) grayhi = 1; else grayhi = pow(grayhi, data.gamma) * (1+DBL_EPSILON); err = (grayhi - gray) / 2; gray = (grayhi + gray) / 2; if (err <= in_qe) err = gray * DBL_EPSILON; else err -= in_qe; if (err > pm->limit) { size_t pos = 0; char buffer[128]; pos = safecat(buffer, sizeof buffer, pos, "rgb_to_gray error "); pos = safecatd(buffer, sizeof buffer, pos, err, 6); pos = safecat(buffer, sizeof buffer, pos, " exceeds limit "); pos = safecatd(buffer, sizeof buffer, pos, pm->limit, 6); png_error(pp, buffer); } } } #endif that->bluef = that->greenf = that->redf = gray; that->bluee = that->greene = that->rede = err; if (that->red_sBIT > that->green_sBIT) that->red_sBIT = that->green_sBIT; if (that->red_sBIT > that->blue_sBIT) that->red_sBIT = that->blue_sBIT; that->blue_sBIT = that->green_sBIT = that->red_sBIT; if (that->colour_type == PNG_COLOR_TYPE_RGB) that->colour_type = PNG_COLOR_TYPE_GRAY; else if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA) that->colour_type = PNG_COLOR_TYPE_GRAY_ALPHA; } this->next->mod(this->next, that, pp, display); }<SPLIT>[8.560958091100542, 3.3514390293806895, 0.0, 8.406378258619554, 3.1683594004803717, 0.0, 1.3177536816088504, 1.3480932287791254, 1.2376156019774536, -0.27925050329511203, 4.144497124853893, 3.6796532188601057, 1.5492555913616908, 0.0, 0.0, 0.30852482215402843, 3.9550144766577677, 3.601574676300892, 1.4331787317565279, 1.799886203811078, 1.8934442195827013, 0.0, 12.481703609697945, 1.5771521192305922, 3.486669404139322, 1.7637827696683932, 1.6986878034543498, 1.5806237532086234, 1.4560196452037908, 1.3170847170463484, 1.3475072793347742, 1.2369948159429325, -0.27935383381430245, 1.7623686513065309, 0.0, 1.3123839157220905, 1.3427725632242797, 1.2323429545022004, -0.28182971586402455]
0<SPLIT>static void interlace_row(png_bytep buffer, png_const_bytep imageRow, unsigned int pixel_size, png_uint_32 w, int pass) { png_uint_32 xin, xout, xstep; xin = PNG_PASS_START_COL(pass); xstep = 1U<<PNG_PASS_COL_SHIFT(pass); for (xout=0; xin<w; xin+=xstep) { pixel_copy(buffer, xout, imageRow, xin, pixel_size); ++xout; } }<SPLIT>[0.36491818514653585, -0.3727452499124955, 0.0, 0.34210700232091185, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.29081490870517385, 0.3762494122151511, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, 0.35306556693537716, -0.42209287060340067, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int png_have_neon(png_structp png_ptr) { PNG_UNUSED(png_ptr) return android_getCpuFamily() == ANDROID_CPU_FAMILY_ARM && (android_getCpuFeatures() & ANDROID_CPU_ARM_FEATURE_NEON) != 0; }<SPLIT>[0.36491818514653585, -0.5049648101240879, 0.0, 0.34210700232091185, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, 0.3762494122151511, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, 0.35306556693537716, -0.554612270771967, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void standard_test(png_store* PNG_CONST psIn, png_uint_32 PNG_CONST id, int do_interlace, int use_update_info) { standard_display d; context(psIn, fault); standard_display_init(&d, psIn, id, do_interlace, use_update_info); Try { png_structp pp; png_infop pi; pp = set_store_for_read(d.ps, &pi, d.id, d.do_interlace ? (d.ps->progressive ? "pngvalid progressive deinterlacer" : "pngvalid sequential deinterlacer") : (d.ps->progressive ? "progressive reader" : "sequential reader")); standard_palette_init(&d); if (d.ps->progressive) { png_set_progressive_read_fn(pp, &d, standard_info, progressive_row, standard_end); store_progressive_read(d.ps, pp, pi); } else { png_set_read_fn(pp, d.ps, store_read); png_read_info(pp, pi); standard_info_imp(&d, pp, pi, 2 ); { sequential_row(&d, pp, pi, 0, 1); if (!d.speed) { standard_text_validate(&d, pp, pi, 1); standard_image_validate(&d, pp, 0, 1); } else d.ps->validated = 1; } } if (!d.ps->validated) png_error(pp, "image read failed silently"); } Catch(fault) d.ps = fault; store_read_reset(d.ps); }<SPLIT>[3.921690219805821, 0.35446233125126253, 0.0, 3.8416964154316435, 0.2744463367362555, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.8280025412016178, 3.994263105207244, 0.3868187012671718, 0.0, 0.0, 0.30852482215402843, 0.7389935469405828, 3.910956496240465, 0.3067638303237141, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void print_pixel(char string[64], const Pixel *pixel, png_uint_32 format) { switch (format & (PNG_FORMAT_FLAG_ALPHA|PNG_FORMAT_FLAG_COLOR)) { case 0: sprintf(string, "%s(%d)", format_names[format], pixel->g); break; case PNG_FORMAT_FLAG_ALPHA: sprintf(string, "%s(%d,%d)", format_names[format], pixel->g, pixel->a); break; case PNG_FORMAT_FLAG_COLOR: sprintf(string, "%s(%d,%d,%d)", format_names[format], pixel->r, pixel->g, pixel->b); break; case PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_ALPHA: sprintf(string, "%s(%d,%d,%d,%d)", format_names[format], pixel->r, pixel->g, pixel->b, pixel->a); break; default: sprintf(string, "invalid-format"); break; } }<SPLIT>[-0.25365086435942685, -0.10830612948931077, 0.0, -0.2665172434374763, -0.17240788634188003, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.13098384443277505, -0.25297036047912586, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, -0.26569807294376846, -0.157054070266268, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI store_error(png_structp ppIn, png_const_charp message) { png_const_structp pp = ppIn; png_store *ps = voidcast(png_store*, png_get_error_ptr(pp)); if (!ps->expect_error) store_log(ps, pp, message, 1 ); { struct exception_context *the_exception_context = &ps->exception_context; Throw ps; } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.11436118199787926, -0.44903192919977347, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4234236565716526, -0.11100716297398205, -0.44417943729816173, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int rpng2_x_create_window(void) { ulg bg_red = rpng2_info.bg_red; ulg bg_green = rpng2_info.bg_green; ulg bg_blue = rpng2_info.bg_blue; ulg bg_pixel = 0L; ulg attrmask; int need_colormap = FALSE; int screen, pad; uch *xdata; Window root; XEvent e; XGCValues gcvalues; XSetWindowAttributes attr; XTextProperty windowName, *pWindowName = &windowName; XTextProperty iconName, *pIconName = &iconName; XVisualInfo visual_info; XSizeHints *size_hints; XWMHints *wm_hints; XClassHint *class_hints; Trace((stderr, "beginning rpng2_x_create_window()\n")) screen = DefaultScreen(display); depth = DisplayPlanes(display, screen); root = RootWindow(display, screen); #ifdef DEBUG XSynchronize(display, True); #endif if (depth != 16 && depth != 24 && depth != 32) { int visuals_matched = 0; Trace((stderr, "default depth is %d: checking other visuals\n", depth)) visual_info.screen = screen; visual_info.depth = 24; visual_list = XGetVisualInfo(display, VisualScreenMask | VisualDepthMask, &visual_info, &visuals_matched); if (visuals_matched == 0) { fprintf(stderr, "default screen depth %d not supported, and no" " 24-bit visuals found\n", depth); return 2; } Trace((stderr, "XGetVisualInfo() returned %d 24-bit visuals\n", visuals_matched)) visual = visual_list[0].visual; depth = visual_list[0].depth; have_nondefault_visual = TRUE; need_colormap = TRUE; } else { XMatchVisualInfo(display, screen, depth, TrueColor, &visual_info); visual = visual_info.visual; } RMask = visual->red_mask; GMask = visual->green_mask; BMask = visual->blue_mask; if (depth == 8 || need_colormap) { colormap = XCreateColormap(display, root, visual, AllocNone); if (!colormap) { fprintf(stderr, "XCreateColormap() failed\n"); return 2; } have_colormap = TRUE; if (depth == 8) bg_image = FALSE; } if (depth == 15 || depth == 16) { RShift = 15 - rpng2_x_msb(RMask); GShift = 15 - rpng2_x_msb(GMask); BShift = 15 - rpng2_x_msb(BMask); } else if (depth > 16) { RShift = rpng2_x_msb(RMask) - 7; GShift = rpng2_x_msb(GMask) - 7; BShift = rpng2_x_msb(BMask) - 7; } if (depth >= 15 && (RShift < 0 || GShift < 0 || BShift < 0)) { fprintf(stderr, "rpng2 internal logic error: negative X shift(s)!\n"); return 2; } attr.backing_store = Always; attr.event_mask = ExposureMask | KeyPressMask | ButtonPressMask; attrmask = CWBackingStore | CWEventMask; if (have_nondefault_visual) { attr.colormap = colormap; attr.background_pixel = 0; attr.border_pixel = 1; attrmask |= CWColormap | CWBackPixel | CWBorderPixel; } window = XCreateWindow(display, root, 0, 0, rpng2_info.width, rpng2_info.height, 0, depth, InputOutput, visual, attrmask, &attr); if (window == None) { fprintf(stderr, "XCreateWindow() failed\n"); return 2; } else have_window = TRUE; if (depth == 8) XSetWindowColormap(display, window, colormap); if (!XStringListToTextProperty(&window_name, 1, pWindowName)) pWindowName = NULL; if (!XStringListToTextProperty(&icon_name, 1, pIconName)) pIconName = NULL; if ((size_hints = XAllocSizeHints()) != NULL) { size_hints->flags = PMinSize | PMaxSize; size_hints->min_width = size_hints->max_width = (int)rpng2_info.width; size_hints->min_height = size_hints->max_height = (int)rpng2_info.height; } if ((wm_hints = XAllocWMHints()) != NULL) { wm_hints->initial_state = NormalState; wm_hints->input = True; wm_hints->flags = StateHint | InputHint ; } if ((class_hints = XAllocClassHint()) != NULL) { class_hints->res_name = res_name; class_hints->res_class = res_class; } XSetWMProperties(display, window, pWindowName, pIconName, NULL, 0, size_hints, wm_hints, class_hints); if (pWindowName) XFree(pWindowName->value); if (pIconName) XFree(pIconName->value); if (size_hints) XFree(size_hints); if (wm_hints) XFree(wm_hints); if (class_hints) XFree(class_hints); XMapWindow(display, window); gc = XCreateGC(display, window, 0, &gcvalues); have_gc = TRUE; if (depth == 24 || depth == 32) { xdata = (uch *)malloc(4*rpng2_info.width*rpng2_info.height); pad = 32; } else if (depth == 16) { xdata = (uch *)malloc(2*rpng2_info.width*rpng2_info.height); pad = 16; } else { xdata = (uch *)malloc(rpng2_info.width*rpng2_info.height); pad = 8; } if (!xdata) { fprintf(stderr, PROGNAME ": unable to allocate image memory\n"); return 4; } ximage = XCreateImage(display, visual, depth, ZPixmap, 0, (char *)xdata, rpng2_info.width, rpng2_info.height, pad, 0); if (!ximage) { fprintf(stderr, PROGNAME ": XCreateImage() failed\n"); free(xdata); return 3; } ximage->byte_order = MSBFirst; if (bg_image) rpng2_x_load_bg_image(); if (!bg_image) { if (depth == 24 || depth == 32) { bg_pixel = (bg_red << RShift) | (bg_green << GShift) | (bg_blue << BShift); } else if (depth == 16) { bg_pixel = (((bg_red << 8) >> RShift) & RMask) | (((bg_green << 8) >> GShift) & GMask) | (((bg_blue << 8) >> BShift) & BMask); } else { } XSetForeground(display, gc, bg_pixel); XFillRectangle(display, window, gc, 0, 0, rpng2_info.width, rpng2_info.height); } do XNextEvent(display, &e); while (e.type != Expose || e.xexpose.count); XFlush(display); return 0; }<SPLIT>[4.849543794064766, 3.1531096890633012, 0.0, 4.7546327840692255, 2.9981292202601297, 0.0, 3.0556860513185464, 3.1155264735511756, 2.8960354674881272, 2.3593549488603003, 3.485193984730248, 4.938092764248659, 3.2131358458107075, 0.0, 0.0, 0.30852482215402843, 3.3350586347845756, 4.839101956059183, 3.067584667168846, 2.8350620576552843, 1.78382786780983, 0.0, 0.02378964451747194, 0.9973611507722091, 2.92455499616194, 2.6357015363451315, 2.4889413778205984, 0.6817979554923368, 2.391727366407248, 3.054572050007196, 3.114574170141601, 2.8950067463586415, 2.3586066116229683, 0.9056307075691036, 0.0, 3.0476805382307717, 3.107645078610713, 2.88816198510519, 2.352007466638268]
0<SPLIT>static size_t store_read_buffer_avail(png_store *ps) { if (ps->current != NULL && ps->next != NULL) { png_store_buffer *next = &ps->current->data; size_t cbAvail = ps->current->datacount; while (next != ps->next && next != NULL) { next = next->prev; cbAvail += STORE_BUFFER_SIZE; } if (next != ps->next) png_error(ps->pread, "buffer read error"); if (cbAvail > ps->readpos) return cbAvail - ps->readpos; } return 0; }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_rgb_to_gray_ini(PNG_CONST image_transform *this, transform_display *that) { png_modifier *pm = that->pm; PNG_CONST color_encoding *e = pm->current_encoding; UNUSED(this) pm->test_uses_encoding = 1; if (e != 0) { PNG_CONST double whiteY = e->red.Y + e->green.Y + e->blue.Y; data.red_coefficient = e->red.Y; data.green_coefficient = e->green.Y; data.blue_coefficient = e->blue.Y; if (whiteY != 1) { data.red_coefficient /= whiteY; data.green_coefficient /= whiteY; data.blue_coefficient /= whiteY; } } else { data.red_coefficient = 6968 / 32768.; data.green_coefficient = 23434 / 32768.; data.blue_coefficient = 2366 / 32768.; } data.gamma = pm->current_gamma; if (data.gamma == 0) data.gamma = 1; if (pm->test_exhaustive) { data.coefficients_overridden = !data.coefficients_overridden; pm->repeat = data.coefficients_overridden != 0; } else data.coefficients_overridden = random_choice(); if (data.coefficients_overridden) { png_uint_32 ru; double total; RANDOMIZE(ru); data.green_coefficient = total = (ru & 0xffff) / 65535.; ru >>= 16; data.red_coefficient = (1 - total) * (ru & 0xffff) / 65535.; total += data.red_coefficient; data.blue_coefficient = 1 - total; #ifdef PNG_FLOATING_POINT_SUPPORTED data.red_to_set = data.red_coefficient; data.green_to_set = data.green_coefficient; #else data.red_to_set = fix(data.red_coefficient); data.green_to_set = fix(data.green_coefficient); #endif pm->encoding_ignored = 1; } else { data.red_to_set = -1; data.green_to_set = -1; } if (data.gamma != 1) { if (that->this.bit_depth == 16 || pm->assume_16_bit_calculations) { that->pm->limit += #if PNG_MAX_GAMMA_8 < 14 pow((that->this.bit_depth == 16 ? 8. : 6. + (1<<(15-PNG_MAX_GAMMA_8)))/65535, data.gamma); #else pow((that->this.bit_depth == 16 ? 8. : 8. + (1<<(15-PNG_MAX_GAMMA_8)))/65535, data.gamma); #endif } else { that->pm->limit += #if DIGITIZE pow(1.1 /255, data.gamma); #else pow(1.0 /255, data.gamma); #endif } } else { if (that->this.bit_depth != 16 && !pm->assume_16_bit_calculations) that->pm->limit += 4E-3; } }<SPLIT>[7.323819992088616, 1.3240724394696066, 0.0, 7.189129767102778, 1.2107123279475873, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, -0.27925050329511203, 2.146608821448908, 7.454971855025768, 1.070605107205124, 0.0, 0.0, 0.30852482215402843, 2.017652470804042, 7.314156515575767, 0.9693608311665458, 0.11772544131424245, 0.13958259121676436, 0.0, 0.4647777494796126, 5.055897929980891, 0.6409652137538272, 0.01994523631491676, -0.10760608081136262, 0.6817979554923368, 0.05245806339860493, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, -0.27935383381430245, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI pngtest_write_data(png_structp png_ptr, png_bytep data, png_size_t length) { png_size_t check; check = fwrite(data, 1, length, (png_FILE_p)png_get_io_ptr(png_ptr)); if (check != length) { png_error(png_ptr, "Write Error"); } #ifdef PNG_IO_STATE_SUPPORTED pngtest_check_io_state(png_ptr, length, PNG_IO_WRITING); #endif }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.11436118199787926, 0.4233977444289674, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.37089476582837494, -0.11100716297398205, 0.3288503970184752, -0.7880534307994381, -0.518115519420462, 0.0, 0.13403667075800713, 2.1569430876889752, 0.14911510677361828, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>int readpng_get_bgcolor(uch *red, uch *green, uch *blue) { return 1; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static png_uint_32 get_unknown(display *d, png_infop info_ptr, int after_IDAT) { png_uint_32 flags = 0; UNUSED(after_IDAT) { png_unknown_chunkp unknown; int num_unknown = png_get_unknown_chunks(d->png_ptr, info_ptr, &unknown); while (--num_unknown >= 0) { int chunk = findb(unknown[num_unknown].name); if (chunk < 0) switch (d->keep) { default: case PNG_HANDLE_CHUNK_AS_DEFAULT: case PNG_HANDLE_CHUNK_NEVER: fprintf(stderr, "%s(%s): %s: %s: unknown chunk saved\n", d->file, d->test, d->keep ? "discard" : "default", unknown[num_unknown].name); ++(d->error_count); break; case PNG_HANDLE_CHUNK_IF_SAFE: if (!ancillaryb(unknown[num_unknown].name)) { fprintf(stderr, "%s(%s): if-safe: %s: unknown critical chunk saved\n", d->file, d->test, unknown[num_unknown].name); ++(d->error_count); break; } case PNG_HANDLE_CHUNK_ALWAYS: break; } else flags |= chunk_info[chunk].flag; } } return flags; }<SPLIT>[0.6742027098995172, 0.20020617767107143, 0.0, 0.6464191252001059, 0.12549492904354367, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.268593816248222, 0.6908592985622897, 0.22726853988164963, 0.0, 0.0, 0.30852482215402843, 0.19653218530153962, 0.66244738687495, 0.15215786346038676, -0.14106852214680915, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.1980344553542678, 0.005287286955244392, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void usage(const char *prog) { fprintf(stderr, "%s: usage: %s [-linear|-sRGB] [-gray|-color] component{1,4}\n", prog, prog); exit(1); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void usage() { fprintf (stderr, "PNG2PNM\n"); fprintf (stderr, "by Willem van Schaik, 1999\n"); #ifdef __TURBOC__ fprintf (stderr, "for Turbo-C and Borland-C compilers\n"); #else fprintf (stderr, "for Linux (and Unix) compilers\n"); #endif fprintf (stderr, "Usage: png2pnm [options] <file>.png [<file>.pnm]\n"); fprintf (stderr, "or: ... | png2pnm [options]\n"); fprintf (stderr, "Options:\n"); fprintf (stderr, " -r[aw] write pnm-file in binary format (P4/P5/P6) (default)\n"); fprintf (stderr, " -n[oraw] write pnm-file in ascii format (P1/P2/P3)\n"); fprintf (stderr, " -a[lpha] <file>.pgm write PNG alpha channel as pgm-file\n"); fprintf (stderr, " -h | -? print this help-information\n"); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.28780831616189184, -0.26569807294376846, -0.3558331705191175, -0.917450412529964, -0.518115519420462, 0.0, 0.02378964451747194, 1.5771521192305922, -0.30760284970800433, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void gpc_g8b(Pixel *out, const Pixel *in, const Background *back) { if (in->a <= 0) out->r = out->g = out->b = back->ig; else if (in->a >= 255) { if (in->r == in->g && in->g == in->b) out->r = out->g = out->b = in->g; else out->r = out->g = out->b = sRGB(YfromRGB( sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b])); } else { double a = in->a/255.; out->r = out->g = out->b = sRGB(a * YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]) + back->dg * (1-a)); } out->a = 255; }<SPLIT>[-0.25365086435942685, -0.1964525029637057, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.21089937656897445, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3615192241061562, -0.4462861841111837, 0.6817979554923368, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void IDAT_list_init(struct IDAT_list *list) { CLEAR(*list); list->next = NULL; list->length = IDAT_INIT_LENGTH; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int png_have_neon(png_structp png_ptr) { FILE *f = fopen("/proc/cpuinfo", "rb"); if (f != NULL) { static const char ch_feature[] = { 70, 69, 65, 84, 85, 82, 69, 83 }; static const char ch_neon[] = { 78, 69, 79, 78 }; enum { StartLine, Feature, Colon, StartTag, Neon, HaveNeon, SkipTag, SkipLine } state; int counter; for (state=StartLine, counter=0;;) { int ch = fgetc(f); if (ch == EOF) { fclose(f); return 0; } switch (state) { case StartLine: if (ch <= 32) break; counter=0; state = Feature; case Feature: if ((ch & ~0x20) == ch_feature[counter]) { if (++counter == (sizeof ch_feature)) state = Colon; break; } state = SkipLine; case SkipLine: skipLine: if (ch != 10 && ch != 13) break; state = StartLine; break; case Colon: if (ch == 32 || ch == 9) break; if (ch == 58) { state = StartTag; break; } state = SkipLine; goto skipLine; case StartTag: if (ch == 32 || ch == 9) break; state = Neon; counter = 0; case Neon: if ((ch & ~0x20) == ch_neon[counter]) { if (++counter == (sizeof ch_neon)) state = HaveNeon; break; } state = SkipTag; case SkipTag: if (ch == 10 || ch == 13) state = StartLine; else if (ch == 32 || ch == 9) state = StartTag; break; case HaveNeon: if (ch == 10 || ch == 13 || ch == 32 || ch == 9) { fclose(f); return 1; } state = SkipTag; break; default: png_error(png_ptr, "png_have_neon: internal error (bug)"); } } } #ifdef PNG_WARNINGS_SUPPORTED else png_warning(png_ptr, "/proc/cpuinfo open failed"); #endif return 0; }<SPLIT>[3.4577634326763493, 1.3240724394696066, 0.0, 3.3852282311128525, 1.2107123279475873, 0.0, 3.577065762231455, 2.4085531756423553, 4.720297319549869, 5.987437445573992, 1.6471367455976618, 3.5223482756865363, 1.2985339091844414, 0.0, 0.0, 0.30852482215402843, 1.5333119693406105, 3.446883766331106, 1.1902264981141564, 0.6353133682363457, 5.4011674763145745, 0.0, 0.13403667075800713, 0.9973611507722091, 0.7112295147509999, 3.398630457187277, 1.3600077001545285, 2.47944955092491, 4.450284353054854, 3.57581824989545, 2.4077474138188704, 4.718819869815921, 5.985802224099215, 3.475844538781386, 0.0, 3.5682695249833762, 2.4016960724561396, 4.709562918768478, 5.973533592578921]
0<SPLIT>static void image_transform_png_set_@_mod(PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp, PNG_CONST transform_display *display) { this->next->mod(this->next, that, pp, display); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int cmppixel(Transform *transform, png_const_voidp in, png_const_voidp out, png_uint_32 x, png_uint_32 y) { int maxerr; png_const_charp errmsg; Pixel pixel_in, pixel_calc, pixel_out; transform->in_gp(&pixel_in, in); if (transform->from_linear == NULL) transform->transform(&pixel_calc, &pixel_in, transform->background); else { transform->transform(&pixel_out, &pixel_in, transform->background); transform->from_linear(&pixel_calc, &pixel_out, NULL); } transform->out_gp(&pixel_out, out); if (pixel_calc.a == pixel_out.a && pixel_calc.r == pixel_out.r && pixel_calc.g == pixel_out.g && pixel_calc.b == pixel_out.b) return 1; if (transform->output_8bit && pixel_calc.a == 0 && pixel_out.a == 0) return 1; errmsg = NULL; { int err_a = abs(pixel_calc.a-pixel_out.a); if (err_a > transform->error[3]) { if (transform->accumulate) transform->error[3] = (png_uint_16)err_a; else errmsg = "alpha"; } } if (errmsg == NULL && transform->output_8bit && (pixel_calc.a == 0 || pixel_out.a == 0)) return 1; if (errmsg == NULL) { int err_r = abs(pixel_calc.r - pixel_out.r); int err_g = abs(pixel_calc.g - pixel_out.g); int err_b = abs(pixel_calc.b - pixel_out.b); int limit; if ((err_r | err_g | err_b) == 0) return 1; if (pixel_in.a >= transform->in_opaque) { errmsg = "opaque component"; limit = 2; } else if (pixel_in.a > 0) { errmsg = "alpha component"; limit = 1; } else { errmsg = "transparent component (background)"; limit = 0; } maxerr = err_r; if (maxerr < err_g) maxerr = err_g; if (maxerr < err_b) maxerr = err_b; if (maxerr <= transform->error[limit]) return 1; if (transform->accumulate) { transform->error[limit] = (png_uint_16)maxerr; return 1; } } return logpixel(transform, x, y, &pixel_in, &pixel_calc, &pixel_out, errmsg); }<SPLIT>[2.3752675960409144, 0.9053771654662308, 0.0, 2.320135801035673, 0.8064156499245122, 0.0, 1.8391333925217592, 1.8783232022107403, 1.7351415616306558, 2.0295292673408736, 1.1276857867123655, 2.4212136734715513, 0.9566407062154653, 0.0, 0.0, 0.30852482215402843, 1.0295978478186416, 2.3640473965426008, 0.8589279976927405, 0.24712242304476825, 1.674211516036959, 0.0, -0.08645738172306322, -0.16222078614455715, 0.4653044612608955, 1.327823386330024, 0.11818065472185141, 0.6817979554923368, 2.111015050046211, 1.8383309169346027, 1.8776273465768223, 1.7343983950676451, 2.0288615559433096, 0.9056307075691036, 0.0, 1.832972902474695, 1.8722343178402097, 1.7290886636830973, 2.0227778188254817]
0<SPLIT>static struct file * get_control(png_const_structrp png_ptr) { struct control *control = png_voidcast(struct control*, png_get_error_ptr(png_ptr)); return &control->file; }<SPLIT>[0.21027592277004517, -0.5049648101240879, 0.0, 0.18995094088131478, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, 0.21894446904158188, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, 0.19837465696559078, -0.554612270771967, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void readpng2_cleanup(mainprog_info *mainprog_ptr) { png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr; png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr; if (png_ptr && info_ptr) png_destroy_read_struct(&png_ptr, &info_ptr, NULL); mainprog_ptr->png_ptr = NULL; mainprog_ptr->info_ptr = NULL; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void display_clean_read(struct display *dp) { if (dp->read_pp != NULL) png_destroy_read_struct(&dp->read_pp, &dp->read_ip, NULL); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int store_read_buffer_next(png_store *ps) { png_store_buffer *pbOld = ps->next; png_store_buffer *pbNew = &ps->current->data; if (pbOld != pbNew) { while (pbNew != NULL && pbNew->prev != pbOld) pbNew = pbNew->prev; if (pbNew != NULL) { ps->next = pbNew; ps->readpos = 0; return 1; } png_error(ps->pread, "buffer lost"); } return 0; }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, -0.6586564490689124, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.41601414702345235, -0.6720729196443977, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int rpng_win_create_window(HINSTANCE hInst, int showmode) { uch *dest; int extra_width, extra_height; ulg i, j; WNDCLASSEX wndclass; wimage_rowbytes = ((3*image_width + 3L) >> 2) << 2; if (!(dib = (uch *)malloc(sizeof(BITMAPINFOHEADER) + wimage_rowbytes*image_height))) { return 4; } memset(dib, 0, sizeof(BITMAPINFOHEADER)); bmih = (BITMAPINFOHEADER *)dib; bmih->biSize = sizeof(BITMAPINFOHEADER); bmih->biWidth = image_width; bmih->biHeight = -((long)image_height); bmih->biPlanes = 1; bmih->biBitCount = 24; bmih->biCompression = 0; wimage_data = dib + sizeof(BITMAPINFOHEADER); for (j = 0; j < image_height; ++j) { dest = wimage_data + j*wimage_rowbytes; for (i = image_width; i > 0; --i) { *dest++ = bg_blue; *dest++ = bg_green; *dest++ = bg_red; } } memset(&wndclass, 0, sizeof(wndclass)); wndclass.cbSize = sizeof(wndclass); wndclass.style = CS_HREDRAW | CS_VREDRAW; wndclass.lpfnWndProc = rpng_win_wndproc; wndclass.hInstance = hInst; wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION); wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); wndclass.hbrBackground = (HBRUSH)GetStockObject(DKGRAY_BRUSH); wndclass.lpszMenuName = NULL; wndclass.lpszClassName = progname; wndclass.hIconSm = LoadIcon(NULL, IDI_APPLICATION); RegisterClassEx(&wndclass); extra_width = 2*(GetSystemMetrics(SM_CXBORDER) + GetSystemMetrics(SM_CXDLGFRAME)); extra_height = 2*(GetSystemMetrics(SM_CYBORDER) + GetSystemMetrics(SM_CYDLGFRAME)) + GetSystemMetrics(SM_CYCAPTION); global_hwnd = CreateWindow(progname, titlebar, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, image_width+extra_width, image_height+extra_height, NULL, NULL, hInst, NULL); ShowWindow(global_hwnd, showmode); UpdateWindow(global_hwnd); return 0; }<SPLIT>[2.684552120793896, 0.5087184848314537, 0.0, 2.6244479239148673, 0.4446765169564977, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.8080236581675679, 2.73582355981869, 0.546368862652694, 0.0, 0.0, 0.30852482215402843, 0.7389935469405828, 2.6734292164821736, 0.4834563638818026, 0.37651940477529405, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.7463616652495864, 0.01994523631491676, 0.34396739025506545, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int add_one_file(FILE *fp, char *name) { FILE *ip = fopen(name, "rb"); if (ip != NULL) { int ch; for (;;) { ch = getc(ip); if (ch == EOF) break; putc(ch, fp); } if (ferror(ip)) { perror(name); fprintf(stderr, "%s: read error\n", name); return 0; } (void)fclose(ip); if (ferror(fp)) { perror("temporary file"); fprintf(stderr, "temporary file write error\n"); return 0; } } else { perror(name); fprintf(stderr, "%s: open failed\n", name); return 0; } return 1; }<SPLIT>[-0.25365086435942685, 0.0900232108280778, 0.0, -0.2665172434374763, 0.04037983893342262, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, 1.3698779043020206, 0.04882610287367361, -0.25297036047912586, 0.11330413889199094, 0.0, 0.0, 0.30852482215402843, 0.0027959847161670454, -0.26569807294376846, 0.06381159668134254, 0.24712242304476825, 0.6876643500811196, 0.0, -0.08645738172306322, -0.16222078614455715, -0.06167779621789984, 0.5648944654878781, 0.11818065472185141, 2.47944955092491, 0.6138826961206794, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, 1.3693714445839917, 1.7623686513065309, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 1.3643185231999084]
0<SPLIT>static unsigned int random_mod(unsigned int max) { unsigned int x; RANDOMIZE(x); return x % max; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>int png_set_text_2(png_const_structrp png_ptr, png_inforp info_ptr, png_const_textp text_ptr, int num_text) { int i; png_debug1(1, "in %lx storage function", png_ptr == NULL ? "unexpected" : (unsigned long)png_ptr->chunk_name); if (png_ptr == NULL || info_ptr == NULL || num_text <= 0 || text_ptr == NULL) return(0); if (num_text > info_ptr->max_text - info_ptr->num_text) { int old_num_text = info_ptr->num_text; int max_text; png_textp new_text = NULL; max_text = old_num_text; if (num_text <= INT_MAX - max_text) { max_text += num_text; if (max_text < INT_MAX-8) max_text = (max_text + 8) & ~0x7; else max_text = INT_MAX; new_text = png_voidcast(png_textp,png_realloc_array(png_ptr, info_ptr->text, old_num_text, max_text-old_num_text, sizeof *new_text)); } if (new_text == NULL) { png_chunk_report(png_ptr, "too many text chunks", PNG_CHUNK_WRITE_ERROR); return 1; } png_free(png_ptr, info_ptr->text); info_ptr->text = new_text; info_ptr->free_me |= PNG_FREE_TEXT; info_ptr->max_text = max_text; png_debug1(3, "allocated %d entries for info_ptr->text", max_text); } for (i = 0; i < num_text; i++) { size_t text_length, key_len; size_t lang_len, lang_key_len; png_textp textp = &(info_ptr->text[info_ptr->num_text]); if (text_ptr[i].key == NULL) continue; if (text_ptr[i].compression < PNG_TEXT_COMPRESSION_NONE || text_ptr[i].compression >= PNG_TEXT_COMPRESSION_LAST) { png_chunk_report(png_ptr, "text compression mode is out of range", PNG_CHUNK_WRITE_ERROR); continue; } key_len = strlen(text_ptr[i].key); if (text_ptr[i].compression <= 0) { lang_len = 0; lang_key_len = 0; } else #ifdef PNG_iTXt_SUPPORTED { if (text_ptr[i].lang != NULL) lang_len = strlen(text_ptr[i].lang); else lang_len = 0; if (text_ptr[i].lang_key != NULL) lang_key_len = strlen(text_ptr[i].lang_key); else lang_key_len = 0; } #else { png_chunk_report(png_ptr, "iTXt chunk not supported", PNG_CHUNK_WRITE_ERROR); continue; } #endif if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\0') { text_length = 0; #ifdef PNG_iTXt_SUPPORTED if (text_ptr[i].compression > 0) textp->compression = PNG_ITXT_COMPRESSION_NONE; else #endif textp->compression = PNG_TEXT_COMPRESSION_NONE; } else { text_length = strlen(text_ptr[i].text); textp->compression = text_ptr[i].compression; } textp->key = png_voidcast(png_charp,png_malloc_base(png_ptr, key_len + text_length + lang_len + lang_key_len + 4)); if (textp->key == NULL) { png_chunk_report(png_ptr, "text chunk: out of memory", PNG_CHUNK_WRITE_ERROR); return 1; } png_debug2(2, "Allocated %lu bytes at %p in png_set_text", (unsigned long)(png_uint_32) (key_len + lang_len + lang_key_len + text_length + 4), textp->key); memcpy(textp->key, text_ptr[i].key, key_len); *(textp->key + key_len) = '\0'; if (text_ptr[i].compression > 0) { textp->lang = textp->key + key_len + 1; memcpy(textp->lang, text_ptr[i].lang, lang_len); *(textp->lang + lang_len) = '\0'; textp->lang_key = textp->lang + lang_len + 1; memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len); *(textp->lang_key + lang_key_len) = '\0'; textp->text = textp->lang_key + lang_key_len + 1; } else { textp->lang=NULL; textp->lang_key=NULL; textp->text = textp->key + key_len + 1; } if (text_length != 0) memcpy(textp->text, text_ptr[i].text, text_length); *(textp->text + text_length) = '\0'; #ifdef PNG_iTXt_SUPPORTED if (textp->compression > 0) { textp->text_length = 0; textp->itxt_length = text_length; } else #endif { textp->text_length = text_length; textp->itxt_length = 0; } info_ptr->num_text++; png_debug1(3, "transferred text chunk %d", info_ptr->num_text); } return(0); }<SPLIT>[7.169177729712126, 2.4699752946367406, 0.0, 7.036973705663181, 2.338487271906691, 0.0, 1.6653401555507896, 1.7015798777335354, 1.5692995750795884, 2.3593549488603003, 3.16553185618545, 6.196532309637213, 1.9823203151223938, 0.0, 0.0, 0.30852482215402843, 3.0250807138479794, 6.0766292358174745, 1.852823498956988, 1.0235043134279231, 1.674211516036959, 0.0, 2.7799653005308507, 4.4761069615225075, 1.5895332772156587, 1.7637827696683932, 1.0213275968547075, 0.6817979554923368, 2.111015050046211, 1.664582183638518, 1.7009206574961395, 1.5685972020260743, 2.3586066116229683, 1.7623686513065309, 0.0, 1.6594432402238268, 1.6957470663015664, 1.5635067606227984, 2.352007466638268]
0<SPLIT>int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, PSTR cmd, int showmode) { char *args[1024]; char **argv = args; char *p, *q, *bgstr = NULL; int argc = 0; int rc, alen, flen; int error = 0; int timing = FALSE; int have_bg = FALSE; double LUT_exponent; double CRT_exponent = 2.2; double default_display_exponent; MSG msg; global_hInst = hInst; global_showmode = showmode; filename = (char *)NULL; memset(&rpng2_info, 0, sizeof(mainprog_info)); #ifndef __CYGWIN__ AllocConsole(); freopen("CONOUT$", "a", stderr); freopen("CONOUT$", "a", stdout); #endif #if defined(NeXT) LUT_exponent = 1.0 / 2.2; #elif defined(sgi) LUT_exponent = 1.0 / 1.7; infile = fopen("/etc/config/system.glGammaVal", "r"); if (infile) { double sgi_gamma; fgets(tmpline, 80, infile); fclose(infile); sgi_gamma = atof(tmpline); if (sgi_gamma > 0.0) LUT_exponent = 1.0 / sgi_gamma; } #elif defined(Macintosh) LUT_exponent = 1.8 / 2.61; #else LUT_exponent = 1.0; #endif default_display_exponent = LUT_exponent * CRT_exponent; if ((p = getenv("SCREEN_GAMMA")) != NULL) rpng2_info.display_exponent = atof(p); else rpng2_info.display_exponent = default_display_exponent; argv[argc++] = PROGNAME; p = cmd; for (;;) { if (*p == ' ') while (*++p == ' ') ; if (*p == '\0') break; argv[argc++] = q = p; while (*q && *q != ' ') ++q; if (*q == '\0') break; *q = '\0'; p = q + 1; } argv[argc] = NULL; while (*++argv && !error) { if (!strncmp(*argv, "-gamma", 2)) { if (!*++argv) ++error; else { rpng2_info.display_exponent = atof(*argv); if (rpng2_info.display_exponent <= 0.0) ++error; } } else if (!strncmp(*argv, "-bgcolor", 4)) { if (!*++argv) ++error; else { bgstr = *argv; if (strlen(bgstr) != 7 || bgstr[0] != '#') ++error; else { have_bg = TRUE; bg_image = FALSE; } } } else if (!strncmp(*argv, "-bgpat", 4)) { if (!*++argv) ++error; else { pat = atoi(*argv) - 1; if (pat < 0 || pat >= num_bgpat) ++error; else { bg_image = TRUE; have_bg = FALSE; } } } else if (!strncmp(*argv, "-timing", 2)) { timing = TRUE; } else { if (**argv != '-') { filename = *argv; if (argv[1]) ++error; } else ++error; } } if (!filename) ++error; if (error) { #ifndef __CYGWIN__ int ch; #endif fprintf(stderr, "\n%s %s: %s\n\n", PROGNAME, VERSION, appname); readpng2_version_info(); fprintf(stderr, "\n" "Usage: %s [-gamma exp] [-bgcolor bg | -bgpat pat] [-timing]\n" " %*s file.png\n\n" " exp \ttransfer-function exponent (``gamma'') of the display\n" "\t\t system in floating-point format (e.g., ``%.1f''); equal\n" "\t\t to the product of the lookup-table exponent (varies)\n" "\t\t and the CRT exponent (usually 2.2); must be positive\n" " bg \tdesired background color in 7-character hex RGB format\n" "\t\t (e.g., ``#ff7700'' for orange: same as HTML colors);\n" "\t\t used with transparent images; overrides -bgpat option\n" " pat \tdesired background pattern number (1-%d); used with\n" "\t\t transparent images; overrides -bgcolor option\n" " -timing\tenables delay for every block read, to simulate modem\n" "\t\t download of image (~36 Kbps)\n" "\nPress Q, Esc or mouse button 1 after image is displayed to quit.\n" #ifndef __CYGWIN__ "Press Q or Esc to quit this usage screen. ", #else , #endif PROGNAME, #if (defined(__i386__) || defined(_M_IX86) || defined(__x86_64__)) && \ !(defined(__CYGWIN__) || defined(__MINGW32__)) (int)strlen(PROGNAME), " ", #endif (int)strlen(PROGNAME), " ", default_display_exponent, num_bgpat); fflush(stderr); #ifndef __CYGWIN__ do ch = _getch(); while (ch != 'q' && ch != 'Q' && ch != 0x1B); #endif exit(1); } if (!(infile = fopen(filename, "rb"))) { fprintf(stderr, PROGNAME ": can't open PNG file [%s]\n", filename); ++error; } else { incount = fread(inbuf, 1, INBUFSIZE, infile); if (incount < 8 || !readpng2_check_sig(inbuf, 8)) { fprintf(stderr, PROGNAME ": [%s] is not a PNG file: incorrect signature\n", filename); ++error; } else if ((rc = readpng2_init(&rpng2_info)) != 0) { switch (rc) { case 2: fprintf(stderr, PROGNAME ": [%s] has bad IHDR (libpng longjmp)\n", filename); break; case 4: fprintf(stderr, PROGNAME ": insufficient memory\n"); break; default: fprintf(stderr, PROGNAME ": unknown readpng2_init() error\n"); break; } ++error; } if (error) fclose(infile); } if (error) { #ifndef __CYGWIN__ int ch; #endif fprintf(stderr, PROGNAME ": aborting.\n"); #ifndef __CYGWIN__ do ch = _getch(); while (ch != 'q' && ch != 'Q' && ch != 0x1B); #endif exit(2); } else { fprintf(stderr, "\n%s %s: %s\n", PROGNAME, VERSION, appname); #ifndef __CYGWIN__ fprintf(stderr, "\n [console window: closing this window will terminate %s]\n\n", PROGNAME); #endif fflush(stderr); } alen = strlen(appname); flen = strlen(filename); if (alen + flen + 3 > 1023) sprintf(titlebar, "%s: ...%s", appname, filename+(alen+flen+6-1023)); else sprintf(titlebar, "%s: %s", appname, filename); if (have_bg) { unsigned r, g, b; sscanf(bgstr+1, "%2x%2x%2x", &r, &g, &b); rpng2_info.bg_red = (uch)r; rpng2_info.bg_green = (uch)g; rpng2_info.bg_blue = (uch)b; } else rpng2_info.need_bgcolor = TRUE; rpng2_info.state = kPreInit; rpng2_info.mainprog_init = rpng2_win_init; rpng2_info.mainprog_display_row = rpng2_win_display_row; rpng2_info.mainprog_finish_display = rpng2_win_finish_display; for (;;) { Trace((stderr, "about to call readpng2_decode_data()\n")) if (readpng2_decode_data(&rpng2_info, inbuf, incount)) ++error; Trace((stderr, "done with readpng2_decode_data()\n")) if (error || incount != INBUFSIZE || rpng2_info.state == kDone) { if (rpng2_info.state == kDone) { Trace((stderr, "done decoding PNG image\n")) } else if (ferror(infile)) { fprintf(stderr, PROGNAME ": error while reading PNG image file\n"); exit(3); } else if (feof(infile)) { fprintf(stderr, PROGNAME ": end of file reached " "(unexpectedly) while reading PNG image file\n"); exit(3); } else { } break; } if (timing) Sleep(1000L); incount = fread(inbuf, 1, INBUFSIZE, infile); } fclose(infile); Trace((stderr, "about to call readpng2_cleanup()\n")) readpng2_cleanup(&rpng2_info); if (error) { fprintf(stderr, PROGNAME ": libpng error while decoding PNG image\n"); exit(3); } while (GetMessage(&msg, NULL, 0, 0)) { TranslateMessage(&msg); DispatchMessage(&msg); } Trace((stderr, "about to call rpng2_win_cleanup()\n")) rpng2_win_cleanup(); return msg.wParam; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 7.341285828542375, 4.721709794990081, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 5.253047020579764, 5.767247415877902, 4.1498264352121375, -0.6586564490689124, -0.518115519420462, 0.0, 2.7799653005308507, 12.593180519939871, 3.6623301566322537, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void gpc_glin(Pixel *out, const Pixel *in, const Background *back) { (void)back; if (in->r == in->g && in->g == in->b) out->r = out->g = out->b = ilinear(in->g); else out->r = out->g = out->b = u16d(65535 * YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b])); out->a = 65535; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static size_t store_message(png_store *ps, png_const_structp pp, char *buffer, size_t bufsize, size_t pos, PNG_CONST char *msg) { if (pp != NULL && pp == ps->pread) { pos = safecat(buffer, bufsize, pos, "read: "); if (ps->current != NULL) { pos = safecat(buffer, bufsize, pos, ps->current->name); pos = safecat(buffer, bufsize, pos, sep); } } else if (pp != NULL && pp == ps->pwrite) { pos = safecat(buffer, bufsize, pos, "write: "); pos = safecat(buffer, bufsize, pos, ps->wname); pos = safecat(buffer, bufsize, pos, sep); } else { pos = safecat(buffer, bufsize, pos, "pngvalid: "); } if (ps->test[0] != 0) { pos = safecat(buffer, bufsize, pos, ps->test); pos = safecat(buffer, bufsize, pos, sep); } pos = safecat(buffer, bufsize, pos, msg); return pos; }<SPLIT>[0.21027592277004517, 0.023913430722281605, 0.0, 0.18995094088131478, -0.044735251176698444, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 0.04882610287367361, 0.21894446904158188, 0.04492549829819571, 0.0, 0.0, 0.30852482215402843, -0.016577635342370212, 0.19837465696559078, -0.024534670097701678, -0.5292594673383866, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.1980344553542678, -0.6720729196443977, -0.21702784222394986, 0.23959960763929639, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI makepng_error(png_structp png_ptr, png_const_charp message) { makepng_warning(png_ptr, message); png_longjmp(png_ptr, 1); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void PNGCBAPI pngtest_flush(png_structp png_ptr) { PNG_UNUSED(png_ptr) }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.11436118199787926, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5590389969814135, -0.11100716297398205, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6940565051924542, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int srgb_modify(png_modifier *pm, png_modification *me, int add) { UNUSED(add) png_save_uint_32(pm->buffer, 1); png_save_uint_32(pm->buffer+4, CHUNK_sRGB); pm->buffer[8] = ((srgb_modification*)me)->intent; return 1; }<SPLIT>[-0.09900860198293619, -0.46089162338689044, 0.0, -0.11436118199787926, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.09566541730555662, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.11100716297398205, -0.5104391373824448, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>void png_handle_tRNS(png_structp png_ptr, png_infop info_ptr, png_uint_32 length) { png_debug(1, "in png_handle_tRNS\n"); if (!(png_ptr->mode & PNG_HAVE_IHDR)) png_error(png_ptr, "Missing IHDR before tRNS"); else if (png_ptr->mode & PNG_HAVE_IDAT) { png_warning(png_ptr, "Invalid tRNS after IDAT"); png_crc_finish(png_ptr, length); return; } else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_tRNS) { png_warning(png_ptr, "Duplicate tRNS chunk"); png_crc_finish(png_ptr, length); return; } if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) { if (!(png_ptr->mode & PNG_HAVE_PLTE)) { png_warning(png_ptr, "Missing PLTE before tRNS"); } else if (length > png_ptr->num_palette) { png_warning(png_ptr, "Incorrect tRNS chunk length"); png_crc_finish(png_ptr, length); return; } png_ptr->trans = (png_bytep)png_malloc(png_ptr, length); png_ptr->flags |= PNG_FLAG_FREE_TRANS; png_crc_read(png_ptr, png_ptr->trans, (png_size_t)length); png_ptr->num_trans = (png_uint_16)length; } else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB) { png_byte buf[6]; if (length != 6) { png_warning(png_ptr, "Incorrect tRNS chunk length"); png_crc_finish(png_ptr, length); return; } png_crc_read(png_ptr, buf, (png_size_t)length); png_ptr->num_trans = 1; png_ptr->trans_values.red = png_get_uint_16(buf); png_ptr->trans_values.green = png_get_uint_16(buf + 2); png_ptr->trans_values.blue = png_get_uint_16(buf + 4); } else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY) { png_byte buf[6]; if (length != 2) { png_warning(png_ptr, "Incorrect tRNS chunk length"); png_crc_finish(png_ptr, length); return; } png_crc_read(png_ptr, buf, 2); png_ptr->num_trans = 1; png_ptr->trans_values.gray = png_get_uint_16(buf); } else { png_warning(png_ptr, "tRNS chunk not allowed with alpha channel"); png_crc_finish(png_ptr, length); return; } if (png_crc_finish(png_ptr, 0)) return; png_set_tRNS(png_ptr, info_ptr, png_ptr->trans, png_ptr->num_trans, &(png_ptr->trans_values)); }<SPLIT>[1.2927717594054797, 0.971486945572027, 0.0, 1.2550433709584938, 0.8915307400346333, 0.0, 1.49154691857982, 1.5248365532563304, 1.403457588528521, 3.34883199341858, 1.0477702545761662, 1.3200790712565666, 1.0250193468092605, 0.0, 0.0, 0.30852482215402843, 0.9714769876430299, 1.281211026754096, 0.9251876977770237, 0.11772544131424245, 1.1261297571726039, 0.0, -0.08645738172306322, 0.417570182313826, 0.6058330632552409, 0.7828741571570628, 0.005287286955244392, 0.6817979554923368, 1.2688781009630994, 1.4908334503424332, 1.524213968415457, 1.4027960089845035, 3.347841778661945, 0.9056307075691036, 0.0, 1.4859135779729586, 1.519259814762923, 1.3979248575624994, 3.339696410076628]
0<SPLIT>static void PNGCBAPI store_write(png_structp ppIn, png_bytep pb, png_size_t st) { png_const_structp pp = ppIn; png_store *ps = voidcast(png_store*, png_get_io_ptr(pp)); if (ps->pwrite != pp) png_error(pp, "store state damaged"); while (st > 0) { size_t cb; if (ps->writepos >= STORE_BUFFER_SIZE) store_storenew(ps); cb = st; if (cb > STORE_BUFFER_SIZE - ps->writepos) cb = STORE_BUFFER_SIZE - ps->writepos; memcpy(ps->new.buffer + ps->writepos, pb, cb); pb += cb; st -= cb; ps->writepos += cb; } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void gamma_threshold_test(png_modifier *pm, png_byte colour_type, png_byte bit_depth, int interlace_type, double file_gamma, double screen_gamma) { size_t pos = 0; char name[64]; pos = safecat(name, sizeof name, pos, "threshold "); pos = safecatd(name, sizeof name, pos, file_gamma, 3); pos = safecat(name, sizeof name, pos, "/"); pos = safecatd(name, sizeof name, pos, screen_gamma, 3); (void)gamma_test(pm, colour_type, bit_depth, 0, interlace_type, file_gamma, screen_gamma, 0, 1, name, 0 , 0 , 0 , 0 , 0 , 0 ); }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, 0.11772544131424245, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.1980344553542678, -0.22049944857796966, -0.21702784222394986, -0.13468348084208653, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void perform_gamma_test(png_modifier *pm, int summary) { unsigned int calculations_use_input_precision = pm->calculations_use_input_precision; #ifdef PNG_READ_BACKGROUND_SUPPORTED double maxout8 = pm->maxout8; #endif if (!pm->this.speed && pm->test_gamma_threshold) { perform_gamma_threshold_tests(pm); if (fail(pm)) return; } if (pm->test_gamma_transform) { if (summary) { fflush(stderr); printf("Gamma correction error summary\n\n"); printf("The printed value is the maximum error in the pixel values\n"); printf("calculated by the libpng gamma correction code. The error\n"); printf("is calculated as the difference between the output pixel\n"); printf("value (always an integer) and the ideal value from the\n"); printf("libpng specification (typically not an integer).\n\n"); printf("Expect this value to be less than .5 for 8 bit formats,\n"); printf("less than 1 for formats with fewer than 8 bits and a small\n"); printf("number (typically less than 5) for the 16 bit formats.\n"); printf("For performance reasons the value for 16 bit formats\n"); printf("increases when the image file includes an sBIT chunk.\n"); fflush(stdout); } init_gamma_errors(pm); if (pm->test_gamma_expand16) pm->calculations_use_input_precision = 1; perform_gamma_transform_tests(pm); if (!calculations_use_input_precision) pm->calculations_use_input_precision = 0; if (summary) summarize_gamma_errors(pm, 0, 1, 1); if (fail(pm)) return; } if (pm->test_gamma_sbit) { init_gamma_errors(pm); perform_gamma_sbit_tests(pm); if (summary) summarize_gamma_errors(pm, "sBIT", pm->sbitlow < 8U, 1); if (fail(pm)) return; } #ifdef DO_16BIT if (pm->test_gamma_scale16) { init_gamma_errors(pm); perform_gamma_scale16_tests(pm); if (summary) { fflush(stderr); printf("\nGamma correction with 16 to 8 bit reduction:\n"); printf(" 16 bit gray: %.5f\n", pm->error_gray_16); printf(" 16 bit color: %.5f\n", pm->error_color_16); fflush(stdout); } if (fail(pm)) return; } #endif #ifdef PNG_READ_BACKGROUND_SUPPORTED if (pm->test_gamma_background) { init_gamma_errors(pm); if (pm->test_gamma_expand16) { pm->calculations_use_input_precision = 1; pm->maxout8 = .499; } perform_gamma_composition_tests(pm, PNG_BACKGROUND_GAMMA_UNIQUE, pm->test_gamma_expand16); if (!calculations_use_input_precision) pm->calculations_use_input_precision = 0; pm->maxout8 = maxout8; if (summary) summarize_gamma_errors(pm, "background", 1, 0); if (fail(pm)) return; } #endif #ifdef PNG_READ_ALPHA_MODE_SUPPORTED if (pm->test_gamma_alpha_mode) { int do_background; init_gamma_errors(pm); if (pm->test_gamma_expand16) pm->calculations_use_input_precision = 1; for (do_background = ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD; do_background <= ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN && !fail(pm); ++do_background) perform_gamma_composition_tests(pm, do_background, pm->test_gamma_expand16); if (!calculations_use_input_precision) pm->calculations_use_input_precision = 0; if (summary) summarize_gamma_errors(pm, "alpha mode", 1, 0); if (fail(pm)) return; } #endif }<SPLIT>[2.065983071287933, 1.764804306841581, 0.0, 2.015823678156479, 1.6362877784981926, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, 1.699703585821447, 1.8669044589722101, 1.0054691849094282, 0.4779902220588988, 0.0, 0.0, 0.30852482215402843, 1.7464217899845202, 0.9718292068145229, 0.39511009710275835, 0.37651940477529405, 1.2357461089454749, 0.0, 6.4181171664685115, 4.4761069615225075, 1.1328153207340361, 0.9463589259089511, 0.23107402248845843, -0.21702784222394986, 1.4560196452037908, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, 1.6991165002636506, 0.9056307075691036, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 1.693548171012695]
0<SPLIT>static void read_png(struct display *dp, struct buffer *bp, const char *operation, int transforms) { png_structp pp; png_infop ip; display_clean_read(dp); if (operation != NULL) { dp->operation = operation; dp->transforms = transforms; } dp->read_pp = pp = png_create_read_struct(PNG_LIBPNG_VER_STRING, dp, display_error, display_warning); if (pp == NULL) display_log(dp, LIBPNG_ERROR, "failed to create read struct"); dp->read_ip = ip = png_create_info_struct(pp); if (ip == NULL) display_log(dp, LIBPNG_ERROR, "failed to create info struct"); #ifdef PNG_SET_USER_LIMITS_SUPPORTED png_set_user_limits(pp, 0x7fffffff, 0x7fffffff); #endif buffer_start_read(bp); png_set_read_fn(pp, bp, read_function); png_read_png(pp, ip, transforms, NULL); #if 0 { png_bytep pr = png_get_rows(pp, ip)[0]; size_t rb = png_get_rowbytes(pp, ip); size_t cb; char c = ' '; fprintf(stderr, "%.4x %2d (%3lu bytes):", transforms, png_get_bit_depth(pp,ip), (unsigned long)rb); for (cb=0; cb<rb; ++cb) fputc(c, stderr), fprintf(stderr, "%.2x", pr[cb]), c='.'; fputc('\n', stderr); } #endif }<SPLIT>[0.9834872346524985, 0.1781695843024727, 0.0, 0.9507312480792999, 0.10421615651601342, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.2885726992822718, 0.8481642417358589, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, 0.21590580536007686, 0.8171382968447365, -0.2012272036557901, 0.24712242304476825, -0.1892664641018488, 0.0, 1.2365069331633587, 2.1569430876889752, 0.07885080577644558, -0.03454968660237938, 0.23107402248845843, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void make_transform_image(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type, png_byte PNG_CONST bit_depth, unsigned int palette_number, int interlace_type, png_const_charp name) { context(ps, fault); check_interlace_type(interlace_type); Try { png_infop pi; png_structp pp = set_store_for_write(ps, &pi, name); png_uint_32 h; if (pp == NULL) Throw ps; h = transform_height(pp, colour_type, bit_depth); png_set_IHDR(pp, pi, transform_width(pp, colour_type, bit_depth), h, bit_depth, colour_type, interlace_type, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE); #ifdef PNG_TEXT_SUPPORTED #if defined(PNG_READ_zTXt_SUPPORTED) && defined(PNG_WRITE_zTXt_SUPPORTED) #define TEXT_COMPRESSION PNG_TEXT_COMPRESSION_zTXt #else #define TEXT_COMPRESSION PNG_TEXT_COMPRESSION_NONE #endif { static char key[] = "image name"; size_t pos; png_text text; char copy[FILE_NAME_SIZE]; text.compression = TEXT_COMPRESSION; text.key = key; pos = safecat(copy, sizeof copy, 0, ps->wname); text.text = copy; text.text_length = pos; text.itxt_length = 0; text.lang = 0; text.lang_key = 0; png_set_text(pp, pi, &text, 1); } #endif if (colour_type == 3) init_standard_palette(ps, pp, pi, 1U << bit_depth, 1); png_write_info(pp, pi); if (png_get_rowbytes(pp, pi) != transform_rowsize(pp, colour_type, bit_depth)) png_error(pp, "row size incorrect"); else { int npasses = png_set_interlace_handling(pp); int pass; if (npasses != npasses_from_interlace_type(pp, interlace_type)) png_error(pp, "write: png_set_interlace_handling failed"); for (pass=0; pass<npasses; ++pass) { png_uint_32 y; for (y=0; y<h; ++y) { png_byte buffer[TRANSFORM_ROWMAX]; transform_row(pp, buffer, colour_type, bit_depth, y); png_write_row(pp, buffer); } } } #ifdef PNG_TEXT_SUPPORTED { static char key[] = "end marker"; static char comment[] = "end"; png_text text; text.compression = TEXT_COMPRESSION; text.key = key; text.text = comment; text.text_length = (sizeof comment)-1; text.itxt_length = 0; text.lang = 0; text.lang_key = 0; png_set_text(pp, pi, &text, 1); } #endif png_write_end(pp, pi); store_storefile(ps, FILEID(colour_type, bit_depth, palette_number, interlace_type, 0, 0, 0)); store_write_reset(ps); } Catch(fault) { store_write_reset(fault); } }<SPLIT>[2.8391943831703865, 1.279999252732409, 0.0, 2.7766039853544644, 1.1681547828925267, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 1.5272634473933626, 1.7919939007772745, 0.5007831022568305, 0.0, 0.0, 0.30852482215402843, 1.417070248989387, 1.7452837566634551, 0.4171966637975194, -0.270465503877335, -0.518115519420462, 0.0, 4.323423667898343, 5.055897929980891, 1.0625510197368635, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>BOOL PngFileSaveDlg (HWND hwnd, PTSTR pstrFileName, PTSTR pstrTitleName) { ofn.hwndOwner = hwnd; ofn.lpstrFile = pstrFileName; ofn.lpstrFileTitle = pstrTitleName; ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT; return GetSaveFileName (&ofn); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int image_transform_png_set_gray_to_rgb_add(image_transform *this, PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth) { UNUSED(bit_depth) this->next = *that; *that = this; return (colour_type & PNG_COLOR_MASK_COLOR) == 0; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI progressive_row(png_structp ppIn, png_bytep new_row, png_uint_32 y, int pass) { png_const_structp pp = ppIn; PNG_CONST standard_display *dp = voidcast(standard_display*, png_get_progressive_ptr(pp)); if (new_row != NULL) { png_bytep row; if (dp->do_interlace && dp->interlace_type == PNG_INTERLACE_ADAM7) { #ifdef PNG_USER_TRANSFORM_INFO_SUPPORTED if (y != png_get_current_row_number(pp)) png_error(pp, "png_get_current_row_number is broken"); if (pass != png_get_current_pass_number(pp)) png_error(pp, "png_get_current_pass_number is broken"); #endif y = PNG_ROW_FROM_PASS_ROW(y, pass); } if (y >= dp->h) png_error(pp, "invalid y to progressive row callback"); row = store_image_row(dp->ps, pp, 0, y); #ifdef PNG_READ_INTERLACING_SUPPORTED if (dp->do_interlace) { if (dp->interlace_type == PNG_INTERLACE_ADAM7) deinterlace_row(row, new_row, dp->pixel_size, dp->w, pass); else row_copy(row, new_row, dp->pixel_size * dp->w); } else png_progressive_combine_row(pp, row, new_row); #endif } #ifdef PNG_READ_INTERLACING_SUPPORTED else if (dp->interlace_type == PNG_INTERLACE_ADAM7 && PNG_ROW_IN_INTERLACE_PASS(y, pass) && PNG_PASS_COLS(dp->w, pass) > 0) png_error(pp, "missing row in progressive de-interlacing"); #endif }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 1.4071994323980908, 0.16805247409860422, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.3321475257113004, 1.1265201167843093, -0.3116600371295954, -0.7880534307994381, -0.518115519420462, 0.0, 2.0082361168471046, 3.3165250246057414, -0.27247069920941797, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
1<SPLIT>int png_set_text_2(png_structp png_ptr, png_infop info_ptr, png_const_textp text_ptr, int num_text) { int i; png_debug1(1, "in %s storage function", ((png_ptr == NULL || png_ptr->chunk_name[0] == '\0') ? "text" : (png_const_charp)png_ptr->chunk_name)); if (png_ptr == NULL || info_ptr == NULL || num_text == 0) return(0); if (info_ptr->num_text + num_text > info_ptr->max_text) { if (info_ptr->text != NULL) { png_textp old_text; int old_max; old_max = info_ptr->max_text; info_ptr->max_text = info_ptr->num_text + num_text + 8; old_text = info_ptr->text; info_ptr->text = (png_textp)png_malloc_warn(png_ptr, (png_size_t)(info_ptr->max_text * png_sizeof(png_text))); if (info_ptr->text == NULL) { png_free(png_ptr, old_text); return(1); } png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max * png_sizeof(png_text))); png_free(png_ptr, old_text); } else { info_ptr->max_text = num_text + 8; info_ptr->num_text = 0; info_ptr->text = (png_textp)png_malloc_warn(png_ptr, (png_size_t)(info_ptr->max_text * png_sizeof(png_text))); if (info_ptr->text == NULL) return(1); info_ptr->free_me |= PNG_FREE_TEXT; } png_debug1(3, "allocated %d entries for info_ptr->text", info_ptr->max_text); } for (i = 0; i < num_text; i++) { png_size_t text_length, key_len; png_size_t lang_len, lang_key_len; png_textp textp = &(info_ptr->text[info_ptr->num_text]); if (text_ptr[i].key == NULL) continue; if (text_ptr[i].compression < PNG_TEXT_COMPRESSION_NONE || text_ptr[i].compression >= PNG_TEXT_COMPRESSION_LAST) { png_warning(png_ptr, "text compression mode is out of range"); continue; } key_len = png_strlen(text_ptr[i].key); if (text_ptr[i].compression <= 0) { lang_len = 0; lang_key_len = 0; } else #ifdef PNG_iTXt_SUPPORTED { if (text_ptr[i].lang != NULL) lang_len = png_strlen(text_ptr[i].lang); else lang_len = 0; if (text_ptr[i].lang_key != NULL) lang_key_len = png_strlen(text_ptr[i].lang_key); else lang_key_len = 0; } #else { png_warning(png_ptr, "iTXt chunk not supported"); continue; } #endif if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\0') { text_length = 0; #ifdef PNG_iTXt_SUPPORTED if (text_ptr[i].compression > 0) textp->compression = PNG_ITXT_COMPRESSION_NONE; else #endif textp->compression = PNG_TEXT_COMPRESSION_NONE; } else { text_length = png_strlen(text_ptr[i].text); textp->compression = text_ptr[i].compression; } textp->key = (png_charp)png_malloc_warn(png_ptr, (png_size_t) (key_len + text_length + lang_len + lang_key_len + 4)); if (textp->key == NULL) return(1); png_debug2(2, "Allocated %lu bytes at %p in png_set_text", (unsigned long)(png_uint_32) (key_len + lang_len + lang_key_len + text_length + 4), textp->key); png_memcpy(textp->key, text_ptr[i].key,(png_size_t)(key_len)); *(textp->key + key_len) = '\0'; if (text_ptr[i].compression > 0) { textp->lang = textp->key + key_len + 1; png_memcpy(textp->lang, text_ptr[i].lang, lang_len); *(textp->lang + lang_len) = '\0'; textp->lang_key = textp->lang + lang_len + 1; png_memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len); *(textp->lang_key + lang_key_len) = '\0'; textp->text = textp->lang_key + lang_key_len + 1; } else { textp->lang=NULL; textp->lang_key=NULL; textp->text = textp->key + key_len + 1; } if (text_length) png_memcpy(textp->text, text_ptr[i].text, (png_size_t)(text_length)); *(textp->text + text_length) = '\0'; #ifdef PNG_iTXt_SUPPORTED if (textp->compression > 0) { textp->text_length = 0; textp->itxt_length = text_length; } else #endif { textp->text_length = text_length; textp->itxt_length = 0; } info_ptr->num_text++; png_debug1(3, "transferred text chunk %d", info_ptr->num_text); } return(0); }<SPLIT>[5.158828318817746, 2.4920118880053392, 0.0, 5.05894490694842, 2.3597660444342217, 0.0, 1.6653401555507896, 1.7015798777335354, 1.5692995750795884, 3.0190063118991532, 2.9257852597768523, 4.151568048380813, 2.0051131953203254, 0.0, 0.0, 0.30852482215402843, 2.792597273145532, 4.0656474062102514, 1.874910065651749, 0.5059163865058198, 1.0165134053997327, 0.0, 2.7799653005308507, 4.4761069615225075, 1.5895332772156587, 1.0008538488262473, 0.23107402248845843, -0.21702784222394986, 1.5495904173241366, 1.664582183638518, 1.7009206574961395, 1.5685972020260743, 3.018096722982286, 1.7623686513065309, 0.0, 1.6594432402238268, 1.6957470663015664, 1.5635067606227984, 3.0104667622638415]
0<SPLIT>static void modification_init(png_modification *pmm) { memset(pmm, 0, sizeof *pmm); pmm->next = NULL; pmm->chunk = 0; pmm->modify_fn = NULL; pmm->add = 0; modification_reset(pmm); }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int sbit_modify(png_modifier *pm, png_modification *me, int add) { png_byte sbit = ((sbit_modification*)me)->sbit; if (pm->bit_depth > sbit) { int cb = 0; switch (pm->colour_type) { case 0: cb = 1; break; case 2: case 3: cb = 3; break; case 4: cb = 2; break; case 6: cb = 4; break; default: png_error(pm->this.pread, "unexpected colour type in sBIT modification"); } png_save_uint_32(pm->buffer, cb); png_save_uint_32(pm->buffer+4, CHUNK_sBIT); while (cb > 0) (pm->buffer+8)[--cb] = sbit; return 1; } else if (!add) { pm->buffer_count = pm->buffer_position = 0; return 1; } else return 0; }<SPLIT>[-0.09900860198293619, 0.2222427710396702, 0.0, -0.11436118199787926, 0.14677370157107394, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, 0.18867828411202256, -0.09566541730555662, 0.2500614200795814, 0.0, 0.0, 0.30852482215402843, 0.11903770506739059, -0.11100716297398205, 0.17424443015514782, -0.39986248560786075, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.06167779621789984, -0.25252937827156396, -0.4462861841111837, -0.21702784222394986, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int channels_of_type(int color_type) { if (color_type & PNG_COLOR_MASK_PALETTE) return 1; else { int channels = 1; if (color_type & PNG_COLOR_MASK_COLOR) channels = 3; if (color_type & PNG_COLOR_MASK_ALPHA) return channels + 1; else return channels; } }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.380400859743741, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.6586564490689124, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.25252937827156396, -0.6720729196443977, -0.21702784222394986, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.3801362775450152, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.3766295797615486]
0<SPLIT>static void rpng2_x_finish_display(void) { Trace((stderr, "beginning rpng2_x_finish_display()\n")) rpng2_info.state = kDone; printf( "Done. Press Q, Esc or mouse button 1 (within image window) to quit.\n"); fflush(stdout); }<SPLIT>[0.21027592277004517, -0.4829282167554892, 0.0, 0.18995094088131478, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, 0.21894446904158188, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, 0.19837465696559078, -0.5104391373824448, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int ancillaryb(const png_byte *name) { return PNG_CHUNK_ANCILLARY(PNG_U32(name[0], name[1], name[2], name[3])); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int readpng_init(FILE *infile, ulg *pWidth, ulg *pHeight) { static uch ppmline[256]; int maxval; saved_infile = infile; fgets(ppmline, 256, infile); if (ppmline[0] != 'P' || ppmline[1] != '6') { fprintf(stderr, "ERROR: not a PPM file\n"); return 1; } if (ppmline[1] == '6') { color_type = 2; channels = 3; } else if (ppmline[1] == '8') { color_type = 6; channels = 4; } else { color_type = 0; channels = 1; } do { fgets(ppmline, 256, infile); } while (ppmline[0] == '#'); sscanf(ppmline, "%lu %lu", &width, &height); do { fgets(ppmline, 256, infile); } while (ppmline[0] == '#'); sscanf(ppmline, "%d", &maxval); if (maxval != 255) { fprintf(stderr, "ERROR: maxval = %d\n", maxval); return 2; } bit_depth = 8; *pWidth = width; *pHeight = height; return 0; }<SPLIT>[-0.09900860198293619, 0.15613299093387398, 0.0, -0.11436118199787926, 0.08293738398848315, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 0.380400859743741, 0.128741635009873, -0.09566541730555662, 0.18168277948578615, 0.0, 0.0, 0.30852482215402843, 0.060916844891778815, -0.11100716297398205, 0.10798473007086465, -0.270465503877335, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, 0.14911510677361828, -0.03454968660237938, -0.22049944857796966, -0.21702784222394986, 0.14602883551895066, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 0.3801362775450152, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 0.3766295797615486]
0<SPLIT>static int file_end(struct file *file) { int rc; if (file->idat != NULL) IDAT_end(&file->idat); if (file->chunk != NULL) chunk_end(&file->chunk); rc = file->status_code; if (file->file != NULL) (void)fclose(file->file); if (file->out != NULL) { if (ferror(file->out) | fflush(file->out) | fclose(file->out)) { perror(file->out_name); emit_error(file, READ_ERROR_CODE, "output write error"); rc |= WRITE_ERROR; } } file->global->status_code |= rc; CLEAR(*file); return rc; }<SPLIT>[0.8288449722760078, -0.13034272285790952, 0.0, 0.798575186639703, -0.1936866588694103, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.011110546228475942, 0.8481642417358589, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.07469849551798198, 0.8171382968447365, -0.17914063696102905, 0.24712242304476825, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, 0.01994523631491676, 0.34396739025506545, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static const char * strcode(int code) { switch (code) { case LIBPNG_WARNING_CODE: return "warning"; case LIBPNG_ERROR_CODE: return "libpng"; case ZLIB_ERROR_CODE: return "zlib"; case INVALID_ERROR_CODE: return "invalid"; case READ_ERROR_CODE: return "read"; case WRITE_ERROR_CODE: return "write"; case UNEXPECTED_ERROR_CODE: return "unexpected"; default: return "INVALID"; } }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.7880534307994381, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.14353953243697165, -0.7849662874110047, -0.21702784222394986, 0.42674115187998785, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, 0.04889276383167627, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void png_read_data(png_structrp png_ptr, png_bytep data, png_size_t length) { png_debug1(4, "reading %d bytes", (int)length); if (png_ptr->read_data_fn != NULL) (*(png_ptr->read_data_fn))(png_ptr, data, length); else png_error(png_ptr, "Call to NULL read function"); }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_tRNS_to_alpha_set(PNG_CONST image_transform *this, transform_display *that, png_structp pp, png_infop pi) { png_set_tRNS_to_alpha(pp); this->next->set(this->next, that, pp, pi); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static size_t safecatd(char *buffer, size_t bufsize, size_t pos, double d, int precision) { char number[64]; sprintf(number, "%.*f", precision, d); return safecat(buffer, bufsize, pos, number); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5202917568643389, -0.26569807294376846, -0.7092182376352943, -0.917450412529964, -0.518115519420462, 0.0, 0.6852718019606829, 0.417570182313826, -0.5886600536966952, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void transform_display_init(transform_display *dp, png_modifier *pm, png_uint_32 id, PNG_CONST image_transform *transform_list) { memset(dp, 0, sizeof *dp); standard_display_init(&dp->this, &pm->this, id, 0, pm->use_update_info); dp->pm = pm; dp->transform_list = transform_list; dp->output_colour_type = 255; dp->output_bit_depth = 255; }<SPLIT>[0.21027592277004517, -0.3947818432810943, 0.0, 0.18995094088131478, -0.44903192919977347, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.33077267477327355, 0.21894446904158188, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, 0.19837465696559078, -0.44417943729816173, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gpc_lin(Pixel *out, const Pixel *in, const Background *back) { (void)back; out->r = ilinear(in->r); if (in->g == in->r) { out->g = out->r; if (in->b == in->r) out->b = out->r; else out->b = ilinear(in->b); } else { out->g = ilinear(in->g); if (in->b == in->r) out->b = out->r; else if (in->b == in->g) out->b = out->g; else out->b = ilinear(in->b); } out->a = 65535; }<SPLIT>[-0.25365086435942685, -0.10830612948931077, 0.0, -0.2665172434374763, -0.17240788634188003, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.13098384443277505, -0.25297036047912586, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, -0.26569807294376846, -0.157054070266268, -0.6586564490689124, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void perform_gamma_composition_tests(png_modifier *pm, int do_background, int expand_16) { png_byte colour_type = 0; png_byte bit_depth = 0; unsigned int palette_number = 0; while (next_format(&colour_type, &bit_depth, &palette_number, 1)) if ((colour_type & PNG_COLOR_MASK_ALPHA) != 0) { unsigned int i, j; for (i=0; i<pm->ngamma_tests; ++i) for (j=0; j<pm->ngamma_tests; ++j) { gamma_composition_test(pm, colour_type, bit_depth, palette_number, pm->interlace_type, 1/pm->gammas[i], pm->gammas[j], pm->use_input_precision, do_background, expand_16); if (fail(pm)) return; } } }<SPLIT>[0.36491818514653585, -0.1964525029637057, 0.0, 0.34210700232091185, -0.2575229764520011, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.13098384443277505, 0.3762494122151511, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, 0.35306556693537716, -0.24540033704531222, -0.011671540416283347, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.3615192241061562, -0.10760608081136262, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static char type_char(png_uint_32 v) { if (v & 32) return "!abcdefghijklmnopqrstuvwxyz56789"[(v-96)&31]; else return "@ABCDEFGHIJKLMNOPQRSTUVWXYZ01234"[(v-64)&31]; }<SPLIT>[0.6742027098995172, -0.4829282167554892, 0.0, 0.6464191252001059, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, 0.6908592985622897, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, 0.66244738687495, -0.5325257040772059, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int display_rc(const display *d, int strict) { return d->error_count + (strict ? d->warning_count : 0); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void make_size(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type, int bdlo, int PNG_CONST bdhi) { for (; bdlo <= bdhi; ++bdlo) { png_uint_32 width; for (width = 1; width <= 16; ++width) { png_uint_32 height; for (height = 1; height <= 16; ++height) { make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_NONE, width, height, 0); make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_NONE, width, height, 1); #ifdef PNG_WRITE_INTERLACING_SUPPORTED make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_ADAM7, width, height, 0); make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_ADAM7, width, height, 1); #endif } } } }<SPLIT>[0.36491818514653585, -0.08626953612071205, 0.0, 0.34210700232091185, -0.15112911381434976, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.031089429262525795, 0.3762494122151511, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.09407211557651925, 0.35306556693537716, -0.2674869037400733, -0.5292594673383866, -0.518115519420462, 0.0, 0.3545307232390774, 0.9973611507722091, -0.27247069920941797, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int check_all_characters(checkfp_command *co, checkfp_control c) { int ch; if (c.cnumber+4 < sizeof co->number) for (ch=0; ch<256; ++ch) { if (!check_one_character(co, c, ch)) return 0; } return 1; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.5292594673383866, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.1980344553542678, -0.5591795518777907, -0.21702784222394986, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 1.7623686513065309, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static int image_transform_default_add(image_transform *this, PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth) { UNUSED(colour_type) UNUSED(bit_depth) this->next = *that; *that = this; return 1; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI makepng_warning(png_structp png_ptr, png_const_charp message) { const char **ep = png_get_error_ptr(png_ptr); const char *name; if (ep != NULL && *ep != NULL) name = *ep; else name = "makepng"; fprintf(stderr, "%s: warning: %s\n", name, message); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void zlib_end(struct zlib *zlib) { if (!zlib->global->quiet) { if (zlib->ok_bits < 16) { const char *reason; if (zlib->cksum) reason = "CHK"; else if (zlib->ok_bits > zlib->file_bits) reason = "TFB"; else if (zlib->ok_bits == zlib->file_bits) reason = "OK "; else reason = "OPT"; type_name(zlib->chunk->chunk_type, stdout); printf(" %s %s %d %d ", reason, zlib_flevel(zlib), zlib->file_bits, zlib->ok_bits); uarb_print(zlib->compressed_bytes, zlib->compressed_digits, stdout); putc(' ', stdout); uarb_print(zlib->uncompressed_bytes, zlib->uncompressed_digits, stdout); putc(' ', stdout); fputs(zlib->file->file_name, stdout); putc('\n', stdout); } else { type_name(zlib->chunk->chunk_type, stdout); printf(" SKP %s %d %s ", zlib_flevel(zlib), zlib->file_bits, zlib_rc(zlib)); uarb_print(zlib->compressed_bytes, zlib->compressed_digits, stdout); putc(' ', stdout); emit_string(zlib->z.msg ? zlib->z.msg : "[no_message]", stdout); putc(' ', stdout); fputs(zlib->file->file_name, stdout); putc('\n', stdout); } } if (zlib->state >= 0) { zlib->rc = inflateEnd(&zlib->z); if (zlib->rc != Z_OK) zlib_message(zlib, 1); } CLEAR(*zlib); }<SPLIT>[2.529909858417405, 0.39853551798846004, 0.0, 2.47229186247527, 0.31700388179131606, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, -0.27925050329511203, 0.6881503599632689, 2.5785186166451206, 0.4324044616630353, 0.0, 0.0, 0.30852482215402843, 0.603378206530822, 2.5187383065123874, 0.35093696371323624, 0.6353133682363457, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, 0.14911510677361828, 0.6738843113224704, 0.6826474935548865, -0.21702784222394986, 0.6138826961206794, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, -0.27935383381430245, 1.7623686513065309, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, -0.28182971586402455]
0<SPLIT>static int read_png(FILE *fp) { png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,0,0,0); png_infop info_ptr = NULL; png_bytep row = NULL, display = NULL; if (png_ptr == NULL) return 0; if (setjmp(png_jmpbuf(png_ptr))) { png_destroy_read_struct(&png_ptr, &info_ptr, NULL); if (row != NULL) free(row); if (display != NULL) free(display); return 0; } png_init_io(png_ptr, fp); info_ptr = png_create_info_struct(png_ptr); if (info_ptr == NULL) png_error(png_ptr, "OOM allocating info structure"); png_read_info(png_ptr, info_ptr); { png_size_t rowbytes = png_get_rowbytes(png_ptr, info_ptr); row = malloc(rowbytes); display = malloc(rowbytes); if (row == NULL || display == NULL) png_error(png_ptr, "OOM allocating row buffers"); { png_uint_32 height = png_get_image_height(png_ptr, info_ptr); int passes = png_set_interlace_handling(png_ptr); int pass; png_start_read_image(png_ptr); for (pass = 0; pass < passes; ++pass) { png_uint_32 y = height; while (y-- > 0) png_read_row(png_ptr, row, display); } } } png_read_end(png_ptr, info_ptr); png_destroy_read_struct(&png_ptr, &info_ptr, NULL); free(row); free(display); return 1; }<SPLIT>[0.36491818514653585, 0.3103891445140651, 0.0, 0.34210700232091185, 0.25316756420872527, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.380400859743741, 0.3285304653503715, 0.3762494122151511, 0.34123294087130834, 0.0, 0.0, 0.30852482215402843, 0.27402666553568866, 0.35306556693537716, 0.262590696934192, 0.8941073316973973, 0.029966239443893296, 0.0, -0.08645738172306322, 0.417570182313826, 0.32477585926655006, 0.5648944654878781, 0.9084342290881006, -0.21702784222394986, 0.23959960763929639, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.3801362775450152, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.3766295797615486]
0<SPLIT>void PNGCBAPI png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length) { png_uint_32 check; png_byte *near_data; png_FILE_p io_ptr; if (png_ptr == NULL) return; near_data = (png_byte *)CVT_PTR_NOCHECK(data); io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr); if ((png_bytep)near_data == data) { check = fwrite(near_data, 1, length, io_ptr); } else { png_byte buf[NEAR_BUF_SIZE]; png_size_t written, remaining, err; check = 0; remaining = length; do { written = MIN(NEAR_BUF_SIZE, remaining); png_memcpy(buf, data, written); err = fwrite(buf, 1, written, io_ptr); if (err != written) break; else check += err; data += written; remaining -= written; } while (remaining != 0); } if (check != length) png_error(png_ptr, "Write Error"); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.11436118199787926, 0.2957251092637858, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.2546530454771514, -0.11100716297398205, 0.3288503970184752, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.14911510677361828, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int format_isset(format_list *pf, png_uint_32 format) { return format < FORMAT_COUNT && (pf->bits[format >> 5] & (((png_uint_32)1) << (format & 31))) != 0; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, 0.417570182313826, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int is_combo(int transforms) { return transforms & (transforms-1); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>void png_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length) { png_textp text_ptr; png_charp chunkdata; png_charp key, lang, text, lang_key; int comp_flag; int comp_type = 0; int ret; png_size_t slength, prefix_len, data_len; png_debug(1, "in png_handle_iTXt\n"); if (!(png_ptr->mode & PNG_HAVE_IHDR)) png_error(png_ptr, "Missing IHDR before iTXt"); if (png_ptr->mode & PNG_HAVE_IDAT) png_ptr->mode |= PNG_AFTER_IDAT; #ifdef PNG_MAX_MALLOC_64K if (length > (png_uint_32)65535L) { png_warning(png_ptr,"iTXt chunk too large to fit in memory"); png_crc_finish(png_ptr, length); return; } #endif chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1); if (chunkdata == NULL) { png_warning(png_ptr, "No memory to process iTXt chunk."); return; } slength = (png_size_t)length; png_crc_read(png_ptr, (png_bytep)chunkdata, slength); if (png_crc_finish(png_ptr, 0)) { png_free(png_ptr, chunkdata); return; } chunkdata[slength] = 0x00; for (lang = chunkdata; *lang; lang++) ; lang++; if (lang >= chunkdata + slength) { comp_flag = PNG_TEXT_COMPRESSION_NONE; png_warning(png_ptr, "Zero length iTXt chunk"); } else { comp_flag = *lang++; comp_type = *lang++; } for (lang_key = lang; *lang_key; lang_key++) ; lang_key++; for (text = lang_key; *text; text++) ; text++; prefix_len = text - chunkdata; key=chunkdata; if (comp_flag) chunkdata = png_decompress_chunk(png_ptr, comp_type, chunkdata, (size_t)length, prefix_len, &data_len); else data_len=png_strlen(chunkdata + prefix_len); text_ptr = (png_textp)png_malloc_warn(png_ptr, (png_uint_32)png_sizeof(png_text)); if (text_ptr == NULL) { png_warning(png_ptr,"Not enough memory to process iTXt chunk."); png_free(png_ptr, chunkdata); return; } text_ptr->compression = (int)comp_flag + 1; text_ptr->lang_key = chunkdata+(lang_key-key); text_ptr->lang = chunkdata+(lang-key); text_ptr->itxt_length = data_len; text_ptr->text_length = 0; text_ptr->key = chunkdata; text_ptr->text = chunkdata + prefix_len; ret=png_set_text_2(png_ptr, info_ptr, text_ptr, 1); png_free(png_ptr, text_ptr); png_free(png_ptr, chunkdata); if (ret) png_error(png_ptr, "Insufficient memory to store iTXt chunk."); }<SPLIT>[2.8391943831703865, 1.1257430991522182, 0.0, 2.7766039853544644, 1.0404821477273452, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 0.7102265412631674, 1.447347915257163, 2.5785186166451206, 1.0022264666113287, 0.0, 0.0, 0.30852482215402843, 1.3589493888137751, 2.5187383065123874, 0.9031011310822626, 0.7647103499668715, 0.2491989429896354, 0.0, 0.7955188282012181, 1.5771521192305922, 1.2733439227283816, 0.40140969673598975, 0.5697541257882794, -0.21702784222394986, 0.23959960763929639, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 0.7098813332246741, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 0.7058592275743352]
0<SPLIT>static CIE_color white_point(PNG_CONST color_encoding *encoding) { CIE_color white; white.X = encoding->red.X + encoding->green.X + encoding->blue.X; white.Y = encoding->red.Y + encoding->green.Y + encoding->blue.Y; white.Z = encoding->red.Z + encoding->green.Z + encoding->blue.Z; return white; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gpc_b16c(Pixel *out, const Pixel *in, const Background *back) { if (in->a <= 0) { out->r = back->ir; out->g = back->ig; out->b = back->ib; } else { double a = in->a/65535.; double a1 = 1-a; a /= 65535; out->r = sRGB(in->r * a + back->dr * a1); out->g = sRGB(in->g * a + back->dg * a1); out->b = sRGB(in->b * a + back->db * a1); } out->a = 255; }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.39986248560786075, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.41601414702345235, -0.4462861841111837, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void gpc_sGp(Pixel *out, const Pixel *in, const Background *back) { (void)back; if (in->a <= 128) { out->r = out->g = out->b = 255; out->a = 0; } else { out->r = out->g = out->b = sRGB(YfromRGBint(in->r, in->g, in->b)/in->a); out->a = u8d(in->a / 257.); } }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int image_transform_png_set_strip_alpha_add(image_transform *this, PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth) { UNUSED(bit_depth) this->next = *that; *that = this; return (colour_type & PNG_COLOR_MASK_ALPHA) != 0; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static png_uint_16 u16d(double d) { d = closestinteger(d); return (png_uint_16)d; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void store_init(png_store* ps) { memset(ps, 0, sizeof *ps); init_exception_context(&ps->exception_context); store_pool_init(ps, &ps->read_memory_pool); store_pool_init(ps, &ps->write_memory_pool); ps->verbose = 0; ps->treat_warnings_as_errors = 0; ps->expect_error = 0; ps->expect_warning = 0; ps->saw_warning = 0; ps->speed = 0; ps->progressive = 0; ps->validated = 0; ps->nerrors = ps->nwarnings = 0; ps->pread = NULL; ps->piread = NULL; ps->saved = ps->current = NULL; ps->next = NULL; ps->readpos = 0; ps->image = NULL; ps->cb_image = 0; ps->cb_row = 0; ps->image_h = 0; ps->pwrite = NULL; ps->piwrite = NULL; ps->writepos = 0; ps->new.prev = NULL; ps->palette = NULL; ps->npalette = 0; ps->noptions = 0; }<SPLIT>[-0.25365086435942685, 0.06798661745947907, 0.0, -0.2665172434374763, -0.0021777061216379156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.02884721983962376, -0.25297036047912586, 0.0905112586940592, 0.0, 0.0, 0.30852482215402843, -0.03595125540090747, -0.26569807294376846, 0.01963846329182043, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.32477585926655006, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void make_transform_images(png_store *ps) { png_byte colour_type = 0; png_byte bit_depth = 0; unsigned int palette_number = 0; safecat(ps->test, sizeof ps->test, 0, "make standard images"); while (next_format(&colour_type, &bit_depth, &palette_number, 0)) { int interlace_type; for (interlace_type = PNG_INTERLACE_NONE; interlace_type < INTERLACE_LAST; ++interlace_type) { char name[FILE_NAME_SIZE]; standard_name(name, sizeof name, 0, colour_type, bit_depth, palette_number, interlace_type, 0, 0, 0); make_transform_image(ps, colour_type, bit_depth, palette_number, interlace_type, name); } } }<SPLIT>[0.36491818514653585, -0.1964525029637057, 0.0, 0.34210700232091185, -0.2575229764520011, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.13098384443277505, 0.3762494122151511, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, 0.35306556693537716, -0.24540033704531222, 0.11772544131424245, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.3070243011888601, 0.005287286955244392, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void format_default(format_list *pf, int redundant) { if (redundant) { int i; for (i=0; i<FORMAT_SET_COUNT; ++i) pf->bits[i] = ~(png_uint_32)0; } else { png_uint_32 f; for (f=0; f<FORMAT_COUNT; ++f) { #ifdef PNG_FORMAT_BGR_SUPPORTED if ((f & PNG_FORMAT_FLAG_COLOR) == 0 && (f & PNG_FORMAT_FLAG_BGR) != 0) #else if ((f & 0x10U) != 0) #endif continue; #ifdef PNG_FORMAT_AFIRST_SUPPORTED if ((f & PNG_FORMAT_FLAG_ALPHA) == 0 && (f & PNG_FORMAT_FLAG_AFIRST) != 0) #else if ((f & 0x20U) != 0) #endif continue; format_set(pf, f); } } }<SPLIT>[0.36491818514653585, 0.023913430722281605, 0.0, 0.34210700232091185, -0.02345647864916818, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.06880498590772346, 0.21894446904158188, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, 0.022169604774704303, 0.19837465696559078, -0.22331377035055117, -0.5292594673383866, -0.2988828158747199, 0.0, 0.4647777494796126, 3.3165250246057414, -0.3427350002065907, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void transform_test(png_modifier *pmIn, PNG_CONST png_uint_32 idIn, PNG_CONST image_transform* transform_listIn, PNG_CONST char * volatile name) { transform_display d; context(&pmIn->this, fault); transform_display_init(&d, pmIn, idIn, transform_listIn); Try { size_t pos = 0; png_structp pp; png_infop pi; char full_name[256]; transform_set_encoding(&d); d.transform_list->ini(d.transform_list, &d); pos = safecat(full_name, sizeof full_name, pos, name); pos = safecat_current_encoding(full_name, sizeof full_name, pos, d.pm); pp = set_modifier_for_read(d.pm, &pi, d.this.id, full_name); standard_palette_init(&d.this); #if 0 { char buffer[256]; (void)store_message(&d.pm->this, pp, buffer, sizeof buffer, 0, "running test"); fprintf(stderr, "%s\n", buffer); } #endif if (d.pm->this.progressive) { png_set_progressive_read_fn(pp, &d, transform_info, progressive_row, transform_end); modifier_progressive_read(d.pm, pp, pi); } else { png_set_read_fn(pp, d.pm, modifier_read); png_read_info(pp, pi); transform_info_imp(&d, pp, pi); sequential_row(&d.this, pp, pi, -1, 0); if (!d.this.speed) transform_image_validate(&d, pp, pi); else d.this.ps->validated = 1; } modifier_reset(d.pm); } Catch(fault) { modifier_reset(voidcast(png_modifier*,(void*)fault)); } }<SPLIT>[1.7566985465349518, 0.4646452980942562, 0.0, 1.7115115552772848, 0.38084019937390684, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.6481925938951691, 1.6346889576037051, 0.3184400606733766, 0.0, 0.0, 0.30852482215402843, 0.5646309664137475, 1.5905928466936687, 0.24050413023943099, -0.39986248560786075, -0.518115519420462, 0.0, 0.6852718019606829, 0.9973611507722091, 0.21937940777079099, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>double sRGB(unsigned int i) { return fsRGB(i); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 6.389364479309494, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, 0.11772544131424245, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.03454968660237938, 0.11818065472185141, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.3766295797615486]
1<SPLIT>png_charp PNGAPI png_convert_to_rfc1123(png_structp png_ptr, png_timep ptime) { static PNG_CONST char short_months[12][4] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}; if (png_ptr == NULL) return (NULL); if (png_ptr->time_buffer == NULL) { png_ptr->time_buffer = (png_charp)png_malloc(png_ptr, (png_uint_32)(29* png_sizeof(char))); } #ifdef USE_FAR_KEYWORD { char near_time_buf[29]; png_snprintf6(near_time_buf, 29, "%d %s %d %02d:%02d:%02d +0000", ptime->day % 32, short_months[(ptime->month - 1) % 12], ptime->year, ptime->hour % 24, ptime->minute % 60, ptime->second % 61); png_memcpy(png_ptr->time_buffer, near_time_buf, 29*png_sizeof(char)); } #else png_snprintf6(png_ptr->time_buffer, 29, "%d %s %d %02d:%02d:%02d +0000", ptime->day % 32, short_months[(ptime->month - 1) % 12], ptime->year, ptime->hour % 24, ptime->minute % 60, ptime->second % 61); #endif return ((png_charp)png_ptr->time_buffer); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.037794879441717756, -0.02345647864916818, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.016577635342370212, 0.04368374699580437, -0.28957347043483433, -0.7880534307994381, -0.518115519420462, 0.0, 0.9057658544417533, 2.1569430876889752, -0.4129993012037634, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void store_write_reset(png_store *ps) { if (ps->pwrite != NULL) { anon_context(ps); Try png_destroy_write_struct(&ps->pwrite, &ps->piwrite); Catch_anonymous { } ps->pwrite = NULL; ps->piwrite = NULL; } #ifdef PNG_USER_MEM_SUPPORTED store_pool_delete(ps, &ps->write_memory_pool); #endif store_freenew(ps); }<SPLIT>[0.36491818514653585, -0.24052568970090316, 0.0, 0.34210700232091185, -0.30008052150706166, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.17094161050087475, 0.3762494122151511, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, 0.35306556693537716, -0.3558331705191175, -0.5292594673383866, -0.4084991676475909, 0.0, 0.02378964451747194, 0.9973611507722091, -0.4832636022009361, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static png_uint_32 transform_height(png_const_structp pp, png_byte colour_type, png_byte bit_depth) { switch (bit_size(pp, colour_type, bit_depth)) { case 1: case 2: case 4: return 1; case 8: return 2; case 16: return 512; case 24: case 32: return 512; case 48: case 64: return 2048; #define TRANSFORM_HEIGHTMAX 2048 default: return 0; } }<SPLIT>[-0.25365086435942685, -0.13034272285790952, 0.0, -0.2665172434374763, -0.1936866588694103, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.1509627274668249, -0.25297036047912586, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.21031383592774278, -0.26569807294376846, -0.2012272036557901, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, 0.417570182313826, -0.4832636022009361, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>BOOL PngFileOpenDlg (HWND hwnd, PTSTR pstrFileName, PTSTR pstrTitleName) { ofn.hwndOwner = hwnd; ofn.lpstrFile = pstrFileName; ofn.lpstrFileTitle = pstrTitleName; ofn.Flags = OFN_HIDEREADONLY; return GetOpenFileName (&ofn); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static size_t standard_name_from_id(char *buffer, size_t bufsize, size_t pos, png_uint_32 id) { return standard_name(buffer, bufsize, pos, COL_FROM_ID(id), DEPTH_FROM_ID(id), PALETTE_FROM_ID(id), INTERLACE_FROM_ID(id), WIDTH_FROM_ID(id), HEIGHT_FROM_ID(id), DO_INTERLACE_FROM_ID(id)); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.25252937827156396, 0.11818065472185141, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void readpng2_end_callback(png_structp png_ptr, png_infop info_ptr) { mainprog_info *mainprog_ptr; mainprog_ptr = png_get_progressive_ptr(png_ptr); (*mainprog_ptr->mainprog_finish_display)(); return; }<SPLIT>[0.9834872346524985, -0.5049648101240879, 0.0, 0.9507312480792999, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.33077267477327355, 1.0054691849094282, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, 0.9718292068145229, -0.5325257040772059, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void type_name(png_uint_32 type, FILE *out) { putc(type_char(type >> 24), out); putc(type_char(type >> 16), out); putc(type_char(type >> 8), out); putc(type_char(type), out); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int is_number(char *p) { while (*p) { if (!isdigit(*p)) return FALSE; ++p; } return TRUE; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.6586564490689124, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5250039928580447, -0.6720729196443977, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void sequential_row(standard_display *dp, png_structp pp, png_infop pi, PNG_CONST int iImage, PNG_CONST int iDisplay) { PNG_CONST int npasses = dp->npasses; PNG_CONST int do_interlace = dp->do_interlace && dp->interlace_type == PNG_INTERLACE_ADAM7; PNG_CONST png_uint_32 height = standard_height(pp, dp->id); PNG_CONST png_uint_32 width = standard_width(pp, dp->id); PNG_CONST png_store* ps = dp->ps; int pass; for (pass=0; pass<npasses; ++pass) { png_uint_32 y; png_uint_32 wPass = PNG_PASS_COLS(width, pass); for (y=0; y<height; ++y) { if (do_interlace) { if (wPass > 0 && PNG_ROW_IN_INTERLACE_PASS(y, pass)) { png_byte row[STANDARD_ROWMAX], display[STANDARD_ROWMAX]; memset(row, 0xc5, sizeof row); memset(display, 0x5c, sizeof display); png_read_row(pp, row, display); if (iImage >= 0) deinterlace_row(store_image_row(ps, pp, iImage, y), row, dp->pixel_size, dp->w, pass); if (iDisplay >= 0) deinterlace_row(store_image_row(ps, pp, iDisplay, y), display, dp->pixel_size, dp->w, pass); } } else png_read_row(pp, iImage >= 0 ? store_image_row(ps, pp, iImage, y) : NULL, iDisplay >= 0 ? store_image_row(ps, pp, iDisplay, y) : NULL); } } png_read_end(pp, pi); }<SPLIT>[2.065983071287933, 0.24427936440826892, 0.0, 2.015823678156479, 0.16805247409860422, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.48836152962277035, 2.106603787124413, 0.2728543002775131, 0.0, 0.0, 0.30852482215402843, 0.40964200594544947, 2.054665576603028, 0.19633099684990887, 0.11772544131424245, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, -0.3070243011888601, 0.005287286955244392, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static size_t transform_rowsize(png_const_structp pp, png_byte colour_type, png_byte bit_depth) { return (TRANSFORM_WIDTH * bit_size(pp, colour_type, bit_depth)) / 8; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int png_col_in_interlace_pass(png_uint_32 x, int pass) { int y; x &= 7; ++pass; for (y=0; y<8; ++y) if (adam7[y][x] == pass) return 1; return 0; }<SPLIT>[-0.09900860198293619, -0.43885503001829174, 0.0, -0.11436118199787926, -0.491589474254834, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.41068820690947294, -0.09566541730555662, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.11100716297398205, -0.48835257068768384, -0.6586564490689124, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.25252937827156396, -0.6720729196443977, -0.21702784222394986, 0.14602883551895066, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static void perform_formatting_test(png_store *volatile ps) { #ifdef PNG_TIME_RFC1123_SUPPORTED context(ps, fault); Try { png_const_charp correct = "29 Aug 2079 13:53:60 +0000"; png_const_charp result; #if PNG_LIBPNG_VER >= 10600 char timestring[29]; #endif png_structp pp; png_time pt; pp = set_store_for_write(ps, NULL, "libpng formatting test"); if (pp == NULL) Throw ps; pt.year = 2079; pt.month = 8; pt.day = 29; pt.hour = 13; pt.minute = 53; pt.second = 60; #if PNG_LIBPNG_VER < 10600 result = png_convert_to_rfc1123(pp, &pt); #else if (png_convert_to_rfc1123_buffer(timestring, &pt)) result = timestring; else result = NULL; #endif if (result == NULL) png_error(pp, "png_convert_to_rfc1123 failed"); if (strcmp(result, correct) != 0) { size_t pos = 0; char msg[128]; pos = safecat(msg, sizeof msg, pos, "png_convert_to_rfc1123("); pos = safecat(msg, sizeof msg, pos, correct); pos = safecat(msg, sizeof msg, pos, ") returned: '"); pos = safecat(msg, sizeof msg, pos, result); pos = safecat(msg, sizeof msg, pos, "'"); png_error(pp, msg); } store_write_reset(ps); } Catch(fault) { store_write_reset(fault); } #else UNUSED(ps) #endif }<SPLIT>[0.36491818514653585, 0.5307550782000524, 0.0, 0.34210700232091185, 0.4446765169564977, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.52831929569087, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, 0.44838924606252395, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, 5.425893930303695, 4.4761069615225075, 0.2896437087679637, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static png_uint_32 formatof(const char *arg) { char *ep; unsigned long format = strtoul(arg, &ep, 0); if (ep > arg && *ep == 0 && format < FORMAT_COUNT) return (png_uint_32)format; else for (format=0; format < FORMAT_COUNT; ++format) { if (strcmp(format_names[format], arg) == 0) return (png_uint_32)format; } fprintf(stderr, "pngstest: format name '%s' invalid\n", arg); return FORMAT_COUNT; }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI read_function(png_structp pp, png_bytep data, png_size_t size) { buffer_read(get_dp(pp), get_buffer(pp), data, size); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void store_freefile(png_store_file **ppf) { if (*ppf != NULL) { store_freefile(&(*ppf)->next); store_freebuffer(&(*ppf)->data); (*ppf)->datacount = 0; if ((*ppf)->palette != NULL) { free((*ppf)->palette); (*ppf)->palette = NULL; (*ppf)->npalette = 0; } free(*ppf); *ppf = NULL; } }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void store_progressive_read(png_store *ps, png_structp pp, png_infop pi) { if (ps->pread != pp || ps->current == NULL || ps->next == NULL) png_error(pp, "store state damaged (progressive)"); do { if (ps->readpos != 0) png_error(pp, "store_read called during progressive read"); png_process_data(pp, pi, ps->next->buffer, store_read_buffer_size(ps)); } while (store_read_buffer_next(ps)); }<SPLIT>[0.21027592277004517, -0.3727452499124955, 0.0, 0.18995094088131478, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3107937917392237, 0.21894446904158188, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, 0.19837465696559078, -0.42209287060340067, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.4705090699407485, -0.3333928163445767, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static chunk_insert * find_insert(png_const_charp what, png_charp param) { png_uint_32 chunk = 0; png_charp parameter_list[1024]; int i, nparams; for (i=0; i<4; ++i) { char ch = what[i]; if ((ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122)) chunk = (chunk << 8) + what[i]; else break; } if (i < 4 || what[4] != 0) { fprintf(stderr, "makepng --insert \"%s\": invalid chunk name\n", what); exit(1); } nparams = find_parameters(what, param, parameter_list, 1024); #define CHUNK(a,b,c,d) (((a)<<24)+((b)<<16)+((c)<<8)+(d)) switch (chunk) { case CHUNK(105,67,67,80): if (nparams == 2) return make_insert(what, insert_iCCP, nparams, parameter_list); break; case CHUNK(116,69,88,116): if (nparams == 2) return make_insert(what, insert_tEXt, nparams, parameter_list); break; case CHUNK(122,84,88,116): if (nparams == 2) return make_insert(what, insert_zTXt, nparams, parameter_list); break; case CHUNK(105,84,88,116): if (nparams == 4) return make_insert(what, insert_iTXt, nparams, parameter_list); break; case CHUNK(104,73,83,84): if (nparams <= 256) return make_insert(what, insert_hIST, nparams, parameter_list); break; #if 0 case CHUNK(115,80,76,84): return make_insert(what, insert_sPLT, nparams, parameter_list); #endif default: fprintf(stderr, "makepng --insert \"%s\": unrecognized chunk name\n", what); exit(1); } bad_parameter_count(what, nparams); return NULL; }<SPLIT>[0.05563366039355449, 0.5527916715686512, 0.0, 0.037794879441717756, 0.4659552894840279, 0.0, 0.10120102281206332, 0.11088995743869048, 0.5742476557731842, 0.380400859743741, 0.5083404126568202, 0.061639525868012635, 0.4779902220588988, 0.0, 0.0, 0.30852482215402843, 0.4290156260039867, 0.04368374699580437, 0.39511009710275835, 0.11772544131424245, 0.13958259121676436, 0.0, 0.13403667075800713, 1.5771521192305922, 0.21937940777079099, 0.18343000506680518, 0.11818065472185141, 0.6817979554923368, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.5737900437766489, 0.3801362775450152, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.5700153422610048, 0.3766295797615486]
0<SPLIT>static void image_transform_png_set_@_set(PNG_CONST image_transform *this, transform_display *that, png_structp pp, png_infop pi) { png_set_@(pp); this->next->set(this->next, that, pp, pi); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void gpc_preq(Pixel *out, const Pixel *in, const Background *back) { (void)back; out->r = ilineara(in->r, in->a); if (in->g == in->r) { out->g = out->r; if (in->b == in->r) out->b = out->r; else out->b = ilineara(in->b, in->a); } else { out->g = ilineara(in->g, in->a); if (in->b == in->r) out->b = out->r; else if (in->b == in->g) out->b = out->g; else out->b = ilineara(in->b, in->a); } out->a = 65535; }<SPLIT>[-0.25365086435942685, -0.10830612948931077, 0.0, -0.2665172434374763, -0.17240788634188003, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.13098384443277505, -0.25297036047912586, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, -0.26569807294376846, -0.157054070266268, -0.6586564490689124, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>BOOL DisplayImage (HWND hwnd, BYTE **ppDib, BYTE **ppDiData, int cxWinSize, int cyWinSize, BYTE *pbImage, int cxImgSize, int cyImgSize, int cImgChannels, BOOL bStretched) { BYTE *pDib = *ppDib; BYTE *pDiData = *ppDiData; BITMAPINFOHEADER *pbmih; WORD wDIRowBytes; png_color bkgBlack = {0, 0, 0}; png_color bkgGray = {127, 127, 127}; png_color bkgWhite = {255, 255, 255}; wDIRowBytes = (WORD) ((3 * cxWinSize + 3L) >> 2) << 2; if (pDib) { free (pDib); pDib = NULL; } if (!(pDib = (BYTE *) malloc (sizeof(BITMAPINFOHEADER) + wDIRowBytes * cyWinSize))) { MessageBox (hwnd, TEXT ("Error in displaying the PNG image"), szProgName, MB_ICONEXCLAMATION | MB_OK); *ppDib = pDib = NULL; return FALSE; } *ppDib = pDib; memset (pDib, 0, sizeof(BITMAPINFOHEADER)); pbmih = (BITMAPINFOHEADER *) pDib; pbmih->biSize = sizeof(BITMAPINFOHEADER); pbmih->biWidth = cxWinSize; pbmih->biHeight = -((long) cyWinSize); pbmih->biPlanes = 1; pbmih->biBitCount = 24; pbmih->biCompression = 0; pDiData = pDib + sizeof(BITMAPINFOHEADER); *ppDiData = pDiData; InitBitmap (pDiData, cxWinSize, cyWinSize); if (pbImage) { FillBitmap (pDiData, cxWinSize, cyWinSize, pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched); } return TRUE; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.4942630637605089, 0.31700388179131606, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.3515211457698377, 0.5077564769051636, 0.35093696371323624, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2545115582693773, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int first_transform(int transforms) { return transforms & -transforms; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_strip_alpha_set(PNG_CONST image_transform *this, transform_display *that, png_structp pp, png_infop pi) { png_set_strip_alpha(pp); this->next->set(this->next, that, pp, pi); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static png_byte isRGB(int fixed_linear) { return sRGB(fixed_linear / 65535.); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>double fsRGB(double l) { return sRGB_from_linear(l/max_input); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void store_verbose(png_store *ps, png_const_structp pp, png_const_charp prefix, png_const_charp message) { char buffer[512]; if (prefix) fputs(prefix, stderr); (void)store_message(ps, pp, buffer, sizeof buffer, 0, message); fputs(buffer, stderr); fputc('\n', stderr); }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.4705090699407485, -0.3333928163445767, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void image_pixel_add_alpha(image_pixel *this, PNG_CONST standard_display *display) { if (this->colour_type == PNG_COLOR_TYPE_PALETTE) image_pixel_convert_PLTE(this); if ((this->colour_type & PNG_COLOR_MASK_ALPHA) == 0) { if (this->colour_type == PNG_COLOR_TYPE_GRAY) { if (this->bit_depth < 8) this->bit_depth = 8; if (this->have_tRNS) { this->have_tRNS = 0; if (this->red == display->transparent.red) this->alphaf = 0; else this->alphaf = 1; } else this->alphaf = 1; this->colour_type = PNG_COLOR_TYPE_GRAY_ALPHA; } else if (this->colour_type == PNG_COLOR_TYPE_RGB) { if (this->have_tRNS) { this->have_tRNS = 0; if (this->red == display->transparent.red && this->green == display->transparent.green && this->blue == display->transparent.blue) this->alphaf = 0; else this->alphaf = 1; this->colour_type = PNG_COLOR_TYPE_RGB_ALPHA; } } this->alphae = 0; this->alpha_sBIT = display->alpha_sBIT; } }<SPLIT>[1.1381294970289892, 0.24427936440826892, 0.0, 1.102887309518897, 0.16805247409860422, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, -0.27925050329511203, 0.3684882314184712, 1.1627741280829973, 0.2728543002775131, 0.0, 0.0, 0.30852482215402843, 0.29340028559422593, 1.1265201167843093, 0.19633099684990887, -0.6586564490689124, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.3070243011888601, -0.6720729196443977, 0.6817979554923368, -0.04111270872174079, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, -0.27935383381430245, 1.7623686513065309, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, -0.28182971586402455]
1<SPLIT>png_size_t png_check_keyword(png_structp png_ptr, png_const_charp key, png_charpp new_key) { png_size_t key_len; png_const_charp ikp; png_charp kp, dp; int kflag; int kwarn=0; png_debug(1, "in png_check_keyword"); *new_key = NULL; if (key == NULL || (key_len = png_strlen(key)) == 0) { png_warning(png_ptr, "zero length keyword"); return ((png_size_t)0); } png_debug1(2, "Keyword to be checked is '%s'", key); *new_key = (png_charp)png_malloc_warn(png_ptr, (png_uint_32)(key_len + 2)); if (*new_key == NULL) { png_warning(png_ptr, "Out of memory while procesing keyword"); return ((png_size_t)0); } for (ikp = key, dp = *new_key; *ikp != '\0'; ikp++, dp++) { if ((png_byte)*ikp < 0x20 || ((png_byte)*ikp > 0x7E && (png_byte)*ikp < 0xA1)) { PNG_WARNING_PARAMETERS(p) png_warning_parameter_unsigned(p, 1, PNG_NUMBER_FORMAT_02x, (png_byte)*ikp); png_formatted_warning(png_ptr, p, "invalid keyword character 0x@1"); *dp = ' '; } else { *dp = *ikp; } } *dp = '\0'; kp = *new_key + key_len - 1; if (*kp == ' ') { png_warning(png_ptr, "trailing spaces removed from keyword"); while (*kp == ' ') { *(kp--) = '\0'; key_len--; } } kp = *new_key; if (*kp == ' ') { png_warning(png_ptr, "leading spaces removed from keyword"); while (*kp == ' ') { kp++; key_len--; } } png_debug1(2, "Checking for multiple internal spaces in '%s'", kp); for (kflag = 0, dp = *new_key; *kp != '\0'; kp++) { if (*kp == ' ' && kflag == 0) { *(dp++) = *kp; kflag = 1; } else if (*kp == ' ') { key_len--; kwarn = 1; } else { *(dp++) = *kp; kflag = 0; } } *dp = '\0'; if (kwarn) png_warning(png_ptr, "extra interior spaces removed from keyword"); if (key_len == 0) { png_free(png_ptr, *new_key); png_warning(png_ptr, "Zero length keyword"); } if (key_len > 79) { png_warning(png_ptr, "keyword length must be 1 - 79 characters"); (*new_key)[79] = '\0'; key_len = 79; } return (key_len); }<SPLIT>[3.4577634326763493, 1.4122188129440014, 0.0, 3.3852282311128525, 1.2958274180577083, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, -0.27925050329511203, 1.727052277733861, 3.5223482756865363, 1.4808769507678954, 0.0, 0.0, 0.30852482215402843, 1.6108064495747596, 3.446883766331106, 1.3669190316722448, 0.37651940477529405, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.8868902672439317, 0.18343000506680518, 0.23107402248845843, -0.21702784222394986, 0.14602883551895066, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, -0.27935383381430245, 0.04889276383167627, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, -0.28182971586402455]
1<SPLIT>void png_handle_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_32 length) { int num, i; png_debug(1, "in png_handle_hIST\n"); if (!(png_ptr->mode & PNG_HAVE_IHDR)) png_error(png_ptr, "Missing IHDR before hIST"); else if (png_ptr->mode & PNG_HAVE_IDAT) { png_warning(png_ptr, "Invalid hIST after IDAT"); png_crc_finish(png_ptr, length); return; } else if (!(png_ptr->mode & PNG_HAVE_PLTE)) { png_warning(png_ptr, "Missing PLTE before hIST"); png_crc_finish(png_ptr, length); return; } else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_hIST) { png_warning(png_ptr, "Duplicate hIST chunk"); png_crc_finish(png_ptr, length); return; } if (length != (png_uint_32)(2 * png_ptr->num_palette)) { png_warning(png_ptr, "Incorrect hIST chunk length"); png_crc_finish(png_ptr, length); return; } num = (int)length / 2; png_ptr->hist = (png_uint_16p)png_malloc(png_ptr, (png_uint_32)(num * sizeof (png_uint_16))); png_ptr->flags |= PNG_FLAG_FREE_HIST; for (i = 0; i < num; i++) { png_byte buf[2]; png_crc_read(png_ptr, buf, 2); png_ptr->hist[i] = png_get_uint_16(buf); } if (png_crc_finish(png_ptr, 0)) return; png_set_hIST(png_ptr, info_ptr, png_ptr->hist); }<SPLIT>[0.8288449722760078, 0.33242573788266383, 0.0, 0.798575186639703, 0.2744463367362555, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, 1.699703585821447, 0.40844599748657096, 0.8481642417358589, 0.3640258210692401, 0.0, 0.0, 0.30852482215402843, 0.3515211457698377, 0.8171382968447365, 0.28467726362895307, 0.24712242304476825, 0.6876643500811196, 0.0, -0.08645738172306322, 0.417570182313826, 0.18424725727220465, 0.6738843113224704, 0.23107402248845843, 0.6817979554923368, 0.8945950124817165, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, 1.6991165002636506, 0.04889276383167627, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 1.693548171012695]
0<SPLIT>static void gpc_bckc(Pixel *out, const Pixel *in, const Background *back) { if (in->a <= 0) { out->r = back->ir; out->g = back->ig; out->b = back->ib; } else if (in->a >= 255) { out->r = in->r; out->g = in->g; out->b = in->b; } else { double a = in->a / 255.; out->r = sRGB(sRGB_to_d[in->r] * a + back->dr * (1-a)); out->g = sRGB(sRGB_to_d[in->g] * a + back->dg * (1-a)); out->b = sRGB(sRGB_to_d[in->b] * a + back->db * (1-a)); } out->a = 255; }<SPLIT>[-0.25365086435942685, -0.13034272285790952, 0.0, -0.2665172434374763, -0.1936866588694103, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.1509627274668249, -0.25297036047912586, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.21031383592774278, -0.26569807294376846, -0.17914063696102905, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_palette_to_rgb_set(PNG_CONST image_transform *this, transform_display *that, png_structp pp, png_infop pi) { png_set_palette_to_rgb(pp); this->next->set(this->next, that, pp, pi); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void (*get_pixel(png_uint_32 format))(Pixel *p, png_const_voidp pb) { if (format & PNG_FORMAT_FLAG_LINEAR) { if (format & PNG_FORMAT_FLAG_COLOR) { #ifdef PNG_FORMAT_BGR_SUPPORTED if (format & PNG_FORMAT_FLAG_BGR) { if (format & PNG_FORMAT_FLAG_ALPHA) { #ifdef PNG_FORMAT_AFIRST_SUPPORTED if (format & PNG_FORMAT_FLAG_AFIRST) return gp_abgr16; else #endif return gp_bgra16; } else return gp_bgr16; } else #endif { if (format & PNG_FORMAT_FLAG_ALPHA) { #ifdef PNG_FORMAT_AFIRST_SUPPORTED if (format & PNG_FORMAT_FLAG_AFIRST) return gp_argb16; else #endif return gp_rgba16; } else return gp_rgb16; } } else { if (format & PNG_FORMAT_FLAG_ALPHA) { #ifdef PNG_FORMAT_AFIRST_SUPPORTED if (format & PNG_FORMAT_FLAG_AFIRST) return gp_ag16; else #endif return gp_ga16; } else return gp_g16; } } else { if (format & PNG_FORMAT_FLAG_COLOR) { #ifdef PNG_FORMAT_BGR_SUPPORTED if (format & PNG_FORMAT_FLAG_BGR) { if (format & PNG_FORMAT_FLAG_ALPHA) { #ifdef PNG_FORMAT_AFIRST_SUPPORTED if (format & PNG_FORMAT_FLAG_AFIRST) return gp_abgr8; else #endif return gp_bgra8; } else return gp_bgr8; } else #endif { if (format & PNG_FORMAT_FLAG_ALPHA) { #ifdef PNG_FORMAT_AFIRST_SUPPORTED if (format & PNG_FORMAT_FLAG_AFIRST) return gp_argb8; else #endif return gp_rgba8; } else return gp_rgb8; } } else { if (format & PNG_FORMAT_FLAG_ALPHA) { #ifdef PNG_FORMAT_AFIRST_SUPPORTED if (format & PNG_FORMAT_FLAG_AFIRST) return gp_ag8; else #endif return gp_ga8; } else return gp_g8; } } }<SPLIT>[0.36491818514653585, 1.6325847466299888, 0.0, 0.34210700232091185, 1.5086151433330108, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, -0.27925050329511203, 1.5272634473933626, 0.3762494122151511, 0.4779902220588988, 0.0, 0.0, 0.30852482215402843, 1.417070248989387, 0.35306556693537716, 0.39511009710275835, -0.7880534307994381, 0.35881529476250645, 0.0, 4.543917720379413, 9.114434709189572, -0.06167779621789984, -0.08904460951967552, -0.7849662874110047, 3.3782753486411963, 0.14602883551895066, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, -0.27935383381430245, 1.7623686513065309, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, -0.28182971586402455]
0<SPLIT>static int compare_two_images(Image *a, Image *b, int via_linear, png_const_colorp background) { ptrdiff_t stridea = a->stride; ptrdiff_t strideb = b->stride; png_const_bytep rowa = a->buffer+16; png_const_bytep rowb = b->buffer+16; const png_uint_32 width = a->image.width; const png_uint_32 height = a->image.height; const png_uint_32 formata = a->image.format; const png_uint_32 formatb = b->image.format; const unsigned int a_sample = PNG_IMAGE_SAMPLE_SIZE(formata); const unsigned int b_sample = PNG_IMAGE_SAMPLE_SIZE(formatb); int alpha_added, alpha_removed; int bchannels; int btoa[4]; png_uint_32 y; Transform tr; if (width != b->image.width || height != b->image.height) return logerror(a, a->file_name, ": width x height changed: ", b->file_name); transform_from_formats(&tr, a, b, background, via_linear); if (!(formata & PNG_FORMAT_FLAG_COLORMAP) && (formata & PNG_FORMAT_FLAG_LINEAR)) stridea *= 2; if (!(formatb & PNG_FORMAT_FLAG_COLORMAP) && (formatb & PNG_FORMAT_FLAG_LINEAR)) strideb *= 2; if (stridea < 0) rowa += (height-1) * (-stridea); if (strideb < 0) rowb += (height-1) * (-strideb); if (formata & formatb & PNG_FORMAT_FLAG_COLORMAP) { png_const_bytep ppa, ppb; int match; png_byte in_use[256], amax = 0, bmax = 0; memset(in_use, 0, sizeof in_use); ppa = rowa; ppb = rowb; for (y=0, match=1; y<height && match; ++y, ppa += stridea, ppb += strideb) { png_uint_32 x; for (x=0; x<width; ++x) { png_byte bval = ppb[x]; png_byte aval = ppa[x]; if (bval > bmax) bmax = bval; if (bval != aval) match = 0; in_use[aval] = 1; if (aval > amax) amax = aval; } } if (match) { png_const_bytep a_cmap = (png_const_bytep)a->colormap; png_const_bytep b_cmap = (png_const_bytep)b->colormap; int result = 1; tr.is_palette = 1; for (y=0; y<256; ++y, a_cmap += a_sample, b_cmap += b_sample) if (in_use[y]) { if (y >= a->image.colormap_entries) { if ((a->opts & ACCUMULATE) == 0) { char pindex[9]; sprintf(pindex, "%lu[%lu]", (unsigned long)y, (unsigned long)a->image.colormap_entries); logerror(a, a->file_name, ": bad pixel index: ", pindex); } result = 0; } else if (y >= b->image.colormap_entries) { if ((a->opts & ACCUMULATE) == 0) { char pindex[9]; sprintf(pindex, "%lu[%lu]", (unsigned long)y, (unsigned long)b->image.colormap_entries); logerror(b, b->file_name, ": bad pixel index: ", pindex); } result = 0; } else if (!cmppixel(&tr, a_cmap, b_cmap, 0, y)) result = 0; } if (a->opts & ACCUMULATE) { tr.error_ptr[0] = tr.error[0]; tr.error_ptr[1] = tr.error[1]; tr.error_ptr[2] = tr.error[2]; tr.error_ptr[3] = tr.error[3]; result = 1; } return result; } else if ((a->opts & ACCUMULATE) == 0) { if (amax >= a->image.colormap_entries) { char pindex[9]; sprintf(pindex, "%d[%lu]", amax, (unsigned long)a->image.colormap_entries); return logerror(a, a->file_name, ": bad pixel index: ", pindex); } else if (bmax >= b->image.colormap_entries) { char pindex[9]; sprintf(pindex, "%d[%lu]", bmax, (unsigned long)b->image.colormap_entries); return logerror(b, b->file_name, ": bad pixel index: ", pindex); } } } if (!(((formata ^ formatb) & PNG_FORMAT_FLAG_LINEAR) | (formata & (formatb ^ PNG_FORMAT_FLAG_COLOR) & PNG_FORMAT_FLAG_COLOR))) { const png_uint_32 alpha_changed = (formata ^ formatb) & PNG_FORMAT_FLAG_ALPHA; alpha_removed = (formata & alpha_changed) != 0; alpha_added = (formatb & alpha_changed) != 0; { int i; png_byte aloc[4]; png_byte bloc[4]; (void)component_loc(aloc, formata); bchannels = component_loc(bloc, formatb); for (i=0; i<4; ++i) if (bloc[i] < 4) btoa[bloc[i]] = aloc[i]; if (alpha_added) alpha_added = bloc[0]; else alpha_added = 4; if (alpha_removed) alpha_removed = aloc[0]; else alpha_removed = 4; } } else { bchannels = 0; alpha_removed = alpha_added = 4; btoa[3] = btoa[2] = btoa[1] = btoa[0] = 4; } for (y=0; y<height; ++y, rowa += stridea, rowb += strideb) { png_const_bytep ppa, ppb; png_uint_32 x; for (x=0, ppa=rowa, ppb=rowb; x<width; ++x) { png_const_bytep psa, psb; if (formata & PNG_FORMAT_FLAG_COLORMAP) psa = (png_const_bytep)a->colormap + a_sample * *ppa++; else psa = ppa, ppa += a_sample; if (formatb & PNG_FORMAT_FLAG_COLORMAP) psb = (png_const_bytep)b->colormap + b_sample * *ppb++; else psb = ppb, ppb += b_sample; if (bchannels) { if (formatb & PNG_FORMAT_FLAG_LINEAR) { png_const_uint_16p pua = aligncastconst(png_const_uint_16p, psa); png_const_uint_16p pub = aligncastconst(png_const_uint_16p, psb); switch (bchannels) { case 4: if (pua[btoa[3]] != pub[3]) break; case 3: if (pua[btoa[2]] != pub[2]) break; case 2: if (pua[btoa[1]] != pub[1]) break; case 1: if (pua[btoa[0]] != pub[0]) break; if (alpha_added != 4 && pub[alpha_added] != 65535) break; continue; default: break; } } else if (alpha_removed == 4 || psa[alpha_removed] == 255) { switch (bchannels) { case 4: if (psa[btoa[3]] != psb[3]) break; case 3: if (psa[btoa[2]] != psb[2]) break; case 2: if (psa[btoa[1]] != psb[1]) break; case 1: if (psa[btoa[0]] != psb[0]) break; if (alpha_added != 4 && psb[alpha_added] != 255) break; continue; default: break; } } } if (!cmppixel(&tr, psa, psb, x, y) && (a->opts & KEEP_GOING) == 0) return 0; } } if (a->opts & ACCUMULATE) { tr.error_ptr[0] = tr.error[0]; tr.error_ptr[1] = tr.error[1]; tr.error_ptr[2] = tr.error[2]; tr.error_ptr[3] = tr.error[3]; } return 1; }<SPLIT>[11.808445601006845, 4.122719797281645, 0.0, 11.60165554885109, 3.913116438943931, 0.0, 1.3177536816088504, 1.3480932287791254, 1.2376156019774536, 0.380400859743741, 5.263314574760685, 12.016815207059278, 4.284401215113499, 0.0, 0.0, 0.30852482215402843, 5.039937199935854, 11.800192904699573, 4.083566735127855, 2.317474130733181, 2.0030605713555723, 0.0, -0.08645738172306322, -0.16222078614455715, 3.3812729526435628, 1.7637827696683932, 2.0373679067541706, 1.5806237532086234, 1.1753073288427536, 1.3170847170463484, 1.3475072793347742, 1.2369948159429325, 0.3801362775450152, 1.7623686513065309, 0.0, 1.3123839157220905, 1.3427725632242797, 1.2323429545022004, 0.3766295797615486]
0<SPLIT>static void make_random_bytes(png_uint_32* seed, void* pv, size_t size) { png_uint_32 u0 = seed[0], u1 = seed[1]; png_bytep bytes = voidcast(png_bytep, pv); size_t i; for (i=0; i<size; ++i) { png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff; u1 <<= 8; u1 |= u0 >> 24; u0 <<= 8; u0 |= u; *bytes++ = (png_byte)u; } seed[0] = u0; seed[1] = u1; }<SPLIT>[0.36491818514653585, -0.2625622830695019, 0.0, 0.34210700232091185, -0.3213592940345919, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1909204935349246, 0.3762494122151511, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, 0.35306556693537716, -0.3116600371295954, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.4705090699407485, -0.6720729196443977, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int validation_ascii_to_fp(int count, int argc, char **argv) { int showall = 0; double max_error=2; double max_error_abs=17; double max = 0; double max_abs = 0; double test = 0; int precision = 5; int nonfinite = 0; int finite = 0; int ok = 0; int failcount = 0; int minorarith = 0; while (--argc > 0) if (strcmp(*++argv, "-a") == 0) showall = 1; else if (strcmp(*argv, "-e") == 0 && argc > 0) { --argc; max_error = atof(*++argv); } else if (strcmp(*argv, "-E") == 0 && argc > 0) { --argc; max_error_abs = atof(*++argv); } else { fprintf(stderr, "unknown argument %s\n", *argv); return 1; } do { png_size_t index; int state, failed = 0; char buffer[64]; if (isfinite(test)) ++finite; else ++nonfinite; if (verbose) fprintf(stderr, "%.*g %d\n", DBL_DIG, test, precision); memset(buffer, 71, sizeof buffer); png_ascii_from_fp(0, buffer, precision+10, test, precision); if (buffer[precision+7] != 71) { fprintf(stderr, "%g[%d] -> '%s'[%lu] buffer overflow\n", test, precision, buffer, (unsigned long)strlen(buffer)); failed = 1; } state = 0; index = 0; if (!isfinite(test)) { if (test >= 0 && strcmp(buffer, "inf") || test < 0 && strcmp(buffer, "-inf")) { fprintf(stderr, "%g[%d] -> '%s' but expected 'inf'\n", test, precision, buffer); failed = 1; } } else if (!png_check_fp_number(buffer, precision+10, &state, &index) || buffer[index] != 0) { fprintf(stderr, "%g[%d] -> '%s' but has bad format ('%c')\n", test, precision, buffer, buffer[index]); failed = 1; } else if (PNG_FP_IS_NEGATIVE(state) && !(test < 0)) { fprintf(stderr, "%g[%d] -> '%s' but negative value not so reported\n", test, precision, buffer); failed = 1; assert(!PNG_FP_IS_ZERO(state)); assert(!PNG_FP_IS_POSITIVE(state)); } else if (PNG_FP_IS_ZERO(state) && !(test == 0)) { fprintf(stderr, "%g[%d] -> '%s' but zero value not so reported\n", test, precision, buffer); failed = 1; assert(!PNG_FP_IS_NEGATIVE(state)); assert(!PNG_FP_IS_POSITIVE(state)); } else if (PNG_FP_IS_POSITIVE(state) && !(test > 0)) { fprintf(stderr, "%g[%d] -> '%s' but postive value not so reported\n", test, precision, buffer); failed = 1; assert(!PNG_FP_IS_NEGATIVE(state)); assert(!PNG_FP_IS_ZERO(state)); } else { double out = atof(buffer); double change = fabs((out - test)/test); double allow = .5/pow(10, (precision >= DBL_DIG) ? DBL_DIG-1 : precision-1); if (change >= allow && (isfinite(out) || fabs(test/DBL_MAX) <= 1-allow)) { double percent = (precision >= DBL_DIG) ? max_error_abs : max_error; double allowp = (change-allow)*100/allow; if (precision >= DBL_DIG) { if (max_abs < allowp) max_abs = allowp; } else { if (max < allowp) max = allowp; } if (showall || allowp >= percent) { fprintf(stderr, "%.*g[%d] -> '%s' -> %.*g number changed (%g > %g (%d%%))\n", DBL_DIG, test, precision, buffer, DBL_DIG, out, change, allow, (int)round(allowp)); failed = 1; } else ++minorarith; } } if (failed) ++failcount; else ++ok; skip: precision = rand(); if (precision & 1) test = -test; precision >>= 1; if (test == 0 || !isfinite(test)) test = precision+1; else { int exponent = precision % (DBL_MAX_EXP - DBL_MIN_EXP) + DBL_MIN_EXP; int tmp; test = frexp(test * rand(), &tmp); test = ldexp(test, exponent); precision >>= 8; } precision = (precision & 0x1f) + 1; } while (--count); printf("Tested %d finite values, %d non-finite, %d OK (%d failed) %d minor " "arithmetic errors\n", finite, nonfinite, ok, failcount, minorarith); printf(" Error with >=%d digit precision %.2f%%\n", DBL_DIG, max_abs); printf(" Error with < %d digit precision %.2f%%\n", DBL_DIG, max); return 0; }<SPLIT>[3.148478907923368, 2.690341228322728, 0.0, 3.0809161082336582, 2.551274997181994, 0.0, 3.229479288289516, 3.292269798028381, 4.720297319549869, 1.040052222782594, 2.8458697276406526, 3.2077383893393976, 2.8028640022479365, 0.0, 0.0, 0.30852482215402843, 2.715102792911383, 3.137501946391533, 2.6700264666631472, 4.258428856691069, 8.580041677727834, 0.0, -0.08645738172306322, -0.16222078614455715, 1.9408547822015223, 4.978983221788866, 4.182341894319704, -0.21702784222394986, 5.105279757897274, 3.2283207833032805, 3.2912808592222835, 4.718819869815921, 1.039626388904333, 3.475844538781386, 0.0, 3.22121020048164, 3.284132330149356, 4.709562918768478, 1.0350888753871217]
0<SPLIT>static void gpc_g16(Pixel *out, const Pixel *in, const Background *back) { (void)back; out->r = out->g = out->b = u16d(YfromRGBint(in->r, in->g, in->b)); out->a = 65535; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_background_set(PNG_CONST image_transform *this, transform_display *that, png_structp pp, png_infop pi) { png_byte colour_type, bit_depth; png_byte random_bytes[8]; int expand; png_color_16 back; RANDOMIZE(random_bytes); colour_type = that->this.colour_type; if (colour_type == 3) { colour_type = PNG_COLOR_TYPE_RGB; bit_depth = 8; expand = 0; } else { bit_depth = that->this.bit_depth; expand = 1; } image_pixel_init(&data, random_bytes, colour_type, bit_depth, 0, 0); RANDOMIZE(back); if (colour_type & PNG_COLOR_MASK_COLOR) { back.red = (png_uint_16)data.red; back.green = (png_uint_16)data.green; back.blue = (png_uint_16)data.blue; } else back.gray = (png_uint_16)data.red; #ifdef PNG_FLOATING_POINT_SUPPORTED png_set_background(pp, &back, PNG_BACKGROUND_GAMMA_FILE, expand, 0); #else png_set_background_fixed(pp, &back, PNG_BACKGROUND_GAMMA_FILE, expand, 0); #endif this->next->set(this->next, that, pp, pi); }<SPLIT>[1.4474140217819704, 0.20020617767107143, 0.0, 1.4071994323980908, 0.12549492904354367, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.3684882314184712, 1.477384014430136, 0.13609701908992267, 0.0, 0.0, 0.30852482215402843, 0.29340028559422593, 1.4359019367238823, 0.06381159668134254, -0.14106852214680915, 0.029966239443893296, 0.0, 0.02378964451747194, 1.5771521192305922, 0.00858650477927287, -0.1980344553542678, -0.3333928163445767, 0.6817979554923368, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static unsigned int sample_scale(double sample_value, unsigned int scale) { sample_value = floor(sample_value * scale + .5); if (!(sample_value > 0)) sample_value = 0; else if (sample_value > scale) sample_value = scale; return (unsigned int)sample_value; }<SPLIT>[-0.09900860198293619, -0.43885503001829174, 0.0, -0.11436118199787926, -0.491589474254834, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.41068820690947294, -0.09566541730555662, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.11100716297398205, -0.48835257068768384, -0.6586564490689124, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.3070243011888601, -0.6720729196443977, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static size_t safecat_current_encoding(char *buffer, size_t bufsize, size_t pos, PNG_CONST png_modifier *pm) { pos = safecat_color_encoding(buffer, bufsize, pos, pm->current_encoding, pm->current_gamma); if (pm->encoding_ignored) pos = safecat(buffer, bufsize, pos, "[overridden]"); return pos; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.39986248560786075, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
1<SPLIT>static png_size_t png_inflate(png_structp png_ptr, const png_byte *data, png_size_t size, png_bytep output, png_size_t output_size) { png_size_t count = 0; png_ptr->zstream.next_in = (png_bytep)data; png_ptr->zstream.avail_in = size; while (1) { int ret, avail; png_ptr->zstream.next_out = png_ptr->zbuf; png_ptr->zstream.avail_out = png_ptr->zbuf_size; ret = inflate(&png_ptr->zstream, Z_NO_FLUSH); avail = png_ptr->zbuf_size - png_ptr->zstream.avail_out; if ((ret == Z_OK || ret == Z_STREAM_END) && avail > 0) { if (output != 0 && output_size > count) { int copy = output_size - count; if (avail < copy) copy = avail; png_memcpy(output + count, png_ptr->zbuf, copy); } count += avail; } if (ret == Z_OK) continue; png_ptr->zstream.avail_in = 0; inflateReset(&png_ptr->zstream); if (ret == Z_STREAM_END) return count; { PNG_CONST char *msg; if (png_ptr->zstream.msg != 0) msg = png_ptr->zstream.msg; else { #ifdef PNG_STDIO_SUPPORTED char umsg[52]; switch (ret) { case Z_BUF_ERROR: msg = "Buffer error in compressed datastream in %s chunk"; break; case Z_DATA_ERROR: msg = "Data error in compressed datastream in %s chunk"; break; default: msg = "Incomplete compressed datastream in %s chunk"; break; } png_snprintf(umsg, sizeof umsg, msg, png_ptr->chunk_name); msg = umsg; #else msg = "Damaged compressed datastream in chunk other than IDAT"; #endif } png_warning(png_ptr, msg); } return 0; } }<SPLIT>[4.6949015316882745, 0.6850112317802435, 0.0, 4.602476722629628, 0.5936279246492095, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 0.380400859743741, 1.2275802018826147, 4.151568048380813, 0.3184400606733766, 0.0, 0.0, 0.30852482215402843, 1.126465948111328, 4.0656474062102514, 0.24050413023943099, -0.011671540416283347, 0.13958259121676436, 0.0, 2.0082361168471046, 1.5771521192305922, 0.3599080097651364, 0.23792492798410134, 0.005287286955244392, 0.6817979554923368, 0.33317037975964214, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 0.3801362775450152, 2.6191065950439585, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 0.3766295797615486]
0<SPLIT>static int test_one_file(const char *file_name, format_list *formats, png_uint_32 opts, int stride_extra, int log_pass) { int result; Image image; newimage(&image); initimage(&image, opts, file_name, stride_extra); result = read_one_file(&image); if (result) result = testimage(&image, opts, formats); freeimage(&image); fflush(stderr); if (log_pass) { if (result) printf("PASS:"); else printf("FAIL:"); #ifndef PNG_SIMPLIFIED_WRITE_SUPPORTED printf(" (no write)"); #endif print_opts(opts); printf(" %s\n", file_name); fflush(stdout); } else if (!result) exit(1); return result; }<SPLIT>[0.05563366039355449, 0.0018768373536828752, 0.0, 0.037794879441717756, -0.06601402370422871, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.380400859743741, 0.008868336805573909, 0.061639525868012635, -0.023453142295599506, 0.0, 0.0, 0.30852482215402843, -0.05532487545944473, 0.04368374699580437, -0.09079437018198484, 0.6353133682363457, 0.5780479983082486, 0.0, -0.08645738172306322, 0.9973611507722091, -0.13194209721507255, 0.3469147738186936, 0.34396739025506545, -0.21702784222394986, 0.33317037975964214, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.3801362775450152, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.3766295797615486]
0<SPLIT>static size_t safecatn(char *buffer, size_t bufsize, size_t pos, int n) { char number[64]; sprintf(number, "%d", n); return safecat(buffer, bufsize, pos, number); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.39986248560786075, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.41601414702345235, -0.4462861841111837, -0.21702784222394986, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void sbit_modification_init(sbit_modification *me, png_modifier *pm, png_byte sbit) { modification_init(&me->this); me->this.chunk = CHUNK_sBIT; me->this.modify_fn = sbit_modify; me->this.add = CHUNK_PLTE; me->sbit = sbit; me->this.next = pm->modifications; pm->modifications = &me->this; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static png_bytep store_image_row(PNG_CONST png_store* ps, png_const_structp pp, int nImage, png_uint_32 y) { png_size_t coffset = (nImage * ps->image_h + y) * (ps->cb_row + 5) + 2; if (ps->image == NULL) png_error(pp, "no allocated image"); if (coffset + ps->cb_row + 3 > ps->cb_image) png_error(pp, "image too small"); return ps->image + coffset; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int global_end(struct global *global) { int rc; IDAT_list_end(&global->idat_cache); rc = global->status_code; CLEAR(*global); return rc; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gamma_info_imp(gamma_display *dp, png_structp pp, png_infop pi) { standard_info_part1(&dp->this, pp, pi); if (dp->scale16) #ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED png_set_scale_16(pp); #else #ifdef PNG_READ_16_TO_8_SUPPORTED png_set_strip_16(pp); #else png_error(pp, "scale16 (16 to 8 bit conversion) not supported"); #endif #endif if (dp->expand16) #ifdef PNG_READ_EXPAND_16_SUPPORTED png_set_expand_16(pp); #else png_error(pp, "expand16 (8 to 16 bit conversion) not supported"); #endif if (dp->do_background >= ALPHA_MODE_OFFSET) { #ifdef PNG_READ_ALPHA_MODE_SUPPORTED { int mode = dp->do_background - ALPHA_MODE_OFFSET; PNG_CONST double sg = dp->screen_gamma; #ifndef PNG_FLOATING_POINT_SUPPORTED PNG_CONST png_fixed_point g = fix(sg); #endif #ifdef PNG_FLOATING_POINT_SUPPORTED png_set_alpha_mode(pp, mode, sg); #else png_set_alpha_mode_fixed(pp, mode, g); #endif if (mode == PNG_ALPHA_STANDARD && sg != 1) { #ifdef PNG_FLOATING_POINT_SUPPORTED png_set_gamma(pp, sg, dp->file_gamma); #else png_fixed_point f = fix(dp->file_gamma); png_set_gamma_fixed(pp, g, f); #endif } } #else png_error(pp, "alpha mode handling not supported"); #endif } else { #ifdef PNG_FLOATING_POINT_SUPPORTED png_set_gamma(pp, dp->screen_gamma, dp->file_gamma); #else { png_fixed_point s = fix(dp->screen_gamma); png_fixed_point f = fix(dp->file_gamma); png_set_gamma_fixed(pp, s, f); } #endif if (dp->do_background) { #ifdef PNG_READ_BACKGROUND_SUPPORTED PNG_CONST double bg = dp->background_gamma; #ifndef PNG_FLOATING_POINT_SUPPORTED PNG_CONST png_fixed_point g = fix(bg); #endif #ifdef PNG_FLOATING_POINT_SUPPORTED png_set_background(pp, &dp->background_color, dp->do_background, 0, bg); #else png_set_background_fixed(pp, &dp->background_color, dp->do_background, 0, g); #endif #else png_error(pp, "png_set_background not supported"); #endif } } { int i = dp->this.use_update_info; do png_read_update_info(pp, pi); while (--i > 0); } standard_info_part2(&dp->this, pp, pi, 1 ); }<SPLIT>[2.9938366455468772, 1.2359260659952118, 0.0, 2.9287600467940615, 1.1255972378374661, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 1.5072845643593127, 1.3200790712565666, 0.06771837849612745, 0.0, 0.0, 0.30852482215402843, 1.3976966289308497, 1.281211026754096, -0.0024481034029406237, -0.011671540416283347, -0.2988828158747199, 0.0, 5.095152851582089, 17.81129923606532, 0.2896437087679637, -0.25252937827156396, -0.10760608081136262, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI write_function(png_structp pp, png_bytep data, png_size_t size) { buffer_write(get_dp(pp), get_buffer(pp), data, size); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int mytime(struct timespec *t) { if (!clock_gettime(CLOCK_PROCESS_CPUTIME_ID, t)) return 1; perror("CLOCK_PROCESS_CPUTIME_ID"); fprintf(stderr, "timepng: could not get the time\n"); return 0; }<SPLIT>[-0.09900860198293619, -0.4829282167554892, 0.0, -0.11436118199787926, -0.5128682467823643, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4506459729775727, -0.09566541730555662, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.11100716297398205, -0.5104391373824448, -0.39986248560786075, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.25252937827156396, -0.3333928163445767, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI warning_handler(png_structp png_ptr, png_const_charp message) { struct file *file = get_control(png_ptr); if (file->global->warnings) emit_error(file, LIBPNG_WARNING_CODE, message); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void pixel_copy(png_bytep toBuffer, png_uint_32 toIndex, png_const_bytep fromBuffer, png_uint_32 fromIndex, unsigned int pixelSize) { toIndex *= pixelSize; fromIndex *= pixelSize; if (pixelSize < 8) { unsigned int destMask = ((1U<<pixelSize)-1) << (8-pixelSize-(toIndex&7)); unsigned int destByte = toBuffer[toIndex >> 3] & ~destMask; unsigned int sourceByte = fromBuffer[fromIndex >> 3]; fromIndex &= 7; if (fromIndex > 0) sourceByte <<= fromIndex; if ((toIndex & 7) > 0) sourceByte >>= toIndex & 7; toBuffer[toIndex >> 3] = (png_byte)(destByte | (sourceByte & destMask)); } else memmove(toBuffer+(toIndex>>3), fromBuffer+(fromIndex>>3), pixelSize>>3); }<SPLIT>[0.6742027098995172, -0.24052568970090316, 0.0, 0.6464191252001059, -0.30008052150706166, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.13098384443277505, 0.6908592985622897, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, 0.66244738687495, -0.28957347043483433, -0.14106852214680915, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.3615192241061562, -0.3333928163445767, 0.6817979554923368, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void standard_info_part1(standard_display *dp, png_structp pp, png_infop pi) { if (png_get_bit_depth(pp, pi) != dp->bit_depth) png_error(pp, "validate: bit depth changed"); if (png_get_color_type(pp, pi) != dp->colour_type) png_error(pp, "validate: color type changed"); if (png_get_filter_type(pp, pi) != PNG_FILTER_TYPE_BASE) png_error(pp, "validate: filter type changed"); if (png_get_interlace_type(pp, pi) != dp->interlace_type) png_error(pp, "validate: interlacing changed"); if (png_get_compression_type(pp, pi) != PNG_COMPRESSION_TYPE_BASE) png_error(pp, "validate: compression type changed"); dp->w = png_get_image_width(pp, pi); if (dp->w != standard_width(pp, dp->id)) png_error(pp, "validate: image width changed"); dp->h = png_get_image_height(pp, pi); if (dp->h != standard_height(pp, dp->id)) png_error(pp, "validate: image height changed"); { png_color_8p sBIT = 0; if (png_get_sBIT(pp, pi, &sBIT) & PNG_INFO_sBIT) { int sBIT_invalid = 0; if (sBIT == 0) png_error(pp, "validate: unexpected png_get_sBIT result"); if (dp->colour_type & PNG_COLOR_MASK_COLOR) { if (sBIT->red == 0 || sBIT->red > dp->bit_depth) sBIT_invalid = 1; else dp->red_sBIT = sBIT->red; if (sBIT->green == 0 || sBIT->green > dp->bit_depth) sBIT_invalid = 1; else dp->green_sBIT = sBIT->green; if (sBIT->blue == 0 || sBIT->blue > dp->bit_depth) sBIT_invalid = 1; else dp->blue_sBIT = sBIT->blue; } else { if (sBIT->gray == 0 || sBIT->gray > dp->bit_depth) sBIT_invalid = 1; else dp->blue_sBIT = dp->green_sBIT = dp->red_sBIT = sBIT->gray; } if (dp->colour_type & PNG_COLOR_MASK_ALPHA) { if (sBIT->alpha == 0 || sBIT->alpha > dp->bit_depth) sBIT_invalid = 1; else dp->alpha_sBIT = sBIT->alpha; } if (sBIT_invalid) png_error(pp, "validate: sBIT value out of range"); } } if (png_get_rowbytes(pp, pi) != standard_rowsize(pp, dp->id)) png_error(pp, "validate: row size changed"); standard_palette_validate(dp, pp, pi); { png_color_16p trans_color = 0; if (png_get_tRNS(pp, pi, 0, 0, &trans_color) & PNG_INFO_tRNS) { if (trans_color == 0) png_error(pp, "validate: unexpected png_get_tRNS (color) result"); switch (dp->colour_type) { case 0: dp->transparent.red = dp->transparent.green = dp->transparent.blue = trans_color->gray; dp->is_transparent = 1; break; case 2: dp->transparent.red = trans_color->red; dp->transparent.green = trans_color->green; dp->transparent.blue = trans_color->blue; dp->is_transparent = 1; break; case 3: png_error(pp, "validate: unexpected png_get_tRNS result"); break; default: png_error(pp, "validate: invalid tRNS chunk with alpha image"); } } } dp->npasses = npasses_from_interlace_type(pp, dp->interlace_type); if (!dp->do_interlace && dp->npasses != png_set_interlace_handling(pp)) png_error(pp, "validate: file changed interlace type"); }<SPLIT>[4.076332482182312, 1.3901822195754028, 0.0, 3.9938524768712407, 1.274548645530178, 0.0, 1.1439604446378808, 1.1713499043019204, 1.0717736154263862, -0.27925050329511203, 1.7869889268360106, 4.151568048380813, 1.4580840705699636, 0.0, 0.0, 0.30852482215402843, 1.6689273097503714, 4.0656474062102514, 1.3448324649774837, 1.4116952586195004, 0.9068970536268617, 0.0, -0.08645738172306322, -0.16222078614455715, 0.7112295147509999, 1.327823386330024, 1.2471143323879217, 4.277101146357483, 0.8010242403613708, 1.143335983750264, 1.1708005902540914, 1.0711936229013617, -0.27935383381430245, 1.7623686513065309, 0.0, 1.1388542534712223, 1.1662853116856364, 1.0667610514419015, -0.28182971586402455]
0<SPLIT>void png_warning(png_const_structrp png_ptr, png_const_charp msg) { fprintf(stderr, "validation: %s\n", msg); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, 0.417570182313826, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void store_ensure_image(png_store *ps, png_const_structp pp, int nImages, png_size_t cbRow, png_uint_32 cRows) { png_size_t cb = nImages * cRows * (cbRow + 5); if (ps->cb_image < cb) { png_bytep image; store_image_free(ps, pp); image = voidcast(png_bytep, malloc(cb+2)); if (image == NULL) { if (pp == NULL) return; png_error(pp, "OOM allocating image buffer"); } ++image; image[-1] = 0xed; image[cb] = 0xfe; ps->image = image; ps->cb_image = cb; } ps->cb_row = cbRow; ps->image_h = cRows; memset(ps->image, 178, cb); while (--nImages >= 0) { png_uint_32 y; for (y=0; y<cRows; ++y) { png_bytep row = store_image_row(ps, pp, nImages, y); row[-2] = 190; row[-1] = 239; row[cbRow] = 222; row[cbRow+1] = 173; row[cbRow+2] = 17; } } }<SPLIT>[2.065983071287933, 0.20020617767107143, 0.0, 2.015823678156479, 0.12549492904354367, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 0.7102265412631674, 0.44840376355467065, 2.106603787124413, 0.22726853988164963, 0.0, 0.0, 0.30852482215402843, 0.37089476582837494, 2.054665576603028, 0.15215786346038676, -0.14106852214680915, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.11398295627503194, -0.14353953243697165, -0.22049944857796966, -0.21702784222394986, -0.04111270872174079, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 0.7098813332246741, 1.7623686513065309, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 0.7058592275743352]
0<SPLIT>static const char * zlib_flevel(struct zlib *zlib) { switch (zlib->header[1] >> 6) { case 0: return "supfast"; case 1: return "stdfast"; case 2: return "default"; case 3: return "maximum"; default: assert(UNREACHED); } return "COMPILER BUG"; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void store_storenew(png_store *ps) { png_store_buffer *pb; if (ps->writepos != STORE_BUFFER_SIZE) png_error(ps->pwrite, "invalid store call"); pb = voidcast(png_store_buffer*, malloc(sizeof *pb)); if (pb == NULL) png_error(ps->pwrite, "store new: OOM"); *pb = ps->new; ps->new.prev = pb; ps->writepos = 0; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void transform_enable(PNG_CONST char *name) { static int all_disabled = 0; int found_it = 0; image_transform *list = image_transform_first; while (list != &image_transform_end) { if (strcmp(list->name, name) == 0) { list->enable = 1; found_it = 1; } else if (!all_disabled) list->enable = 0; list = list->list; } all_disabled = 1; if (!found_it) { fprintf(stderr, "pngvalid: --transform-enable=%s: unknown transform\n", name); exit(99); } }<SPLIT>[0.21027592277004517, -0.10830612948931077, 0.0, 0.18995094088131478, -0.17240788634188003, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.07104719533062549, 0.21894446904158188, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.13281935569359377, 0.19837465696559078, -0.157054070266268, -0.14106852214680915, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.25252937827156396, -0.22049944857796966, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>BOOL pnm2png (FILE *pnm_file, FILE *png_file, FILE *alpha_file, BOOL interlace, BOOL alpha) { png_struct *png_ptr = NULL; png_info *info_ptr = NULL; png_byte *png_pixels = NULL; png_byte **row_pointers = NULL; png_byte *pix_ptr = NULL; volatile png_uint_32 row_bytes; char type_token[16]; char width_token[16]; char height_token[16]; char maxval_token[16]; volatile int color_type; unsigned long ul_width=0, ul_alpha_width=0; unsigned long ul_height=0, ul_alpha_height=0; unsigned long ul_maxval=0; volatile png_uint_32 width, height; volatile png_uint_32 alpha_width, alpha_height; png_uint_32 maxval; volatile int bit_depth = 0; int channels; int alpha_depth = 0; int alpha_present; int row, col; BOOL raw, alpha_raw = FALSE; #if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED) BOOL packed_bitmap = FALSE; #endif png_uint_32 tmp16; int i; get_token(pnm_file, type_token); if (type_token[0] != 'P') { return FALSE; } else if ((type_token[1] == '1') || (type_token[1] == '4')) { #if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED) raw = (type_token[1] == '4'); color_type = PNG_COLOR_TYPE_GRAY; get_token(pnm_file, width_token); sscanf (width_token, "%lu", &ul_width); width = (png_uint_32) ul_width; get_token(pnm_file, height_token); sscanf (height_token, "%lu", &ul_height); height = (png_uint_32) ul_height; bit_depth = 1; packed_bitmap = TRUE; #else fprintf (stderr, "PNM2PNG built without PNG_WRITE_INVERT_SUPPORTED and \n"); fprintf (stderr, "PNG_WRITE_PACK_SUPPORTED can't read PBM (P1,P4) files\n"); #endif } else if ((type_token[1] == '2') || (type_token[1] == '5')) { raw = (type_token[1] == '5'); color_type = PNG_COLOR_TYPE_GRAY; get_token(pnm_file, width_token); sscanf (width_token, "%lu", &ul_width); width = (png_uint_32) ul_width; get_token(pnm_file, height_token); sscanf (height_token, "%lu", &ul_height); height = (png_uint_32) ul_height; get_token(pnm_file, maxval_token); sscanf (maxval_token, "%lu", &ul_maxval); maxval = (png_uint_32) ul_maxval; if (maxval <= 1) bit_depth = 1; else if (maxval <= 3) bit_depth = 2; else if (maxval <= 15) bit_depth = 4; else if (maxval <= 255) bit_depth = 8; else bit_depth = 16; } else if ((type_token[1] == '3') || (type_token[1] == '6')) { raw = (type_token[1] == '6'); color_type = PNG_COLOR_TYPE_RGB; get_token(pnm_file, width_token); sscanf (width_token, "%lu", &ul_width); width = (png_uint_32) ul_width; get_token(pnm_file, height_token); sscanf (height_token, "%lu", &ul_height); height = (png_uint_32) ul_height; get_token(pnm_file, maxval_token); sscanf (maxval_token, "%lu", &ul_maxval); maxval = (png_uint_32) ul_maxval; if (maxval <= 1) bit_depth = 1; else if (maxval <= 3) bit_depth = 2; else if (maxval <= 15) bit_depth = 4; else if (maxval <= 255) bit_depth = 8; else bit_depth = 16; } else { return FALSE; } if (alpha) { if (color_type == PNG_COLOR_TYPE_GRAY) color_type = PNG_COLOR_TYPE_GRAY_ALPHA; if (color_type == PNG_COLOR_TYPE_RGB) color_type = PNG_COLOR_TYPE_RGB_ALPHA; get_token(alpha_file, type_token); if (type_token[0] != 'P') { return FALSE; } else if ((type_token[1] == '2') || (type_token[1] == '5')) { alpha_raw = (type_token[1] == '5'); get_token(alpha_file, width_token); sscanf (width_token, "%lu", &ul_alpha_width); alpha_width=(png_uint_32) ul_alpha_width; if (alpha_width != width) return FALSE; get_token(alpha_file, height_token); sscanf (height_token, "%lu", &ul_alpha_height); alpha_height = (png_uint_32) ul_alpha_height; if (alpha_height != height) return FALSE; get_token(alpha_file, maxval_token); sscanf (maxval_token, "%lu", &ul_maxval); maxval = (png_uint_32) ul_maxval; if (maxval <= 1) alpha_depth = 1; else if (maxval <= 3) alpha_depth = 2; else if (maxval <= 15) alpha_depth = 4; else if (maxval <= 255) alpha_depth = 8; else alpha_depth = 16; if (alpha_depth != bit_depth) return FALSE; } else { return FALSE; } } if (color_type == PNG_COLOR_TYPE_GRAY) channels = 1; else if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA) channels = 2; else if (color_type == PNG_COLOR_TYPE_RGB) channels = 3; else if (color_type == PNG_COLOR_TYPE_RGB_ALPHA) channels = 4; else channels = 0; alpha_present = (channels - 1) % 2; #if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED) if (packed_bitmap) row_bytes = (width * channels * bit_depth + 7) / 8; else #endif row_bytes = width * channels * ((bit_depth <= 8) ? 1 : 2); if ((png_pixels = (png_byte *) malloc (row_bytes * height * sizeof (png_byte))) == NULL) return FALSE; pix_ptr = png_pixels; for (row = 0; row < (int) height; row++) { #if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED) if (packed_bitmap) { for (i = 0; i < (int) row_bytes; i++) *pix_ptr++ = get_data (pnm_file, 8); } else #endif { for (col = 0; col < (int) width; col++) { for (i = 0; i < (channels - alpha_present); i++) { if (raw) *pix_ptr++ = get_data (pnm_file, bit_depth); else if (bit_depth <= 8) *pix_ptr++ = get_value (pnm_file, bit_depth); else { tmp16 = get_value (pnm_file, bit_depth); *pix_ptr = (png_byte) ((tmp16 >> 8) & 0xFF); pix_ptr++; *pix_ptr = (png_byte) (tmp16 & 0xFF); pix_ptr++; } } if (alpha) { if (alpha_raw) *pix_ptr++ = get_data (alpha_file, alpha_depth); else if (alpha_depth <= 8) *pix_ptr++ = get_value (alpha_file, bit_depth); else { tmp16 = get_value (alpha_file, bit_depth); *pix_ptr++ = (png_byte) ((tmp16 >> 8) & 0xFF); *pix_ptr++ = (png_byte) (tmp16 & 0xFF); } } } } } png_ptr = png_create_write_struct (png_get_libpng_ver(NULL), NULL, NULL, NULL); if (!png_ptr) { return FALSE; } info_ptr = png_create_info_struct (png_ptr); if (!info_ptr) { png_destroy_write_struct (&png_ptr, (png_infopp) NULL); return FALSE; } #if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED) if (packed_bitmap == TRUE) { png_set_packing (png_ptr); png_set_invert_mono (png_ptr); } #endif if (setjmp (png_jmpbuf(png_ptr))) { png_destroy_write_struct (&png_ptr, (png_infopp) NULL); return FALSE; } png_init_io (png_ptr, png_file); png_set_IHDR (png_ptr, info_ptr, width, height, bit_depth, color_type, (!interlace) ? PNG_INTERLACE_NONE : PNG_INTERLACE_ADAM7, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE); png_write_info (png_ptr, info_ptr); if (row_pointers == (unsigned char**) NULL) { if ((row_pointers = (png_byte **) malloc (height * sizeof (png_bytep))) == NULL) { png_destroy_write_struct (&png_ptr, (png_infopp) NULL); return FALSE; } } for (i = 0; i < (int) height; i++) row_pointers[i] = png_pixels + i * row_bytes; png_write_image (png_ptr, row_pointers); png_write_end (png_ptr, info_ptr); png_destroy_write_struct (&png_ptr, (png_infopp) NULL); if (row_pointers != (unsigned char**) NULL) free (row_pointers); if (png_pixels != (unsigned char*) NULL) free (png_pixels); return TRUE; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 2.320135801035673, 4.955776292792914, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 4.807453759233407, 2.054665576603028, 4.414865235549271, -0.917450412529964, -0.518115519420462, 0.0, 2.669718274290316, 6.215479866897657, 4.575766069595499, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void clear(void *pv, size_t size) { static png_uint_32 clear_seed[2] = { 0x12345678, 0x9abcdef0 }; make_random_bytes(clear_seed, pv, size); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int read_file(Image *image, png_uint_32 format, png_const_colorp background) { memset(&image->image, 0, sizeof image->image); image->image.version = PNG_IMAGE_VERSION; if (image->input_memory != NULL) { if (!png_image_begin_read_from_memory(&image->image, image->input_memory, image->input_memory_size)) return logerror(image, "memory init: ", image->file_name, ""); } #ifdef PNG_STDIO_SUPPORTED else if (image->input_file != NULL) { if (!png_image_begin_read_from_stdio(&image->image, image->input_file)) return logerror(image, "stdio init: ", image->file_name, ""); } else { if (!png_image_begin_read_from_file(&image->image, image->file_name)) return logerror(image, "file init: ", image->file_name, ""); } #else else { return logerror(image, "unsupported file/stdio init: ", image->file_name, ""); } #endif if (image->opts & sRGB_16BIT) image->image.flags |= PNG_IMAGE_FLAG_16BIT_sRGB; { int result; png_uint_32 image_format; image_format = image->image.format; if (image->opts & VERBOSE) { printf("%s %lu x %lu %s -> %s", image->file_name, (unsigned long)image->image.width, (unsigned long)image->image.height, format_names[image_format & FORMAT_MASK], (format & FORMAT_NO_CHANGE) != 0 || image->image.format == format ? "no change" : format_names[format & FORMAT_MASK]); if (background != NULL) printf(" background(%d,%d,%d)\n", background->red, background->green, background->blue); else printf("\n"); fflush(stdout); } if ((format & FORMAT_NO_CHANGE) != 0) { if ((format & PNG_FORMAT_FLAG_COLORMAP) != 0 && (image_format & PNG_FORMAT_FLAG_COLORMAP) != 0) format = (image_format & ~BASE_FORMATS) | (format & BASE_FORMATS); else format = image_format; } image->image.format = format; image->stride = PNG_IMAGE_ROW_STRIDE(image->image) + image->stride_extra; allocbuffer(image); result = png_image_finish_read(&image->image, background, image->buffer+16, (png_int_32)image->stride, image->colormap); checkbuffer(image, image->file_name); if (result) return checkopaque(image); else return logerror(image, image->file_name, ": image read failed", ""); } }<SPLIT>[1.1381294970289892, 0.8833405720976321, 0.0, 1.102887309518897, 0.7851368773969819, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 0.9478758394059169, 1.1627741280829973, 0.637540383444421, 0.0, 0.0, 0.30852482215402843, 0.8552352672918063, 1.1265201167843093, 0.5497160639660857, 0.6353133682363457, -0.07965011232897776, 0.0, 1.0160128806822883, 1.5771521192305922, 0.11398295627503194, 0.23792492798410134, 0.4568607580216725, 0.6817979554923368, -0.04111270872174079, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static void standard_check_text(png_const_structp pp, png_const_textp tp, png_const_charp keyword, png_const_charp text) { char msg[1024]; size_t pos = safecat(msg, sizeof msg, 0, "text: "); size_t ok; pos = safecat(msg, sizeof msg, pos, keyword); pos = safecat(msg, sizeof msg, pos, ": "); ok = pos; if (tp->compression != TEXT_COMPRESSION) { char buf[64]; sprintf(buf, "compression [%d->%d], ", TEXT_COMPRESSION, tp->compression); pos = safecat(msg, sizeof msg, pos, buf); } if (tp->key == NULL || strcmp(tp->key, keyword) != 0) { pos = safecat(msg, sizeof msg, pos, "keyword \""); if (tp->key != NULL) { pos = safecat(msg, sizeof msg, pos, tp->key); pos = safecat(msg, sizeof msg, pos, "\", "); } else pos = safecat(msg, sizeof msg, pos, "null, "); } if (tp->text == NULL) pos = safecat(msg, sizeof msg, pos, "text lost, "); else { if (tp->text_length != strlen(text)) { char buf[64]; sprintf(buf, "text length changed[%lu->%lu], ", (unsigned long)strlen(text), (unsigned long)tp->text_length); pos = safecat(msg, sizeof msg, pos, buf); } if (strcmp(tp->text, text) != 0) { pos = safecat(msg, sizeof msg, pos, "text becomes \""); pos = safecat(msg, sizeof msg, pos, tp->text); pos = safecat(msg, sizeof msg, pos, "\" (was \""); pos = safecat(msg, sizeof msg, pos, text); pos = safecat(msg, sizeof msg, pos, "\"), "); } } if (tp->itxt_length != 0) pos = safecat(msg, sizeof msg, pos, "iTXt length set, "); if (tp->lang != NULL) { pos = safecat(msg, sizeof msg, pos, "iTXt language \""); pos = safecat(msg, sizeof msg, pos, tp->lang); pos = safecat(msg, sizeof msg, pos, "\", "); } if (tp->lang_key != NULL) { pos = safecat(msg, sizeof msg, pos, "iTXt keyword \""); pos = safecat(msg, sizeof msg, pos, tp->lang_key); pos = safecat(msg, sizeof msg, pos, "\", "); } if (pos > ok) { msg[pos-2] = '\0'; png_error(pp, msg); } }<SPLIT>[-0.25365086435942685, 0.8392673853604347, 0.0, -0.2665172434374763, 0.7425793323419214, 0.0, 1.3177536816088504, 1.3480932287791254, 1.2376156019774536, -0.27925050329511203, 0.7281081260313685, -0.25297036047912586, 0.8882620656216701, 0.0, 0.0, 0.30852482215402843, 0.6421254466478965, -0.26569807294376846, 0.7926682976084574, 0.5059163865058198, 2.2222932749013142, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3950401602637228, 1.327823386330024, 0.34396739025506545, -0.21702784222394986, 2.0174442779258652, 1.3170847170463484, 1.3475072793347742, 1.2369948159429325, -0.27935383381430245, 0.9056307075691036, 0.0, 1.3123839157220905, 1.3427725632242797, 1.2323429545022004, -0.28182971586402455]
0<SPLIT>static void gp_ga16(Pixel *p, png_const_voidp pb) { png_const_uint_16p pp = voidcast(png_const_uint_16p, pb); p->r = p->g = p->b = pp[0]; p->a = pp[1]; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static store_palette_entry * store_write_palette(png_store *ps, int npalette) { if (ps->pwrite == NULL) store_log(ps, NULL, "attempt to write palette without write stream", 1); if (ps->palette != NULL) png_error(ps->pwrite, "multiple store_write_palette calls"); if (npalette > 0) { ps->palette = voidcast(store_palette_entry*, malloc(npalette * sizeof *ps->palette)); if (ps->palette == NULL) png_error(ps->pwrite, "store new palette: OOM"); ps->npalette = npalette; } return ps->palette; }<SPLIT>[-0.09900860198293619, -0.2845988764381006, 0.0, -0.11436118199787926, -0.34263806656212215, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.270836025671124, -0.09566541730555662, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.11100716297398205, -0.33374660382435645, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_strip_16_set(PNG_CONST image_transform *this, transform_display *that, png_structp pp, png_infop pi) { png_set_strip_16(pp); this->next->set(this->next, that, pp, pi); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gpc_cb16(Pixel *out, const Pixel *in, const Background *back) { if (in->a <= 0) { out->r = back->ir; out->g = back->ig; out->b = back->ib; } else if (in->a >= 65535) { out->r = isRGB(in->r); out->g = isRGB(in->g); out->b = isRGB(in->b); } else { double a = in->a / 65535.; double a1 = 1-a; a /= 65535; out->r = sRGB(in->r * a + back->dr * a1); out->g = sRGB(in->g * a + back->dg * a1); out->b = sRGB(in->b * a + back->db * a1); } out->a = 255; }<SPLIT>[-0.25365086435942685, -0.08626953612071205, 0.0, -0.2665172434374763, -0.15112911381434976, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.1110049613987252, -0.25297036047912586, -0.06903890269146298, 0.0, 0.0, 0.30852482215402843, -0.17156659581066827, -0.26569807294376846, -0.13496750357150694, -0.270465503877335, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.3070243011888601, -0.3333928163445767, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static png_uint_32 crc_init_4(png_uint_32 value) { png_uint_32 crc = crc_table[(~value >> 24)] ^ 0xffffff; crc = crc_table[(crc ^ (value >> 16)) & 0xff] ^ (crc >> 8); crc = crc_table[(crc ^ (value >> 8)) & 0xff] ^ (crc >> 8); return crc_table[(crc ^ value) & 0xff] ^ (crc >> 8); }<SPLIT>[0.8288449722760078, -0.4829282167554892, 0.0, 0.798575186639703, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.33077267477327355, 0.8481642417358589, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, 0.8171382968447365, -0.5325257040772059, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void pngtest_check_io_state(png_structp png_ptr, png_size_t data_length, png_uint_32 io_op) { png_uint_32 io_state = png_get_io_state(png_ptr); int err = 0; if ((io_state & PNG_IO_MASK_OP) != io_op) png_error(png_ptr, "Incorrect operation in I/O state"); switch (io_state & PNG_IO_MASK_LOC) { case PNG_IO_SIGNATURE: if (data_length > 8) err = 1; break; case PNG_IO_CHUNK_HDR: if (data_length != 8) err = 1; break; case PNG_IO_CHUNK_DATA: break; case PNG_IO_CHUNK_CRC: if (data_length != 4) err = 1; break; default: err = 1; } if (err) png_error(png_ptr, "Bad I/O state or buffer size"); }<SPLIT>[0.36491818514653585, 0.0018768373536828752, 0.0, 0.34210700232091185, -0.06601402370422871, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.04882610287367361, 0.3762494122151511, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, -0.016577635342370212, 0.35306556693537716, -0.04662123679246273, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void insert_iTXt(png_structp png_ptr, png_infop info_ptr, int nparams, png_charpp params) { png_text text; check_param_count(nparams, 4); clear_text(&text, params[0]); text.compression = 2; text.lang = params[1]; text.lang_key = params[2]; set_text(png_ptr, info_ptr, &text, params[3]); }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void png_flush(png_structp png_ptr) { if (png_ptr->output_flush_fn != NULL) (*(png_ptr->output_flush_fn))(png_ptr); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>void png_handle_sBIT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length) { png_size_t truelen; png_byte buf[4]; png_debug(1, "in png_handle_sBIT\n"); buf[0] = buf[1] = buf[2] = buf[3] = 0; if (!(png_ptr->mode & PNG_HAVE_IHDR)) png_error(png_ptr, "Missing IHDR before sBIT"); else if (png_ptr->mode & PNG_HAVE_IDAT) { png_warning(png_ptr, "Invalid sBIT after IDAT"); png_crc_finish(png_ptr, length); return; } else if (png_ptr->mode & PNG_HAVE_PLTE) { png_warning(png_ptr, "Out of place sBIT chunk"); } else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_sBIT) { png_warning(png_ptr, "Duplicate sBIT chunk"); png_crc_finish(png_ptr, length); return; } if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) truelen = 3; else truelen = (png_size_t)png_ptr->channels; if (length != truelen) { png_warning(png_ptr, "Incorrect sBIT chunk length"); png_crc_finish(png_ptr, length); return; } png_crc_read(png_ptr, buf, truelen); if (png_crc_finish(png_ptr, 0)) return; if (png_ptr->color_type & PNG_COLOR_MASK_COLOR) { png_ptr->sig_bit.red = buf[0]; png_ptr->sig_bit.green = buf[1]; png_ptr->sig_bit.blue = buf[2]; png_ptr->sig_bit.alpha = buf[3]; } else { png_ptr->sig_bit.gray = buf[0]; png_ptr->sig_bit.alpha = buf[1]; } png_set_sBIT(png_ptr, info_ptr, &(png_ptr->sig_bit)); }<SPLIT>[0.9834872346524985, 0.48668189146285495, 0.0, 0.9507312480792999, 0.4233977444289674, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, 1.699703585821447, 0.5682770617589697, 1.0054691849094282, 0.5235759824547622, 0.0, 0.0, 0.30852482215402843, 0.5065101062381357, 0.9718292068145229, 0.43928323049228046, -0.011671540416283347, 0.5780479983082486, 0.0, -0.08645738172306322, 0.417570182313826, 0.21937940777079099, 0.3469147738186936, -0.10760608081136262, 0.6817979554923368, 0.6138826961206794, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, 1.6991165002636506, 0.04889276383167627, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 1.693548171012695]
0<SPLIT>static void make_size_images(png_store *ps) { safecat(ps->test, sizeof ps->test, 0, "make size images"); make_size(ps, 0, 0, WRITE_BDHI); make_size(ps, 2, 3, WRITE_BDHI); make_size(ps, 3, 0, 3 ); make_size(ps, 4, 3, WRITE_BDHI); make_size(ps, 6, 3, WRITE_BDHI); }<SPLIT>[0.21027592277004517, -0.43885503001829174, 0.0, 0.18995094088131478, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, 0.21894446904158188, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, 0.19837465696559078, -0.48835257068768384, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void store_image_check(PNG_CONST png_store* ps, png_const_structp pp, int iImage) { png_const_bytep image = ps->image; if (image[-1] != 0xed || image[ps->cb_image] != 0xfe) png_error(pp, "image overwrite"); else { png_size_t cbRow = ps->cb_row; png_uint_32 rows = ps->image_h; image += iImage * (cbRow+5) * ps->image_h; image += 2; while (rows-- > 0) { if (image[-2] != 190 || image[-1] != 239) png_error(pp, "row start overwritten"); if (image[cbRow] != 222 || image[cbRow+1] != 173 || image[cbRow+2] != 17) png_error(pp, "row end overwritten"); image += cbRow+5; } } }<SPLIT>[-0.25365086435942685, -0.15237931622650824, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.17094161050087475, -0.25297036047912586, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, -0.6586564490689124, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.5250039928580447, -0.6720729196443977, 0.6817979554923368, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static png_uint_32 random_32(void) { for (;;) { png_byte mark[4]; png_uint_32 result; store_pool_mark(mark); result = png_get_uint_32(mark); if (result != 0) return result; } }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.41601414702345235, -0.5591795518777907, 2.47944955092491, -0.5089665693234694, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void PNGCBAPI gamma_info(png_structp pp, png_infop pi) { gamma_info_imp(voidcast(gamma_display*, png_get_progressive_ptr(pp)), pp, pi); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
1<SPLIT>void png_handle_sPLT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length) { png_bytep chunkdata; png_bytep entry_start; png_sPLT_t new_palette; #ifdef PNG_NO_POINTER_INDEXING png_sPLT_entryp pp; #endif int data_length, entry_size, i; png_uint_32 skip = 0; png_size_t slength; png_debug(1, "in png_handle_sPLT\n"); if (!(png_ptr->mode & PNG_HAVE_IHDR)) png_error(png_ptr, "Missing IHDR before sPLT"); else if (png_ptr->mode & PNG_HAVE_IDAT) { png_warning(png_ptr, "Invalid sPLT after IDAT"); png_crc_finish(png_ptr, length); return; } #ifdef PNG_MAX_MALLOC_64K if (length > (png_uint_32)65535L) { png_warning(png_ptr, "sPLT chunk too large to fit in memory"); skip = length - (png_uint_32)65535L; length = (png_uint_32)65535L; } #endif chunkdata = (png_bytep)png_malloc(png_ptr, length + 1); slength = (png_size_t)length; png_crc_read(png_ptr, (png_bytep)chunkdata, slength); if (png_crc_finish(png_ptr, skip)) { png_free(png_ptr, chunkdata); return; } chunkdata[slength] = 0x00; for (entry_start = chunkdata; *entry_start; entry_start++) ; ++entry_start; if (entry_start > chunkdata + slength - 2) { png_free(png_ptr, chunkdata); png_warning(png_ptr, "malformed sPLT chunk"); return; } new_palette.depth = *entry_start++; entry_size = (new_palette.depth == 8 ? 6 : 10); data_length = (slength - (entry_start - chunkdata)); if (data_length % entry_size) { png_free(png_ptr, chunkdata); png_warning(png_ptr, "sPLT chunk has bad length"); return; } new_palette.nentries = (png_int_32) ( data_length / entry_size); if ((png_uint_32) new_palette.nentries > (png_uint_32) (PNG_SIZE_MAX / png_sizeof(png_sPLT_entry))) { png_warning(png_ptr, "sPLT chunk too long"); return; } new_palette.entries = (png_sPLT_entryp)png_malloc_warn( png_ptr, new_palette.nentries * png_sizeof(png_sPLT_entry)); if (new_palette.entries == NULL) { png_warning(png_ptr, "sPLT chunk requires too much memory"); return; } #ifndef PNG_NO_POINTER_INDEXING for (i = 0; i < new_palette.nentries; i++) { png_sPLT_entryp pp = new_palette.entries + i; if (new_palette.depth == 8) { pp->red = *entry_start++; pp->green = *entry_start++; pp->blue = *entry_start++; pp->alpha = *entry_start++; } else { pp->red = png_get_uint_16(entry_start); entry_start += 2; pp->green = png_get_uint_16(entry_start); entry_start += 2; pp->blue = png_get_uint_16(entry_start); entry_start += 2; pp->alpha = png_get_uint_16(entry_start); entry_start += 2; } pp->frequency = png_get_uint_16(entry_start); entry_start += 2; } #else pp = new_palette.entries; for (i = 0; i < new_palette.nentries; i++) { if (new_palette.depth == 8) { pp[i].red = *entry_start++; pp[i].green = *entry_start++; pp[i].blue = *entry_start++; pp[i].alpha = *entry_start++; } else { pp[i].red = png_get_uint_16(entry_start); entry_start += 2; pp[i].green = png_get_uint_16(entry_start); entry_start += 2; pp[i].blue = png_get_uint_16(entry_start); entry_start += 2; pp[i].alpha = png_get_uint_16(entry_start); entry_start += 2; } pp->frequency = png_get_uint_16(entry_start); entry_start += 2; } #endif new_palette.name = (png_charp)chunkdata; png_set_sPLT(png_ptr, info_ptr, &new_palette, 1); png_free(png_ptr, chunkdata); png_free(png_ptr, new_palette.entries); }<SPLIT>[2.9938366455468772, 1.8749872736845747, 0.0, 2.9287600467940615, 1.7639604136633742, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, 2.0295292673408736, 2.106651055380808, 2.8931285029922593, 1.2073623883927145, 0.0, 0.0, 0.30852482215402843, 1.9982788507455047, 2.82812012645196, 1.1018802313351121, 0.37651940477529405, 0.6876643500811196, 0.0, 2.890212326771386, 4.4761069615225075, 2.0462512336972813, 0.7828741571570628, 0.4568607580216725, 0.6817979554923368, 0.8945950124817165, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, 2.0288615559433096, 0.04889276383167627, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 2.0227778188254817]
0<SPLIT>static void PNGCBAPI display_error(png_structp pp, png_const_charp error) { struct display *dp = get_dp(pp); display_log(dp, LIBPNG_ERROR, "%s", error); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void modifier_reset(png_modifier *pm) { store_read_reset(&pm->this); pm->limit = 4E-3; pm->pending_len = pm->pending_chunk = 0; pm->flush = pm->buffer_count = pm->buffer_position = 0; pm->modifications = NULL; pm->state = modifier_start; modifier_encoding_iterate(pm); pm->test_uses_encoding = 0; pm->current_gamma = 0; pm->current_encoding = 0; pm->encoding_ignored = 0; pm->bit_depth = pm->colour_type = 0; }<SPLIT>[0.5195604475230265, -0.30663546980669937, 0.0, 0.4942630637605089, -0.36391683908965244, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.21089937656897445, 0.5335543553887203, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, 0.5077564769051636, -0.3558331705191175, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void file_getpos(struct file *file, fpos_t *pos) { if (fgetpos(file->file, pos)) { perror(file->file_name); stop(file, READ_ERROR_CODE, "fgetpos"); } }<SPLIT>[-0.09900860198293619, -0.46089162338689044, 0.0, -0.11436118199787926, -0.5128682467823643, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4306670899435228, -0.09566541730555662, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.11100716297398205, -0.5104391373824448, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void image_transform_png_set_strip_alpha_mod(PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp, PNG_CONST transform_display *display) { if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA) that->colour_type = PNG_COLOR_TYPE_GRAY; else if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA) that->colour_type = PNG_COLOR_TYPE_RGB; that->have_tRNS = 0; that->alphaf = 1; this->next->mod(this->next, that, pp, display); }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void srgb_modification_init(srgb_modification *me, png_modifier *pm, png_byte intent) { modification_init(&me->this); me->this.chunk = CHUNK_sBIT; if (intent <= 3) { me->this.modify_fn = srgb_modify; me->this.add = CHUNK_PLTE; me->intent = intent; } else { me->this.modify_fn = 0; me->this.add = 0; me->intent = 0; } me->this.next = pm->modifications; pm->modifications = &me->this; }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.6586564490689124, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int format_is_initial(format_list *pf) { int i; for (i=0; i<FORMAT_SET_COUNT; ++i) if (pf->bits[i] != 0) return 0; return 1; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5325257040772059, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, 0.417570182313826, -0.5183957526995224, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int check16(png_const_bytep bp, int b) { int i = 16; do if (*bp != b) return 1; while (--i); return 0; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.6586564490689124, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.41601414702345235, -0.6720729196443977, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static void check_param_count(int nparams, int expect) { if (nparams != expect) { fprintf(stderr, "bad parameter count (internal error)\n"); exit(1); } }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void write_png(struct display *dp, png_infop ip, int transforms) { display_clean_write(dp); buffer_start_write(&dp->written_file); dp->operation = "write"; dp->transforms = transforms; dp->write_pp = png_create_write_struct(PNG_LIBPNG_VER_STRING, dp, display_error, display_warning); if (dp->write_pp == NULL) display_log(dp, APP_ERROR, "failed to create write png_struct"); png_set_write_fn(dp->write_pp, &dp->written_file, write_function, NULL); #ifdef PNG_SET_USER_LIMITS_SUPPORTED png_set_user_limits(dp->write_pp, 0x7fffffff, 0x7fffffff); #endif if (transforms & (PNG_TRANSFORM_PACKING|PNG_TRANSFORM_STRIP_FILLER|PNG_TRANSFORM_STRIP_FILLER_BEFORE)) { int ct = dp->color_type; if (transforms & (PNG_TRANSFORM_STRIP_FILLER|PNG_TRANSFORM_STRIP_FILLER_BEFORE)) ct &= ~PNG_COLOR_MASK_ALPHA; png_set_IHDR(dp->write_pp, ip, dp->width, dp->height, dp->bit_depth, ct, dp->interlace_method, dp->compression_method, dp->filter_method); } png_write_png(dp->write_pp, ip, transforms, NULL); display_clean_write(dp); }<SPLIT>[0.8288449722760078, 0.0018768373536828752, 0.0, 0.798575186639703, -0.06601402370422871, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.10876275197582316, 0.6908592985622897, -0.04624602249353125, 0.0, 0.0, 0.30852482215402843, 0.04154322483324156, 0.66244738687495, -0.1128809368767459, 0.24712242304476825, -0.1892664641018488, 0.0, 0.13403667075800713, 0.9973611507722091, -0.2373385487108316, -0.03454968660237938, 0.23107402248845843, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static png_uint_16 ilinear_g22(int fixed_srgb) { return u16d(65535 * g22_to_d[fixed_srgb]); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int image_transform_png_set_expand_add(image_transform *this, PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth) { UNUSED(bit_depth) this->next = *that; *that = this; return (colour_type & PNG_COLOR_MASK_ALPHA) == 0; }<SPLIT>[0.21027592277004517, -0.46089162338689044, 0.0, 0.18995094088131478, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3907093238754231, 0.21894446904158188, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, 0.19837465696559078, -0.5104391373824448, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>PNG_FUNCTION(void, (PNGCBAPI error), (png_structp png_ptr, const char *message), static PNG_NORETURN) { display *d = (display*)png_get_error_ptr(png_ptr); fprintf(stderr, "%s(%s): libpng error: %s\n", d->file, d->test, message); display_exit(d); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int read_one_file(Image *image) { if (!(image->opts & READ_FILE) || (image->opts & USE_STDIO)) { FILE *f = fopen(image->file_name, "rb"); if (f != NULL) { if (image->opts & READ_FILE) image->input_file = f; else { if (fseek(f, 0, SEEK_END) == 0) { long int cb = ftell(f); if (cb > 0 && (unsigned long int)cb < (size_t)~(size_t)0) { png_bytep b = voidcast(png_bytep, malloc((size_t)cb)); if (b != NULL) { rewind(f); if (fread(b, (size_t)cb, 1, f) == 1) { fclose(f); image->input_memory_size = cb; image->input_memory = b; } else { free(b); return logclose(image, f, image->file_name, ": read failed: "); } } else return logclose(image, f, image->file_name, ": out of memory: "); } else if (cb == 0) return logclose(image, f, image->file_name, ": zero length: "); else return logclose(image, f, image->file_name, ": tell failed: "); } else return logclose(image, f, image->file_name, ": seek failed: "); } } else return logerror(image, image->file_name, ": open failed: ", strerror(errno)); } return read_file(image, FORMAT_NO_CHANGE, NULL); }<SPLIT>[-0.09900860198293619, 0.5527916715686512, 0.0, -0.11436118199787926, 0.4659552894840279, 0.0, 0.7963739706959416, 0.8178632553475105, 0.9059316288753189, -0.27925050329511203, 0.48836152962277035, -0.09566541730555662, 0.5919546230485575, 0.0, 0.0, 0.30852482215402843, 0.40964200594544947, -0.11100716297398205, 0.5055429305765636, 0.6353133682363457, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, 0.6193893884051743, 0.5697541257882794, 4.277101146357483, 0.14602883551895066, 0.7958385171580944, 0.8173872120927261, 0.9053924298597907, -0.27935383381430245, 5.1893204262562405, 0.0, 0.791794928969486, 0.8133108086083498, 0.9011791483816026, -0.28182971586402455]
0<SPLIT>png_uint_32 get_value (FILE *pnm_file, int depth) { static png_uint_32 mask = 0; png_byte token[16]; unsigned long ul_ret_value; png_uint_32 ret_value; int i = 0; if (mask == 0) for (i = 0; i < depth; i++) mask = (mask << 1) | 0x01; get_token (pnm_file, (char *) token); sscanf ((const char *) token, "%lu", &ul_ret_value); ret_value = (png_uint_32) ul_ret_value; ret_value &= mask; if (depth < 8) for (i = 0; i < (8 / depth); i++) ret_value = (ret_value << depth) || ret_value; return ret_value; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void perform_error_test(png_modifier *pm) { #ifdef PNG_WARNINGS_SUPPORTED safecat(pm->this.test, sizeof pm->this.test, 0, "error test"); if (!make_errors(pm, 0, 0, WRITE_BDHI)) return; if (!make_errors(pm, 2, 3, WRITE_BDHI)) return; if (!make_errors(pm, 3, 0, 3)) return; if (!make_errors(pm, 4, 3, WRITE_BDHI)) return; if (!make_errors(pm, 6, 3, WRITE_BDHI)) return; #else UNUSED(pm) #endif }<SPLIT>[-0.09900860198293619, -0.24052568970090316, 0.0, -0.11436118199787926, -0.30008052150706166, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, 1.2365069331633587, 1.5771521192305922, -0.4832636022009361, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gpc_sRGB(Pixel *out, const Pixel *in, const Background *back) { (void)back; out->r = isRGB(in->r); if (in->g == in->r) { out->g = out->r; if (in->b == in->r) out->b = out->r; else out->b = isRGB(in->b); } else { out->g = isRGB(in->g); if (in->b == in->r) out->b = out->r; else if (in->b == in->g) out->b = out->g; else out->b = isRGB(in->b); } out->a = 255; }<SPLIT>[-0.25365086435942685, -0.10830612948931077, 0.0, -0.2665172434374763, -0.17240788634188003, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.13098384443277505, -0.25297036047912586, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, -0.26569807294376846, -0.157054070266268, -0.6586564490689124, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static double gamma_component_compose(int do_background, double input_sample, double alpha, double background, int *compose) { switch (do_background) { #ifdef PNG_READ_BACKGROUND_SUPPORTED case PNG_BACKGROUND_GAMMA_SCREEN: case PNG_BACKGROUND_GAMMA_FILE: case PNG_BACKGROUND_GAMMA_UNIQUE: if (alpha < 1) { if (alpha > 0) { input_sample = input_sample * alpha + background * (1-alpha); if (compose != NULL) *compose = 1; } else input_sample = background; } break; #endif #ifdef PNG_READ_ALPHA_MODE_SUPPORTED case ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD: case ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN: case ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED: if (alpha < 1) { if (alpha > 0) { input_sample *= alpha; if (compose != NULL) *compose = 1; } else input_sample = 0; } break; #endif default: UNUSED(alpha) UNUSED(background) UNUSED(compose) break; } return input_sample; }<SPLIT>[1.6020562841584611, 0.39853551798846004, 0.0, 1.559355493837688, 0.31700388179131606, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.5682770617589697, 0.21894446904158188, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, 0.4871364861795985, 0.19837465696559078, -0.4000063039086396, -0.5292594673383866, 0.2491989429896354, 0.0, 4.213176641657808, 2.1569430876889752, -0.3427350002065907, -0.25252937827156396, -0.6720729196443977, -0.21702784222394986, 0.14602883551895066, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, 0.04889276383167627, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gamma_transform_test(png_modifier *pm, PNG_CONST png_byte colour_type, PNG_CONST png_byte bit_depth, PNG_CONST int palette_number, PNG_CONST int interlace_type, PNG_CONST double file_gamma, PNG_CONST double screen_gamma, PNG_CONST png_byte sbit, PNG_CONST int use_input_precision, PNG_CONST int scale16) { size_t pos = 0; char name[64]; if (sbit != bit_depth && sbit != 0) { pos = safecat(name, sizeof name, pos, "sbit("); pos = safecatn(name, sizeof name, pos, sbit); pos = safecat(name, sizeof name, pos, ") "); } else pos = safecat(name, sizeof name, pos, "gamma "); if (scale16) pos = safecat(name, sizeof name, pos, "16to8 "); pos = safecatd(name, sizeof name, pos, file_gamma, 3); pos = safecat(name, sizeof name, pos, "->"); pos = safecatd(name, sizeof name, pos, screen_gamma, 3); gamma_test(pm, colour_type, bit_depth, palette_number, interlace_type, file_gamma, screen_gamma, sbit, 0, name, use_input_precision, scale16, pm->test_gamma_expand16, 0 , 0, 0); }<SPLIT>[-0.25365086435942685, -0.08626953612071205, 0.0, -0.2665172434374763, -0.12985034128681952, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.1110049613987252, -0.25297036047912586, -0.06903890269146298, 0.0, 0.0, 0.30852482215402843, -0.152192975752131, -0.26569807294376846, -0.1128809368767459, 0.6353133682363457, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, 0.01994523631491676, -0.10760608081136262, -0.21702784222394986, 0.14602883551895066, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int find_by_flag(png_uint_32 flag) { int i = NINFO; while (--i >= 0) if (chunk_info[i].flag == flag) return i; fprintf(stderr, "pngunknown: internal error\n"); exit(4); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static png_fixed_point fix(double d) { d = floor(d * PNG_FP_1 + .5); return (png_fixed_point)d; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>void png_handle_sCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length) { png_size_t slength, index; int state; png_debug(1, "in png_handle_sCAL"); if (!(png_ptr->mode & PNG_HAVE_IHDR)) png_error(png_ptr, "Missing IHDR before sCAL"); else if (png_ptr->mode & PNG_HAVE_IDAT) { png_warning(png_ptr, "Invalid sCAL after IDAT"); png_crc_finish(png_ptr, length); return; } else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sCAL)) { png_warning(png_ptr, "Duplicate sCAL chunk"); png_crc_finish(png_ptr, length); return; } png_debug1(2, "Allocating and reading sCAL chunk data (%u bytes)", length + 1); png_ptr->chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1); if (png_ptr->chunkdata == NULL) { png_warning(png_ptr, "Out of memory while processing sCAL chunk"); png_crc_finish(png_ptr, length); return; } slength = (png_size_t)length; png_crc_read(png_ptr, (png_bytep)png_ptr->chunkdata, slength); png_ptr->chunkdata[slength] = 0x00; if (png_crc_finish(png_ptr, 0)) { png_free(png_ptr, png_ptr->chunkdata); png_ptr->chunkdata = NULL; return; } if (png_ptr->chunkdata[0] != 1 && png_ptr->chunkdata[0] != 2) { png_warning(png_ptr, "Invalid sCAL ignored: invalid unit"); png_free(png_ptr, png_ptr->chunkdata); png_ptr->chunkdata = NULL; return; } index = 0; state = 0; if (png_ptr->chunkdata[1] == 45 || !png_check_fp_number(png_ptr->chunkdata, slength, &state, &index) || index >= slength || png_ptr->chunkdata[index++] != 0) png_warning(png_ptr, "Invalid sCAL chunk ignored: bad width format"); else { png_size_t heighti = index; if (png_ptr->chunkdata[index] == 45 || !png_check_fp_number(png_ptr->chunkdata, slength, &state, &index) || index != slength) png_warning(png_ptr, "Invalid sCAL chunk ignored: bad height format"); else png_set_sCAL_s(png_ptr, info_ptr, png_ptr->chunkdata[0], png_ptr->chunkdata+1, png_ptr->chunkdata+heighti); } png_free(png_ptr, png_ptr->chunkdata); png_ptr->chunkdata = NULL; }<SPLIT>[3.148478907923368, 0.7731576052546384, 0.0, 3.0809161082336582, 0.7000217872868608, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, 1.699703585821447, 1.1077069036783158, 3.2077383893393976, 0.8198834250278749, 0.0, 0.0, 0.30852482215402843, 1.0295978478186416, 3.137501946391533, 0.7264085975241742, 0.6353133682363457, 0.6876643500811196, 0.0, -0.08645738172306322, 0.417570182313826, 0.4653044612608955, 0.7828741571570628, 0.4568607580216725, 1.5806237532086234, 0.8010242403613708, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, 1.6991165002636506, 0.04889276383167627, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 1.693548171012695]
0<SPLIT>static void gpc_A(Pixel *out, const Pixel *in, const Background *back) { (void)back; out->r = in->r; out->g = in->g; out->b = in->b; out->a = 65535; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int check(FILE *fp, int argc, const char **argv, png_uint_32p flags, display *d, int set_callback) { int i, npasses, ipass; png_uint_32 height; d->keep = PNG_HANDLE_CHUNK_AS_DEFAULT; d->before_IDAT = 0; d->after_IDAT = 0; d->png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, d, error, warning); if (d->png_ptr == NULL) { fprintf(stderr, "%s(%s): could not allocate png struct\n", d->file, d->test); exit(1); } d->info_ptr = png_create_info_struct(d->png_ptr); d->end_ptr = png_create_info_struct(d->png_ptr); if (d->info_ptr == NULL || d->end_ptr == NULL) { fprintf(stderr, "%s(%s): could not allocate png info\n", d->file, d->test); clean_display(d); exit(1); } png_init_io(d->png_ptr, fp); #ifdef PNG_READ_USER_CHUNKS_SUPPORTED if (set_callback) png_set_read_user_chunk_fn(d->png_ptr, d, read_callback); #else UNUSED(set_callback) #endif for (i=0; i<argc; ++i) { const char *equals = strchr(argv[i], '='); if (equals != NULL) { int chunk, option; if (strcmp(equals+1, "default") == 0) option = PNG_HANDLE_CHUNK_AS_DEFAULT; else if (strcmp(equals+1, "discard") == 0) option = PNG_HANDLE_CHUNK_NEVER; else if (strcmp(equals+1, "if-safe") == 0) option = PNG_HANDLE_CHUNK_IF_SAFE; else if (strcmp(equals+1, "save") == 0) option = PNG_HANDLE_CHUNK_ALWAYS; else { fprintf(stderr, "%s(%s): %s: unrecognized chunk option\n", d->file, d->test, argv[i]); display_exit(d); } switch (equals - argv[i]) { case 4: chunk = find(argv[i]); if (chunk >= 0) { png_byte name[5]; memcpy(name, chunk_info[chunk].name, 5); png_set_keep_unknown_chunks(d->png_ptr, option, name, 1); chunk_info[chunk].keep = option; continue; } break; case 7: if (memcmp(argv[i], "default", 7) == 0) { png_set_keep_unknown_chunks(d->png_ptr, option, NULL, 0); d->keep = option; continue; } break; case 3: if (memcmp(argv[i], "all", 3) == 0) { png_set_keep_unknown_chunks(d->png_ptr, option, NULL, -1); d->keep = option; for (chunk = 0; chunk < NINFO; ++chunk) if (chunk_info[chunk].all) chunk_info[chunk].keep = option; continue; } break; default: break; } } fprintf(stderr, "%s(%s): %s: unrecognized chunk argument\n", d->file, d->test, argv[i]); display_exit(d); } png_read_info(d->png_ptr, d->info_ptr); switch (png_get_interlace_type(d->png_ptr, d->info_ptr)) { case PNG_INTERLACE_NONE: npasses = 1; break; case PNG_INTERLACE_ADAM7: npasses = PNG_INTERLACE_ADAM7_PASSES; break; default: fprintf(stderr, "%s(%s): invalid interlace type\n", d->file, d->test); clean_display(d); exit(1); } if (chunk_info[0].keep == PNG_HANDLE_CHUNK_AS_DEFAULT) { png_start_read_image(d->png_ptr); height = png_get_image_height(d->png_ptr, d->info_ptr); if (npasses > 1) { png_uint_32 width = png_get_image_width(d->png_ptr, d->info_ptr); for (ipass=0; ipass<npasses; ++ipass) { png_uint_32 wPass = PNG_PASS_COLS(width, ipass); if (wPass > 0) { png_uint_32 y; for (y=0; y<height; ++y) if (PNG_ROW_IN_INTERLACE_PASS(y, ipass)) png_read_row(d->png_ptr, NULL, NULL); } } } else { png_uint_32 y; for (y=0; y<height; ++y) png_read_row(d->png_ptr, NULL, NULL); } } png_read_end(d->png_ptr, d->end_ptr); flags[0] = get_valid(d, d->info_ptr); flags[1] = get_unknown(d, d->info_ptr, 0); flags[chunk_info[0].keep != PNG_HANDLE_CHUNK_AS_DEFAULT] |= PNG_INFO_IDAT; flags[2] = get_valid(d, d->end_ptr); flags[3] = get_unknown(d, d->end_ptr, 1); clean_display(d); return d->keep; }<SPLIT>[2.9938366455468772, 2.4699752946367406, 0.0, 2.9287600467940615, 2.317208499379161, 0.0, 2.7080995773766072, 2.4085531756423553, 2.564351494385993, 3.0190063118991532, 2.6261020142661042, 2.5785186166451206, 2.4609707992789605, 0.0, 0.0, 0.30852482215402843, 2.482619352208936, 2.5187383065123874, 2.3166413995469703, 2.5762680941942326, 2.8799913855385406, 0.0, 0.4647777494796126, 1.5771521192305922, 1.9759869327001087, 3.0171659967662046, 2.4889413778205984, 3.3782753486411963, 2.766010454888631, 2.7070745834150265, 2.4077474138188704, 2.5634043602755, 3.018096722982286, 2.6191065950439585, 0.0, 2.7006212137290357, 2.4016960724561396, 2.556998178984592, 3.0104667622638415]
0<SPLIT>static void image_pixel_setf(image_pixel *this, unsigned int max) { this->redf = this->red / (double)max; this->greenf = this->green / (double)max; this->bluef = this->blue / (double)max; this->alphaf = this->alpha / (double)max; if (this->red < max) this->rede = this->redf * DBL_EPSILON; else this->rede = 0; if (this->green < max) this->greene = this->greenf * DBL_EPSILON; else this->greene = 0; if (this->blue < max) this->bluee = this->bluef * DBL_EPSILON; else this->bluee = 0; if (this->alpha < max) this->alphae = this->alphaf * DBL_EPSILON; else this->alphae = 0; }<SPLIT>[-0.25365086435942685, -0.13034272285790952, 0.0, -0.2665172434374763, -0.1936866588694103, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.1509627274668249, -0.25297036047912586, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.21031383592774278, -0.26569807294376846, -0.17914063696102905, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>png_charp png_decompress_chunk(png_structp png_ptr, int comp_type, png_charp chunkdata, png_size_t chunklength, png_size_t prefix_size, png_size_t *newlength) { static char msg[] = "Error decoding compressed text"; png_charp text; png_size_t text_size; if (comp_type == PNG_COMPRESSION_TYPE_BASE) { int ret = Z_OK; png_ptr->zstream.next_in = (png_bytep)(chunkdata + prefix_size); png_ptr->zstream.avail_in = (uInt)(chunklength - prefix_size); png_ptr->zstream.next_out = png_ptr->zbuf; png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size; text_size = 0; text = NULL; while (png_ptr->zstream.avail_in) { ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH); if (ret != Z_OK && ret != Z_STREAM_END) { if (png_ptr->zstream.msg != NULL) png_warning(png_ptr, png_ptr->zstream.msg); else png_warning(png_ptr, msg); inflateReset(&png_ptr->zstream); png_ptr->zstream.avail_in = 0; if (text == NULL) { text_size = prefix_size + png_sizeof(msg) + 1; text = (png_charp)png_malloc_warn(png_ptr, text_size); if (text == NULL) { png_free(png_ptr,chunkdata); png_error(png_ptr,"Not enough memory to decompress chunk"); } png_memcpy(text, chunkdata, prefix_size); } text[text_size - 1] = 0x00; text_size = (png_size_t)(chunklength - (text - chunkdata) - 1); text_size = png_sizeof(msg) > text_size ? text_size : png_sizeof(msg); png_memcpy(text + prefix_size, msg, text_size + 1); break; } if (!png_ptr->zstream.avail_out || ret == Z_STREAM_END) { if (text == NULL) { text_size = prefix_size + png_ptr->zbuf_size - png_ptr->zstream.avail_out; text = (png_charp)png_malloc_warn(png_ptr, text_size + 1); if (text == NULL) { png_free(png_ptr,chunkdata); png_error(png_ptr,"Not enough memory to decompress chunk."); } png_memcpy(text + prefix_size, png_ptr->zbuf, text_size - prefix_size); png_memcpy(text, chunkdata, prefix_size); *(text + text_size) = 0x00; } else { png_charp tmp; tmp = text; text = (png_charp)png_malloc_warn(png_ptr, (png_uint_32)(text_size + png_ptr->zbuf_size - png_ptr->zstream.avail_out + 1)); if (text == NULL) { png_free(png_ptr, tmp); png_free(png_ptr, chunkdata); png_error(png_ptr,"Not enough memory to decompress chunk.."); } png_memcpy(text, tmp, text_size); png_free(png_ptr, tmp); png_memcpy(text + text_size, png_ptr->zbuf, (png_ptr->zbuf_size - png_ptr->zstream.avail_out)); text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out; *(text + text_size) = 0x00; } if (ret == Z_STREAM_END) break; else { png_ptr->zstream.next_out = png_ptr->zbuf; png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size; } } } if (ret != Z_STREAM_END) { #if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE) char umsg[50]; if (ret == Z_BUF_ERROR) sprintf(umsg,"Buffer error in compressed datastream in %s chunk", png_ptr->chunk_name); else if (ret == Z_DATA_ERROR) sprintf(umsg,"Data error in compressed datastream in %s chunk", png_ptr->chunk_name); else sprintf(umsg,"Incomplete compressed datastream in %s chunk", png_ptr->chunk_name); png_warning(png_ptr, umsg); #else png_warning(png_ptr, "Incomplete compressed datastream in chunk other than IDAT"); #endif text_size=prefix_size; if (text == NULL) { text = (png_charp)png_malloc_warn(png_ptr, text_size+1); if (text == NULL) { png_free(png_ptr, chunkdata); png_error(png_ptr,"Not enough memory for text."); } png_memcpy(text, chunkdata, prefix_size); } *(text + text_size) = 0x00; } inflateReset(&png_ptr->zstream); png_ptr->zstream.avail_in = 0; png_free(png_ptr, chunkdata); chunkdata = text; *newlength=text_size; } else { #if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE) char umsg[50]; sprintf(umsg, "Unknown zTXt compression type %d", comp_type); png_warning(png_ptr, umsg); #else png_warning(png_ptr, "Unknown zTXt compression type"); #endif *(chunkdata + prefix_size) = 0x00; *newlength=prefix_size; } return chunkdata; }<SPLIT>[1.9113408089114425, 2.4920118880053392, 0.0, 1.863667616716882, 2.338487271906691, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 2.506228716061805, 1.9492988439508436, 2.392592158685165, 0.0, 0.0, 0.30852482215402843, 2.3663776318577128, 1.8999746666332415, 2.250381699462687, 0.7647103499668715, 0.13958259121676436, 0.0, 0.24428369699854227, 3.3165250246057414, 1.7651940297085906, 0.23792492798410134, 0.5697541257882794, -0.21702784222394986, -0.04111270872174079, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 2.6191065950439585, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>int main(void) { fprintf(stderr, "pngimage: no support for png_read/write_image\n"); return 77; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
