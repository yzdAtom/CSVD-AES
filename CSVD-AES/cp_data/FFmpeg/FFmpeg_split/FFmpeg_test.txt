0<SPLIT>static int config_props(AVFilterLink *inlink) { HueContext *hue = inlink->dst->priv; const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format); hue->hsub = desc->log2_chroma_w; hue->vsub = desc->log2_chroma_h; hue->var_values[VAR_N] = 0; hue->var_values[VAR_TB] = av_q2d(inlink->time_base); hue->var_values[VAR_R] = inlink->frame_rate.num == 0 || inlink->frame_rate.den == 0 ? NAN : av_q2d(inlink->frame_rate); return 0; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void gradfun_filter_line_mmxext(uint8_t *dst, const uint8_t *src, const uint16_t *dc, int width, int thresh, const uint16_t *dithers) { intptr_t x; if (width & 3) { x = width & ~3; ff_gradfun_filter_line_c(dst + x, src + x, dc + x / 2, width - x, thresh, dithers); width = x; } x = -width; ff_gradfun_filter_line_mmxext(x, dst + width, src + width, dc + width / 2, thresh, dithers); }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void RENAME(yuv2rgb32_X_ar)(SwsContext *c, const int16_t *lumFilter, const int16_t **lumSrc, int lumFilterSize, const int16_t *chrFilter, const int16_t **chrUSrc, const int16_t **chrVSrc, int chrFilterSize, const int16_t **alpSrc, uint8_t *dest, int dstW, int dstY) { x86_reg dummy=0; x86_reg dstW_reg = dstW; x86_reg uv_off = c->uv_offx2; if (CONFIG_SWSCALE_ALPHA && c->alpPixBuf) { YSCALEYUV2PACKEDX_ACCURATE YSCALEYUV2RGBX "movq %%mm2, "U_TEMP"(%0) \n\t" "movq %%mm4, "V_TEMP"(%0) \n\t" "movq %%mm5, "Y_TEMP"(%0) \n\t" YSCALEYUV2PACKEDX_ACCURATE_YA(ALP_MMX_FILTER_OFFSET) "movq "Y_TEMP"(%0), %%mm5 \n\t" "psraw $3, %%mm1 \n\t" "psraw $3, %%mm7 \n\t" "packuswb %%mm7, %%mm1 \n\t" WRITEBGR32(%4, "%5", %%REGa, %%mm3, %%mm4, %%mm5, %%mm1, %%mm0, %%mm7, %%mm2, %%mm6) YSCALEYUV2PACKEDX_END } else { YSCALEYUV2PACKEDX_ACCURATE YSCALEYUV2RGBX "pcmpeqd %%mm7, %%mm7 \n\t" WRITEBGR32(%4, "%5", %%REGa, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6) YSCALEYUV2PACKEDX_END } }<SPLIT>[-0.25365086435942685, 0.023913430722281605, 0.0, -0.2665172434374763, -0.044735251176698444, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.011110546228475942, -0.25297036047912586, 0.04492549829819571, 0.0, 0.0, 0.30852482215402843, -0.07469849551798198, -0.26569807294376846, -0.024534670097701678, -0.7880534307994381, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static inline void rgb16to15_c(const uint8_t *src, uint8_t *dst, int src_size) { register uint8_t *d = dst; register const uint8_t *s = src; register const uint8_t *end = s + src_size; const uint8_t *mm_end = end - 3; while (s < mm_end) { register uint32_t x = *((const uint32_t *)s); *((uint32_t *)d) = ((x >> 1) & 0x7FE07FE0) | (x & 0x001F001F); s += 4; d += 4; } if (s < end) { register uint16_t x = *((const uint16_t *)s); *((uint16_t *)d) = ((x >> 1) & 0x7FE0) | (x & 0x001F); } }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.011671540416283347, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.3070243011888601, -0.10760608081136262, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int parse_MP4ODescrTag(MP4DescrParseContext *d, int64_t off, int len) { int id_flags; if (len < 2) return 0; id_flags = avio_rb16(&d->pb); if (!(id_flags & 0x0020)) { update_offsets(&d->pb, &off, &len); return parse_mp4_descr_arr(d, off, len); } else { return 0; } }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.270465503877335, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.25252937827156396, -0.3333928163445767, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static void update_volume(ChanParam *cp, double in) { double delta = in - cp->volume; if (delta > 0.0) cp->volume += delta * cp->attack; else cp->volume += delta * cp->decay; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, AVFrame *picture) { int compno, reslevelno, bandno; int x, y; uint8_t *line; Jpeg2000T1Context t1; for (compno = 0; compno < s->ncomponents; compno++) { Jpeg2000Component *comp = tile->comp + compno; Jpeg2000CodingStyle *codsty = tile->codsty + compno; for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) { Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno; for (bandno = 0; bandno < rlevel->nbands; bandno++) { int nb_precincts, precno; Jpeg2000Band *band = rlevel->band + bandno; int cblkno = 0, bandpos; bandpos = bandno + (reslevelno > 0); if (band->coord[0][0] == band->coord[0][1] || band->coord[1][0] == band->coord[1][1]) continue; nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y; for (precno = 0; precno < nb_precincts; precno++) { Jpeg2000Prec *prec = band->prec + precno; for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) { int x, y; Jpeg2000Cblk *cblk = prec->cblk + cblkno; decode_cblk(s, codsty, &t1, cblk, cblk->coord[0][1] - cblk->coord[0][0], cblk->coord[1][1] - cblk->coord[1][0], bandpos); x = cblk->coord[0][0]; y = cblk->coord[1][0]; if (codsty->transform == FF_DWT97) dequantization_float(x, y, cblk, comp, &t1, band); else dequantization_int(x, y, cblk, comp, &t1, band); } } } } ff_dwt_decode(&comp->dwt, codsty->transform == FF_DWT97 ? (void*)comp->f_data : (void*)comp->i_data); } if (tile->codsty[0].mct) mct_decode(s, tile); if (s->cdef[0] < 0) { for (x = 0; x < s->ncomponents; x++) s->cdef[x] = x + 1; if ((s->ncomponents & 1) == 0) s->cdef[s->ncomponents-1] = 0; } if (s->precision <= 8) { for (compno = 0; compno < s->ncomponents; compno++) { Jpeg2000Component *comp = tile->comp + compno; Jpeg2000CodingStyle *codsty = tile->codsty + compno; float *datap = comp->f_data; int32_t *i_datap = comp->i_data; int cbps = s->cbps[compno]; int w = tile->comp[compno].coord[0][1] - s->image_offset_x; int planar = !!picture->data[2]; int pixelsize = planar ? 1 : s->ncomponents; int plane = 0; if (planar) plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1); y = tile->comp[compno].coord[1][0] - s->image_offset_y; line = picture->data[plane] + y * picture->linesize[plane]; for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) { uint8_t *dst; x = tile->comp[compno].coord[0][0] - s->image_offset_x; dst = line + x * pixelsize + compno*!planar; if (codsty->transform == FF_DWT97) { for (; x < w; x += s->cdx[compno]) { int val = lrintf(*datap) + (1 << (cbps - 1)); val = av_clip(val, 0, (1 << cbps) - 1); *dst = val << (8 - cbps); datap++; dst += pixelsize; } } else { for (; x < w; x += s->cdx[compno]) { int val = *i_datap + (1 << (cbps - 1)); val = av_clip(val, 0, (1 << cbps) - 1); *dst = val << (8 - cbps); i_datap++; dst += pixelsize; } } line += picture->linesize[plane]; } } } else { for (compno = 0; compno < s->ncomponents; compno++) { Jpeg2000Component *comp = tile->comp + compno; Jpeg2000CodingStyle *codsty = tile->codsty + compno; float *datap = comp->f_data; int32_t *i_datap = comp->i_data; uint16_t *linel; int cbps = s->cbps[compno]; int w = tile->comp[compno].coord[0][1] - s->image_offset_x; int planar = !!picture->data[2]; int pixelsize = planar ? 1 : s->ncomponents; int plane = 0; if (planar) plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1); y = tile->comp[compno].coord[1][0] - s->image_offset_y; linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1); for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) { uint16_t *dst; x = tile->comp[compno].coord[0][0] - s->image_offset_x; dst = linel + (x * pixelsize + compno*!planar); if (codsty->transform == FF_DWT97) { for (; x < w; x += s-> cdx[compno]) { int val = lrintf(*datap) + (1 << (cbps - 1)); val = av_clip(val, 0, (1 << cbps) - 1); *dst = val << (16 - cbps); datap++; dst += pixelsize; } } else { for (; x < w; x += s-> cdx[compno]) { int val = *i_datap + (1 << (cbps - 1)); val = av_clip(val, 0, (1 << cbps) - 1); *dst = val << (16 - cbps); i_datap++; dst += pixelsize; } } linel += picture->linesize[plane] >> 1; } } } return 0; }<SPLIT>[5.158828318817746, 2.2496093609507533, 0.0, 5.05894490694842, 2.1044207741038585, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 2.706017546402304, 5.252702650595798, 2.3470063982893015, 0.0, 0.0, 0.30852482215402843, 2.560113832443085, 5.1484837759987565, 2.206208566073165, 2.8350620576552843, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 3.065083598156286, 1.327823386330024, 3.053408216653634, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>int av_frame_is_writable(AVFrame *frame) { int i, ret = 1; if (!frame->buf[0]) return 0; for (i = 0; i < FF_ARRAY_ELEMS(frame->buf); i++) if (frame->buf[i]) ret &= !!av_buffer_is_writable(frame->buf[i]); for (i = 0; i < frame->nb_extended_buf; i++) ret &= !!av_buffer_is_writable(frame->extended_buf[i]); return ret; }<SPLIT>[-0.09900860198293619, -0.3947818432810943, 0.0, -0.11436118199787926, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.37073044084137324, -0.09566541730555662, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.11100716297398205, -0.44417943729816173, -0.39986248560786075, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.3070243011888601, -0.3333928163445767, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void lumRangeToJpeg16_c(int16_t *_dst, int width) { int i; int32_t *dst = (int32_t *) _dst; for (i = 0; i < width; i++) { dst[i] = ((int)(FFMIN(dst[i], 30189 << 4) * 4769U - (39057361 << 2))) >> 12; } }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void show_codec_opts(void) { AVCodec *c = NULL; printf("@section Generic codec AVOptions\n"); show_opts(avcodec_get_class()); printf("@section Codec-specific AVOptions\n"); while ((c = av_codec_next(c))) { if (!c->priv_class) continue; printf("@subsection %s AVOptions\n", c->priv_class->class_name); show_opts(c->priv_class); } }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.39986248560786075, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.3070243011888601, -0.3333928163445767, -0.21702784222394986, -0.22825425296243224, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int is_device(const AVClass *avclass) { if (!avclass) return 0; return AV_IS_INPUT_DEVICE(avclass->category) || AV_IS_OUTPUT_DEVICE(avclass->category); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>AVStereo3D *av_stereo3d_create_side_data(AVFrame *frame) { AVFrameSideData *side_data = av_frame_new_side_data(frame, AV_FRAME_DATA_STEREO3D, sizeof(AVStereo3D)); if (!side_data) return NULL; memset(side_data->data, 0, sizeof(AVStereo3D)); return (AVStereo3D *)side_data->data; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void ff_aac_search_for_tns(AACEncContext *s, SingleChannelElement *sce) { TemporalNoiseShaping *tns = &sce->tns; int w, w2, g, count = 0; const int mmm = FFMIN(sce->ics.tns_max_bands, sce->ics.max_sfb); const int is8 = sce->ics.window_sequence[0] == EIGHT_SHORT_SEQUENCE; const int order = is8 ? 7 : s->profile == FF_PROFILE_AAC_LOW ? 12 : TNS_MAX_ORDER; int sfb_start = av_clip(tns_min_sfb[is8][s->samplerate_index], 0, mmm); int sfb_end = av_clip(sce->ics.num_swb, 0, mmm); for (w = 0; w < sce->ics.num_windows; w++) { float e_ratio = 0.0f, threshold = 0.0f, spread = 0.0f, en[2] = {0.0, 0.0f}; double gain = 0.0f, coefs[MAX_LPC_ORDER] = {0}; int coef_start = w*sce->ics.num_swb + sce->ics.swb_offset[sfb_start]; int coef_len = sce->ics.swb_offset[sfb_end] - sce->ics.swb_offset[sfb_start]; for (g = 0; g < sce->ics.num_swb; g++) { if (w*16+g < sfb_start || w*16+g > sfb_end) continue; for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) { FFPsyBand *band = &s->psy.ch[s->cur_channel].psy_bands[(w+w2)*16+g]; if ((w+w2)*16+g > sfb_start + ((sfb_end - sfb_start)/2)) en[1] += band->energy; else en[0] += band->energy; threshold += band->threshold; spread += band->spread; } } if (coef_len <= 0 || (sfb_end - sfb_start) <= 0) continue; else e_ratio = en[0]/en[1]; gain = ff_lpc_calc_ref_coefs_f(&s->lpc, &sce->coeffs[coef_start], coef_len, order, coefs); if (gain > TNS_GAIN_THRESHOLD_LOW && gain < TNS_GAIN_THRESHOLD_HIGH && (en[0]+en[1]) > TNS_GAIN_THRESHOLD_LOW*threshold && spread < TNS_SPREAD_THRESHOLD && order) { if (is8 || order < 2 || (e_ratio > TNS_E_RATIO_LOW && e_ratio < TNS_E_RATIO_HIGH)) { tns->n_filt[w] = 1; for (g = 0; g < tns->n_filt[w]; g++) { tns->length[w][g] = sfb_end - sfb_start; tns->direction[w][g] = en[0] < en[1]; tns->order[w][g] = order; quantize_coefs(coefs, tns->coef_idx[w][g], tns->coef[w][g], order); } } else { tns->n_filt[w] = 2; for (g = 0; g < tns->n_filt[w]; g++) { tns->direction[w][g] = en[g] < en[!g]; tns->order[w][g] = !g ? order/2 : order - tns->order[w][g-1]; tns->length[w][g] = !g ? (sfb_end - sfb_start)/2 : \ (sfb_end - sfb_start) - tns->length[w][g-1]; quantize_coefs(&coefs[!g ? 0 : order - tns->order[w][g-1]], tns->coef_idx[w][g], tns->coef[w][g], tns->order[w][g]); } } count++; } } sce->tns.present = !!count; }<SPLIT>[-0.09900860198293619, 0.7070478251488422, 0.0, -0.11436118199787926, 0.6149066971767397, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.6282137108611193, -0.09566541730555662, 0.7515047844340796, 0.0, 0.0, 0.30852482215402843, 0.5452573463552103, -0.11100716297398205, 0.660148897439891, 0.7647103499668715, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.7814938157481727, 0.40140969673598975, 1.4729010679211356, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>static char *shorts2str(int16_t *sp, int count, const char *sep) { int i; char *ap, *ap0; if (!sep) sep = ", "; ap = av_malloc((5 + strlen(sep)) * count); if (!ap) return NULL; ap0 = ap; ap[0] = '\0'; for (i = 0; i < count; i++) { int l = snprintf(ap, 5 + strlen(sep), "%d%s", sp[i], sep); ap += l; } ap0[strlen(ap0) - strlen(sep)] = '\0'; return ap0; }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.270465503877335, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, 0.29241985090139744, 0.005287286955244392, -0.21702784222394986, 0.5203119240003335, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int vfw_read_packet(AVFormatContext *s, AVPacket *pkt) { struct vfw_ctx *ctx = s->priv_data; AVPacketList *pktl = NULL; while(!pktl) { WaitForSingleObject(ctx->mutex, INFINITE); pktl = ctx->pktl; if(ctx->pktl) { *pkt = ctx->pktl->pkt; ctx->pktl = ctx->pktl->next; av_free(pktl); } ResetEvent(ctx->event); ReleaseMutex(ctx->mutex); if(!pktl) { if(s->flags & AVFMT_FLAG_NONBLOCK) { return AVERROR(EAGAIN); } else { WaitForSingleObject(ctx->event, INFINITE); } } } ctx->curbufsize -= pkt->size; return pkt->size; }<SPLIT>[-0.25365086435942685, -0.10830612948931077, 0.0, -0.2665172434374763, -0.17240788634188003, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.13098384443277505, -0.25297036047912586, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, -0.26569807294376846, -0.157054070266268, -0.011671540416283347, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.3070243011888601, 0.005287286955244392, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int read_thread(void *arg) { VideoState *is = arg; AVFormatContext *ic = NULL; int err, i, ret; int st_index[AVMEDIA_TYPE_NB]; AVPacket pkt1, *pkt = &pkt1; int64_t stream_start_time; int pkt_in_play_range = 0; AVDictionaryEntry *t; AVDictionary **opts; int orig_nb_streams; SDL_mutex *wait_mutex = SDL_CreateMutex(); int scan_all_pmts_set = 0; int64_t pkt_ts; if (!wait_mutex) { av_log(NULL, AV_LOG_FATAL, "SDL_CreateMutex(): %s\n", SDL_GetError()); ret = AVERROR(ENOMEM); goto fail; } memset(st_index, -1, sizeof(st_index)); is->last_video_stream = is->video_stream = -1; is->last_audio_stream = is->audio_stream = -1; is->last_subtitle_stream = is->subtitle_stream = -1; is->eof = 0; ic = avformat_alloc_context(); if (!ic) { av_log(NULL, AV_LOG_FATAL, "Could not allocate context.\n"); ret = AVERROR(ENOMEM); goto fail; } ic->interrupt_callback.callback = decode_interrupt_cb; ic->interrupt_callback.opaque = is; if (!av_dict_get(format_opts, "scan_all_pmts", NULL, AV_DICT_MATCH_CASE)) { av_dict_set(&format_opts, "scan_all_pmts", "1", AV_DICT_DONT_OVERWRITE); scan_all_pmts_set = 1; } err = avformat_open_input(&ic, is->filename, is->iformat, &format_opts); if (err < 0) { print_error(is->filename, err); ret = -1; goto fail; } if (scan_all_pmts_set) av_dict_set(&format_opts, "scan_all_pmts", NULL, AV_DICT_MATCH_CASE); if ((t = av_dict_get(format_opts, "", NULL, AV_DICT_IGNORE_SUFFIX))) { av_log(NULL, AV_LOG_ERROR, "Option %s not found.\n", t->key); ret = AVERROR_OPTION_NOT_FOUND; goto fail; } is->ic = ic; if (genpts) ic->flags |= AVFMT_FLAG_GENPTS; av_format_inject_global_side_data(ic); opts = setup_find_stream_info_opts(ic, codec_opts); orig_nb_streams = ic->nb_streams; err = avformat_find_stream_info(ic, opts); for (i = 0; i < orig_nb_streams; i++) av_dict_free(&opts[i]); av_freep(&opts); if (err < 0) { av_log(NULL, AV_LOG_WARNING, "%s: could not find codec parameters\n", is->filename); ret = -1; goto fail; } if (ic->pb) ic->pb->eof_reached = 0; if (seek_by_bytes < 0) seek_by_bytes = !!(ic->iformat->flags & AVFMT_TS_DISCONT) && strcmp("ogg", ic->iformat->name); is->max_frame_duration = (ic->iformat->flags & AVFMT_TS_DISCONT) ? 10.0 : 3600.0; if (!window_title && (t = av_dict_get(ic->metadata, "title", NULL, 0))) window_title = av_asprintf("%s - %s", t->value, input_filename); if (start_time != AV_NOPTS_VALUE) { int64_t timestamp; timestamp = start_time; if (ic->start_time != AV_NOPTS_VALUE) timestamp += ic->start_time; ret = avformat_seek_file(ic, -1, INT64_MIN, timestamp, INT64_MAX, 0); if (ret < 0) { av_log(NULL, AV_LOG_WARNING, "%s: could not seek to position %0.3f\n", is->filename, (double)timestamp / AV_TIME_BASE); } } is->realtime = is_realtime(ic); if (show_status) av_dump_format(ic, 0, is->filename, 0); for (i = 0; i < ic->nb_streams; i++) { AVStream *st = ic->streams[i]; enum AVMediaType type = st->codecpar->codec_type; st->discard = AVDISCARD_ALL; if (type >= 0 && wanted_stream_spec[type] && st_index[type] == -1) if (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) > 0) st_index[type] = i; } for (i = 0; i < AVMEDIA_TYPE_NB; i++) { if (wanted_stream_spec[i] && st_index[i] == -1) { av_log(NULL, AV_LOG_ERROR, "Stream specifier %s does not match any %s stream\n", wanted_stream_spec[i], av_get_media_type_string(i)); st_index[i] = INT_MAX; } } if (!video_disable) st_index[AVMEDIA_TYPE_VIDEO] = av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO, st_index[AVMEDIA_TYPE_VIDEO], -1, NULL, 0); if (!audio_disable) st_index[AVMEDIA_TYPE_AUDIO] = av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO, st_index[AVMEDIA_TYPE_AUDIO], st_index[AVMEDIA_TYPE_VIDEO], NULL, 0); if (!video_disable && !subtitle_disable) st_index[AVMEDIA_TYPE_SUBTITLE] = av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE, st_index[AVMEDIA_TYPE_SUBTITLE], (st_index[AVMEDIA_TYPE_AUDIO] >= 0 ? st_index[AVMEDIA_TYPE_AUDIO] : st_index[AVMEDIA_TYPE_VIDEO]), NULL, 0); is->show_mode = show_mode; if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) { AVStream *st = ic->streams[st_index[AVMEDIA_TYPE_VIDEO]]; AVCodecParameters *codecpar = st->codecpar; AVRational sar = av_guess_sample_aspect_ratio(ic, st, NULL); if (codecpar->width) set_default_window_size(codecpar->width, codecpar->height, sar); } if (st_index[AVMEDIA_TYPE_AUDIO] >= 0) { stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]); } ret = -1; if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) { ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]); } if (is->show_mode == SHOW_MODE_NONE) is->show_mode = ret >= 0 ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT; if (st_index[AVMEDIA_TYPE_SUBTITLE] >= 0) { stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]); } if (is->video_stream < 0 && is->audio_stream < 0) { av_log(NULL, AV_LOG_FATAL, "Failed to open file '%s' or configure filtergraph\n", is->filename); ret = -1; goto fail; } if (infinite_buffer < 0 && is->realtime) infinite_buffer = 1; for (;;) { if (is->abort_request) break; if (is->paused != is->last_paused) { is->last_paused = is->paused; if (is->paused) is->read_pause_return = av_read_pause(ic); else av_read_play(ic); } #if CONFIG_RTSP_DEMUXER || CONFIG_MMSH_PROTOCOL if (is->paused && (!strcmp(ic->iformat->name, "rtsp") || (ic->pb && !strncmp(input_filename, "mmsh:", 5)))) { SDL_Delay(10); continue; } #endif if (is->seek_req) { int64_t seek_target = is->seek_pos; int64_t seek_min = is->seek_rel > 0 ? seek_target - is->seek_rel + 2: INT64_MIN; int64_t seek_max = is->seek_rel < 0 ? seek_target - is->seek_rel - 2: INT64_MAX; ret = avformat_seek_file(is->ic, -1, seek_min, seek_target, seek_max, is->seek_flags); if (ret < 0) { av_log(NULL, AV_LOG_ERROR, "%s: error while seeking\n", is->ic->filename); } else { if (is->audio_stream >= 0) { packet_queue_flush(&is->audioq); packet_queue_put(&is->audioq, &flush_pkt); } if (is->subtitle_stream >= 0) { packet_queue_flush(&is->subtitleq); packet_queue_put(&is->subtitleq, &flush_pkt); } if (is->video_stream >= 0) { packet_queue_flush(&is->videoq); packet_queue_put(&is->videoq, &flush_pkt); } if (is->seek_flags & AVSEEK_FLAG_BYTE) { set_clock(&is->extclk, NAN, 0); } else { set_clock(&is->extclk, seek_target / (double)AV_TIME_BASE, 0); } } is->seek_req = 0; is->queue_attachments_req = 1; is->eof = 0; if (is->paused) step_to_next_frame(is); } if (is->queue_attachments_req) { if (is->video_st && is->video_st->disposition & AV_DISPOSITION_ATTACHED_PIC) { AVPacket copy; if ((ret = av_copy_packet(&copy, &is->video_st->attached_pic)) < 0) goto fail; packet_queue_put(&is->videoq, &copy); packet_queue_put_nullpacket(&is->videoq, is->video_stream); } is->queue_attachments_req = 0; } if (infinite_buffer<1 && (is->audioq.size + is->videoq.size + is->subtitleq.size > MAX_QUEUE_SIZE || (stream_has_enough_packets(is->audio_st, is->audio_stream, &is->audioq) && stream_has_enough_packets(is->video_st, is->video_stream, &is->videoq) && stream_has_enough_packets(is->subtitle_st, is->subtitle_stream, &is->subtitleq)))) { SDL_LockMutex(wait_mutex); SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10); SDL_UnlockMutex(wait_mutex); continue; } if (!is->paused && (!is->audio_st || (is->auddec.finished == is->audioq.serial && frame_queue_nb_remaining(&is->sampq) == 0)) && (!is->video_st || (is->viddec.finished == is->videoq.serial && frame_queue_nb_remaining(&is->pictq) == 0))) { if (loop != 1 && (!loop || --loop)) { stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0); } else if (autoexit) { ret = AVERROR_EOF; goto fail; } } ret = av_read_frame(ic, pkt); if (ret < 0) { if ((ret == AVERROR_EOF || avio_feof(ic->pb)) && !is->eof) { if (is->video_stream >= 0) packet_queue_put_nullpacket(&is->videoq, is->video_stream); if (is->audio_stream >= 0) packet_queue_put_nullpacket(&is->audioq, is->audio_stream); if (is->subtitle_stream >= 0) packet_queue_put_nullpacket(&is->subtitleq, is->subtitle_stream); is->eof = 1; } if (ic->pb && ic->pb->error) break; SDL_LockMutex(wait_mutex); SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10); SDL_UnlockMutex(wait_mutex); continue; } else { is->eof = 0; } stream_start_time = ic->streams[pkt->stream_index]->start_time; pkt_ts = pkt->pts == AV_NOPTS_VALUE ? pkt->dts : pkt->pts; pkt_in_play_range = duration == AV_NOPTS_VALUE || (pkt_ts - (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : 0)) * av_q2d(ic->streams[pkt->stream_index]->time_base) - (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000 <= ((double)duration / 1000000); if (pkt->stream_index == is->audio_stream && pkt_in_play_range) { packet_queue_put(&is->audioq, pkt); } else if (pkt->stream_index == is->video_stream && pkt_in_play_range && !(is->video_st->disposition & AV_DISPOSITION_ATTACHED_PIC)) { packet_queue_put(&is->videoq, pkt); } else if (pkt->stream_index == is->subtitle_stream && pkt_in_play_range) { packet_queue_put(&is->subtitleq, pkt); } else { av_packet_unref(pkt); } } ret = 0; fail: if (ic && !is->ic) avformat_close_input(&ic); if (ret != 0) { SDL_Event event; event.type = FF_QUIT_EVENT; event.user.data1 = is; SDL_PushEvent(&event); } SDL_DestroyMutex(wait_mutex); return 0; }<SPLIT>[1.2927717594054797, 5.4889885861347665, 0.0, 1.2550433709584938, 5.232400335650808, 0.0, 5.83637784285406, 5.943419665186456, 5.549507252305205, 5.327786082535139, 5.143441276556386, 1.0054691849094282, 5.515216745801814, 0.0, 0.0, 0.30852482215402843, 4.92369547958463, 0.9718292068145229, 5.276241336644952, 5.811192637457379, 3.428073144402896, 0.0, 0.7955188282012181, 0.9973611507722091, 4.610898220094085, 5.523932450961827, 5.537062307518988, 3.3782753486411963, 4.5438551251752, 5.834551782744551, 5.941881195432524, 5.547825835023776, 5.326312112739897, 2.6191065950439585, 0.0, 5.824155134244663, 5.931441103229006, 5.537472434069973, 5.315074296953347]
0<SPLIT>void ff_butterflies_float_vfp(float *av_restrict v1, float *av_restrict v2, int len); av_cold void ff_float_dsp_init_vfp(AVFloatDSPContext *fdsp, int cpu_flags) { if (!have_vfpv3(cpu_flags)) { fdsp->vector_fmul = ff_vector_fmul_vfp; fdsp->vector_fmul_window = ff_vector_fmul_window_vfp; } fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_vfp; if (!have_vfpv3(cpu_flags)) fdsp->butterflies_float = ff_butterflies_float_vfp; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void quantize_mantissas_blk_ch(AC3Mant *s, int32_t *fixed_coef, uint8_t *exp, uint8_t *bap, int16_t *qmant, int start_freq, int end_freq) { int i; for (i = start_freq; i < end_freq; i++) { int c = fixed_coef[i]; int e = exp[i]; int v = bap[i]; if (v) switch (v) { case 1: v = sym_quant(c, e, 3); switch (s->mant1_cnt) { case 0: s->qmant1_ptr = &qmant[i]; v = 9 * v; s->mant1_cnt = 1; break; case 1: *s->qmant1_ptr += 3 * v; s->mant1_cnt = 2; v = 128; break; default: *s->qmant1_ptr += v; s->mant1_cnt = 0; v = 128; break; } break; case 2: v = sym_quant(c, e, 5); switch (s->mant2_cnt) { case 0: s->qmant2_ptr = &qmant[i]; v = 25 * v; s->mant2_cnt = 1; break; case 1: *s->qmant2_ptr += 5 * v; s->mant2_cnt = 2; v = 128; break; default: *s->qmant2_ptr += v; s->mant2_cnt = 0; v = 128; break; } break; case 3: v = sym_quant(c, e, 7); break; case 4: v = sym_quant(c, e, 11); switch (s->mant4_cnt) { case 0: s->qmant4_ptr = &qmant[i]; v = 11 * v; s->mant4_cnt = 1; break; default: *s->qmant4_ptr += v; s->mant4_cnt = 0; v = 128; break; } break; case 5: v = sym_quant(c, e, 15); break; case 14: v = asym_quant(c, e, 14); break; case 15: v = asym_quant(c, e, 16); break; default: v = asym_quant(c, e, v - 1); break; } qmant[i] = v; } }<SPLIT>[-0.25365086435942685, 1.2359260659952118, 0.0, -0.2665172434374763, 1.1255972378374661, 0.0, 1.1439604446378808, 0.11088995743869048, 1.0717736154263862, -0.27925050329511203, 1.0877280206442659, -0.25297036047912586, 1.2985339091844414, 0.0, 0.0, 0.30852482215402843, 0.9908506077015672, -0.26569807294376846, 1.1902264981141564, 0.37651940477529405, 2.4415259784470567, 0.0, -0.08645738172306322, -0.16222078614455715, 1.2382117722297952, 1.2188335404954318, -0.10760608081136262, -0.21702784222394986, 2.204585822166557, 1.143335983750264, 0.11056045576999526, 1.0711936229013617, -0.27935383381430245, 1.7623686513065309, 0.0, 1.1388542534712223, 0.10736180245377658, 1.0667610514419015, -0.28182971586402455]
0<SPLIT>static void flush_fifo(AVFifoBuffer *fifo) { while (av_fifo_size(fifo)) { AVFrame *tmp; av_fifo_generic_read(fifo, &tmp, sizeof(tmp), NULL); av_frame_free(&tmp); } }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int flv_read_metabody(AVFormatContext *s, int64_t next_pos) { AMFDataType type; AVStream *stream, *astream, *vstream; AVStream av_unused *dstream; AVIOContext *ioc; int i; char buffer[32]; astream = NULL; vstream = NULL; dstream = NULL; ioc = s->pb; type = avio_r8(ioc); if (type != AMF_DATA_TYPE_STRING || amf_get_string(ioc, buffer, sizeof(buffer)) < 0) return TYPE_UNKNOWN; if (!strcmp(buffer, "onTextData")) return TYPE_ONTEXTDATA; if (!strcmp(buffer, "onCaption")) return TYPE_ONCAPTION; if (!strcmp(buffer, "onCaptionInfo")) return TYPE_ONCAPTIONINFO; if (strcmp(buffer, "onMetaData") && strcmp(buffer, "onCuePoint")) { av_log(s, AV_LOG_DEBUG, "Unknown type %s\n", buffer); return TYPE_UNKNOWN; } for (i = 0; i < s->nb_streams; i++) { stream = s->streams[i]; if (stream->codec->codec_type == AVMEDIA_TYPE_VIDEO) vstream = stream; else if (stream->codec->codec_type == AVMEDIA_TYPE_AUDIO) astream = stream; else if (stream->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) dstream = stream; } if (amf_parse_object(s, astream, vstream, buffer, next_pos, 0) < 0) return -1; return 0; }<SPLIT>[0.6742027098995172, 0.20020617767107143, 0.0, 0.6464191252001059, 0.12549492904354367, 0.0, -0.07259221415890627, -0.06585336703851451, 0.07672169611998206, -0.27925050329511203, 0.268593816248222, 0.6908592985622897, 0.22726853988164963, 0.0, 0.0, 0.30852482215402843, 0.19653218530153962, 0.66244738687495, 0.15215786346038676, 0.11772544131424245, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, 0.18424725727220465, -0.08904460951967552, 0.005287286955244392, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>int av_cmp_i(AVInteger a, AVInteger b){ int i; int v= (int16_t)a.v[AV_INTEGER_SIZE-1] - (int16_t)b.v[AV_INTEGER_SIZE-1]; if(v) return (v>>16)|1; for(i=AV_INTEGER_SIZE-2; i>=0; i--){ int v= a.v[i] - b.v[i]; if(v) return (v>>16)|1; } return 0; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.39986248560786075, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.08904460951967552, -0.4462861841111837, 0.6817979554923368, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static int mov_write_uuid_tag_psp(AVIOContext *pb, MOVTrack *mov) { avio_wb32(pb, 0x34); ffio_wfourcc(pb, "uuid"); ffio_wfourcc(pb, "USMT"); avio_wb32(pb, 0x21d24fce); avio_wb32(pb, 0xbb88695c); avio_wb32(pb, 0xfac9c740); avio_wb32(pb, 0x1c); ffio_wfourcc(pb, "MTDT"); avio_wb32(pb, 0x00010012); avio_wb32(pb, 0x0a); avio_wb32(pb, 0x55c40000); avio_wb32(pb, 0x1); avio_wb32(pb, 0x0); return 0x34; }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int test_vector_fmul_window(AVFloatDSPContext *fdsp, AVFloatDSPContext *cdsp, const float *v1, const float *v2, const float *v3) { LOCAL_ALIGNED(32, float, cdst, [LEN]); LOCAL_ALIGNED(32, float, odst, [LEN]); int ret; cdsp->vector_fmul_window(cdst, v1, v2, v3, LEN / 2); fdsp->vector_fmul_window(odst, v1, v2, v3, LEN / 2); if (ret = compare_floats(cdst, odst, LEN, ARBITRARY_FMUL_WINDOW_CONST)) av_log(NULL, AV_LOG_ERROR, "vector_fmul_window failed\n"); return ret; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>static int nsv_parse_NSVf_header(AVFormatContext *s) { NSVContext *nsv = s->priv_data; AVIOContext *pb = s->pb; unsigned int av_unused file_size; unsigned int size; int64_t duration; int strings_size; int table_entries; int table_entries_used; nsv->state = NSV_UNSYNC; size = avio_rl32(pb); if (size < 28) return -1; nsv->NSVf_end = size; file_size = (uint32_t)avio_rl32(pb); av_log(s, AV_LOG_TRACE, "NSV NSVf chunk_size %u\n", size); av_log(s, AV_LOG_TRACE, "NSV NSVf file_size %u\n", file_size); nsv->duration = duration = avio_rl32(pb); av_log(s, AV_LOG_TRACE, "NSV NSVf duration %"PRId64" ms\n", duration); strings_size = avio_rl32(pb); table_entries = avio_rl32(pb); table_entries_used = avio_rl32(pb); av_log(s, AV_LOG_TRACE, "NSV NSVf info-strings size: %d, table entries: %d, bis %d\n", strings_size, table_entries, table_entries_used); if (avio_feof(pb)) return -1; av_log(s, AV_LOG_TRACE, "NSV got header; filepos %"PRId64"\n", avio_tell(pb)); if (strings_size > 0) { char *strings; char *p, *endp; char *token, *value; char quote; p = strings = av_mallocz((size_t)strings_size + 1); if (!p) return AVERROR(ENOMEM); endp = strings + strings_size; avio_read(pb, strings, strings_size); while (p < endp) { while (*p == ' ') p++; if (p >= endp-2) break; token = p; p = strchr(p, '='); if (!p || p >= endp-2) break; *p++ = '\0'; quote = *p++; value = p; p = strchr(p, quote); if (!p || p >= endp) break; *p++ = '\0'; av_log(s, AV_LOG_TRACE, "NSV NSVf INFO: %s='%s'\n", token, value); av_dict_set(&s->metadata, token, value, 0); } av_free(strings); } if (avio_feof(pb)) return -1; av_log(s, AV_LOG_TRACE, "NSV got infos; filepos %"PRId64"\n", avio_tell(pb)); if (table_entries_used > 0) { int i; nsv->index_entries = table_entries_used; if((unsigned)table_entries_used >= UINT_MAX / sizeof(uint32_t)) return -1; nsv->nsvs_file_offset = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t)); if (!nsv->nsvs_file_offset) return AVERROR(ENOMEM); for(i=0;i<table_entries_used;i++) nsv->nsvs_file_offset[i] = avio_rl32(pb) + size; if(table_entries > table_entries_used && avio_rl32(pb) == MKTAG('T','O','C','2')) { nsv->nsvs_timestamps = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t)); if (!nsv->nsvs_timestamps) return AVERROR(ENOMEM); for(i=0;i<table_entries_used;i++) { nsv->nsvs_timestamps[i] = avio_rl32(pb); } } } av_log(s, AV_LOG_TRACE, "NSV got index; filepos %"PRId64"\n", avio_tell(pb)); avio_seek(pb, nsv->base_offset + size, SEEK_SET); if (avio_feof(pb)) return -1; nsv->state = NSV_HAS_READ_NSVF; return 0; }<SPLIT>[2.2206253336644237, 1.302035846101008, 0.0, 2.167979739596076, 1.189433555420057, 0.0, 2.012926629492729, 2.0550665266879453, 2.232667521283858, 3.34883199341858, 1.467326798291213, 2.2639087302979823, 1.3669125497782366, 0.0, 0.0, 0.30852482215402843, 1.3589493888137751, 2.2093564865728146, 1.2564861981984394, 2.0586801672721293, 2.77037503376567, 0.0, -0.08645738172306322, -0.16222078614455715, 1.5895332772156587, 2.581206613427835, 1.9244745389875635, -0.21702784222394986, 2.859581227008977, 2.0120796502306875, 2.054334035657505, 2.231801974192358, 3.347841778661945, 1.7623686513065309, 0.0, 2.006502564725563, 2.048721569378853, 2.225834372863994, 3.339696410076628]
0<SPLIT>static void frame_end(MpegEncContext *s) { if (s->unrestricted_mv && s->current_picture.reference && !s->intra_only) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->avctx->pix_fmt); int hshift = desc->log2_chroma_w; int vshift = desc->log2_chroma_h; s->mpvencdsp.draw_edges(s->current_picture.f->data[0], s->current_picture.f->linesize[0], s->h_edge_pos, s->v_edge_pos, EDGE_WIDTH, EDGE_WIDTH, EDGE_TOP | EDGE_BOTTOM); s->mpvencdsp.draw_edges(s->current_picture.f->data[1], s->current_picture.f->linesize[1], s->h_edge_pos >> hshift, s->v_edge_pos >> vshift, EDGE_WIDTH >> hshift, EDGE_WIDTH >> vshift, EDGE_TOP | EDGE_BOTTOM); s->mpvencdsp.draw_edges(s->current_picture.f->data[2], s->current_picture.f->linesize[2], s->h_edge_pos >> hshift, s->v_edge_pos >> vshift, EDGE_WIDTH >> hshift, EDGE_WIDTH >> vshift, EDGE_TOP | EDGE_BOTTOM); } emms_c(); s->last_pict_type = s->pict_type; s->last_lambda_for [s->pict_type] = s->current_picture_ptr->f->quality; if (s->pict_type!= AV_PICTURE_TYPE_B) s->last_non_b_pict_type = s->pict_type; #if FF_API_CODED_FRAME FF_DISABLE_DEPRECATION_WARNINGS av_frame_copy_props(s->avctx->coded_frame, s->current_picture.f); FF_ENABLE_DEPRECATION_WARNINGS #endif }<SPLIT>[-0.25365086435942685, 0.20020617767107143, 0.0, -0.2665172434374763, 0.12549492904354367, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.14872051804392286, -0.25297036047912586, 0.11330413889199094, 0.0, 0.0, 0.30852482215402843, 0.08029046495031608, -0.26569807294376846, 0.04172502998658149, -0.270465503877335, -0.2988828158747199, 0.0, 0.24428369699854227, 0.9973611507722091, -0.30760284970800433, -0.3070243011888601, -0.22049944857796966, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int main(int argc, char *argv[]) { int fd_in, fd_out, comp_len, uncomp_len, i, last_out; char buf_in[1024], buf_out[65536]; z_stream zstream; struct stat statbuf; int ret = 1; if (argc < 3) { printf("Usage: %s <infile.swf> <outfile.swf>\n", argv[0]); return 1; } fd_in = open(argv[1], O_RDONLY); if (fd_in < 0) { perror("Error opening input file"); return 1; } fd_out = open(argv[2], O_WRONLY | O_CREAT, 00644); if (fd_out < 0) { perror("Error opening output file"); close(fd_in); return 1; } if (read(fd_in, &buf_in, 8) != 8) { printf("Header error\n"); goto out; } if (buf_in[0] != 'C' || buf_in[1] != 'W' || buf_in[2] != 'S') { printf("Not a compressed flash file\n"); goto out; } if (fstat(fd_in, &statbuf) < 0) { perror("fstat failed"); return 1; } comp_len = statbuf.st_size; uncomp_len = buf_in[4] | (buf_in[5] << 8) | (buf_in[6] << 16) | (buf_in[7] << 24); printf("Compressed size: %d Uncompressed size: %d\n", comp_len - 4, uncomp_len - 4); buf_in[0] = 'F'; if (write(fd_out, &buf_in, 8) < 8) { perror("Error writing output file"); goto out; } zstream.zalloc = NULL; zstream.zfree = NULL; zstream.opaque = NULL; if (inflateInit(&zstream) != Z_OK) { fprintf(stderr, "inflateInit failed\n"); return 1; } for (i = 0; i < comp_len - 8;) { int ret, len = read(fd_in, &buf_in, 1024); dbgprintf("read %d bytes\n", len); last_out = zstream.total_out; zstream.next_in = &buf_in[0]; zstream.avail_in = len; zstream.next_out = &buf_out[0]; zstream.avail_out = 65536; ret = inflate(&zstream, Z_SYNC_FLUSH); if (ret != Z_STREAM_END && ret != Z_OK) { printf("Error while decompressing: %d\n", ret); inflateEnd(&zstream); goto out; } dbgprintf("a_in: %d t_in: %lu a_out: %d t_out: %lu -- %lu out\n", zstream.avail_in, zstream.total_in, zstream.avail_out, zstream.total_out, zstream.total_out - last_out); if (write(fd_out, &buf_out, zstream.total_out - last_out) < zstream.total_out - last_out) { perror("Error writing output file"); inflateEnd(&zstream); goto out; } i += len; if (ret == Z_STREAM_END || ret == Z_BUF_ERROR) break; } if (zstream.total_out != uncomp_len - 8) { printf("Size mismatch (%lu != %d), updating header...\n", zstream.total_out, uncomp_len - 8); buf_in[0] = (zstream.total_out + 8) & 0xff; buf_in[1] = ((zstream.total_out + 8) >> 8) & 0xff; buf_in[2] = ((zstream.total_out + 8) >> 16) & 0xff; buf_in[3] = ((zstream.total_out + 8) >> 24) & 0xff; if ( lseek(fd_out, 4, SEEK_SET) < 0 || write(fd_out, &buf_in, 4) < 4) { perror("Error writing output file"); inflateEnd(&zstream); goto out; } } ret = 0; inflateEnd(&zstream); out: close(fd_in); close(fd_out); return ret; }<SPLIT>[-0.09900860198293619, 1.5003651864183964, 0.0, -0.11436118199787926, 1.3809425081678293, 0.0, 2.012926629492729, 2.0550665266879453, 2.232667521283858, 4.33830903797686, 1.347453500086914, -0.09566541730555662, 1.5720484715596224, 0.0, 0.0, 0.30852482215402843, 1.2427076684625518, -0.11100716297398205, 1.455265298451289, 1.5410922403500262, 4.305003958585864, 0.0, -0.08645738172306322, -0.16222078614455715, 1.5192689762184861, 3.398630457187277, 2.2631546422873847, 0.6817979554923368, 3.8888597203327793, 2.0120796502306875, 2.054334035657505, 2.231801974192358, 4.337076945700922, 0.9056307075691036, 0.0, 2.006502564725563, 2.048721569378853, 2.225834372863994, 4.3273853535149875]
0<SPLIT>static int opengl_write_frame(AVFormatContext *h, int stream_index, AVFrame **frame, unsigned flags) { if ((flags & AV_WRITE_UNCODED_FRAME_QUERY)) return 0; return opengl_draw(h, *frame, 0, 0); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5250039928580447, -0.6720729196443977, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void update_alpha(DrawTextContext *s) { double alpha = av_expr_eval(s->a_pexpr, s->var_values, &s->prng); if (isnan(alpha)) return; if (alpha >= 1.0) s->alpha = 255; else if (alpha <= 0) s->alpha = 0; else s->alpha = 256 * alpha; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.41601414702345235, -0.4462861841111837, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void init_output_filter(OutputFilter *ofilter, OptionsContext *o, AVFormatContext *oc) { OutputStream *ost; switch (ofilter->type) { case AVMEDIA_TYPE_VIDEO: ost = new_video_stream(o, oc, -1); break; case AVMEDIA_TYPE_AUDIO: ost = new_audio_stream(o, oc, -1); break; default: av_log(NULL, AV_LOG_FATAL, "Only video and audio filters are supported " "currently.\n"); exit_program(1); } ost->source_index = -1; ost->filter = ofilter; ofilter->ost = ost; ofilter->format = -1; if (ost->stream_copy) { av_log(NULL, AV_LOG_ERROR, "Streamcopy requested for output stream %d:%d, " "which is fed from a complex filtergraph. Filtering and streamcopy " "cannot be used together.\n", ost->file_index, ost->index); exit_program(1); } if (ost->avfilter && (ost->filters || ost->filters_script)) { const char *opt = ost->filters ? "-vf/-af/-filter" : "-filter_script"; av_log(NULL, AV_LOG_ERROR, "%s '%s' was specified through the %s option " "for output stream %d:%d, which is fed from a complex filtergraph.\n" "%s and -filter_complex cannot be used together for the same stream.\n", ost->filters ? "Filtergraph" : "Filtergraph script", ost->filters ? ost->filters : ost->filters_script, opt, ost->file_index, ost->index, opt); exit_program(1); } avfilter_inout_free(&ofilter->out_tmp); }<SPLIT>[-0.25365086435942685, 0.11205980419667652, 0.0, -0.2665172434374763, 0.04037983893342262, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.06880498590772346, -0.25297036047912586, 0.13609701908992267, 0.0, 0.0, 0.30852482215402843, 0.0027959847161670454, -0.26569807294376846, 0.06381159668134254, 0.11772544131424245, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.14353953243697165, -0.10760608081136262, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int pulse_subscribe_events(PulseData *s) { pa_operation *op; pa_threaded_mainloop_lock(s->mainloop); op = pa_context_subscribe(s->ctx, PA_SUBSCRIPTION_MASK_SINK_INPUT, pulse_context_result, s); return pulse_finish_context_operation(s, op, "pa_context_subscribe"); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void run_lavu_rc4(uint8_t *output, const uint8_t *input, unsigned size) { static struct AVRC4 *rc4; if (!rc4 && !(rc4 = av_rc4_alloc())) fatal_error("out of memory"); av_rc4_init(rc4, hardcoded_key, 128, 0); av_rc4_crypt(rc4, output, input, size, NULL, 0); }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.24638545112987587, -0.2425966915157195, -0.08912029043108533, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.011671540416283347, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.25252937827156396, -0.10760608081136262, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void abort_codec_experimental(AVCodec *c, int encoder) { exit_program(1); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int main(void) { int i; for (i = 0; i < FF_ARRAY_ELEMS(error_entries); i++) { const struct error_entry *entry = &error_entries[i]; printf("%d: %s [%s]\n", entry->num, av_err2str(entry->num), entry->tag); } for (i = 0; i < 256; i++) { printf("%d: %s\n", -i, av_err2str(-i)); } return 0; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.08904460951967552, -0.10760608081136262, -0.21702784222394986, -0.04111270872174079, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *in) { AVFilterContext *ctx = inlink->dst; DynamicAudioNormalizerContext *s = ctx->priv; AVFilterLink *outlink = inlink->dst->outputs[0]; int ret = 0; if (!cqueue_empty(s->gain_history_smoothed[0])) { AVFrame *out = ff_bufqueue_get(&s->queue); amplify_frame(s, out); ret = ff_filter_frame(outlink, out); } analyze_frame(s, in); ff_bufqueue_add(ctx, &s->queue, in); return ret; }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, 0.11772544131424245, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.1980344553542678, 0.005287286955244392, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int read_seek(AVFormatContext *s, int stream_index, int64_t pts, int flags) { NUTContext *nut = s->priv_data; AVStream *st = s->streams[stream_index]; Syncpoint dummy = { .ts = pts * av_q2d(st->time_base) * AV_TIME_BASE }; Syncpoint nopts_sp = { .ts = AV_NOPTS_VALUE, .back_ptr = AV_NOPTS_VALUE }; Syncpoint *sp, *next_node[2] = { &nopts_sp, &nopts_sp }; int64_t pos, pos2, ts; int i; if (nut->flags & NUT_PIPE) { return AVERROR(ENOSYS); } if (st->index_entries) { int index = av_index_search_timestamp(st, pts, flags); if (index < 0) index = av_index_search_timestamp(st, pts, flags ^ AVSEEK_FLAG_BACKWARD); if (index < 0) return -1; pos2 = st->index_entries[index].pos; ts = st->index_entries[index].timestamp; } else { av_tree_find(nut->syncpoints, &dummy, (void *) ff_nut_sp_pts_cmp, (void **) next_node); av_log(s, AV_LOG_DEBUG, "%"PRIu64"-%"PRIu64" %"PRId64"-%"PRId64"\n", next_node[0]->pos, next_node[1]->pos, next_node[0]->ts, next_node[1]->ts); pos = ff_gen_search(s, -1, dummy.ts, next_node[0]->pos, next_node[1]->pos, next_node[1]->pos, next_node[0]->ts, next_node[1]->ts, AVSEEK_FLAG_BACKWARD, &ts, nut_read_timestamp); if (pos < 0) return pos; if (!(flags & AVSEEK_FLAG_BACKWARD)) { dummy.pos = pos + 16; next_node[1] = &nopts_sp; av_tree_find(nut->syncpoints, &dummy, (void *) ff_nut_sp_pos_cmp, (void **) next_node); pos2 = ff_gen_search(s, -2, dummy.pos, next_node[0]->pos, next_node[1]->pos, next_node[1]->pos, next_node[0]->back_ptr, next_node[1]->back_ptr, flags, &ts, nut_read_timestamp); if (pos2 >= 0) pos = pos2; } dummy.pos = pos; sp = av_tree_find(nut->syncpoints, &dummy, (void *) ff_nut_sp_pos_cmp, NULL); av_assert0(sp); pos2 = sp->back_ptr - 15; } av_log(NULL, AV_LOG_DEBUG, "SEEKTO: %"PRId64"\n", pos2); pos = find_startcode(s->pb, SYNCPOINT_STARTCODE, pos2); avio_seek(s->pb, pos, SEEK_SET); nut->last_syncpoint_pos = pos; av_log(NULL, AV_LOG_DEBUG, "SP: %"PRId64"\n", pos); if (pos2 > pos || pos2 + 15 < pos) av_log(NULL, AV_LOG_ERROR, "no syncpoint at backptr pos\n"); for (i = 0; i < s->nb_streams; i++) nut->stream[i].skip_until_key_frame = 1; nut->last_resync_pos = 0; return 0; }<SPLIT>[-0.09900860198293619, 0.729084418517441, 0.0, -0.11436118199787926, 0.63618546970427, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 0.380400859743741, 0.6481925938951691, -0.09566541730555662, 0.7742976646320114, 0.0, 0.0, 0.30852482215402843, 0.5646309664137475, -0.11100716297398205, 0.6822354641346521, 0.5059163865058198, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, 0.6058330632552409, 0.18343000506680518, 0.34396739025506545, -0.21702784222394986, 0.05245806339860493, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 0.3801362775450152, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 0.3766295797615486]
0<SPLIT>static av_cold int lutyuv_init(AVFilterContext *ctx) { LutContext *s = ctx->priv; s->is_yuv = 1; return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { PerspectiveContext *s = ctx->priv; av_freep(&s->pv); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int decode_pulses(Pulse *pulse, GetBitContext *gb, const uint16_t *swb_offset, int num_swb) { int i, pulse_swb; pulse->num_pulse = get_bits(gb, 2) + 1; pulse_swb = get_bits(gb, 6); if (pulse_swb >= num_swb) return -1; pulse->pos[0] = swb_offset[pulse_swb]; pulse->pos[0] += get_bits(gb, 5); if (pulse->pos[0] >= swb_offset[num_swb]) return -1; pulse->amp[0] = get_bits(gb, 4); for (i = 1; i < pulse->num_pulse; i++) { pulse->pos[i] = get_bits(gb, 5) + pulse->pos[i - 1]; if (pulse->pos[i] >= swb_offset[num_swb]) return -1; pulse->amp[i] = get_bits(gb, 4); } return 0; }<SPLIT>[-0.25365086435942685, -0.1964525029637057, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.21089937656897445, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, -0.39986248560786075, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.25252937827156396, -0.4462861841111837, -0.21702784222394986, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int sample_rate_idx (int rate) { if (92017 <= rate) return 0; else if (75132 <= rate) return 1; else if (55426 <= rate) return 2; else if (46009 <= rate) return 3; else if (37566 <= rate) return 4; else if (27713 <= rate) return 5; else if (23004 <= rate) return 6; else if (18783 <= rate) return 7; else if (13856 <= rate) return 8; else if (11502 <= rate) return 9; else if (9391 <= rate) return 10; else return 11; }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, 1.49154691857982, 1.5248365532563304, 1.403457588528521, 3.34883199341858, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.7880534307994381, 0.7972807018539907, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, 0.5648944654878781, -0.7849662874110047, -0.21702784222394986, 1.6431611894444824, 1.4908334503424332, 1.524213968415457, 1.4027960089845035, 3.347841778661945, 0.04889276383167627, 0.0, 1.4859135779729586, 1.519259814762923, 1.3979248575624994, 3.339696410076628]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { static const enum AVPixelFormat pix_fmts[] = {AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE}; AVFilterFormats *fmts_list = ff_make_format_list(pix_fmts); if (!fmts_list) return AVERROR(ENOMEM); return ff_set_common_formats(ctx, fmts_list); }<SPLIT>[0.05563366039355449, -0.4829282167554892, 0.0, 0.037794879441717756, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, 0.061639525868012635, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, 0.04368374699580437, -0.5104391373824448, -0.14106852214680915, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.3615192241061562, -0.10760608081136262, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void hvcc_update_ptl(HEVCDecoderConfigurationRecord *hvcc, HVCCProfileTierLevel *ptl) { hvcc->general_profile_space = ptl->profile_space; if (hvcc->general_tier_flag < ptl->tier_flag) hvcc->general_level_idc = ptl->level_idc; else hvcc->general_level_idc = FFMAX(hvcc->general_level_idc, ptl->level_idc); hvcc->general_tier_flag = FFMAX(hvcc->general_tier_flag, ptl->tier_flag); hvcc->general_profile_idc = FFMAX(hvcc->general_profile_idc, ptl->profile_idc); hvcc->general_profile_compatibility_flags &= ptl->profile_compatibility_flags; hvcc->general_constraint_indicator_flags &= ptl->constraint_indicator_flags; }<SPLIT>[5.158828318817746, -0.3727452499124955, 0.0, 5.05894490694842, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.3285304653503715, 5.252702650595798, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, 0.2546530454771514, 5.1484837759987565, -0.42209287060340067, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>av_cold void avpriv_init_lls(LLSModel *m, int indep_count) { memset(m, 0, sizeof(LLSModel)); m->indep_count = indep_count; m->update_lls = update_lls; m->evaluate_lls = evaluate_lls; if (ARCH_X86) ff_init_lls_x86(m); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>int avfilter_graph_add_filter(AVFilterGraph *graph, AVFilterContext *filter) { AVFilterContext **filters = av_realloc(graph->filters, sizeof(*filters) * (graph->nb_filters + 1)); if (!filters) return AVERROR(ENOMEM); graph->filters = filters; graph->filters[graph->nb_filters++] = filter; #if FF_API_FOO_COUNT FF_DISABLE_DEPRECATION_WARNINGS graph->filter_count_unused = graph->nb_filters; FF_ENABLE_DEPRECATION_WARNINGS #endif filter->graph = graph; return 0; }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.4662660039929228, -0.5292594673383866, -0.4084991676475909, 0.0, 0.24428369699854227, 0.9973611507722091, -0.44813145170234975, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int request_frame(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; SilenceRemoveContext *s = ctx->priv; int ret; ret = ff_request_frame(ctx->inputs[0]); if (ret == AVERROR_EOF && (s->mode == SILENCE_COPY_FLUSH || s->mode == SILENCE_COPY)) { int nbs = s->stop_holdoff_end - s->stop_holdoff_offset; if (nbs) { AVFrame *frame; frame = ff_get_audio_buffer(outlink, nbs / outlink->channels); if (!frame) return AVERROR(ENOMEM); memcpy(frame->data[0], &s->stop_holdoff[s->stop_holdoff_offset], nbs * sizeof(double)); ret = ff_filter_frame(ctx->inputs[0], frame); } s->mode = SILENCE_STOP; } return ret; }<SPLIT>[-0.25365086435942685, -0.17441590959510697, 0.0, -0.2665172434374763, -0.23624420392447085, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.1909204935349246, -0.25297036047912586, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.26569807294376846, -0.22331377035055117, 0.11772544131424245, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.14353953243697165, 0.005287286955244392, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void lowpass16(WaveformContext *s, AVFrame *in, AVFrame *out, int component, int intensity, int offset, int column) { const int plane = s->desc->comp[component].plane; const int mirror = s->mirror; const int is_chroma = (component == 1 || component == 2); const int shift_w = (is_chroma ? s->desc->log2_chroma_w : 0); const int shift_h = (is_chroma ? s->desc->log2_chroma_h : 0); const int src_linesize = in->linesize[plane] / 2; const int dst_linesize = out->linesize[plane] / 2; const int dst_signed_linesize = dst_linesize * (mirror == 1 ? -1 : 1); const int limit = s->max - 1; const int max = limit - intensity; const int src_h = FF_CEIL_RSHIFT(in->height, shift_h); const int src_w = FF_CEIL_RSHIFT(in->width, shift_w); const uint16_t *src_data = (const uint16_t *)in->data[plane]; uint16_t *dst_data = (uint16_t *)out->data[plane] + (column ? (offset >> shift_h) * dst_linesize : offset >> shift_w); uint16_t * const dst_bottom_line = dst_data + dst_linesize * ((s->size >> shift_h) - 1); uint16_t * const dst_line = (mirror ? dst_bottom_line : dst_data); const uint16_t *p; int y; if (!column && mirror) dst_data += s->size >> shift_w; for (y = 0; y < src_h; y++) { const uint16_t *src_data_end = src_data + src_w; uint16_t *dst = dst_line; for (p = src_data; p < src_data_end; p++) { uint16_t *target; int v = FFMIN(*p, limit); if (column) { target = dst++ + dst_signed_linesize * (v >> shift_h); } else { if (mirror) target = dst_data - (v >> shift_w) - 1; else target = dst_data + (v >> shift_w); } update16(target, max, intensity, limit); } src_data += src_linesize; dst_data += dst_linesize; } envelope16(s, out, plane, plane); }<SPLIT>[-0.25365086435942685, 0.3103891445140651, 0.0, -0.2665172434374763, 0.231888791681195, 0.0, -0.07259221415890627, -0.06585336703851451, 0.07672169611998206, -0.27925050329511203, 0.24861493321417213, -0.25297036047912586, 0.34123294087130834, 0.0, 0.0, 0.30852482215402843, 0.17715856524300236, -0.26569807294376846, 0.262590696934192, 1.799886203811078, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5004366117594818, 0.6193893884051743, 1.5857944356877427, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void finish(void) { char res[2 * AV_HASH_MAX_SIZE + 4]; printf("%s=", av_hash_get_name(hash)); if (out_b64) { av_hash_final_b64(hash, res, sizeof(res)); printf("b64:%s", res); } else { av_hash_final_hex(hash, res, sizeof(res)); printf("0x%s", res); } }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3615192241061562, -0.22049944857796966, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void sbr_hf_inverse_filter(SBRDSPContext *dsp, int (*alpha0)[2], int (*alpha1)[2], const int X_low[32][40][2], int k0) { int k; int shift, round; for (k = 0; k < k0; k++) { SoftFloat phi[3][2][2]; SoftFloat a00, a01, a10, a11; SoftFloat dk; dsp->autocorrelate(X_low[k], phi); dk = av_sub_sf(av_mul_sf(phi[2][1][0], phi[1][0][0]), av_mul_sf(av_add_sf(av_mul_sf(phi[1][1][0], phi[1][1][0]), av_mul_sf(phi[1][1][1], phi[1][1][1])), FLOAT_0999999)); if (!dk.mant) { a10 = FLOAT_0; a11 = FLOAT_0; } else { SoftFloat temp_real, temp_im; temp_real = av_sub_sf(av_sub_sf(av_mul_sf(phi[0][0][0], phi[1][1][0]), av_mul_sf(phi[0][0][1], phi[1][1][1])), av_mul_sf(phi[0][1][0], phi[1][0][0])); temp_im = av_sub_sf(av_add_sf(av_mul_sf(phi[0][0][0], phi[1][1][1]), av_mul_sf(phi[0][0][1], phi[1][1][0])), av_mul_sf(phi[0][1][1], phi[1][0][0])); a10 = av_div_sf(temp_real, dk); a11 = av_div_sf(temp_im, dk); } if (!phi[1][0][0].mant) { a00 = FLOAT_0; a01 = FLOAT_0; } else { SoftFloat temp_real, temp_im; temp_real = av_add_sf(phi[0][0][0], av_add_sf(av_mul_sf(a10, phi[1][1][0]), av_mul_sf(a11, phi[1][1][1]))); temp_im = av_add_sf(phi[0][0][1], av_sub_sf(av_mul_sf(a11, phi[1][1][0]), av_mul_sf(a10, phi[1][1][1]))); temp_real.mant = -temp_real.mant; temp_im.mant = -temp_im.mant; a00 = av_div_sf(temp_real, phi[1][0][0]); a01 = av_div_sf(temp_im, phi[1][0][0]); } shift = a00.exp; if (shift >= 3) alpha0[k][0] = 0x7fffffff; else { a00.mant <<= 1; shift = 2-shift; if (shift == 0) alpha0[k][0] = a00.mant; else { round = 1 << (shift-1); alpha0[k][0] = (a00.mant + round) >> shift; } } shift = a01.exp; if (shift >= 3) alpha0[k][1] = 0x7fffffff; else { a01.mant <<= 1; shift = 2-shift; if (shift == 0) alpha0[k][1] = a01.mant; else { round = 1 << (shift-1); alpha0[k][1] = (a01.mant + round) >> shift; } } shift = a10.exp; if (shift >= 3) alpha1[k][0] = 0x7fffffff; else { a10.mant <<= 1; shift = 2-shift; if (shift == 0) alpha1[k][0] = a10.mant; else { round = 1 << (shift-1); alpha1[k][0] = (a10.mant + round) >> shift; } } shift = a11.exp; if (shift >= 3) alpha1[k][1] = 0x7fffffff; else { a11.mant <<= 1; shift = 2-shift; if (shift == 0) alpha1[k][1] = a11.mant; else { round = 1 << (shift-1); alpha1[k][1] = (a11.mant + round) >> shift; } } shift = (int)(((int64_t)(alpha1[k][0]>>1) * (alpha1[k][0]>>1) + \ (int64_t)(alpha1[k][1]>>1) * (alpha1[k][1]>>1) + \ 0x40000000) >> 31); if (shift >= 0x20000000){ alpha1[k][0] = 0; alpha1[k][1] = 0; alpha0[k][0] = 0; alpha0[k][1] = 0; } shift = (int)(((int64_t)(alpha0[k][0]>>1) * (alpha0[k][0]>>1) + \ (int64_t)(alpha0[k][1]>>1) * (alpha0[k][1]>>1) + \ 0x40000000) >> 31); if (shift >= 0x20000000){ alpha1[k][0] = 0; alpha1[k][1] = 0; alpha0[k][0] = 0; alpha0[k][1] = 0; } } }<SPLIT>[-0.25365086435942685, 1.8970238670531736, 0.0, -0.2665172434374763, 1.7639604136633742, 0.0, 1.8391333925217592, 1.8783232022107403, 1.7351415616306558, -0.27925050329511203, 1.6870945116657614, -0.25297036047912586, 1.9823203151223938, 0.0, 0.0, 0.30852482215402843, 1.572059209457685, -0.26569807294376846, 1.852823498956988, 0.11772544131424245, 4.305003958585864, 0.0, -0.08645738172306322, -0.16222078614455715, 1.5192689762184861, 1.8182776925856894, 0.005287286955244392, 3.3782753486411963, 2.766010454888631, 1.8383309169346027, 1.8776273465768223, 1.7343983950676451, -0.27935383381430245, 1.7623686513065309, 0.0, 1.832972902474695, 1.8722343178402097, 1.7290886636830973, -0.28182971586402455]
0<SPLIT>int64_t av_gettime(void) { #if HAVE_GETTIMEOFDAY struct timeval tv; gettimeofday(&tv, NULL); return (int64_t)tv.tv_sec * 1000000 + tv.tv_usec; #elif HAVE_GETSYSTEMTIMEASFILETIME FILETIME ft; int64_t t; GetSystemTimeAsFileTime(&ft); t = (int64_t)ft.dwHighDateTime << 32 | ft.dwLowDateTime; return t / 10 - 11644473600000000; #else return -1; #endif }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.4084991676475909, 0.0, 0.9057658544417533, 2.1569430876889752, -0.377867150705177, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { static const enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV411P, AV_PIX_FMT_YUV410P, AV_PIX_FMT_YUV440P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ440P, AV_PIX_FMT_GBRP, AV_PIX_FMT_GRAY8, AV_PIX_FMT_NONE }; AVFilterFormats *fmts_list = ff_make_format_list(pix_fmts); if (!fmts_list) return AVERROR(ENOMEM); return ff_set_common_formats(ctx, fmts_list); }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int filter_slice(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs) { RemoveGrainContext *s = ctx->priv; ThreadData *td = arg; AVFrame *in = td->in; AVFrame *out = td->out; const int i = td->plane; const int height = s->planeheight[i]; const int om = in->linesize[i] - 1; const int o0 = in->linesize[i] ; const int op = in->linesize[i] + 1; int start = (height * jobnr ) / nb_jobs; int end = (height * (jobnr+1)) / nb_jobs; int x, y; start = FFMAX(1, start); end = FFMIN(height-1, end); for (y = start; y < end; y++) { uint8_t *dst = out->data[i]; uint8_t *src = in->data[i]; src = in->data[i] + y * in->linesize[i]; dst = out->data[i] + y * out->linesize[i]; if (s->skip_even && !(y & 1)) { memcpy(dst, src, s->planewidth[i]); continue; } if (s->skip_odd && y & 1) { memcpy(dst, src, s->planewidth[i]); continue; } *dst++ = *src++; if (s->fl[i]) { int w_asm = (s->planewidth[i] - 2) & ~15; s->fl[i](dst, src, in->linesize[i], w_asm); x = 1 + w_asm; dst += w_asm; src += w_asm; } else x = 1; for (; x < s->planewidth[i] - 1; x++) { const int a1 = src[-op]; const int a2 = src[-o0]; const int a3 = src[-om]; const int a4 = src[-1 ]; const int c = src[ 0 ]; const int a5 = src[ 1 ]; const int a6 = src[ om]; const int a7 = src[ o0]; const int a8 = src[ op]; const int res = s->rg[i](c, a1, a2, a3, a4, a5, a6, a7, a8); *dst = res; dst++, src++; } dst[0] = src[0]; } return 0; }<SPLIT>[-0.25365086435942685, 0.5748282649372498, 0.0, -0.2665172434374763, 0.48723406201155817, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 0.7102265412631674, 0.48836152962277035, -0.25297036047912586, 0.6147475032464892, 0.0, 0.0, 0.30852482215402843, 0.40964200594544947, -0.26569807294376846, 0.5276294972713247, 2.0586801672721293, 0.7972807018539907, 0.0, -0.08645738172306322, -0.16222078614455715, 0.9571545682411045, 1.273328463412728, 1.8115811712209564, -0.21702784222394986, 0.7074534682410251, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 0.7098813332246741, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 0.7058592275743352]
0<SPLIT>static int decode_ga_specific_config(AACContext *ac, AVCodecContext *avctx, GetBitContext *gb, MPEG4AudioConfig *m4ac, int channel_config) { int extension_flag, ret, ep_config, res_flags; uint8_t layout_map[MAX_ELEM_ID*4][3]; int tags = 0; if (get_bits1(gb)) { avpriv_request_sample(avctx, "960/120 MDCT window"); return AVERROR_PATCHWELCOME; } m4ac->frame_length_short = 0; if (get_bits1(gb)) skip_bits(gb, 14); extension_flag = get_bits1(gb); if (m4ac->object_type == AOT_AAC_SCALABLE || m4ac->object_type == AOT_ER_AAC_SCALABLE) skip_bits(gb, 3); if (channel_config == 0) { skip_bits(gb, 4); tags = decode_pce(avctx, m4ac, layout_map, gb); if (tags < 0) return tags; } else { if ((ret = set_default_channel_config(avctx, layout_map, &tags, channel_config))) return ret; } if (count_channels(layout_map, tags) > 1) { m4ac->ps = 0; } else if (m4ac->sbr == 1 && m4ac->ps == -1) m4ac->ps = 1; if (ac && (ret = output_configure(ac, layout_map, tags, OC_GLOBAL_HDR, 0))) return ret; if (extension_flag) { switch (m4ac->object_type) { case AOT_ER_BSAC: skip_bits(gb, 5); skip_bits(gb, 11); break; case AOT_ER_AAC_LC: case AOT_ER_AAC_LTP: case AOT_ER_AAC_SCALABLE: case AOT_ER_AAC_LD: res_flags = get_bits(gb, 3); if (res_flags) { avpriv_report_missing_feature(avctx, "AAC data resilience (flags %x)", res_flags); return AVERROR_PATCHWELCOME; } break; } skip_bits1(gb); } switch (m4ac->object_type) { case AOT_ER_AAC_LC: case AOT_ER_AAC_LTP: case AOT_ER_AAC_SCALABLE: case AOT_ER_AAC_LD: ep_config = get_bits(gb, 2); if (ep_config) { avpriv_report_missing_feature(avctx, "epConfig %d", ep_config); return AVERROR_PATCHWELCOME; } } return 0; }<SPLIT>[-0.25365086435942685, 0.8833405720976321, 0.0, -0.2665172434374763, 0.7851368773969819, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, 1.040052222782594, 0.7680658920994683, -0.25297036047912586, 0.9338478260175336, 0.0, 0.0, 0.30852482215402843, 0.680872686764971, -0.26569807294376846, 0.8368414309979795, 1.1529012951584487, 0.6876643500811196, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2896437087679637, 0.7828741571570628, 0.9084342290881006, 0.6817979554923368, 0.5203119240003335, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, 1.039626388904333, 0.9056307075691036, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 1.0350888753871217]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { static const enum AVPixelFormat in_fmts[] = {AV_PIX_FMT_RGB32, AV_PIX_FMT_NONE}; static const enum AVPixelFormat inpal_fmts[] = {AV_PIX_FMT_RGB32, AV_PIX_FMT_NONE}; static const enum AVPixelFormat out_fmts[] = {AV_PIX_FMT_PAL8, AV_PIX_FMT_NONE}; AVFilterFormats *in = ff_make_format_list(in_fmts); AVFilterFormats *inpal = ff_make_format_list(inpal_fmts); AVFilterFormats *out = ff_make_format_list(out_fmts); if (!in || !inpal || !out) { av_freep(&in); av_freep(&inpal); av_freep(&out); return AVERROR(ENOMEM); } ff_formats_ref(in, &ctx->inputs[0]->out_formats); ff_formats_ref(inpal, &ctx->inputs[1]->out_formats); ff_formats_ref(out, &ctx->outputs[0]->in_formats); return 0; }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, 0.24712242304476825, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, -0.08904460951967552, 0.23107402248845843, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int av_opt_set(void *obj, const char *name, const char *val, int search_flags) { int ret = 0; void *dst, *target_obj; const AVOption *o = av_opt_find2(obj, name, NULL, 0, search_flags, &target_obj); if (!o || !target_obj) return AVERROR_OPTION_NOT_FOUND; if (!val && (o->type != AV_OPT_TYPE_STRING && o->type != AV_OPT_TYPE_PIXEL_FMT && o->type != AV_OPT_TYPE_SAMPLE_FMT && o->type != AV_OPT_TYPE_IMAGE_SIZE && o->type != AV_OPT_TYPE_VIDEO_RATE && o->type != AV_OPT_TYPE_DURATION && o->type != AV_OPT_TYPE_COLOR && o->type != AV_OPT_TYPE_CHANNEL_LAYOUT)) return AVERROR(EINVAL); if (o->flags & AV_OPT_FLAG_READONLY) return AVERROR(EINVAL); dst = ((uint8_t*)target_obj) + o->offset; switch (o->type) { case AV_OPT_TYPE_STRING: return set_string(obj, o, val, dst); case AV_OPT_TYPE_BINARY: return set_string_binary(obj, o, val, dst); case AV_OPT_TYPE_FLAGS: case AV_OPT_TYPE_INT: case AV_OPT_TYPE_INT64: case AV_OPT_TYPE_FLOAT: case AV_OPT_TYPE_DOUBLE: case AV_OPT_TYPE_RATIONAL: return set_string_number(obj, target_obj, o, val, dst); case AV_OPT_TYPE_IMAGE_SIZE: return set_string_image_size(obj, o, val, dst); case AV_OPT_TYPE_VIDEO_RATE: return set_string_video_rate(obj, o, val, dst); case AV_OPT_TYPE_PIXEL_FMT: return set_string_pixel_fmt(obj, o, val, dst); case AV_OPT_TYPE_SAMPLE_FMT: return set_string_sample_fmt(obj, o, val, dst); case AV_OPT_TYPE_DURATION: if (!val) { *(int64_t *)dst = 0; return 0; } else { if ((ret = av_parse_time(dst, val, 1)) < 0) av_log(obj, AV_LOG_ERROR, "Unable to parse option value \"%s\" as duration\n", val); return ret; } break; case AV_OPT_TYPE_COLOR: return set_string_color(obj, o, val, dst); case AV_OPT_TYPE_CHANNEL_LAYOUT: if (!val || !strcmp(val, "none")) { *(int64_t *)dst = 0; } else { #if FF_API_GET_CHANNEL_LAYOUT_COMPAT int64_t cl = ff_get_channel_layout(val, 0); #else int64_t cl = av_get_channel_layout(val); #endif if (!cl) { av_log(obj, AV_LOG_ERROR, "Unable to parse option value \"%s\" as channel layout\n", val); ret = AVERROR(EINVAL); } *(int64_t *)dst = cl; return ret; } break; } av_log(obj, AV_LOG_ERROR, "Invalid option type.\n"); return AVERROR(EINVAL); }<SPLIT>[-0.25365086435942685, 0.6850112317802435, 0.0, -0.2665172434374763, 0.5936279246492095, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.5882559447930196, -0.25297036047912586, 0.637540383444421, 0.0, 0.0, 0.30852482215402843, 0.5065101062381357, -0.26569807294376846, 0.5497160639660857, 1.1529012951584487, -0.4084991676475909, 0.0, 0.02378964451747194, 1.5771521192305922, 0.3599080097651364, 0.23792492798410134, 1.1342209646213146, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int compand_delay(AVFilterContext *ctx, AVFrame *frame) { CompandContext *s = ctx->priv; AVFilterLink *inlink = ctx->inputs[0]; const int channels = inlink->channels; const int nb_samples = frame->nb_samples; int chan, i, av_uninit(dindex), oindex, av_uninit(count); AVFrame *out_frame = NULL; int err; if (s->pts == AV_NOPTS_VALUE) { s->pts = (frame->pts == AV_NOPTS_VALUE) ? 0 : frame->pts; } av_assert1(channels > 0); for (chan = 0; chan < channels; chan++) { AVFrame *delay_frame = s->delay_frame; const double *src = (double *)frame->extended_data[chan]; double *dbuf = (double *)delay_frame->extended_data[chan]; ChanParam *cp = &s->channels[chan]; double *dst; count = s->delay_count; dindex = s->delay_index; for (i = 0, oindex = 0; i < nb_samples; i++) { const double in = src[i]; update_volume(cp, fabs(in)); if (count >= s->delay_samples) { if (!out_frame) { out_frame = ff_get_audio_buffer(inlink, nb_samples - i); if (!out_frame) { av_frame_free(&frame); return AVERROR(ENOMEM); } err = av_frame_copy_props(out_frame, frame); if (err < 0) { av_frame_free(&out_frame); av_frame_free(&frame); return err; } out_frame->pts = s->pts; s->pts += av_rescale_q(nb_samples - i, (AVRational){ 1, inlink->sample_rate }, inlink->time_base); } dst = (double *)out_frame->extended_data[chan]; dst[oindex++] = av_clipd(dbuf[dindex] * get_volume(s, cp->volume), -1, 1); } else { count++; } dbuf[dindex] = in; dindex = MOD(dindex + 1, s->delay_samples); } } s->delay_count = count; s->delay_index = dindex; av_frame_free(&frame); if (out_frame) { err = ff_filter_frame(ctx->outputs[0], out_frame); return err; } return 0; }<SPLIT>[-0.25365086435942685, 0.6850112317802435, 0.0, -0.2665172434374763, 0.5936279246492095, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.5882559447930196, -0.25297036047912586, 0.728711904236148, 0.0, 0.0, 0.30852482215402843, 0.5065101062381357, -0.26569807294376846, 0.63806233074513, 1.670489222080552, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.7814938157481727, 0.7283792342397666, 1.6986878034543498, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static uint32_t tf_h(uint32_t X, uint32_t L[4], int k) { uint8_t y[4], l[4]; AV_WL32(y, X); tf_h0(y, L, k); l[0] = y[0] ^ MD2[y[1]] ^ MD1[y[2]] ^ MD1[y[3]]; l[1] = MD1[y[0]] ^ MD2[y[1]] ^ MD2[y[2]] ^ y[3]; l[2] = MD2[y[0]] ^ MD1[y[1]] ^ y[2] ^ MD2[y[3]]; l[3] = MD2[y[0]] ^ y[1] ^ MD2[y[2]] ^ MD1[y[3]]; return AV_RL32(l); }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int main(int argc, char *argv[]) { FILE *f[2]; int len = 1; int shift_first= argc < 5 ? 0 : atoi(argv[4]); int skip_bytes = argc < 6 ? 0 : atoi(argv[5]); int shift_last = shift_first + (argc < 7 ? 0 : atoi(argv[6])); int shift; int max_psnr = -1; int max_psnr_shift = 0; if (shift_last > shift_first) shift_first -= shift_last - shift_first; if (argc > 3) { if (!strcmp(argv[3], "u8")) { len = 1; } else if (!strcmp(argv[3], "s16")) { len = 2; } else if (!strcmp(argv[3], "f32")) { len = 4; } else if (!strcmp(argv[3], "f64")) { len = 8; } else { char *end; len = strtol(argv[3], &end, 0); if (*end || len < 1 || len > 2) { fprintf(stderr, "Unsupported sample format: %s\nSupported: u8, s16, f32, f64\n", argv[3]); return 1; } } } if (argc < 3) { printf("tiny_psnr <file1> <file2> [<elem size>|u8|s16|f32|f64 [<shift> [<skip bytes> [<shift search range>]]]]\n"); printf("WAV headers are skipped automatically.\n"); return 1; } f[0] = fopen(argv[1], "rb"); f[1] = fopen(argv[2], "rb"); if (!f[0] || !f[1]) { fprintf(stderr, "Could not open input files.\n"); return 1; } for (shift = shift_first; shift <= shift_last; shift++) { int psnr = run_psnr(f, len, shift, skip_bytes); if (psnr > max_psnr || (shift < 0 && psnr == max_psnr)) { max_psnr = psnr; max_psnr_shift = shift; } } if (max_psnr < 0) return 2; if (shift_last > shift_first) printf("Best PSNR is %3d.%02d for shift %i\n", (int)(max_psnr / F), (int)(max_psnr % F), max_psnr_shift); return 0; }<SPLIT>[-0.25365086435942685, 0.5307550782000524, 0.0, -0.2665172434374763, 0.4446765169564977, 0.0, 2.186719866463698, 2.2318098511651505, 2.7301934809370603, 2.689180630379727, 0.44840376355467065, -0.25297036047912586, 0.5691617428506257, 0.0, 0.0, 0.30852482215402843, 0.37089476582837494, -0.26569807294376846, 0.4834563638818026, 1.0235043134279231, 3.208840440857154, 0.0, -0.08645738172306322, -0.16222078614455715, 0.4301723107623091, 1.7637827696683932, 1.0213275968547075, -0.21702784222394986, 2.204585822166557, 2.185828383526772, 2.231040724738188, 2.7292055533170707, 2.6883516673026273, 1.7623686513065309, 0.0, 2.180032226976431, 2.225208820917496, 2.722580082044891, 2.6812371144510547]
0<SPLIT>static int hvcc_array_add_nal_unit(uint8_t *nal_buf, uint32_t nal_size, uint8_t nal_type, int ps_array_completeness, HEVCDecoderConfigurationRecord *hvcc) { int ret; uint8_t index; uint16_t numNalus; HVCCNALUnitArray *array; for (index = 0; index < hvcc->numOfArrays; index++) if (hvcc->array[index].NAL_unit_type == nal_type) break; if (index >= hvcc->numOfArrays) { uint8_t i; ret = av_reallocp_array(&hvcc->array, index + 1, sizeof(HVCCNALUnitArray)); if (ret < 0) return ret; for (i = hvcc->numOfArrays; i <= index; i++) memset(&hvcc->array[i], 0, sizeof(HVCCNALUnitArray)); hvcc->numOfArrays = index + 1; } array = &hvcc->array[index]; numNalus = array->numNalus; ret = av_reallocp_array(&array->nalUnit, numNalus + 1, sizeof(uint8_t*)); if (ret < 0) return ret; ret = av_reallocp_array(&array->nalUnitLength, numNalus + 1, sizeof(uint16_t)); if (ret < 0) return ret; array->nalUnit [numNalus] = nal_buf; array->nalUnitLength[numNalus] = nal_size; array->NAL_unit_type = nal_type; array->numNalus++; if (nal_type == NAL_VPS || nal_type == NAL_SPS || nal_type == NAL_PPS) array->array_completeness = ps_array_completeness; return 0; }<SPLIT>[0.6742027098995172, 0.13409639756527525, 0.0, 0.6464191252001059, 0.06165861146095288, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 1.040052222782594, 0.2086571671460724, 0.6908592985622897, 0.1588898992878544, 0.0, 0.0, 0.30852482215402843, 0.13841132512592785, 0.66244738687495, 0.08589816337610359, -0.011671540416283347, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, 0.21937940777079099, -0.03454968660237938, -0.3333928163445767, -0.21702784222394986, 0.23959960763929639, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 1.039626388904333, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 1.0350888753871217]
0<SPLIT>static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign) { unsigned nz = idx >> 12; dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1)); sign <<= nz & 1; nz >>= 1; dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1)); sign <<= nz & 1; nz >>= 1; dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1)); sign <<= nz & 1; nz >>= 1; dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1)); return dst + 4; }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.6586564490689124, 0.7972807018539907, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.03454968660237938, -0.6720729196443977, -0.21702784222394986, 0.5203119240003335, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>static int get_siz(Jpeg2000DecoderContext *s) { int i; int ncomponents; uint32_t log2_chroma_wh = 0; const enum AVPixelFormat *possible_fmts = NULL; int possible_fmts_nb = 0; if (bytestream2_get_bytes_left(&s->g) < 36) return AVERROR_INVALIDDATA; s->avctx->profile = bytestream2_get_be16u(&s->g); s->width = bytestream2_get_be32u(&s->g); s->height = bytestream2_get_be32u(&s->g); s->image_offset_x = bytestream2_get_be32u(&s->g); s->image_offset_y = bytestream2_get_be32u(&s->g); s->tile_width = bytestream2_get_be32u(&s->g); s->tile_height = bytestream2_get_be32u(&s->g); s->tile_offset_x = bytestream2_get_be32u(&s->g); s->tile_offset_y = bytestream2_get_be32u(&s->g); ncomponents = bytestream2_get_be16u(&s->g); if (s->image_offset_x || s->image_offset_y) { avpriv_request_sample(s->avctx, "Support for image offsets"); return AVERROR_PATCHWELCOME; } if (ncomponents <= 0) { av_log(s->avctx, AV_LOG_ERROR, "Invalid number of components: %d\n", s->ncomponents); return AVERROR_INVALIDDATA; } if (ncomponents > 4) { avpriv_request_sample(s->avctx, "Support for %d components", s->ncomponents); return AVERROR_PATCHWELCOME; } s->ncomponents = ncomponents; if (s->tile_width <= 0 || s->tile_height <= 0) { av_log(s->avctx, AV_LOG_ERROR, "Invalid tile dimension %dx%d.\n", s->tile_width, s->tile_height); return AVERROR_INVALIDDATA; } if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents) return AVERROR_INVALIDDATA; for (i = 0; i < s->ncomponents; i++) { uint8_t x = bytestream2_get_byteu(&s->g); s->cbps[i] = (x & 0x7f) + 1; s->precision = FFMAX(s->cbps[i], s->precision); s->sgnd[i] = !!(x & 0x80); s->cdx[i] = bytestream2_get_byteu(&s->g); s->cdy[i] = bytestream2_get_byteu(&s->g); if ( !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4 || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) { av_log(s->avctx, AV_LOG_ERROR, "Invalid sample seperation\n"); return AVERROR_INVALIDDATA; } log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2; } s->numXtiles = ff_jpeg2000_ceildiv(s->width - s->tile_offset_x, s->tile_width); s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height); if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) { s->numXtiles = s->numYtiles = 0; return AVERROR(EINVAL); } s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile)); if (!s->tile) { s->numXtiles = s->numYtiles = 0; return AVERROR(ENOMEM); } for (i = 0; i < s->numXtiles * s->numYtiles; i++) { Jpeg2000Tile *tile = s->tile + i; tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp)); if (!tile->comp) return AVERROR(ENOMEM); } s->avctx->width = ff_jpeg2000_ceildivpow2(s->width - s->image_offset_x, s->reduction_factor); s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y, s->reduction_factor); if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) { possible_fmts = xyz_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts); } else { switch (s->colour_space) { case 16: possible_fmts = rgb_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts); break; case 17: possible_fmts = gray_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts); break; case 18: possible_fmts = yuv_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts); break; default: possible_fmts = all_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts); break; } } for (i = 0; i < possible_fmts_nb; ++i) { if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) { s->avctx->pix_fmt = possible_fmts[i]; break; } } if (i == possible_fmts_nb) { av_log(s->avctx, AV_LOG_ERROR, "Unknown pix_fmt, profile: %d, colour_space: %d, " "components: %d, precision: %d, " "cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\n", s->avctx->profile, s->colour_space, ncomponents, s->precision, ncomponents > 2 ? s->cdx[1] : 0, ncomponents > 2 ? s->cdy[1] : 0, ncomponents > 2 ? s->cdx[2] : 0, ncomponents > 2 ? s->cdy[2] : 0); return AVERROR_PATCHWELCOME; } return 0; }<SPLIT>[2.3752675960409144, 1.9851702405275684, 0.0, 2.320135801035673, 1.8490755037734952, 0.0, 1.3177536816088504, 1.3480932287791254, 1.2376156019774536, 0.380400859743741, 2.106651055380808, 2.4212136734715513, 2.073491835914121, 0.0, 0.0, 0.30852482215402843, 1.9789052306869674, 2.3640473965426008, 1.9411697657360323, 1.5410922403500262, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, 1.8354583307057633, 1.1098436946608394, 1.3600077001545285, -0.21702784222394986, 0.8010242403613708, 1.3170847170463484, 1.3475072793347742, 1.2369948159429325, 0.3801362775450152, 0.9056307075691036, 0.0, 1.3123839157220905, 1.3427725632242797, 1.2323429545022004, 0.3766295797615486]
0<SPLIT>int ff_rtmp_calc_digest_pos(const uint8_t *buf, int off, int mod_val, int add_val) { int i, digest_pos = 0; for (i = 0; i < 4; i++) digest_pos += buf[i + off]; digest_pos = digest_pos % mod_val + add_val; return digest_pos; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int hvcc_add_nal_unit(uint8_t *nal_buf, uint32_t nal_size, int ps_array_completeness, HEVCDecoderConfigurationRecord *hvcc) { int ret = 0; GetBitContext gbc; uint8_t nal_type; uint8_t *rbsp_buf; uint32_t rbsp_size; rbsp_buf = nal_unit_extract_rbsp(nal_buf, nal_size, &rbsp_size); if (!rbsp_buf) { ret = AVERROR(ENOMEM); goto end; } ret = init_get_bits8(&gbc, rbsp_buf, rbsp_size); if (ret < 0) goto end; nal_unit_parse_header(&gbc, &nal_type); switch (nal_type) { case NAL_VPS: case NAL_SPS: case NAL_PPS: case NAL_SEI_PREFIX: case NAL_SEI_SUFFIX: ret = hvcc_array_add_nal_unit(nal_buf, nal_size, nal_type, ps_array_completeness, hvcc); if (ret < 0) goto end; else if (nal_type == NAL_VPS) ret = hvcc_parse_vps(&gbc, hvcc); else if (nal_type == NAL_SPS) ret = hvcc_parse_sps(&gbc, hvcc); else if (nal_type == NAL_PPS) ret = hvcc_parse_pps(&gbc, hvcc); if (ret < 0) goto end; break; default: ret = AVERROR_INVALIDDATA; goto end; } end: av_free(rbsp_buf); return ret; }<SPLIT>[0.5195604475230265, 0.33242573788266383, 0.0, 0.4942630637605089, 0.25316756420872527, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, 0.3684882314184712, 0.5335543553887203, 0.3640258210692401, 0.0, 0.0, 0.30852482215402843, 0.29340028559422593, 0.5077564769051636, 0.28467726362895307, 0.7647103499668715, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, 0.07885080577644558, 0.23792492798410134, 0.4568607580216725, 0.6817979554923368, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int send_filter_eof(InputStream *ist) { int i, ret; for (i = 0; i < ist->nb_filters; i++) { ret = ifilter_send_eof(ist->filters[i]); if (ret < 0) return ret; } return 0; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void copy_default_source_addrs(struct RTSPSource **addrs, int count, struct RTSPSource ***dest, int *dest_count) { RTSPSource *rtsp_src, *rtsp_src2; int i; for (i = 0; i < count; i++) { rtsp_src = addrs[i]; rtsp_src2 = av_malloc(sizeof(*rtsp_src2)); if (!rtsp_src2) continue; memcpy(rtsp_src2, rtsp_src, sizeof(*rtsp_src)); dynarray_add(dest, dest_count, rtsp_src2); } }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.011671540416283347, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, 0.0744401592322129, 0.005287286955244392, -0.21702784222394986, 0.14602883551895066, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { print_stats(ctx); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static double clip(void *opaque, double val) { LutContext *s = opaque; double minval = s->var_values[VAR_MINVAL]; double maxval = s->var_values[VAR_MAXVAL]; return av_clip(val, minval, maxval); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int decode_drc_channel_exclusions(DynamicRangeControl *che_drc, GetBitContext *gb) { int i; int num_excl_chan = 0; do { for (i = 0; i < 7; i++) che_drc->exclude_mask[num_excl_chan++] = get_bits1(gb); } while (num_excl_chan < MAX_CHANNELS - 7 && get_bits1(gb)); return num_excl_chan / 7; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>AVFilterGraph *avfilter_graph_alloc(void) { AVFilterGraph *ret = av_mallocz(sizeof(*ret)); if (!ret) return NULL; ret->internal = av_mallocz(sizeof(*ret->internal)); if (!ret->internal) { av_freep(&ret); return NULL; } ret->av_class = &filtergraph_class; av_opt_set_defaults(ret); return ret; }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int ff_hevc_annexb2mp4_buf(const uint8_t *buf_in, uint8_t **buf_out, int *size, int filter_ps, int *ps_count) { AVIOContext *pb; int ret; ret = avio_open_dyn_buf(&pb); if (ret < 0) return ret; ret = ff_hevc_annexb2mp4(pb, buf_in, *size, filter_ps, ps_count); *size = avio_close_dyn_buf(pb, buf_out); return ret; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.14106852214680915, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.3070243011888601, -0.3333928163445767, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_cold int opengl_write_trailer(AVFormatContext *h) { OpenGLContext *opengl = h->priv_data; if (opengl->no_window && avdevice_dev_to_app_control_message(h, AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER, NULL , 0) < 0) av_log(opengl, AV_LOG_ERROR, "Application failed to prepare window buffer.\n"); opengl_deinit_context(opengl); opengl_release_window(h); return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int filter_frame(AVFilterLink *link, AVFrame *inpicref) { do_swap(inpicref); return ff_filter_frame(link->dst->outputs[0], inpicref); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int x11grab_read_close(AVFormatContext *s1) { X11GrabContext *x11grab = s1->priv_data; if (x11grab->use_shm) { XShmDetach(x11grab->dpy, &x11grab->shminfo); shmdt(x11grab->shminfo.shmaddr); shmctl(x11grab->shminfo.shmid, IPC_RMID, NULL); } if (x11grab->image) { XDestroyImage(x11grab->image); x11grab->image = NULL; } if (x11grab->region_win) XDestroyWindow(x11grab->dpy, x11grab->region_win); XCloseDisplay(x11grab->dpy); return 0; }<SPLIT>[0.21027592277004517, -0.2845988764381006, 0.0, 0.18995094088131478, -0.34263806656212215, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.2308782596030243, 0.21894446904158188, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, 0.19837465696559078, -0.33374660382435645, -0.011671540416283347, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.1980344553542678, -0.10760608081136262, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *in) { AVFilterContext *ctx = inlink->dst; AVFilterLink *outlink = inlink->dst->outputs[0]; EQContext *eq = ctx->priv; AVFrame *out; int64_t pos = av_frame_get_pkt_pos(in); const AVPixFmtDescriptor *desc; int i; out = ff_get_video_buffer(outlink, inlink->w, inlink->h); if (!out) return AVERROR(ENOMEM); av_frame_copy_props(out, in); desc = av_pix_fmt_desc_get(inlink->format); eq->var_values[VAR_N] = inlink->frame_count; eq->var_values[VAR_POS] = pos == -1 ? NAN : pos; eq->var_values[VAR_T] = TS2T(in->pts, inlink->time_base); if (eq->eval_mode == EVAL_MODE_FRAME) { set_gamma(eq); set_contrast(eq); set_brightness(eq); set_saturation(eq); } for (i = 0; i < desc->nb_components; i++) { int w = inlink->w; int h = inlink->h; if (i == 1 || i == 2) { w = FF_CEIL_RSHIFT(w, desc->log2_chroma_w); h = FF_CEIL_RSHIFT(h, desc->log2_chroma_h); } if (eq->param[i].adjust) eq->param[i].adjust(&eq->param[i], out->data[i], out->linesize[i], in->data[i], in->linesize[i], w, h); else av_image_copy_plane(out->data[i], out->linesize[i], in->data[i], in->linesize[i], w, h); } av_frame_free(&in); return ff_filter_frame(outlink, out); }<SPLIT>[-0.25365086435942685, 0.2222427710396702, 0.0, -0.2665172434374763, 0.14677370157107394, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.1686994010779727, -0.25297036047912586, 0.2500614200795814, 0.0, 0.0, 0.30852482215402843, 0.09966408500885333, -0.26569807294376846, 0.17424443015514782, 1.4116952586195004, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2896437087679637, 0.29241985090139744, 1.1342209646213146, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { static const enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUV411P, AV_PIX_FMT_GRAY8, AV_PIX_FMT_YUV440P, AV_PIX_FMT_YUV410P, AV_PIX_FMT_YUV420P9 , AV_PIX_FMT_YUV422P9 , AV_PIX_FMT_YUV444P9, AV_PIX_FMT_YUV420P10, AV_PIX_FMT_YUV422P10, AV_PIX_FMT_YUV444P10, AV_PIX_FMT_YUV420P12, AV_PIX_FMT_YUV422P12, AV_PIX_FMT_YUV444P12, AV_PIX_FMT_YUV420P14, AV_PIX_FMT_YUV422P14, AV_PIX_FMT_YUV444P14, AV_PIX_FMT_YUV420P16, AV_PIX_FMT_YUV422P16, AV_PIX_FMT_YUV444P16, AV_PIX_FMT_NV12, AV_PIX_FMT_NV21, AV_PIX_FMT_RGB24, AV_PIX_FMT_BGR24, AV_PIX_FMT_RGBA, AV_PIX_FMT_BGRA, AV_PIX_FMT_NONE }; AVFilterFormats *fmts_list = ff_make_format_list(pix_fmts); if (!fmts_list) return AVERROR(ENOMEM); return ff_set_common_formats(ctx, fmts_list); }<SPLIT>[-0.25365086435942685, -0.15237931622650824, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.17094161050087475, -0.25297036047912586, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int filetime_to_iso8601(char *buf, int buf_size, int64_t value) { time_t t = (value / 10000000LL) - 11644473600LL; struct tm tmbuf; struct tm *tm = gmtime_r(&t, &tmbuf); if (!tm) return -1; if (!strftime(buf, buf_size, "%Y-%m-%d %H:%M:%S", tm)) return -1; return 0; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.270465503877335, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.08904460951967552, -0.10760608081136262, -0.21702784222394986, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int dc1394_v2_close(AVFormatContext * context) { struct dc1394_data *dc1394 = context->priv_data; dc1394_video_set_transmission(dc1394->camera, DC1394_OFF); dc1394_capture_stop(dc1394->camera); dc1394_camera_free(dc1394->camera); dc1394_free(dc1394->d); return 0; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3070243011888601, -0.10760608081136262, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int a64multi_encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *p, int *got_packet) { A64Context *c = avctx->priv_data; int frame; int x, y; int b_height; int b_width; int req_size, ret; uint8_t *buf = NULL; int *charmap = c->mc_charmap; uint8_t *colram = c->mc_colram; uint8_t *charset = c->mc_charset; int *meta = c->mc_meta_charset; int *best_cb = c->mc_best_cb; int charset_size = 0x800 * (INTERLACED + 1); int colram_size = 0x100 * c->mc_use_5col; int screen_size; if(CROP_SCREENS) { b_height = FFMIN(avctx->height,C64YRES) >> 3; b_width = FFMIN(avctx->width ,C64XRES) >> 3; screen_size = b_width * b_height; } else { b_height = C64YRES >> 3; b_width = C64XRES >> 3; screen_size = 0x400; } if (!p) { if (!c->mc_lifetime) return 0; if (!c->mc_frame_counter) { c->mc_lifetime = 0; } else c->mc_lifetime = c->mc_frame_counter; } else { if (c->mc_frame_counter < c->mc_lifetime) { to_meta_with_crop(avctx, p, meta + 32000 * c->mc_frame_counter); c->mc_frame_counter++; if (c->next_pts == AV_NOPTS_VALUE) c->next_pts = p->pts; return 0; } } if (c->mc_frame_counter == c->mc_lifetime) { req_size = 0; if (c->mc_lifetime) { int alloc_size = charset_size + c->mc_lifetime*(screen_size + colram_size); if ((ret = ff_alloc_packet2(avctx, pkt, alloc_size, 0)) < 0) return ret; buf = pkt->data; ret = avpriv_init_elbg(meta, 32, 1000 * c->mc_lifetime, best_cb, CHARSET_CHARS, 50, charmap, &c->randctx); if (ret < 0) return ret; ret = avpriv_do_elbg(meta, 32, 1000 * c->mc_lifetime, best_cb, CHARSET_CHARS, 50, charmap, &c->randctx); if (ret < 0) return ret; render_charset(avctx, charset, colram); memcpy(buf, charset, charset_size); buf += charset_size; req_size += charset_size; } for (frame = 0; frame < c->mc_lifetime; frame++) { for (y = 0; y < b_height; y++) { for (x = 0; x < b_width; x++) { buf[y * b_width + x] = charmap[y * b_width + x]; } } buf += screen_size; req_size += screen_size; if (c->mc_use_5col) { a64_compress_colram(buf, charmap, colram); buf += colram_size; req_size += colram_size; } charmap += 1000; } AV_WB32(avctx->extradata + 4, c->mc_frame_counter); AV_WB32(avctx->extradata + 8, charset_size); AV_WB32(avctx->extradata + 12, screen_size + colram_size); c->mc_frame_counter = 0; pkt->pts = pkt->dts = c->next_pts; c->next_pts = AV_NOPTS_VALUE; av_assert0(pkt->size >= req_size); pkt->size = req_size; pkt->flags |= AV_PKT_FLAG_KEY; *got_packet = !!req_size; } return 0; }<SPLIT>[2.8391943831703865, 1.3240724394696066, 0.0, 2.7766039853544644, 1.2107123279475873, 0.0, 1.3177536816088504, 1.3480932287791254, 1.2376156019774536, 2.3593549488603003, 1.5672212134614623, 2.8931285029922593, 1.3897054299761684, 0.0, 0.0, 0.30852482215402843, 1.4558174891064615, 2.82812012645196, 1.2785727648932006, 2.1880771490026554, 1.3453624607183459, 0.0, -0.08645738172306322, -0.16222078614455715, 1.5544011267170725, 1.8182776925856894, 1.9244745389875635, 0.6817979554923368, 1.4560196452037908, 1.3170847170463484, 1.3475072793347742, 1.2369948159429325, 2.3586066116229683, 1.7623686513065309, 0.0, 1.3123839157220905, 1.3427725632242797, 1.2323429545022004, 2.352007466638268]
0<SPLIT>static void init_thres2(PP7Context *p) { int qp, i; int bias = 0; for (qp = 0; qp < 99; qp++) { for (i = 0; i < 16; i++) { p->thres2[qp][i] = ((i&1) ? SN2 : SN0) * ((i&4) ? SN2 : SN0) * FFMAX(1, qp) * (1<<2) - 1 - bias; } } }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.39986248560786075, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.14353953243697165, -0.3333928163445767, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int audio_read_packet(AVFormatContext *s1, AVPacket *pkt) { AlsaData *s = s1->priv_data; int res; int64_t dts; snd_pcm_sframes_t delay = 0; if (av_new_packet(pkt, s->period_size * s->frame_size) < 0) { return AVERROR(EIO); } while ((res = snd_pcm_readi(s->h, pkt->data, s->period_size)) < 0) { if (res == -EAGAIN) { av_free_packet(pkt); return AVERROR(EAGAIN); } if (ff_alsa_xrun_recover(s1, res) < 0) { av_log(s1, AV_LOG_ERROR, "ALSA read error: %s\n", snd_strerror(res)); av_free_packet(pkt); return AVERROR(EIO); } ff_timefilter_reset(s->timefilter); } dts = av_gettime(); snd_pcm_delay(s->h, &delay); dts -= av_rescale(delay + res, 1000000, s->sample_rate); pkt->pts = ff_timefilter_update(s->timefilter, dts, s->last_period); s->last_period = res; pkt->size = res * s->frame_size; return 0; }<SPLIT>[-0.25365086435942685, 0.0018768373536828752, 0.0, -0.2665172434374763, -0.06601402370422871, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.031089429262525795, -0.25297036047912586, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, -0.09407211557651925, -0.26569807294376846, -0.04662123679246273, 0.8941073316973973, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.06167779621789984, 0.12893508214950905, 0.6826474935548865, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int av_match_name(const char *name, const char *names) { const char *p; int len, namelen; if (!name || !names) return 0; namelen = strlen(name); while ((p = strchr(names, ','))) { len = FFMAX(p - names, namelen); if (!av_strncasecmp(name, names, len)) return 1; names = p + 1; } return !av_strcasecmp(name, names); }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, 0.10120102281206332, 0.11088995743869048, 0.24256368267104944, 0.7102265412631674, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, 0.11772544131424245, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, 0.23792492798410134, 0.11818065472185141, -0.21702784222394986, 0.33317037975964214, 0.10084358397375535, 0.11056045576999526, 0.24218765769350709, 0.7098813332246741, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.23885153614040697, 0.7058592275743352]
0<SPLIT>int ff_opencl_unsharp_process_inout_buf(AVFilterContext *ctx, AVFrame *in, AVFrame *out) { int ret = 0; AVFilterLink *link = ctx->inputs[0]; UnsharpContext *unsharp = ctx->priv; int ch = FF_CEIL_RSHIFT(link->h, unsharp->vsub); if ((!unsharp->opencl_ctx.cl_inbuf) || (!unsharp->opencl_ctx.cl_outbuf)) { unsharp->opencl_ctx.in_plane_size[0] = (in->linesize[0] * in->height); unsharp->opencl_ctx.in_plane_size[1] = (in->linesize[1] * ch); unsharp->opencl_ctx.in_plane_size[2] = (in->linesize[2] * ch); unsharp->opencl_ctx.out_plane_size[0] = (out->linesize[0] * out->height); unsharp->opencl_ctx.out_plane_size[1] = (out->linesize[1] * ch); unsharp->opencl_ctx.out_plane_size[2] = (out->linesize[2] * ch); unsharp->opencl_ctx.cl_inbuf_size = unsharp->opencl_ctx.in_plane_size[0] + unsharp->opencl_ctx.in_plane_size[1] + unsharp->opencl_ctx.in_plane_size[2]; unsharp->opencl_ctx.cl_outbuf_size = unsharp->opencl_ctx.out_plane_size[0] + unsharp->opencl_ctx.out_plane_size[1] + unsharp->opencl_ctx.out_plane_size[2]; if (!unsharp->opencl_ctx.cl_inbuf) { ret = av_opencl_buffer_create(&unsharp->opencl_ctx.cl_inbuf, unsharp->opencl_ctx.cl_inbuf_size, CL_MEM_READ_ONLY, NULL); if (ret < 0) return ret; } if (!unsharp->opencl_ctx.cl_outbuf) { ret = av_opencl_buffer_create(&unsharp->opencl_ctx.cl_outbuf, unsharp->opencl_ctx.cl_outbuf_size, CL_MEM_READ_WRITE, NULL); if (ret < 0) return ret; } } return av_opencl_buffer_write_image(unsharp->opencl_ctx.cl_inbuf, unsharp->opencl_ctx.cl_inbuf_size, 0, in->data, unsharp->opencl_ctx.in_plane_size, unsharp->opencl_ctx.plane_num); }<SPLIT>[-0.25365086435942685, 0.20020617767107143, 0.0, -0.2665172434374763, 0.12549492904354367, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, 1.3698779043020206, 0.14872051804392286, -0.25297036047912586, 0.22726853988164963, 0.0, 0.0, 0.30852482215402843, 0.08029046495031608, -0.26569807294376846, 0.15215786346038676, -0.270465503877335, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.03454968660237938, -0.22049944857796966, -0.21702784222394986, 0.14602883551895066, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, 1.3693714445839917, 1.7623686513065309, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 1.3643185231999084]
0<SPLIT>static void make_bands(int16_t* bands, int start, int stop, int num_bands) { int k, previous, present; int base, prod, nz = 0; base = (stop << 23) / start; while (base < 0x40000000){ base <<= 1; nz++; } base = fixed_log(base - 0x80000000); base = (((base + 0x80) >> 8) + (8-nz)*CONST_LN2) / num_bands; base = fixed_exp(base); previous = start; prod = start << 23; for (k = 0; k < num_bands-1; k++) { prod = (int)(((int64_t)prod * base + 0x400000) >> 23); present = (prod + 0x400000) >> 23; bands[k] = present - previous; previous = present; } bands[num_bands-1] = stop - previous; }<SPLIT>[-0.25365086435942685, -0.17441590959510697, 0.0, -0.2665172434374763, -0.23624420392447085, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.1909204935349246, -0.25297036047912586, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.26569807294376846, -0.22331377035055117, -0.270465503877335, 0.7972807018539907, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, 0.4559046196532859, 0.11818065472185141, -0.21702784222394986, 0.7074534682410251, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void vector_fmul_c(int *dst, const int *src0, const int *src1, int len) { int i; int64_t accu; for (i = 0; i < len; i++){ accu = (int64_t)src0[i] * src1[i]; dst[i] = (int)((accu+0x40000000) >> 31); } }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.4705090699407485, -0.6720729196443977, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static double get_f64l(uint8_t *p) { return av_int2double(AV_RL64(p)); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int configure_output_filter(FilterGraph *fg, OutputFilter *ofilter, AVFilterInOut *out) { if (!ofilter->ost) { av_log(NULL, AV_LOG_FATAL, "Filter %s has an unconnected output\n", ofilter->name); exit_program(1); } switch (avfilter_pad_get_type(out->filter_ctx->output_pads, out->pad_idx)) { case AVMEDIA_TYPE_VIDEO: return configure_output_video_filter(fg, ofilter, out); case AVMEDIA_TYPE_AUDIO: return configure_output_audio_filter(fg, ofilter, out); default: av_assert0(0); } }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.011671540416283347, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.25252937827156396, -0.10760608081136262, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int asf_read_generic_value(AVIOContext *pb, int type, uint64_t *value) { switch (type) { case ASF_BOOL: *value = avio_rl16(pb); break; case ASF_DWORD: *value = avio_rl32(pb); break; case ASF_QWORD: *value = avio_rl64(pb); break; case ASF_WORD: *value = avio_rl16(pb); break; default: return AVERROR_INVALIDDATA; } return 0; }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.39986248560786075, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.08904460951967552, -0.4462861841111837, 0.6817979554923368, 0.14602883551895066, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, 0.04889276383167627, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void subband_scale(int *dst, int *src, int scale, int offset, int len) { int ssign = scale < 0 ? -1 : 1; int s = FFABS(scale); unsigned int round; int i, out, c = exp2tab[s & 3]; s = offset - (s >> 2); if (s > 0) { round = 1 << (s-1); for (i=0; i<len; i++) { out = (int)(((int64_t)src[i] * c) >> 32); dst[i] = ((int)(out+round) >> s) * ssign; } } else { s = s + 32; round = 1 << (s-1); for (i=0; i<len; i++) { out = (int)((int64_t)((int64_t)src[i] * c + round) >> s); dst[i] = out * ssign; } } }<SPLIT>[-0.25365086435942685, -0.15237931622650824, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, -0.17094161050087475, -0.25297036047912586, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, -0.270465503877335, 0.7972807018539907, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, 0.40140969673598975, 0.005287286955244392, -0.21702784222394986, 0.7074534682410251, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static int process_metadata(AVFormatContext *s, const uint8_t *name, uint16_t name_len, uint16_t val_len, uint16_t type, AVDictionary **met) { int ret; ff_asf_guid guid; if (val_len) { switch (type) { case ASF_UNICODE: asf_read_value(s, name, name_len, val_len, type, met); break; case ASF_BYTE_ARRAY: if (!strcmp(name, "WM/Picture")) asf_read_picture(s, val_len); else if (!strcmp(name, "ID3")) get_id3_tag(s, val_len); else asf_read_value(s, name, name_len, val_len, type, met); break; case ASF_GUID: ff_get_guid(s->pb, &guid); break; default: if ((ret = asf_set_metadata(s, name, name_len, type, met)) < 0) return ret; break; } } return 0; }<SPLIT>[-0.25365086435942685, -0.020159756014915854, 0.0, -0.2665172434374763, -0.08729279623175898, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.051068312296575644, -0.25297036047912586, -0.0006602620976677653, 0.0, 0.0, 0.30852482215402843, -0.1134457356350565, -0.26569807294376846, -0.06870780348722379, 0.24712242304476825, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.1980344553542678, 0.005287286955244392, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_cold int init(AVFilterContext *ctx) { CropDetectContext *s = ctx->priv; s->frame_nb = -2; av_log(ctx, AV_LOG_VERBOSE, "limit:%f round:%d reset_count:%d\n", s->limit, s->round, s->reset_count); return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int dxva2_get_decoder_configuration(AVCodecContext *s, const GUID *device_guid, const DXVA2_VideoDesc *desc, DXVA2_ConfigPictureDecode *config) { InputStream *ist = s->opaque; int loglevel = (ist->hwaccel_id == HWACCEL_AUTO) ? AV_LOG_VERBOSE : AV_LOG_ERROR; DXVA2Context *ctx = ist->hwaccel_ctx; unsigned cfg_count = 0, best_score = 0; DXVA2_ConfigPictureDecode *cfg_list = NULL; DXVA2_ConfigPictureDecode best_cfg = {{0}}; HRESULT hr; int i; hr = IDirectXVideoDecoderService_GetDecoderConfigurations(ctx->decoder_service, device_guid, desc, NULL, &cfg_count, &cfg_list); if (FAILED(hr)) { av_log(NULL, loglevel, "Unable to retrieve decoder configurations\n"); return AVERROR(EINVAL); } for (i = 0; i < cfg_count; i++) { DXVA2_ConfigPictureDecode *cfg = &cfg_list[i]; unsigned score; if (cfg->ConfigBitstreamRaw == 1) score = 1; else if (s->codec_id == AV_CODEC_ID_H264 && cfg->ConfigBitstreamRaw == 2) score = 2; else continue; if (IsEqualGUID(&cfg->guidConfigBitstreamEncryption, &DXVA2_NoEncrypt)) score += 16; if (score > best_score) { best_score = score; best_cfg = *cfg; } } CoTaskMemFree(cfg_list); if (!best_score) { av_log(NULL, loglevel, "No valid decoder configuration available\n"); return AVERROR(EINVAL); } *config = best_cfg; return 0; }<SPLIT>[-0.25365086435942685, 0.24427936440826892, 0.0, -0.2665172434374763, 0.16805247409860422, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, 0.7102265412631674, 0.18867828411202256, -0.25297036047912586, 0.2728543002775131, 0.0, 0.0, 0.30852482215402843, 0.11903770506739059, -0.26569807294376846, 0.19633099684990887, 0.7647103499668715, 0.9068970536268617, 0.0, -0.08645738172306322, -0.16222078614455715, 0.21937940777079099, 0.7283792342397666, 0.4568607580216725, -0.21702784222394986, 0.8945950124817165, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, 0.7098813332246741, 0.9056307075691036, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 0.7058592275743352]
0<SPLIT>static int select_cur_seq_no(HLSContext *c, struct playlist *pls) { int seq_no; if (!pls->finished && !c->first_packet && av_gettime_relative() - pls->last_load_time >= default_reload_interval(pls)) parse_playlist(c, pls->url, pls, NULL); if (pls->finished && c->cur_timestamp != AV_NOPTS_VALUE) { find_timestamp_in_playlist(c, pls, c->cur_timestamp, &seq_no); return seq_no; } if (!pls->finished) { if (!c->first_packet && c->cur_seq_no >= pls->start_seq_no && c->cur_seq_no < pls->start_seq_no + pls->n_segments) return c->cur_seq_no; if (c->live_start_index < 0) return pls->start_seq_no + FFMAX(pls->n_segments + c->live_start_index, 0); else return pls->start_seq_no + FFMIN(c->live_start_index, pls->n_segments - 1); } return pls->start_seq_no; }<SPLIT>[1.4474140217819704, -0.17441590959510697, 0.0, 1.4071994323980908, -0.23624420392447085, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.02884721983962376, 1.477384014430136, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.03595125540090747, 1.4359019367238823, -0.22331377035055117, -0.011671540416283347, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.08904460951967552, 0.11818065472185141, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int mxf_add_metadata_set(MXFContext *mxf, void *metadata_set) { MXFMetadataSet **tmp; tmp = av_realloc_array(mxf->metadata_sets, mxf->metadata_sets_count + 1, sizeof(*mxf->metadata_sets)); if (!tmp) return AVERROR(ENOMEM); mxf->metadata_sets = tmp; mxf->metadata_sets[mxf->metadata_sets_count] = metadata_set; mxf->metadata_sets_count++; return 0; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int64_t av_gettime_monotonic(void) { return av_gettime_relative(); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int ff_rtsp_send_cmd_async(AVFormatContext *s, const char *method, const char *url, const char *headers) { return rtsp_send_cmd_with_content_async(s, method, url, headers, NULL, 0); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int lex_fixed(struct sbg_parser *p, const char *t, int l) { if (p->end - p->cursor < l || memcmp(p->cursor, t, l)) return 0; p->cursor += l; return 1; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { LutContext *s = ctx->priv; const enum AVPixelFormat *pix_fmts = s->is_rgb ? rgb_pix_fmts : s->is_yuv ? yuv_pix_fmts : all_pix_fmts; AVFilterFormats *fmts_list = ff_make_format_list(pix_fmts); if (!fmts_list) return AVERROR(ENOMEM); return ff_set_common_formats(ctx, fmts_list); }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int decoder_decode_frame(Decoder *d, AVFrame *frame, AVSubtitle *sub) { int got_frame = 0; do { int ret = -1; if (d->queue->abort_request) return -1; if (!d->packet_pending || d->queue->serial != d->pkt_serial) { AVPacket pkt; do { if (d->queue->nb_packets == 0) SDL_CondSignal(d->empty_queue_cond); if (packet_queue_get(d->queue, &pkt, 1, &d->pkt_serial) < 0) return -1; if (pkt.data == flush_pkt.data) { avcodec_flush_buffers(d->avctx); d->finished = 0; d->next_pts = d->start_pts; d->next_pts_tb = d->start_pts_tb; } } while (pkt.data == flush_pkt.data || d->queue->serial != d->pkt_serial); av_packet_unref(&d->pkt); d->pkt_temp = d->pkt = pkt; d->packet_pending = 1; } switch (d->avctx->codec_type) { case AVMEDIA_TYPE_VIDEO: ret = avcodec_decode_video2(d->avctx, frame, &got_frame, &d->pkt_temp); if (got_frame) { if (decoder_reorder_pts == -1) { frame->pts = av_frame_get_best_effort_timestamp(frame); } else if (!decoder_reorder_pts) { frame->pts = frame->pkt_dts; } } break; case AVMEDIA_TYPE_AUDIO: ret = avcodec_decode_audio4(d->avctx, frame, &got_frame, &d->pkt_temp); if (got_frame) { AVRational tb = (AVRational){1, frame->sample_rate}; if (frame->pts != AV_NOPTS_VALUE) frame->pts = av_rescale_q(frame->pts, av_codec_get_pkt_timebase(d->avctx), tb); else if (d->next_pts != AV_NOPTS_VALUE) frame->pts = av_rescale_q(d->next_pts, d->next_pts_tb, tb); if (frame->pts != AV_NOPTS_VALUE) { d->next_pts = frame->pts + frame->nb_samples; d->next_pts_tb = tb; } } break; case AVMEDIA_TYPE_SUBTITLE: ret = avcodec_decode_subtitle2(d->avctx, sub, &got_frame, &d->pkt_temp); break; } if (ret < 0) { d->packet_pending = 0; } else { d->pkt_temp.dts = d->pkt_temp.pts = AV_NOPTS_VALUE; if (d->pkt_temp.data) { if (d->avctx->codec_type != AVMEDIA_TYPE_AUDIO) ret = d->pkt_temp.size; d->pkt_temp.data += ret; d->pkt_temp.size -= ret; if (d->pkt_temp.size <= 0) d->packet_pending = 0; } else { if (!got_frame) { d->packet_pending = 0; d->finished = d->pkt_serial; } } } } while (!got_frame && !d->finished); return got_frame; }<SPLIT>[-0.25365086435942685, 0.9935235389406257, 0.0, -0.2665172434374763, 0.8915307400346333, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.8679603072697175, -0.25297036047912586, 1.0478122270071923, 0.0, 0.0, 0.30852482215402843, 0.7777407870576574, -0.26569807294376846, 0.9472742644717848, 0.6353133682363457, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.6058330632552409, 0.01994523631491676, 0.5697541257882794, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold int initialize(AVFilterContext *ctx) { FFTFILTContext *fftfilt = ctx->priv; int ret = 0, plane; if (!fftfilt->dc[U] && !fftfilt->dc[V]) { fftfilt->dc[U] = fftfilt->dc[Y]; fftfilt->dc[V] = fftfilt->dc[Y]; } else { if (!fftfilt->dc[U]) fftfilt->dc[U] = fftfilt->dc[V]; if (!fftfilt->dc[V]) fftfilt->dc[V] = fftfilt->dc[U]; } if (!fftfilt->weight_str[U] && !fftfilt->weight_str[V]) { fftfilt->weight_str[U] = av_strdup(fftfilt->weight_str[Y]); fftfilt->weight_str[V] = av_strdup(fftfilt->weight_str[Y]); } else { if (!fftfilt->weight_str[U]) fftfilt->weight_str[U] = av_strdup(fftfilt->weight_str[V]); if (!fftfilt->weight_str[V]) fftfilt->weight_str[V] = av_strdup(fftfilt->weight_str[U]); } for (plane = 0; plane < 3; plane++) { static double (*p[])(void *, double, double) = { weight_Y, weight_U, weight_V }; const char *const func2_names[] = {"weight_Y", "weight_U", "weight_V", NULL }; double (*func2[])(void *, double, double) = { weight_Y, weight_U, weight_V, p[plane], NULL }; ret = av_expr_parse(&fftfilt->weight_expr[plane], fftfilt->weight_str[plane], var_names, NULL, NULL, func2_names, func2, 0, ctx); if (ret < 0) break; } return ret; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.08729279623175898, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.1134457356350565, -0.26569807294376846, -0.06870780348722379, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.06167779621789984, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>DitherContext *ff_dither_alloc(AVAudioResampleContext *avr, enum AVSampleFormat out_fmt, enum AVSampleFormat in_fmt, int channels, int sample_rate, int apply_map) { AVLFG seed_gen; DitherContext *c; int ch; if (av_get_packed_sample_fmt(out_fmt) != AV_SAMPLE_FMT_S16 || av_get_bytes_per_sample(in_fmt) <= 2) { av_log(avr, AV_LOG_ERROR, "dithering %s to %s is not supported\n", av_get_sample_fmt_name(in_fmt), av_get_sample_fmt_name(out_fmt)); return NULL; } c = av_mallocz(sizeof(*c)); if (!c) return NULL; c->apply_map = apply_map; if (apply_map) c->ch_map_info = &avr->ch_map_info; if (avr->dither_method == AV_RESAMPLE_DITHER_TRIANGULAR_NS && sample_rate != 48000 && sample_rate != 44100) { av_log(avr, AV_LOG_WARNING, "sample rate must be 48000 or 44100 Hz " "for triangular_ns dither. using triangular_hp instead.\n"); avr->dither_method = AV_RESAMPLE_DITHER_TRIANGULAR_HP; } c->method = avr->dither_method; dither_init(&c->ddsp, c->method); if (c->method == AV_RESAMPLE_DITHER_TRIANGULAR_NS) { if (sample_rate == 48000) { c->ns_coef_b = ns_48_coef_b; c->ns_coef_a = ns_48_coef_a; } else { c->ns_coef_b = ns_44_coef_b; c->ns_coef_a = ns_44_coef_a; } } if (out_fmt != AV_SAMPLE_FMT_S16P) { c->s16_data = ff_audio_data_alloc(channels, 1024, AV_SAMPLE_FMT_S16P, "dither s16 buffer"); if (!c->s16_data) goto fail; c->ac_out = ff_audio_convert_alloc(avr, out_fmt, AV_SAMPLE_FMT_S16P, channels, sample_rate, 0); if (!c->ac_out) goto fail; } if (in_fmt != AV_SAMPLE_FMT_FLTP || c->apply_map) { c->flt_data = ff_audio_data_alloc(channels, 1024, AV_SAMPLE_FMT_FLTP, "dither flt buffer"); if (!c->flt_data) goto fail; } if (in_fmt != AV_SAMPLE_FMT_FLTP) { c->ac_in = ff_audio_convert_alloc(avr, AV_SAMPLE_FMT_FLTP, in_fmt, channels, sample_rate, c->apply_map); if (!c->ac_in) goto fail; } c->state = av_mallocz(channels * sizeof(*c->state)); if (!c->state) goto fail; c->channels = channels; c->mute_dither_threshold = lrintf(sample_rate * MUTE_THRESHOLD_SEC); c->mute_reset_threshold = c->mute_dither_threshold * 4; av_lfg_init(&seed_gen, 0xC0FFEE); for (ch = 0; ch < channels; ch++) { DitherState *state = &c->state[ch]; state->mute = c->mute_reset_threshold + 1; state->seed = av_lfg_get(&seed_gen); generate_dither_noise(c, state, FFMAX(32768, sample_rate / 2)); } return c; fail: ff_dither_free(&c); return NULL; }<SPLIT>[0.6742027098995172, 1.0375967256778231, 0.0, 0.6464191252001059, 0.9340882850896938, 0.0, 1.8391333925217592, 1.8783232022107403, 1.7351415616306558, 2.3593549488603003, 1.0277913715421163, 0.6908592985622897, 1.0933979874030557, 0.0, 0.0, 0.30852482215402843, 0.9327297475259554, 0.66244738687495, 0.9914473978613069, 1.1529012951584487, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, 0.7112295147509999, 1.3823183092473201, 1.1342209646213146, 0.6817979554923368, 1.3624488730834452, 1.8383309169346027, 1.8776273465768223, 1.7343983950676451, 2.3586066116229683, 0.9056307075691036, 0.0, 1.832972902474695, 1.8722343178402097, 1.7290886636830973, 2.352007466638268]
0<SPLIT>int av_utf8_decode(int32_t *codep, const uint8_t **bufp, const uint8_t *buf_end, unsigned int flags) { const uint8_t *p = *bufp; uint32_t top; uint64_t code; int ret = 0, tail_len; uint32_t overlong_encoding_mins[6] = { 0x00000000, 0x00000080, 0x00000800, 0x00010000, 0x00200000, 0x04000000, }; if (p >= buf_end) return 0; code = *p++; if ((code & 0xc0) == 0x80 || code >= 0xFE) { ret = AVERROR(EILSEQ); goto end; } top = (code & 128) >> 1; tail_len = 0; while (code & top) { int tmp; tail_len++; if (p >= buf_end) { (*bufp) ++; return AVERROR(EILSEQ); } tmp = *p++ - 128; if (tmp>>6) { (*bufp) ++; return AVERROR(EILSEQ); } code = (code<<6) + tmp; top <<= 5; } code &= (top << 1) - 1; av_assert0(tail_len <= 5); if (code < overlong_encoding_mins[tail_len]) { ret = AVERROR(EILSEQ); goto end; } if (code >= 1U<<31) { ret = AVERROR(EILSEQ); goto end; } *codep = code; if (code > 0x10FFFF && !(flags & AV_UTF8_FLAG_ACCEPT_INVALID_BIG_CODES)) ret = AVERROR(EILSEQ); if (code < 0x20 && code != 0x9 && code != 0xA && code != 0xD && flags & AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES) ret = AVERROR(EILSEQ); if (code >= 0xD800 && code <= 0xDFFF && !(flags & AV_UTF8_FLAG_ACCEPT_SURROGATES)) ret = AVERROR(EILSEQ); if ((code == 0xFFFE || code == 0xFFFF) && !(flags & AV_UTF8_FLAG_ACCEPT_NON_CHARACTERS)) ret = AVERROR(EILSEQ); end: *bufp = p; return ret; }<SPLIT>[0.36491818514653585, 0.6850112317802435, 0.0, 0.34210700232091185, 0.5936279246492095, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 1.040052222782594, 0.668171476929219, 0.3762494122151511, 0.728711904236148, 0.0, 0.0, 0.30852482215402843, 0.5840045864722848, 0.35306556693537716, 0.63806233074513, -0.011671540416283347, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, 0.4653044612608955, 0.3469147738186936, 0.005287286955244392, 0.6817979554923368, 0.5203119240003335, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 1.039626388904333, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 1.0350888753871217]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *in) { int direct = 0; AVFilterContext *ctx = inlink->dst; OWDenoiseContext *s = ctx->priv; AVFilterLink *outlink = ctx->outputs[0]; AVFrame *out; const int cw = FF_CEIL_RSHIFT(inlink->w, s->hsub); const int ch = FF_CEIL_RSHIFT(inlink->h, s->vsub); if (av_frame_is_writable(in)) { direct = 1; out = in; } else { out = ff_get_video_buffer(outlink, outlink->w, outlink->h); if (!out) { av_frame_free(&in); return AVERROR(ENOMEM); } av_frame_copy_props(out, in); } filter(s, out->data[0], out->linesize[0], in->data[0], in->linesize[0], inlink->w, inlink->h, s->luma_strength); filter(s, out->data[1], out->linesize[1], in->data[1], in->linesize[1], cw, ch, s->chroma_strength); filter(s, out->data[2], out->linesize[2], in->data[2], in->linesize[2], cw, ch, s->chroma_strength); if (!direct) { if (in->data[3]) av_image_copy_plane(out->data[3], out->linesize[3], in ->data[3], in ->linesize[3], inlink->w, inlink->h); av_frame_free(&in); } return ff_filter_frame(outlink, out); }<SPLIT>[-0.25365086435942685, 0.04595002409088034, 0.0, -0.2665172434374763, -0.02345647864916818, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.008868336805573909, -0.25297036047912586, 0.06771837849612745, 0.0, 0.0, 0.30852482215402843, -0.05532487545944473, -0.26569807294376846, -0.0024481034029406237, 0.6353133682363457, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, 0.18343000506680518, 0.5697541257882794, -0.21702784222394986, -0.13468348084208653, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static int matroska_read_header(AVFormatContext *s) { MatroskaDemuxContext *matroska = s->priv_data; EbmlList *attachments_list = &matroska->attachments; EbmlList *chapters_list = &matroska->chapters; MatroskaAttachment *attachments; MatroskaChapter *chapters; uint64_t max_start = 0; int64_t pos; Ebml ebml = { 0 }; int i, j, res; matroska->ctx = s; matroska->cues_parsing_deferred = 1; if (ebml_parse(matroska, ebml_syntax, &ebml) || !ebml.doctype) { av_log(matroska->ctx, AV_LOG_ERROR, "EBML header parsing failed\n"); ebml_free(ebml_syntax, &ebml); return AVERROR_INVALIDDATA; } if (ebml.version > EBML_VERSION || ebml.max_size > sizeof(uint64_t) || ebml.id_length > sizeof(uint32_t) || ebml.doctype_version > 3) { av_log(matroska->ctx, AV_LOG_ERROR, "EBML header using unsupported features\n" "(EBML version %"PRIu64", doctype %s, doc version %"PRIu64")\n", ebml.version, ebml.doctype, ebml.doctype_version); ebml_free(ebml_syntax, &ebml); return AVERROR_PATCHWELCOME; } else if (ebml.doctype_version == 3) { av_log(matroska->ctx, AV_LOG_WARNING, "EBML header using unsupported features\n" "(EBML version %"PRIu64", doctype %s, doc version %"PRIu64")\n", ebml.version, ebml.doctype, ebml.doctype_version); } for (i = 0; i < FF_ARRAY_ELEMS(matroska_doctypes); i++) if (!strcmp(ebml.doctype, matroska_doctypes[i])) break; if (i >= FF_ARRAY_ELEMS(matroska_doctypes)) { av_log(s, AV_LOG_WARNING, "Unknown EBML doctype '%s'\n", ebml.doctype); if (matroska->ctx->error_recognition & AV_EF_EXPLODE) { ebml_free(ebml_syntax, &ebml); return AVERROR_INVALIDDATA; } } ebml_free(ebml_syntax, &ebml); pos = avio_tell(matroska->ctx->pb); res = ebml_parse(matroska, matroska_segments, matroska); while (res != 1) { res = matroska_resync(matroska, pos); if (res < 0) return res; pos = avio_tell(matroska->ctx->pb); res = ebml_parse(matroska, matroska_segment, matroska); } matroska_execute_seekhead(matroska); if (!matroska->time_scale) matroska->time_scale = 1000000; if (matroska->duration) matroska->ctx->duration = matroska->duration * matroska->time_scale * 1000 / AV_TIME_BASE; av_dict_set(&s->metadata, "title", matroska->title, 0); av_dict_set(&s->metadata, "encoder", matroska->muxingapp, 0); if (matroska->date_utc.size == 8) matroska_metadata_creation_time(&s->metadata, AV_RB64(matroska->date_utc.data)); res = matroska_parse_tracks(s); if (res < 0) return res; attachments = attachments_list->elem; for (j = 0; j < attachments_list->nb_elem; j++) { if (!(attachments[j].filename && attachments[j].mime && attachments[j].bin.data && attachments[j].bin.size > 0)) { av_log(matroska->ctx, AV_LOG_ERROR, "incomplete attachment\n"); } else { AVStream *st = avformat_new_stream(s, NULL); if (!st) break; av_dict_set(&st->metadata, "filename", attachments[j].filename, 0); av_dict_set(&st->metadata, "mimetype", attachments[j].mime, 0); st->codec->codec_id = AV_CODEC_ID_NONE; for (i = 0; ff_mkv_image_mime_tags[i].id != AV_CODEC_ID_NONE; i++) { if (!strncmp(ff_mkv_image_mime_tags[i].str, attachments[j].mime, strlen(ff_mkv_image_mime_tags[i].str))) { st->codec->codec_id = ff_mkv_image_mime_tags[i].id; break; } } attachments[j].stream = st; if (st->codec->codec_id != AV_CODEC_ID_NONE) { st->disposition |= AV_DISPOSITION_ATTACHED_PIC; st->codec->codec_type = AVMEDIA_TYPE_VIDEO; av_init_packet(&st->attached_pic); if ((res = av_new_packet(&st->attached_pic, attachments[j].bin.size)) < 0) return res; memcpy(st->attached_pic.data, attachments[j].bin.data, attachments[j].bin.size); st->attached_pic.stream_index = st->index; st->attached_pic.flags |= AV_PKT_FLAG_KEY; } else { st->codec->codec_type = AVMEDIA_TYPE_ATTACHMENT; if (ff_alloc_extradata(st->codec, attachments[j].bin.size)) break; memcpy(st->codec->extradata, attachments[j].bin.data, attachments[j].bin.size); for (i = 0; ff_mkv_mime_tags[i].id != AV_CODEC_ID_NONE; i++) { if (!strncmp(ff_mkv_mime_tags[i].str, attachments[j].mime, strlen(ff_mkv_mime_tags[i].str))) { st->codec->codec_id = ff_mkv_mime_tags[i].id; break; } } } } } chapters = chapters_list->elem; for (i = 0; i < chapters_list->nb_elem; i++) if (chapters[i].start != AV_NOPTS_VALUE && chapters[i].uid && (max_start == 0 || chapters[i].start > max_start)) { chapters[i].chapter = avpriv_new_chapter(s, chapters[i].uid, (AVRational) { 1, 1000000000 }, chapters[i].start, chapters[i].end, chapters[i].title); if (chapters[i].chapter) { av_dict_set(&chapters[i].chapter->metadata, "title", chapters[i].title, 0); } max_start = chapters[i].start; } matroska_add_index_entries(matroska); matroska_convert_tags(s); return 0; }<SPLIT>[0.21027592277004517, 2.2275727675821546, 0.0, 0.18995094088131478, 2.083142001576328, 0.0, 0.9701672076669112, 0.9946065798247155, 0.9059316288753189, 0.7102265412631674, 2.046714406278659, 0.21894446904158188, 2.3242135180913697, 0.0, 0.0, 0.30852482215402843, 1.9207843705113556, 0.19837465696559078, 2.184121999378404, 2.0586801672721293, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, 1.9759869327001087, 1.273328463412728, 2.0373679067541706, -0.21702784222394986, 0.5203119240003335, 0.969587250454179, 0.9940939011734088, 0.9053924298597907, 0.7098813332246741, 0.9056307075691036, 0.0, 0.9653245912203542, 0.9897980601469931, 0.9011791483816026, 0.7058592275743352]
0<SPLIT>static void init_multbl2(uint32_t tbl[][256], const int c[4], const uint8_t *log8, const uint8_t *alog8, const uint8_t *sbox) { int i; for (i = 0; i < 256; i++) { int x = sbox[i]; if (x) { int k, l, m, n; x = log8[x]; k = alog8[x + log8[c[0]]]; l = alog8[x + log8[c[1]]]; m = alog8[x + log8[c[2]]]; n = alog8[x + log8[c[3]]]; tbl[0][i] = AV_NE(MKBETAG(k,l,m,n), MKTAG(k,l,m,n)); #if !CONFIG_SMALL tbl[1][i] = ROT(tbl[0][i], 8); tbl[2][i] = ROT(tbl[0][i], 16); tbl[3][i] = ROT(tbl[0][i], 24); #endif } } }<SPLIT>[-0.25365086435942685, -0.15237931622650824, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.17094161050087475, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, -0.26569807294376846, -0.24540033704531222, 0.11772544131424245, -0.1892664641018488, 0.0, -0.08645738172306322, 0.9973611507722091, -0.20220639821224526, 0.0744401592322129, 0.34396739025506545, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { SelectContext *select = ctx->priv; if (!select->do_scene_detect) { return ff_default_query_formats(ctx); } else { int ret; static const enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_RGB24, AV_PIX_FMT_BGR24, AV_PIX_FMT_NONE }; AVFilterFormats *fmts_list = ff_make_format_list(pix_fmts); if (!fmts_list) return AVERROR(ENOMEM); ret = ff_set_common_formats(ctx, fmts_list); if (ret < 0) return ret; } return 0; }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.011671540416283347, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.08904460951967552, 0.005287286955244392, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int nut_read_close(AVFormatContext *s) { NUTContext *nut = s->priv_data; int i; av_freep(&nut->time_base); av_freep(&nut->stream); ff_nut_free_sp(nut); for (i = 1; i < nut->header_count; i++) av_freep(&nut->header[i]); return 0; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void chrRangeToJpeg16_c(int16_t *_dstU, int16_t *_dstV, int width) { int i; int32_t *dstU = (int32_t *) _dstU; int32_t *dstV = (int32_t *) _dstV; for (i = 0; i < width; i++) { dstU[i] = (FFMIN(dstU[i], 30775 << 4) * 4663 - (9289992 << 4)) >> 12; dstV[i] = (FFMIN(dstV[i], 30775 << 4) * 4663 - (9289992 << 4)) >> 12; } }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int filter_frame_left(AVFilterLink *inlink, AVFrame *frame) { FramepackContext *s = inlink->dst->priv; s->input_views[LEFT] = frame; return 0; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.7880534307994381, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int config_input(AVFilterLink *inlink) { AVFilterContext *ctx = inlink->dst; FSPPContext *fspp = ctx->priv; const int h = FFALIGN(inlink->h + 16, 16); const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format); fspp->hsub = desc->log2_chroma_w; fspp->vsub = desc->log2_chroma_h; fspp->temp_stride = FFALIGN(inlink->w + 16, 16); fspp->temp = av_malloc_array(fspp->temp_stride, h * sizeof(*fspp->temp)); fspp->src = av_malloc_array(fspp->temp_stride, h * sizeof(*fspp->src)); if (!fspp->temp || !fspp->src) return AVERROR(ENOMEM); if (!fspp->use_bframe_qp && !fspp->qp) { fspp->non_b_qp_alloc_size = FF_CEIL_RSHIFT(inlink->w, 4) * FF_CEIL_RSHIFT(inlink->h, 4); fspp->non_b_qp_table = av_calloc(fspp->non_b_qp_alloc_size, sizeof(*fspp->non_b_qp_table)); if (!fspp->non_b_qp_table) return AVERROR(ENOMEM); } fspp->store_slice = store_slice_c; fspp->store_slice2 = store_slice2_c; fspp->mul_thrmat = mul_thrmat_c; fspp->column_fidct = column_fidct_c; fspp->row_idct = row_idct_c; fspp->row_fdct = row_fdct_c; if (ARCH_X86) ff_fspp_init_x86(fspp); return 0; }<SPLIT>[-0.25365086435942685, -0.020159756014915854, 0.0, -0.2665172434374763, -0.08729279623175898, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.051068312296575644, -0.25297036047912586, -0.0006602620976677653, 0.0, 0.0, 0.30852482215402843, -0.1134457356350565, -0.26569807294376846, -0.06870780348722379, 0.11772544131424245, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.043718655277859224, -0.08904460951967552, 0.23107402248845843, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void pulse_audio_sink_device_cb(pa_context *c, const pa_sink_info *dev, int eol, void *userdata) { if (!eol) pulse_add_detected_device(userdata, dev->name, dev->description); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int request_frame(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; ChorusContext *s = ctx->priv; int ret; ret = ff_request_frame(ctx->inputs[0]); if (ret == AVERROR_EOF && !ctx->is_disabled && s->fade_out) { int nb_samples = FFMIN(s->fade_out, 2048); AVFrame *frame; frame = ff_get_audio_buffer(outlink, nb_samples); if (!frame) return AVERROR(ENOMEM); s->fade_out -= nb_samples; av_samples_set_silence(frame->extended_data, 0, frame->nb_samples, outlink->channels, frame->format); frame->pts = s->next_pts; if (s->next_pts != AV_NOPTS_VALUE) s->next_pts += av_rescale_q(nb_samples, (AVRational){1, outlink->sample_rate}, outlink->time_base); ret = filter_frame(ctx->inputs[0], frame); } return ret; }<SPLIT>[-0.25365086435942685, -0.13034272285790952, 0.0, -0.2665172434374763, -0.1936866588694103, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1509627274668249, -0.25297036047912586, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.21031383592774278, -0.26569807294376846, -0.17914063696102905, 0.24712242304476825, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.08904460951967552, 0.23107402248845843, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int opt_read_intervals(void *optctx, const char *opt, const char *arg) { return parse_read_intervals(arg); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static inline int validate_string(WriterContext *wctx, char **dstp, const char *src) { const uint8_t *p, *endp; AVBPrint dstbuf; int invalid_chars_nb = 0, ret = 0; av_bprint_init(&dstbuf, 0, AV_BPRINT_SIZE_UNLIMITED); endp = src + strlen(src); for (p = (uint8_t *)src; *p;) { uint32_t code; int invalid = 0; const uint8_t *p0 = p; if (av_utf8_decode(&code, &p, endp, wctx->string_validation_utf8_flags) < 0) { AVBPrint bp; av_bprint_init(&bp, 0, AV_BPRINT_SIZE_AUTOMATIC); bprint_bytes(&bp, p0, p-p0); av_log(wctx, AV_LOG_DEBUG, "Invalid UTF-8 sequence %s found in string '%s'\n", bp.str, src); invalid = 1; } if (invalid) { invalid_chars_nb++; switch (wctx->string_validation) { case WRITER_STRING_VALIDATION_FAIL: av_log(wctx, AV_LOG_ERROR, "Invalid UTF-8 sequence found in string '%s'\n", src); ret = AVERROR_INVALIDDATA; goto end; break; case WRITER_STRING_VALIDATION_REPLACE: av_bprintf(&dstbuf, "%s", wctx->string_validation_replacement); break; } } if (!invalid || wctx->string_validation == WRITER_STRING_VALIDATION_IGNORE) av_bprint_append_data(&dstbuf, p0, p-p0); } if (invalid_chars_nb && wctx->string_validation == WRITER_STRING_VALIDATION_REPLACE) { av_log(wctx, AV_LOG_WARNING, "%d invalid UTF-8 sequence(s) found in string '%s', replaced with '%s'\n", invalid_chars_nb, src, wctx->string_validation_replacement); } end: av_bprint_finalize(&dstbuf, dstp); return ret; }<SPLIT>[-0.25365086435942685, 0.33242573788266383, 0.0, -0.2665172434374763, 0.25316756420872527, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.268593816248222, -0.25297036047912586, 0.3640258210692401, 0.0, 0.0, 0.30852482215402843, 0.19653218530153962, -0.26569807294376846, 0.28467726362895307, 0.7647103499668715, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.21937940777079099, 0.23792492798410134, 0.7955408613214935, 0.6817979554923368, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int handle_invoke_error(URLContext *s, RTMPPacket *pkt) { RTMPContext *rt = s->priv_data; const uint8_t *data_end = pkt->data + pkt->size; char *tracked_method = NULL; int level = AV_LOG_ERROR; uint8_t tmpstr[256]; int ret; if ((ret = find_tracked_method(s, pkt, 9, &tracked_method)) < 0) return ret; if (!ff_amf_get_field_value(pkt->data + 9, data_end, "description", tmpstr, sizeof(tmpstr))) { if (tracked_method && (!strcmp(tracked_method, "_checkbw") || !strcmp(tracked_method, "releaseStream") || !strcmp(tracked_method, "FCSubscribe") || !strcmp(tracked_method, "FCPublish"))) { level = AV_LOG_WARNING; ret = 0; } else if (tracked_method && !strcmp(tracked_method, "getStreamLength")) { level = rt->live ? AV_LOG_DEBUG : AV_LOG_WARNING; ret = 0; } else if (tracked_method && !strcmp(tracked_method, "connect")) { ret = handle_connect_error(s, tmpstr); if (!ret) { rt->do_reconnect = 1; level = AV_LOG_VERBOSE; } } else ret = AVERROR_UNKNOWN; av_log(s, level, "Server error: %s\n", tmpstr); } av_free(tracked_method); return ret; }<SPLIT>[-0.09900860198293619, 0.0900232108280778, 0.0, -0.11436118199787926, 0.01910106640589235, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, -0.27925050329511203, 0.06880498590772346, -0.09566541730555662, 0.11330413889199094, 0.0, 0.0, 0.30852482215402843, 0.0027959847161670454, -0.11100716297398205, 0.04172502998658149, 0.5059163865058198, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, -0.06167779621789984, 0.4559046196532859, 0.34396739025506545, 0.6817979554923368, 0.42674115187998785, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, -0.27935383381430245, 1.7623686513065309, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, -0.28182971586402455]
0<SPLIT>static void gen_image(int num, int w, int h) { int r, g, b, x, y, i, dx, dy, x1, y1; unsigned int seed1; if (num == 0) { for (i = 0; i < NB_OBJS; i++) { objs[i].x = myrnd(&seed, w); objs[i].y = myrnd(&seed, h); objs[i].w = myrnd(&seed, w / 4) + 10; objs[i].h = myrnd(&seed, h / 4) + 10; objs[i].r = myrnd(&seed, 256); objs[i].g = myrnd(&seed, 256); objs[i].b = myrnd(&seed, 256); } } dx = int_cos(num * FRAC_ONE / 50) * 35; dy = int_cos(num * FRAC_ONE / 50 + FRAC_ONE / 10) * 30; for (y = 0; y < h; y++) { for (x = 0; x < w; x++) { x1 = (x << FRAC_BITS) + dx; y1 = (y << FRAC_BITS) + dy; r = ((y1 * 7) >> FRAC_BITS) & 0xff; g = (((x1 + y1) * 9) >> FRAC_BITS) & 0xff; b = ((x1 * 5) >> FRAC_BITS) & 0xff; put_pixel(x, y, r, g, b); } } seed1 = num; for (y = 0; y < NOISE_W; y++) { for (x = 0; x < NOISE_W; x++) { r = myrnd(&seed1, 256); g = myrnd(&seed1, 256); b = myrnd(&seed1, 256); put_pixel(x + NOISE_X, y + NOISE_Y, r, g, b); } } for (i = 0; i < NB_OBJS; i++) { VObj *p = &objs[i]; seed1 = i; for (y = 0; y < p->h; y++) { for (x = 0; x < p->w; x++) { r = p->r; g = p->g; b = p->b; r += myrnd(&seed1, 50); g += myrnd(&seed1, 50); b += myrnd(&seed1, 50); put_pixel(x + p->x, y + p->y, r, g, b); } } p->x += myrnd(&seed, 21) - 10; p->y += myrnd(&seed, 21) - 10; } }<SPLIT>[0.5195604475230265, 0.5307550782000524, 0.0, 0.4942630637605089, 0.4659552894840279, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.5482981787249199, 0.5335543553887203, 0.5691617428506257, 0.0, 0.0, 0.30852482215402843, 0.4871364861795985, 0.5077564769051636, 0.5055429305765636, -0.011671540416283347, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, 1.0625510197368635, 0.6193893884051743, 0.9084342290881006, -0.21702784222394986, 0.33317037975964214, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static int opt_add_vfilter(void *optctx, const char *opt, const char *arg) { GROW_ARRAY(vfilters_list, nb_vfilters); vfilters_list[nb_vfilters - 1] = arg; return 0; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int mov_write_d263_tag(AVIOContext *pb) { avio_wb32(pb, 0xf); ffio_wfourcc(pb, "d263"); ffio_wfourcc(pb, "FFMP"); avio_w8(pb, 0); avio_w8(pb, 0xa); avio_w8(pb, 0); return 0xf; }<SPLIT>[-0.09900860198293619, -0.43885503001829174, 0.0, -0.11436118199787926, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.09566541730555662, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.11100716297398205, -0.48835257068768384, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int find_and_decode_index(NUTContext *nut) { AVFormatContext *s = nut->avf; AVIOContext *bc = s->pb; uint64_t tmp, end; int i, j, syncpoint_count; int64_t filesize = avio_size(bc); int64_t *syncpoints = NULL; uint64_t max_pts; int8_t *has_keyframe = NULL; int ret = AVERROR_INVALIDDATA; if(filesize <= 0) return -1; avio_seek(bc, filesize - 12, SEEK_SET); avio_seek(bc, filesize - avio_rb64(bc), SEEK_SET); if (avio_rb64(bc) != INDEX_STARTCODE) { av_log(s, AV_LOG_ERROR, "no index at the end\n"); if(s->duration<=0) s->duration = find_duration(nut, filesize); return ret; } end = get_packetheader(nut, bc, 1, INDEX_STARTCODE); end += avio_tell(bc); max_pts = ffio_read_varlen(bc); s->duration = av_rescale_q(max_pts / nut->time_base_count, nut->time_base[max_pts % nut->time_base_count], AV_TIME_BASE_Q); s->duration_estimation_method = AVFMT_DURATION_FROM_PTS; GET_V(syncpoint_count, tmp < INT_MAX / 8 && tmp > 0); syncpoints = av_malloc_array(syncpoint_count, sizeof(int64_t)); has_keyframe = av_malloc_array(syncpoint_count + 1, sizeof(int8_t)); if (!syncpoints || !has_keyframe) { ret = AVERROR(ENOMEM); goto fail; } for (i = 0; i < syncpoint_count; i++) { syncpoints[i] = ffio_read_varlen(bc); if (syncpoints[i] <= 0) goto fail; if (i) syncpoints[i] += syncpoints[i - 1]; } for (i = 0; i < s->nb_streams; i++) { int64_t last_pts = -1; for (j = 0; j < syncpoint_count;) { uint64_t x = ffio_read_varlen(bc); int type = x & 1; int n = j; x >>= 1; if (type) { int flag = x & 1; x >>= 1; if (n + x >= syncpoint_count + 1) { av_log(s, AV_LOG_ERROR, "index overflow A %d + %"PRIu64" >= %d\n", n, x, syncpoint_count + 1); goto fail; } while (x--) has_keyframe[n++] = flag; has_keyframe[n++] = !flag; } else { if (x <= 1) { av_log(s, AV_LOG_ERROR, "index: x %"PRIu64" is invalid\n", x); goto fail; } while (x != 1) { if (n >= syncpoint_count + 1) { av_log(s, AV_LOG_ERROR, "index overflow B\n"); goto fail; } has_keyframe[n++] = x & 1; x >>= 1; } } if (has_keyframe[0]) { av_log(s, AV_LOG_ERROR, "keyframe before first syncpoint in index\n"); goto fail; } av_assert0(n <= syncpoint_count + 1); for (; j < n && j < syncpoint_count; j++) { if (has_keyframe[j]) { uint64_t B, A = ffio_read_varlen(bc); if (!A) { A = ffio_read_varlen(bc); B = ffio_read_varlen(bc); } else B = 0; av_add_index_entry(s->streams[i], 16 * syncpoints[j - 1], last_pts + A, 0, 0, AVINDEX_KEYFRAME); last_pts += A + B; } } } } if (skip_reserved(bc, end) || ffio_get_checksum(bc)) { av_log(s, AV_LOG_ERROR, "index checksum mismatch\n"); goto fail; } ret = 0; fail: av_free(syncpoints); av_free(has_keyframe); return ret; }<SPLIT>[-0.09900860198293619, 1.6105481532613901, 0.0, -0.11436118199787926, 1.4873363708054808, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 1.3698779043020206, 1.447347915257163, -0.09566541730555662, 1.6860128725492811, 0.0, 0.0, 0.30852482215402843, 1.3395757687552379, -0.11100716297398205, 1.5656981319250942, 1.799886203811078, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, 1.6949297287114178, 1.327823386330024, 1.9244745389875635, 0.6817979554923368, 0.6138826961206794, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 1.3693714445839917, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 1.3643185231999084]
0<SPLIT>static void extract_field(AVFrame *frame, int nb_planes, int type) { int i; for (i = 0; i < nb_planes; i++) { if (type) frame->data[i] = frame->data[i] + frame->linesize[i]; frame->linesize[i] *= 2; } }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.4705090699407485, -0.6720729196443977, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>AVFilter *avfilter_get_by_name(const char *name) { const AVFilter *f = NULL; if (!name) return NULL; while ((f = avfilter_next(f))) if (!strcmp(f->name, name)) return (AVFilter *)f; return NULL; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int config_props(AVFilterLink *outlink) { TestSourceContext *test = outlink->src->priv; outlink->w = test->w; outlink->h = test->h; outlink->sample_aspect_ratio = test->sar; outlink->frame_rate = test->frame_rate; outlink->time_base = test->time_base; return 0; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.7880534307994381, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>const char *av_frame_side_data_name(enum AVFrameSideDataType type) { switch(type) { case AV_FRAME_DATA_PANSCAN: return "AVPanScan"; case AV_FRAME_DATA_A53_CC: return "ATSC A53 Part 4 Closed Captions"; case AV_FRAME_DATA_STEREO3D: return "Stereoscopic 3d metadata"; case AV_FRAME_DATA_MATRIXENCODING: return "AVMatrixEncoding"; case AV_FRAME_DATA_DOWNMIX_INFO: return "Metadata relevant to a downmix procedure"; case AV_FRAME_DATA_REPLAYGAIN: return "AVReplayGain"; case AV_FRAME_DATA_DISPLAYMATRIX: return "3x3 displaymatrix"; case AV_FRAME_DATA_MOTION_VECTORS: return "Motion vectors"; } return NULL; }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.7880534307994381, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.14353953243697165, -0.6720729196443977, -0.21702784222394986, 0.33317037975964214, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, 0.04889276383167627, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void matroska_convert_tag(AVFormatContext *s, EbmlList *list, AVDictionary **metadata, char *prefix) { MatroskaTag *tags = list->elem; char key[1024]; int i; for (i = 0; i < list->nb_elem; i++) { const char *lang = tags[i].lang && strcmp(tags[i].lang, "und") ? tags[i].lang : NULL; if (!tags[i].name) { av_log(s, AV_LOG_WARNING, "Skipping invalid tag with no TagName.\n"); continue; } if (prefix) snprintf(key, sizeof(key), "%s/%s", prefix, tags[i].name); else av_strlcpy(key, tags[i].name, sizeof(key)); if (tags[i].def || !lang) { av_dict_set(metadata, key, tags[i].string, 0); if (tags[i].sub.nb_elem) matroska_convert_tag(s, &tags[i].sub, metadata, key); } if (lang) { av_strlcat(key, "-", sizeof(key)); av_strlcat(key, lang, sizeof(key)); av_dict_set(metadata, key, tags[i].string, 0); if (tags[i].sub.nb_elem) matroska_convert_tag(s, &tags[i].sub, metadata, key); } } ff_metadata_conv(metadata, NULL, ff_mkv_metadata_conv); }<SPLIT>[-0.25365086435942685, 0.04595002409088034, 0.0, -0.2665172434374763, -0.02345647864916818, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.008868336805573909, -0.25297036047912586, 0.06771837849612745, 0.0, 0.0, 0.30852482215402843, -0.05532487545944473, -0.26569807294376846, -0.0024481034029406237, 0.6353133682363457, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.14353953243697165, 0.34396739025506545, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *link, AVFrame *frame) { AVFilterContext *ctx = link->dst; SidechainCompressContext *s = ctx->priv; AVFilterLink *sclink = ctx->inputs[1]; AVFilterLink *outlink = ctx->outputs[0]; const double makeup = s->makeup; const double *scsrc; double *sample; int nb_samples; int ret, i, c; for (i = 0; i < 2; i++) if (link == ctx->inputs[i]) break; av_assert0(i < 2 && !s->input_frame[i]); s->input_frame[i] = frame; if (!s->input_frame[0] || !s->input_frame[1]) return 0; nb_samples = FFMIN(s->input_frame[0]->nb_samples, s->input_frame[1]->nb_samples); sample = (double *)s->input_frame[0]->data[0]; scsrc = (const double *)s->input_frame[1]->data[0]; for (i = 0; i < nb_samples; i++) { double abs_sample, gain = 1.0; abs_sample = FFABS(scsrc[0]); if (s->link == 1) { for (c = 1; c < sclink->channels; c++) abs_sample = FFMAX(FFABS(scsrc[c]), abs_sample); } else { for (c = 1; c < sclink->channels; c++) abs_sample += FFABS(scsrc[c]); abs_sample /= sclink->channels; } if (s->detection) abs_sample *= abs_sample; s->lin_slope += (abs_sample - s->lin_slope) * (abs_sample > s->lin_slope ? s->attack_coeff : s->release_coeff); if (s->lin_slope > 0.0 && s->lin_slope > s->lin_knee_start) gain = output_gain(s->lin_slope, s->ratio, s->thres, s->knee, s->knee_start, s->knee_stop, s->compressed_knee_stop, s->detection); for (c = 0; c < outlink->channels; c++) sample[c] *= gain * makeup; sample += outlink->channels; scsrc += sclink->channels; } ret = ff_filter_frame(outlink, s->input_frame[0]); s->input_frame[0] = NULL; av_frame_free(&s->input_frame[1]); return ret; }<SPLIT>[-0.25365086435942685, 0.4426087047256575, 0.0, -0.2665172434374763, 0.3595614268463766, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 0.380400859743741, 0.3684882314184712, -0.25297036047912586, 0.4779902220588988, 0.0, 0.0, 0.30852482215402843, 0.29340028559422593, -0.26569807294376846, 0.39511009710275835, 0.8941073316973973, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, 0.7463616652495864, 1.0008538488262473, 1.0213275968547075, -0.21702784222394986, 0.8945950124817165, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 0.3801362775450152, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 0.3766295797615486]
0<SPLIT>AVFilterFormats *ff_make_format_list(const int *fmts) { MAKE_FORMAT_LIST(AVFilterFormats, formats, nb_formats); while (count--) formats->formats[count] = fmts[count]; return formats; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int mode05(int c, int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8) { REMOVE_GRAIN_SORT_AXIS const int c1 = FFABS(c - av_clip(c, mi1, ma1)); const int c2 = FFABS(c - av_clip(c, mi2, ma2)); const int c3 = FFABS(c - av_clip(c, mi3, ma3)); const int c4 = FFABS(c - av_clip(c, mi4, ma4)); const int mindiff = FFMIN(FFMIN(c1, c2), FFMIN(c3, c4)); if (mindiff == c4) { return av_clip(c, mi4, ma4); } else if (mindiff == c2) { return av_clip(c, mi2, ma2); } else if (mindiff == c3) { return av_clip(c, mi3, ma3); } return av_clip(c, mi1, ma1); }<SPLIT>[-0.09900860198293619, -0.2845988764381006, 0.0, -0.11436118199787926, -0.34263806656212215, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.270836025671124, -0.09566541730555662, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.11100716297398205, -0.33374660382435645, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.14353953243697165, 0.005287286955244392, -0.21702784222394986, -0.22825425296243224, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static float calc_replaygain(uint32_t *histogram) { uint32_t loud_count = 0, total_windows = 0; float gain; int i; for (i = 0; i < HISTOGRAM_SLOTS; i++) total_windows += histogram [i]; while (i--) if ((loud_count += histogram [i]) * 20 >= total_windows) break; gain = (float)(64.54 - i / 100.0); return av_clipf(gain, -24.0, 64.0); }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.39986248560786075, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.25252937827156396, -0.4462861841111837, -0.21702784222394986, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static void sdp_parse_line(AVFormatContext *s, SDPParseState *s1, int letter, const char *buf) { RTSPState *rt = s->priv_data; char buf1[64], st_type[64]; const char *p; enum AVMediaType codec_type; int payload_type; AVStream *st; RTSPStream *rtsp_st; RTSPSource *rtsp_src; struct sockaddr_storage sdp_ip; int ttl; av_log(s, AV_LOG_TRACE, "sdp: %c='%s'\n", letter, buf); p = buf; if (s1->skip_media && letter != 'm') return; switch (letter) { case 'c': get_word(buf1, sizeof(buf1), &p); if (strcmp(buf1, "IN") != 0) return; get_word(buf1, sizeof(buf1), &p); if (strcmp(buf1, "IP4") && strcmp(buf1, "IP6")) return; get_word_sep(buf1, sizeof(buf1), "/", &p); if (get_sockaddr(buf1, &sdp_ip)) return; ttl = 16; if (*p == '/') { p++; get_word_sep(buf1, sizeof(buf1), "/", &p); ttl = atoi(buf1); } if (s->nb_streams == 0) { s1->default_ip = sdp_ip; s1->default_ttl = ttl; } else { rtsp_st = rt->rtsp_streams[rt->nb_rtsp_streams - 1]; rtsp_st->sdp_ip = sdp_ip; rtsp_st->sdp_ttl = ttl; } break; case 's': av_dict_set(&s->metadata, "title", p, 0); break; case 'i': if (s->nb_streams == 0) { av_dict_set(&s->metadata, "comment", p, 0); break; } break; case 'm': s1->skip_media = 0; s1->seen_fmtp = 0; s1->seen_rtpmap = 0; codec_type = AVMEDIA_TYPE_UNKNOWN; get_word(st_type, sizeof(st_type), &p); if (!strcmp(st_type, "audio")) { codec_type = AVMEDIA_TYPE_AUDIO; } else if (!strcmp(st_type, "video")) { codec_type = AVMEDIA_TYPE_VIDEO; } else if (!strcmp(st_type, "application")) { codec_type = AVMEDIA_TYPE_DATA; } else if (!strcmp(st_type, "text")) { codec_type = AVMEDIA_TYPE_SUBTITLE; } if (codec_type == AVMEDIA_TYPE_UNKNOWN || !(rt->media_type_mask & (1 << codec_type))) { s1->skip_media = 1; return; } rtsp_st = av_mallocz(sizeof(RTSPStream)); if (!rtsp_st) return; rtsp_st->stream_index = -1; dynarray_add(&rt->rtsp_streams, &rt->nb_rtsp_streams, rtsp_st); rtsp_st->sdp_ip = s1->default_ip; rtsp_st->sdp_ttl = s1->default_ttl; copy_default_source_addrs(s1->default_include_source_addrs, s1->nb_default_include_source_addrs, &rtsp_st->include_source_addrs, &rtsp_st->nb_include_source_addrs); copy_default_source_addrs(s1->default_exclude_source_addrs, s1->nb_default_exclude_source_addrs, &rtsp_st->exclude_source_addrs, &rtsp_st->nb_exclude_source_addrs); get_word(buf1, sizeof(buf1), &p); rtsp_st->sdp_port = atoi(buf1); get_word(buf1, sizeof(buf1), &p); if (!strcmp(buf1, "udp")) rt->transport = RTSP_TRANSPORT_RAW; else if (strstr(buf1, "/AVPF") || strstr(buf1, "/SAVPF")) rtsp_st->feedback = 1; get_word(buf1, sizeof(buf1), &p); rtsp_st->sdp_payload_type = atoi(buf1); if (!strcmp(ff_rtp_enc_name(rtsp_st->sdp_payload_type), "MP2T")) { if (rt->transport == RTSP_TRANSPORT_RAW) { if (CONFIG_RTPDEC && !rt->ts) rt->ts = avpriv_mpegts_parse_open(s); } else { RTPDynamicProtocolHandler *handler; handler = ff_rtp_handler_find_by_id( rtsp_st->sdp_payload_type, AVMEDIA_TYPE_DATA); init_rtp_handler(handler, rtsp_st, NULL); finalize_rtp_handler_init(s, rtsp_st, NULL); } } else if (rt->server_type == RTSP_SERVER_WMS && codec_type == AVMEDIA_TYPE_DATA) { } else { st = avformat_new_stream(s, NULL); if (!st) return; st->id = rt->nb_rtsp_streams - 1; rtsp_st->stream_index = st->index; st->codec->codec_type = codec_type; if (rtsp_st->sdp_payload_type < RTP_PT_PRIVATE) { RTPDynamicProtocolHandler *handler; ff_rtp_get_codec_info(st->codec, rtsp_st->sdp_payload_type); if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO && st->codec->sample_rate > 0) avpriv_set_pts_info(st, 32, 1, st->codec->sample_rate); handler = ff_rtp_handler_find_by_id( rtsp_st->sdp_payload_type, st->codec->codec_type); init_rtp_handler(handler, rtsp_st, st); finalize_rtp_handler_init(s, rtsp_st, st); } if (rt->default_lang[0]) av_dict_set(&st->metadata, "language", rt->default_lang, 0); } av_strlcpy(rtsp_st->control_url, rt->control_uri, sizeof(rtsp_st->control_url)); break; case 'a': if (av_strstart(p, "control:", &p)) { if (s->nb_streams == 0) { if (!strncmp(p, "rtsp: av_strlcpy(rt->control_uri, p, sizeof(rt->control_uri)); } else { char proto[32]; rtsp_st = rt->rtsp_streams[rt->nb_rtsp_streams - 1]; av_url_split(proto, sizeof(proto), NULL, 0, NULL, 0, NULL, NULL, 0, p); if (proto[0] == '\0') { if (rtsp_st->control_url[strlen(rtsp_st->control_url)-1]!='/') av_strlcat(rtsp_st->control_url, "/", sizeof(rtsp_st->control_url)); av_strlcat(rtsp_st->control_url, p, sizeof(rtsp_st->control_url)); } else av_strlcpy(rtsp_st->control_url, p, sizeof(rtsp_st->control_url)); } } else if (av_strstart(p, "rtpmap:", &p) && s->nb_streams > 0) { get_word(buf1, sizeof(buf1), &p); payload_type = atoi(buf1); rtsp_st = rt->rtsp_streams[rt->nb_rtsp_streams - 1]; if (rtsp_st->stream_index >= 0) { st = s->streams[rtsp_st->stream_index]; sdp_parse_rtpmap(s, st, rtsp_st, payload_type, p); } s1->seen_rtpmap = 1; if (s1->seen_fmtp) { parse_fmtp(s, rt, payload_type, s1->delayed_fmtp); } } else if (av_strstart(p, "fmtp:", &p) || av_strstart(p, "framesize:", &p)) { get_word(buf1, sizeof(buf1), &p); payload_type = atoi(buf1); if (s1->seen_rtpmap) { parse_fmtp(s, rt, payload_type, buf); } else { s1->seen_fmtp = 1; av_strlcpy(s1->delayed_fmtp, buf, sizeof(s1->delayed_fmtp)); } } else if (av_strstart(p, "range:", &p)) { int64_t start, end; rtsp_parse_range_npt(p, &start, &end); s->start_time = start; s->duration = (end == AV_NOPTS_VALUE) ? AV_NOPTS_VALUE : end - start; } else if (av_strstart(p, "lang:", &p)) { if (s->nb_streams > 0) { get_word(buf1, sizeof(buf1), &p); rtsp_st = rt->rtsp_streams[rt->nb_rtsp_streams - 1]; if (rtsp_st->stream_index >= 0) { st = s->streams[rtsp_st->stream_index]; av_dict_set(&st->metadata, "language", buf1, 0); } } else get_word(rt->default_lang, sizeof(rt->default_lang), &p); } else if (av_strstart(p, "IsRealDataType:integer;",&p)) { if (atoi(p) == 1) rt->transport = RTSP_TRANSPORT_RDT; } else if (av_strstart(p, "SampleRate:integer;", &p) && s->nb_streams > 0) { st = s->streams[s->nb_streams - 1]; st->codec->sample_rate = atoi(p); } else if (av_strstart(p, "crypto:", &p) && s->nb_streams > 0) { rtsp_st = rt->rtsp_streams[rt->nb_rtsp_streams - 1]; get_word(buf1, sizeof(buf1), &p); get_word(rtsp_st->crypto_suite, sizeof(rtsp_st->crypto_suite), &p); p += strspn(p, SPACE_CHARS); if (av_strstart(p, "inline:", &p)) get_word(rtsp_st->crypto_params, sizeof(rtsp_st->crypto_params), &p); } else if (av_strstart(p, "source-filter:", &p)) { int exclude = 0; get_word(buf1, sizeof(buf1), &p); if (strcmp(buf1, "incl") && strcmp(buf1, "excl")) return; exclude = !strcmp(buf1, "excl"); get_word(buf1, sizeof(buf1), &p); if (strcmp(buf1, "IN") != 0) return; get_word(buf1, sizeof(buf1), &p); if (strcmp(buf1, "IP4") && strcmp(buf1, "IP6") && strcmp(buf1, "*")) return; get_word(buf1, sizeof(buf1), &p); while (*p != '\0') { rtsp_src = av_mallocz(sizeof(*rtsp_src)); if (!rtsp_src) return; get_word(rtsp_src->addr, sizeof(rtsp_src->addr), &p); if (exclude) { if (s->nb_streams == 0) { dynarray_add(&s1->default_exclude_source_addrs, &s1->nb_default_exclude_source_addrs, rtsp_src); } else { rtsp_st = rt->rtsp_streams[rt->nb_rtsp_streams - 1]; dynarray_add(&rtsp_st->exclude_source_addrs, &rtsp_st->nb_exclude_source_addrs, rtsp_src); } } else { if (s->nb_streams == 0) { dynarray_add(&s1->default_include_source_addrs, &s1->nb_default_include_source_addrs, rtsp_src); } else { rtsp_st = rt->rtsp_streams[rt->nb_rtsp_streams - 1]; dynarray_add(&rtsp_st->include_source_addrs, &rtsp_st->nb_include_source_addrs, rtsp_src); } } } } else { if (rt->server_type == RTSP_SERVER_WMS) ff_wms_parse_sdp_a_line(s, p); if (s->nb_streams > 0) { rtsp_st = rt->rtsp_streams[rt->nb_rtsp_streams - 1]; if (rt->server_type == RTSP_SERVER_REAL) ff_real_parse_sdp_a_line(s, rtsp_st->stream_index, p); if (rtsp_st->dynamic_handler && rtsp_st->dynamic_handler->parse_sdp_a_line) rtsp_st->dynamic_handler->parse_sdp_a_line(s, rtsp_st->stream_index, rtsp_st->dynamic_protocol_context, buf); } } break; } }<SPLIT>[2.3752675960409144, 4.982146938656996, 0.0, 2.320135801035673, 4.742988567517611, 0.0, 7.921896686505695, 7.3573662610040955, 8.368821023673352, 9.285694260768258, 4.823779148011588, 2.4212136734715513, 5.173323542832837, 0.0, 0.0, 0.30852482215402843, 4.613717558648035, 2.3640473965426008, 4.944942836223536, 4.387825838421595, 8.799274381273577, 0.0, -0.08645738172306322, -0.16222078614455715, 4.154180263612463, 6.668325832225046, 3.95655515878649, 3.3782753486411963, 7.8188321493873, 7.919536582297568, 7.355534708077985, 8.366446116730481, 9.283252780895804, 3.475844538781386, 0.0, 7.906511081255081, 7.343339115538153, 8.352364786095055, 9.265830070706787]
0<SPLIT>static int mov_add_tfra_entries(AVIOContext *pb, MOVMuxContext *mov, int tracks, int size) { int i; for (i = 0; i < mov->nb_streams; i++) { MOVTrack *track = &mov->tracks[i]; MOVFragmentInfo *info; if ((tracks >= 0 && i != tracks) || !track->entry) continue; track->nb_frag_info++; if (track->nb_frag_info >= track->frag_info_capacity) { unsigned new_capacity = track->nb_frag_info + MOV_FRAG_INFO_ALLOC_INCREMENT; if (av_reallocp_array(&track->frag_info, new_capacity, sizeof(*track->frag_info))) return AVERROR(ENOMEM); track->frag_info_capacity = new_capacity; } info = &track->frag_info[track->nb_frag_info - 1]; info->offset = avio_tell(pb); info->size = size; info->time = track->start_dts + track->frag_start + track->cluster[0].cts; info->duration = track->end_pts - (track->cluster[0].dts + track->cluster[0].cts); if (info->time < 0) { info->duration += info->time; info->time = 0; } info->tfrf_offset = 0; mov_write_tfrf_tags(pb, mov, track); } return 0; }<SPLIT>[0.5195604475230265, 0.0900232108280778, 0.0, 0.4942630637605089, 0.01910106640589235, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.14872051804392286, 0.5335543553887203, 0.11330413889199094, 0.0, 0.0, 0.30852482215402843, 0.08029046495031608, 0.5077564769051636, 0.04172502998658149, 0.11772544131424245, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, -0.3070243011888601, -0.10760608081136262, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int default_execute(AVFilterContext *ctx, avfilter_action_func *func, void *arg, int *ret, int nb_jobs) { int i; for (i = 0; i < nb_jobs; i++) { int r = func(ctx, arg, i, nb_jobs); if (ret) ret[i] = r; } return 0; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.39986248560786075, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.25252937827156396, -0.5591795518777907, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>enum AVMediaType avfilter_pad_get_type(const AVFilterPad *pads, int pad_idx) { return pads[pad_idx].type; }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void palToUV_c(uint8_t *_dstU, uint8_t *_dstV, const uint8_t *unused0, const uint8_t *src1, const uint8_t *src2, int width, uint32_t *pal) { uint16_t *dstU = (uint16_t *)_dstU; int16_t *dstV = (int16_t *)_dstV; int i; av_assert1(src1 == src2); for (i = 0; i < width; i++) { int p = pal[src1[i]]; dstU[i] = (uint8_t)(p>> 8)<<6; dstV[i] = (uint8_t)(p>>16)<<6; } }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.3615192241061562, -0.4462861841111837, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void rtsp_cmd_options(HTTPContext *c, const char *url) { avio_printf(c->pb, "RTSP/1.0 %d %s\r\n", RTSP_STATUS_OK, "OK"); avio_printf(c->pb, "CSeq: %d\r\n", c->seq); avio_printf(c->pb, "Public: %s\r\n", "OPTIONS, DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE"); avio_printf(c->pb, "\r\n"); }<SPLIT>[-0.09900860198293619, -0.4829282167554892, 0.0, -0.11436118199787926, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.09566541730555662, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.11100716297398205, -0.5325257040772059, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void print_help(const char* name) { printf("usage: %s file|dir [w=%i] [h=%i]\n" "generate a test video stream\n", name, DEFAULT_WIDTH, DEFAULT_HEIGHT); exit(1); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static AVCodec *choose_decoder(OptionsContext *o, AVFormatContext *s, AVStream *st) { char *codec_name = NULL; MATCH_PER_STREAM_OPT(codec_names, str, codec_name, s, st); if (codec_name) { AVCodec *codec = find_codec_or_die(codec_name, st->codecpar->codec_type, 0); st->codecpar->codec_id = codec->id; return codec; } else return avcodec_find_decoder(st->codecpar->codec_id); }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3615192241061562, -0.3333928163445767, 0.6817979554923368, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int handle_file(struct Tracks *tracks, const char *file) { AVFormatContext *ctx = NULL; int err = 0, i, orig_tracks = tracks->nb_tracks; char errbuf[50], *ptr; struct Track *track; err = avformat_open_input(&ctx, file, NULL, NULL); if (err < 0) { av_strerror(err, errbuf, sizeof(errbuf)); fprintf(stderr, "Unable to open %s: %s\n", file, errbuf); return 1; } err = avformat_find_stream_info(ctx, NULL); if (err < 0) { av_strerror(err, errbuf, sizeof(errbuf)); fprintf(stderr, "Unable to identify %s: %s\n", file, errbuf); goto fail; } if (ctx->nb_streams < 1) { fprintf(stderr, "No streams found in %s\n", file); goto fail; } if (ctx->nb_streams > 1) tracks->multiple_tracks_per_file = 1; for (i = 0; i < ctx->nb_streams; i++) { struct Track **temp; AVStream *st = ctx->streams[i]; if (st->codec->bit_rate == 0) { fprintf(stderr, "Skipping track %d in %s as it has zero bitrate\n", st->id, file); continue; } track = av_mallocz(sizeof(*track)); if (!track) { err = AVERROR(ENOMEM); goto fail; } temp = av_realloc_array(tracks->tracks, tracks->nb_tracks + 1, sizeof(*tracks->tracks)); if (!temp) { av_free(track); err = AVERROR(ENOMEM); goto fail; } tracks->tracks = temp; tracks->tracks[tracks->nb_tracks] = track; track->name = file; if ((ptr = strrchr(file, '/'))) track->name = ptr + 1; track->bitrate = st->codec->bit_rate; track->track_id = st->id; track->timescale = st->time_base.den; track->duration = st->duration; track->is_audio = st->codec->codec_type == AVMEDIA_TYPE_AUDIO; track->is_video = st->codec->codec_type == AVMEDIA_TYPE_VIDEO; if (!track->is_audio && !track->is_video) { fprintf(stderr, "Track %d in %s is neither video nor audio, skipping\n", track->track_id, file); av_freep(&tracks->tracks[tracks->nb_tracks]); continue; } tracks->duration = FFMAX(tracks->duration, av_rescale_rnd(track->duration, AV_TIME_BASE, track->timescale, AV_ROUND_UP)); if (track->is_audio) { track->channels = st->codec->channels; track->sample_rate = st->codec->sample_rate; } if (track->is_video) { track->width = st->codec->width; track->height = st->codec->height; } set_codec_str(st->codec, track->codec_str, sizeof(track->codec_str)); tracks->nb_tracks++; } avformat_close_input(&ctx); err = find_sidx(tracks, orig_tracks, file); fail: if (ctx) avformat_close_input(&ctx); return err; }<SPLIT>[-0.25365086435942685, 1.1698162858894157, 0.0, -0.2665172434374763, 1.0617609202548755, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, 1.0277913715421163, -0.25297036047912586, 1.2301552685906463, 0.0, 0.0, 0.30852482215402843, 0.9327297475259554, -0.26569807294376846, 1.123966798029873, 1.670489222080552, 0.7972807018539907, 0.0, -0.08645738172306322, -0.16222078614455715, 1.1328153207340361, 1.273328463412728, 2.0373679067541706, 0.6817979554923368, 0.42674115187998785, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static void vector_fmac_scalar_c(float *dst, const float *src, float mul, int len) { int i; for (i = 0; i < len; i++) dst[i] += src[i] * mul; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.41601414702345235, -0.6720729196443977, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int pulse_get_device_list(AVFormatContext *h, AVDeviceInfoList *device_list) { PulseData *s = h->priv_data; return ff_pulse_audio_get_devices(device_list, s->server, 1); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { AVFilterFormats *formats = NULL; AVFilterChannelLayouts *layouts = NULL; static const enum AVSampleFormat sample_fmts[] = { AV_SAMPLE_FMT_DBL, AV_SAMPLE_FMT_NONE }; int ret; layouts = ff_all_channel_layouts(); if (!layouts) return AVERROR(ENOMEM); ret = ff_set_common_channel_layouts(ctx, layouts); if (ret < 0) return ret; formats = ff_make_format_list(sample_fmts); if (!formats) return AVERROR(ENOMEM); ret = ff_set_common_formats(ctx, formats); if (ret < 0) return ret; formats = ff_all_samplerates(); if (!formats) return AVERROR(ENOMEM); return ff_set_common_samplerates(ctx, formats); }<SPLIT>[-0.25365086435942685, -0.10830612948931077, 0.0, -0.2665172434374763, -0.17240788634188003, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.13098384443277505, -0.25297036047912586, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, -0.26569807294376846, -0.157054070266268, 0.37651940477529405, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, 0.0744401592322129, 0.34396739025506545, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int process_command(AVFilterContext *ctx, const char *cmd, const char *args, char *res, int res_len, int flags) { OverlayContext *s = ctx->priv; int ret; if (!strcmp(cmd, "x")) ret = set_expr(&s->x_pexpr, args, cmd, ctx); else if (!strcmp(cmd, "y")) ret = set_expr(&s->y_pexpr, args, cmd, ctx); else ret = AVERROR(ENOSYS); if (ret < 0) return ret; if (s->eval_mode == EVAL_MODE_INIT) { eval_expr(ctx); av_log(ctx, AV_LOG_VERBOSE, "x:%f xi:%d y:%f yi:%d\n", s->var_values[VAR_X], s->x, s->var_values[VAR_Y], s->y); } return ret; }<SPLIT>[-0.25365086435942685, -0.1964525029637057, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.21089937656897445, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, 0.11772544131424245, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.14353953243697165, -0.10760608081136262, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int skip_fragment(AVIOContext *in) { int ret; ret = skip_tag(in, MKBETAG('m', 'o', 'o', 'f')); if (!ret) ret = skip_tag(in, MKBETAG('m', 'd', 'a', 't')); return ret; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void vdpau_uninit(AVCodecContext *s) { InputStream *ist = s->opaque; VDPAUContext *ctx = ist->hwaccel_ctx; ist->hwaccel_uninit = NULL; ist->hwaccel_get_buffer = NULL; ist->hwaccel_retrieve_data = NULL; av_buffer_unref(&ctx->hw_frames_ctx); av_frame_free(&ctx->tmp_frame); av_freep(&ist->hwaccel_ctx); av_freep(&s->hwaccel_context); }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int config_props(AVFilterLink *inlink) { AVFilterContext *ctx = inlink->src; MBContext *mb = ctx->priv; if (av_image_check_size(mb->w, mb->h, 0, ctx) < 0) return AVERROR(EINVAL); inlink->w = mb->w; inlink->h = mb->h; inlink->time_base = av_inv_q(mb->frame_rate); return 0; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { static const enum AVPixelFormat pixel_fmts_eq[] = { AV_PIX_FMT_GRAY8, AV_PIX_FMT_YUV410P, AV_PIX_FMT_YUV411P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_NONE }; AVFilterFormats *fmts_list = ff_make_format_list(pixel_fmts_eq); if (!fmts_list) return AVERROR(ENOMEM); return ff_set_common_formats(ctx, fmts_list); }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int opt_default_new(OptionsContext *o, const char *opt, const char *arg) { int ret; AVDictionary *cbak = codec_opts; AVDictionary *fbak = format_opts; codec_opts = NULL; format_opts = NULL; ret = opt_default(NULL, opt, arg); av_dict_copy(&o->g->codec_opts , codec_opts, 0); av_dict_copy(&o->g->format_opts, format_opts, 0); av_dict_free(&codec_opts); av_dict_free(&format_opts); codec_opts = cbak; format_opts = fbak; return ret; }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int main(void) { int i, j, retry; uint32_t seeds[N]; for (retry=0; retry<3; retry++){ for (i=0; i<N; i++){ seeds[i] = av_get_random_seed(); for (j=0; j<i; j++) if (seeds[j] == seeds[i]) goto retry; } printf("seeds OK\n"); return 0; retry:; } printf("FAIL at %d with %X\n", j, seeds[j]); return 1; }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.39986248560786075, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, 0.01994523631491676, -0.10760608081136262, 0.6817979554923368, 0.05245806339860493, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int insert_filter(AVFilterContext **last_filter, int *pad_idx, const char *filter_name, const char *args) { AVFilterGraph *graph = (*last_filter)->graph; AVFilterContext *ctx; int ret; ret = avfilter_graph_create_filter(&ctx, avfilter_get_by_name(filter_name), filter_name, args, NULL, graph); if (ret < 0) return ret; ret = avfilter_link(*last_filter, *pad_idx, ctx, 0); if (ret < 0) return ret; *last_filter = ctx; *pad_idx = 0; return 0; }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.14106852214680915, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.14353953243697165, -0.3333928163445767, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static void vaapi_decode_uninit(AVCodecContext *avctx) { InputStream *ist = avctx->opaque; VAAPIDecoderContext *ctx = ist->hwaccel_ctx; if (ctx) { av_buffer_unref(&ctx->frames_ref); av_buffer_unref(&ctx->device_ref); av_free(ctx); } av_buffer_unref(&ist->hw_frames_ctx); ist->hwaccel_ctx = NULL; ist->hwaccel_uninit = NULL; ist->hwaccel_get_buffer = NULL; ist->hwaccel_retrieve_data = NULL; }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { AVFilterFormats *pix_fmts = NULL; int fmt; for (fmt = 0; av_pix_fmt_desc_get(fmt); fmt++) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(fmt); if (!(desc->flags & AV_PIX_FMT_FLAG_HWACCEL || desc->flags & AV_PIX_FMT_FLAG_PAL || desc->flags & AV_PIX_FMT_FLAG_BITSTREAM)) ff_add_format(&pix_fmts, fmt); } return ff_set_common_formats(ctx, pix_fmts); }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.25252937827156396, -0.22049944857796966, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int config_output(AVFilterLink *outlink) { outlink->flags |= FF_LINK_FLAG_REQUEST_LOOP; return 0; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static xcb_screen_t *get_screen(const xcb_setup_t *setup, int screen_num) { xcb_screen_iterator_t it = xcb_setup_roots_iterator(setup); xcb_screen_t *screen = NULL; for (; it.rem > 0; xcb_screen_next (&it)) { if (!screen_num) { screen = it.data; break; } screen_num--; } return screen; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>enum AVCodecID ff_fmt_v4l2codec(uint32_t v4l2_fmt) { int i; for (i = 0; ff_fmt_conversion_table[i].codec_id != AV_CODEC_ID_NONE; i++) { if (ff_fmt_conversion_table[i].v4l2_fmt == v4l2_fmt) { return ff_fmt_conversion_table[i].codec_id; } } return AV_CODEC_ID_NONE; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void sdt_cb(MpegTSFilter *filter, const uint8_t *section, int section_len) { MpegTSContext *ts = filter->u.section_filter.opaque; MpegTSSectionFilter *tssf = &filter->u.section_filter; SectionHeader h1, *h = &h1; const uint8_t *p, *p_end, *desc_list_end, *desc_end; int onid, val, sid, desc_list_len, desc_tag, desc_len, service_type; char *name, *provider_name; av_log(ts->stream, AV_LOG_TRACE, "SDT:\n"); hex_dump_debug(ts->stream, section, section_len); p_end = section + section_len - 4; p = section; if (parse_section_header(h, &p, p_end) < 0) return; if (h->tid != SDT_TID) return; if (ts->skip_changes) return; if (skip_identical(h, tssf)) return; onid = get16(&p, p_end); if (onid < 0) return; val = get8(&p, p_end); if (val < 0) return; for (;;) { sid = get16(&p, p_end); if (sid < 0) break; val = get8(&p, p_end); if (val < 0) break; desc_list_len = get16(&p, p_end); if (desc_list_len < 0) break; desc_list_len &= 0xfff; desc_list_end = p + desc_list_len; if (desc_list_end > p_end) break; for (;;) { desc_tag = get8(&p, desc_list_end); if (desc_tag < 0) break; desc_len = get8(&p, desc_list_end); desc_end = p + desc_len; if (desc_len < 0 || desc_end > desc_list_end) break; av_log(ts->stream, AV_LOG_TRACE, "tag: 0x%02x len=%d\n", desc_tag, desc_len); switch (desc_tag) { case 0x48: service_type = get8(&p, p_end); if (service_type < 0) break; provider_name = getstr8(&p, p_end); if (!provider_name) break; name = getstr8(&p, p_end); if (name) { AVProgram *program = av_new_program(ts->stream, sid); if (program) { av_dict_set(&program->metadata, "service_name", name, 0); av_dict_set(&program->metadata, "service_provider", provider_name, 0); } } av_free(name); av_free(provider_name); break; default: break; } p = desc_end; } p = desc_list_end; } }<SPLIT>[-0.25365086435942685, 1.059633319046422, 0.0, -0.2665172434374763, 0.9553670576172241, 0.0, 2.8818928143475766, 2.9387831490739704, 2.8960354674881272, 5.327786082535139, 0.9278969563718671, -0.25297036047912586, 1.1161908676009875, 0.0, 0.0, 0.30852482215402843, 0.8358616472332691, -0.26569807294376846, 1.013533964556068, 0.8941073316973973, 3.318456792630025, 0.0, -0.08645738172306322, -0.16222078614455715, 1.09768317023545, 2.853681228014316, 1.4729010679211356, 6.074752741790056, 3.046722771249668, 2.880823316711111, 2.937867481060918, 2.8950067463586415, 5.326312112739897, 3.475844538781386, 0.0, 2.8741508759799035, 2.9311578270720693, 2.88816198510519, 5.315074296953347]
0<SPLIT>static int mmap_read_frame(AVFormatContext *ctx, AVPacket *pkt) { struct video_data *s = ctx->priv_data; struct v4l2_buffer buf = { .type = V4L2_BUF_TYPE_VIDEO_CAPTURE, .memory = V4L2_MEMORY_MMAP }; int res; pkt->size = 0; while ((res = v4l2_ioctl(s->fd, VIDIOC_DQBUF, &buf)) < 0 && (errno == EINTR)); if (res < 0) { if (errno == EAGAIN) return AVERROR(EAGAIN); res = AVERROR(errno); av_log(ctx, AV_LOG_ERROR, "ioctl(VIDIOC_DQBUF): %s\n", av_err2str(res)); return res; } if (buf.index >= s->buffers) { av_log(ctx, AV_LOG_ERROR, "Invalid buffer index received.\n"); return AVERROR(EINVAL); } avpriv_atomic_int_add_and_fetch(&s->buffers_queued, -1); av_assert0(avpriv_atomic_int_get(&s->buffers_queued) >= 1); #ifdef V4L2_BUF_FLAG_ERROR if (buf.flags & V4L2_BUF_FLAG_ERROR) { av_log(ctx, AV_LOG_WARNING, "Dequeued v4l2 buffer contains corrupted data (%d bytes).\n", buf.bytesused); buf.bytesused = 0; } else #endif { if (ctx->video_codec_id == AV_CODEC_ID_CPIA) s->frame_size = buf.bytesused; if (s->frame_size > 0 && buf.bytesused != s->frame_size) { av_log(ctx, AV_LOG_ERROR, "Dequeued v4l2 buffer contains %d bytes, but %d were expected. Flags: 0x%08X.\n", buf.bytesused, s->frame_size, buf.flags); enqueue_buffer(s, &buf); return AVERROR_INVALIDDATA; } } if (avpriv_atomic_int_get(&s->buffers_queued) == FFMAX(s->buffers / 8, 1)) { res = av_new_packet(pkt, buf.bytesused); if (res < 0) { av_log(ctx, AV_LOG_ERROR, "Error allocating a packet.\n"); enqueue_buffer(s, &buf); return res; } memcpy(pkt->data, s->buf_start[buf.index], buf.bytesused); res = enqueue_buffer(s, &buf); if (res) { av_free_packet(pkt); return res; } } else { struct buff_data *buf_descriptor; pkt->data = s->buf_start[buf.index]; pkt->size = buf.bytesused; #if FF_API_DESTRUCT_PACKET FF_DISABLE_DEPRECATION_WARNINGS pkt->destruct = dummy_release_buffer; FF_ENABLE_DEPRECATION_WARNINGS #endif buf_descriptor = av_malloc(sizeof(struct buff_data)); if (!buf_descriptor) { av_log(ctx, AV_LOG_ERROR, "Failed to allocate a buffer descriptor\n"); enqueue_buffer(s, &buf); return AVERROR(ENOMEM); } buf_descriptor->index = buf.index; buf_descriptor->s = s; pkt->buf = av_buffer_create(pkt->data, pkt->size, mmap_release_buffer, buf_descriptor, 0); if (!pkt->buf) { av_log(ctx, AV_LOG_ERROR, "Failed to create a buffer\n"); enqueue_buffer(s, &buf); av_freep(&buf_descriptor); return AVERROR(ENOMEM); } } pkt->pts = buf.timestamp.tv_sec * INT64_C(1000000) + buf.timestamp.tv_usec; convert_timestamp(ctx, &pkt->pts); return pkt->size; }<SPLIT>[1.1381294970289892, 1.2359260659952118, 0.0, 1.102887309518897, 1.1255972378374661, 0.0, 0.9701672076669112, 0.9946065798247155, 0.9059316288753189, 1.040052222782594, 1.2675379679507146, 1.1627741280829973, 1.0022264666113287, 0.0, 0.0, 0.30852482215402843, 1.1652131882284025, 1.1265201167843093, 0.9031011310822626, 1.799886203811078, 0.5780479983082486, 0.0, 0.9057658544417533, 2.1569430876889752, 0.8868902672439317, 1.273328463412728, 1.9244745389875635, -0.21702784222394986, 0.6138826961206794, 0.969587250454179, 0.9940939011734088, 0.9053924298597907, 1.039626388904333, 0.9056307075691036, 0.0, 0.9653245912203542, 0.9897980601469931, 0.9011791483816026, 1.0350888753871217]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { int i; ThumbContext *thumb = ctx->priv; for (i = 0; i < thumb->n_frames && thumb->frames[i].buf; i++) av_frame_free(&thumb->frames[i].buf); av_freep(&thumb->frames); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void frac_add(FFFrac *f, int64_t incr) { int64_t num, den; num = f->num + incr; den = f->den; if (num < 0) { f->val += num / den; num = num % den; if (num < 0) { num += den; f->val--; } } else if (num >= den) { f->val += num / den; num = num % den; } f->num = num; }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.7880534307994381, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.5250039928580447, -0.7849662874110047, -0.21702784222394986, -0.22825425296243224, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static av_cold int init(AVFilterContext *ctx) { DecimateContext *decimate = ctx->priv; decimate->sad = av_pixelutils_get_sad_fn(3, 3, 0, ctx); if (!decimate->sad) return AVERROR(EINVAL); av_log(ctx, AV_LOG_VERBOSE, "max_drop_count:%d hi:%d lo:%d frac:%f\n", decimate->max_drop_count, decimate->hi, decimate->lo, decimate->frac); return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void sanitize(uint8_t *line){ while(*line){ if(*line < 0x08 || (*line > 0x0D && *line < 0x20)) *line='?'; line++; } }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 3.3489446507317613, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, 0.04739993194876201]
0<SPLIT>const AVClass *avfilter_get_class(void) { return &avfilter_class; }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>FF_DISABLE_DEPRECATION_WARNINGS static void compat_free_buffer(AVFilterBuffer *buf) { AVFrame *frame = buf->priv; av_frame_free(&frame); av_free(buf); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>void avfilter_graph_free(AVFilterGraph **graph) { if (!*graph) return; while ((*graph)->nb_filters) avfilter_free((*graph)->filters[0]); ff_graph_thread_free(*graph); av_freep(&(*graph)->sink_links); av_freep(&(*graph)->scale_sws_opts); av_freep(&(*graph)->aresample_swr_opts); av_freep(&(*graph)->resample_lavr_opts); av_freep(&(*graph)->filters); av_freep(&(*graph)->internal); av_freep(graph); }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.41601414702345235, -0.4462861841111837, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void ff_ac3_group_exponents(AC3EncodeContext *s) { int blk, ch, i, cpl; int group_size, nb_groups; uint8_t *p; int delta0, delta1, delta2; int exp0, exp1; for (blk = 0; blk < s->num_blocks; blk++) { AC3Block *block = &s->blocks[blk]; for (ch = !block->cpl_in_use; ch <= s->channels; ch++) { int exp_strategy = s->exp_strategy[ch][blk]; if (exp_strategy == EXP_REUSE) continue; cpl = (ch == CPL_CH); group_size = exp_strategy + (exp_strategy == EXP_D45); nb_groups = exponent_group_tab[cpl][exp_strategy-1][block->end_freq[ch]-s->start_freq[ch]]; p = block->exp[ch] + s->start_freq[ch] - cpl; exp1 = *p++; block->grouped_exp[ch][0] = exp1; for (i = 1; i <= nb_groups; i++) { exp0 = exp1; exp1 = p[0]; p += group_size; delta0 = exp1 - exp0 + 2; av_assert2(delta0 >= 0 && delta0 <= 4); exp0 = exp1; exp1 = p[0]; p += group_size; delta1 = exp1 - exp0 + 2; av_assert2(delta1 >= 0 && delta1 <= 4); exp0 = exp1; exp1 = p[0]; p += group_size; delta2 = exp1 - exp0 + 2; av_assert2(delta2 >= 0 && delta2 <= 4); block->grouped_exp[ch][i] = ((delta0 * 5 + delta1) * 5) + delta2; } } } }<SPLIT>[0.21027592277004517, 0.2222427710396702, 0.0, 0.18995094088131478, 0.14677370157107394, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.22863605018012226, 0.21894446904158188, 0.2500614200795814, 0.0, 0.0, 0.30852482215402843, 0.1577849451844651, 0.19837465696559078, 0.17424443015514782, -0.011671540416283347, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5707009127566546, 0.01994523631491676, 0.6826474935548865, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int var_c(const uint8_t *a, const uint8_t *b, ptrdiff_t s) { int i, j, var = 0; for (i = 0; i < 3; i++) { for (j = 0; j < 8; j++) var += ABS(a[j] - a[j + s]); a += s; } return 4 * var; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.25252937827156396, -0.3333928163445767, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int opt_input_file_i(void *optctx, const char *opt, const char *arg) { opt_input_file(optctx, arg); return 0; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5250039928580447, -0.6720729196443977, -0.21702784222394986, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void opengl_make_ortho(float matrix[16], float left, float right, float bottom, float top, float nearZ, float farZ) { float ral = right + left; float rsl = right - left; float tab = top + bottom; float tsb = top - bottom; float fan = farZ + nearZ; float fsn = farZ - nearZ; memset(matrix, 0, 16 * sizeof(float)); matrix[0] = 2.0f / rsl; matrix[5] = 2.0f / tsb; matrix[10] = -2.0f / fsn; matrix[12] = -ral / rsl; matrix[13] = -tab / tsb; matrix[14] = -fan / fsn; matrix[15] = 1.0f; }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, 0.24712242304476825, 1.1261297571726039, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, 0.12893508214950905, 0.005287286955244392, -0.21702784222394986, 0.23959960763929639, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int init(AVFilterContext *ctx) { FlangerContext *s = ctx->priv; s->feedback_gain /= 100; s->delay_gain /= 100; s->channel_phase /= 100; s->delay_min /= 1000; s->delay_depth /= 1000; s->in_gain = 1 / (1 + s->delay_gain); s->delay_gain /= 1 + s->delay_gain; s->delay_gain *= 1 - fabs(s->feedback_gain); return 0; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void show_subtitle(WriterContext *w, AVSubtitle *sub, AVStream *stream, AVFormatContext *fmt_ctx) { AVBPrint pbuf; av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED); writer_print_section_header(w, SECTION_ID_SUBTITLE); print_str ("media_type", "subtitle"); print_ts ("pts", sub->pts); print_time("pts_time", sub->pts, &AV_TIME_BASE_Q); print_int ("format", sub->format); print_int ("start_display_time", sub->start_display_time); print_int ("end_display_time", sub->end_display_time); print_int ("num_rects", sub->num_rects); writer_print_section_footer(w); av_bprint_finalize(&pbuf, NULL); fflush(stdout); }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, 0.5059163865058198, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.14353953243697165, 0.23107402248845843, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>const int av_twofish_size = sizeof(AVTWOFISH); static uint8_t gfmul(uint8_t a, uint8_t b) { uint8_t r = 0, t; while (a && b) { if (a & 1) r = r ^ b; t = b & 0x80; b = b << 1; if (t) b = b ^ 0x4d; a = a >> 1; } return r; }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void recombine_block(int16_t *dst, const uint8_t *scan, int16_t **base, int16_t **ext) { int i, j; for (i = 0; i < 4; i++) { for (j = 0; j < 4; j++) dst[scan[i * 8 + j]] = (*base)[j]; for (j = 0; j < 4; j++) dst[scan[i * 8 + j + 4]] = (*ext)[j]; *base += 4; *ext += 4; } for (; i < 8; i++) { for (j = 0; j < 8; j++) dst[scan[i * 8 + j]] = (*ext)[j]; *ext += 8; } }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.25252937827156396, -0.5591795518777907, 0.6817979554923368, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int yae_align(AudioFragment *frag, const AudioFragment *prev, const int window, const int delta_max, const int drift, FFTSample *correlation, RDFTContext *complex_to_real) { int best_offset = -drift; FFTSample best_metric = -FLT_MAX; FFTSample *xcorr; int i0; int i1; int i; yae_xcorr_via_rdft(correlation, complex_to_real, (const FFTComplex *)prev->xdat, (const FFTComplex *)frag->xdat, window); i0 = FFMAX(window / 2 - delta_max - drift, 0); i0 = FFMIN(i0, window); i1 = FFMIN(window / 2 + delta_max - drift, window - window / 16); i1 = FFMAX(i1, 0); xcorr = correlation + i0; for (i = i0; i < i1; i++, xcorr++) { FFTSample metric = *xcorr; FFTSample drifti = (FFTSample)(drift + i); metric *= drifti * (FFTSample)(i - i0) * (FFTSample)(i1 - i); if (metric > best_metric) { best_metric = metric; best_offset = i - window / 2; } } return best_offset; }<SPLIT>[0.21027592277004517, 0.11205980419667652, 0.0, 0.18995094088131478, 0.04037983893342262, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.128741635009873, 0.21894446904158188, 0.13609701908992267, 0.0, 0.0, 0.30852482215402843, 0.060916844891778815, 0.19837465696559078, 0.06381159668134254, 0.8941073316973973, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, 0.23792492798410134, 0.005287286955244392, 0.6817979554923368, 0.33317037975964214, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int request_frame(AVFilterLink *outlink) { EvalContext *eval = outlink->src->priv; AVFrame *samplesref; int i, j; int64_t t = av_rescale(eval->n, AV_TIME_BASE, eval->sample_rate); if (eval->duration >= 0 && t >= eval->duration) return AVERROR_EOF; samplesref = ff_get_audio_buffer(outlink, eval->nb_samples); if (!samplesref) return AVERROR(ENOMEM); for (i = 0; i < eval->nb_samples; i++, eval->n++) { eval->var_values[VAR_N] = eval->n; eval->var_values[VAR_T] = eval->var_values[VAR_N] * (double)1/eval->sample_rate; for (j = 0; j < eval->nb_channels; j++) { *((double *) samplesref->extended_data[j] + i) = av_expr_eval(eval->expr[j], eval->var_values, NULL); } } samplesref->pts = eval->pts; samplesref->sample_rate = eval->sample_rate; eval->pts += eval->nb_samples; return ff_filter_frame(outlink, samplesref); }<SPLIT>[-0.09900860198293619, -0.13034272285790952, 0.0, -0.11436118199787926, -0.1936866588694103, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.13098384443277505, -0.09566541730555662, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, -0.11100716297398205, -0.17914063696102905, -0.14106852214680915, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.06167779621789984, -0.3615192241061562, -0.10760608081136262, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int config_props_in(AVFilterLink *link) { AVFilterContext *ctx = link->dst; return config_props(ctx, link, 0); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int av_audio_fifo_peek(AVAudioFifo *af, void **data, int nb_samples) { int i, ret, size; if (nb_samples < 0) return AVERROR(EINVAL); nb_samples = FFMIN(nb_samples, af->nb_samples); if (!nb_samples) return 0; size = nb_samples * af->sample_size; for (i = 0; i < af->nb_buffers; i++) { if ((ret = av_fifo_generic_peek(af->buf[i], data[i], size, NULL)) < 0) return AVERROR_BUG; } return nb_samples; }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.1980344553542678, -0.10760608081136262, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int rtmp_pause(URLContext *s, int pause) { RTMPContext *rt = s->priv_data; int ret; av_log(s, AV_LOG_DEBUG, "Pause at timestamp %d\n", rt->last_timestamp); if ((ret = gen_pause(s, rt, pause, rt->last_timestamp)) < 0) { av_log(s, AV_LOG_ERROR, "Unable to send pause command at timestamp %d\n", rt->last_timestamp); return ret; } return 0; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.39986248560786075, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3615192241061562, -0.4462861841111837, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src, const int16_t *filter, const int32_t *filterPos, int filterSize) { int i; for (i = 0; i < dstW; i++) { int j; int srcPos = filterPos[i]; int val = 0; for (j = 0; j < filterSize; j++) { val += ((int)src[srcPos + j]) * filter[filterSize * i + j]; } dst[i] = FFMIN(val >> 7, (1 << 15) - 1); } }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, 0.11772544131424245, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.08904460951967552, -0.22049944857796966, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void print_sequence(const char *p, int l, int indent) { int i; for (i = 0; i < l; i++) printf("%02X", (uint8_t)p[i]); printf("%*s", indent-l*2, ""); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int av_file_map(const char *filename, uint8_t **bufptr, size_t *size, int log_offset, void *log_ctx) { FileLogContext file_log_ctx = { &file_log_ctx_class, log_offset, log_ctx }; int err, fd = avpriv_open(filename, O_RDONLY); struct stat st; av_unused void *ptr; off_t off_size; char errbuf[128]; *bufptr = NULL; if (fd < 0) { err = AVERROR(errno); av_strerror(err, errbuf, sizeof(errbuf)); av_log(&file_log_ctx, AV_LOG_ERROR, "Cannot read file '%s': %s\n", filename, errbuf); return err; } if (fstat(fd, &st) < 0) { err = AVERROR(errno); av_strerror(err, errbuf, sizeof(errbuf)); av_log(&file_log_ctx, AV_LOG_ERROR, "Error occurred in fstat(): %s\n", errbuf); close(fd); return err; } off_size = st.st_size; if (off_size > SIZE_MAX) { av_log(&file_log_ctx, AV_LOG_ERROR, "File size for file '%s' is too big\n", filename); close(fd); return AVERROR(EINVAL); } *size = off_size; #if HAVE_MMAP ptr = mmap(NULL, *size, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0); if (ptr == MAP_FAILED) { err = AVERROR(errno); av_strerror(err, errbuf, sizeof(errbuf)); av_log(&file_log_ctx, AV_LOG_ERROR, "Error occurred in mmap(): %s\n", errbuf); close(fd); return err; } *bufptr = ptr; #elif HAVE_MAPVIEWOFFILE { HANDLE mh, fh = (HANDLE)_get_osfhandle(fd); mh = CreateFileMapping(fh, NULL, PAGE_READONLY, 0, 0, NULL); if (!mh) { av_log(&file_log_ctx, AV_LOG_ERROR, "Error occurred in CreateFileMapping()\n"); close(fd); return -1; } ptr = MapViewOfFile(mh, FILE_MAP_READ, 0, 0, *size); CloseHandle(mh); if (!ptr) { av_log(&file_log_ctx, AV_LOG_ERROR, "Error occurred in MapViewOfFile()\n"); close(fd); return -1; } *bufptr = ptr; } #else *bufptr = av_malloc(*size); if (!*bufptr) { av_log(&file_log_ctx, AV_LOG_ERROR, "Memory allocation error occurred\n"); close(fd); return AVERROR(ENOMEM); } read(fd, *bufptr, *size); #endif close(fd); return 0; }<SPLIT>[-0.25365086435942685, 0.9053771654662308, 0.0, -0.2665172434374763, 0.8064156499245122, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 0.380400859743741, 0.7880447751335181, -0.25297036047912586, 0.2728543002775131, 0.0, 0.0, 0.30852482215402843, 0.7002463068235083, -0.26569807294376846, 0.19633099684990887, 0.6353133682363457, 0.7972807018539907, 0.0, 2.890212326771386, 2.1569430876889752, 0.9220224177425181, 0.7283792342397666, 0.6826474935548865, -0.21702784222394986, 0.7074534682410251, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 0.3801362775450152, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 0.3766295797615486]
0<SPLIT>void av_hmac_update(AVHMAC *c, const uint8_t *data, unsigned int len) { c->update(c->hash, data, len); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void encode_window_bands_info(AACEncContext *s, SingleChannelElement *sce, int win, int group_len, const float lambda) { BandCodingPath path[120][CB_TOT_ALL]; int w, swb, cb, start, size; int i, j; const int max_sfb = sce->ics.max_sfb; const int run_bits = sce->ics.num_windows == 1 ? 5 : 3; const int run_esc = (1 << run_bits) - 1; int idx, ppos, count; int stackrun[120], stackcb[120], stack_len; float next_minrd = INFINITY; int next_mincb = 0; abs_pow34_v(s->scoefs, sce->coeffs, 1024); start = win*128; for (cb = 0; cb < CB_TOT_ALL; cb++) { path[0][cb].cost = 0.0f; path[0][cb].prev_idx = -1; path[0][cb].run = 0; } for (swb = 0; swb < max_sfb; swb++) { size = sce->ics.swb_sizes[swb]; if (sce->zeroes[win*16 + swb]) { for (cb = 0; cb < CB_TOT_ALL; cb++) { path[swb+1][cb].prev_idx = cb; path[swb+1][cb].cost = path[swb][cb].cost; path[swb+1][cb].run = path[swb][cb].run + 1; } } else { float minrd = next_minrd; int mincb = next_mincb; next_minrd = INFINITY; next_mincb = 0; for (cb = 0; cb < CB_TOT_ALL; cb++) { float cost_stay_here, cost_get_here; float rd = 0.0f; if (cb >= 12 && sce->band_type[win*16+swb] < aac_cb_out_map[cb] || cb < aac_cb_in_map[sce->band_type[win*16+swb]] && sce->band_type[win*16+swb] > aac_cb_out_map[cb]) { path[swb+1][cb].prev_idx = -1; path[swb+1][cb].cost = INFINITY; path[swb+1][cb].run = path[swb][cb].run + 1; continue; } for (w = 0; w < group_len; w++) { FFPsyBand *band = &s->psy.ch[s->cur_channel].psy_bands[(win+w)*16+swb]; rd += quantize_band_cost(s, &sce->coeffs[start + w*128], &s->scoefs[start + w*128], size, sce->sf_idx[(win+w)*16+swb], aac_cb_out_map[cb], lambda / band->threshold, INFINITY, NULL, 0); } cost_stay_here = path[swb][cb].cost + rd; cost_get_here = minrd + rd + run_bits + 4; if ( run_value_bits[sce->ics.num_windows == 8][path[swb][cb].run] != run_value_bits[sce->ics.num_windows == 8][path[swb][cb].run+1]) cost_stay_here += run_bits; if (cost_get_here < cost_stay_here) { path[swb+1][cb].prev_idx = mincb; path[swb+1][cb].cost = cost_get_here; path[swb+1][cb].run = 1; } else { path[swb+1][cb].prev_idx = cb; path[swb+1][cb].cost = cost_stay_here; path[swb+1][cb].run = path[swb][cb].run + 1; } if (path[swb+1][cb].cost < next_minrd) { next_minrd = path[swb+1][cb].cost; next_mincb = cb; } } } start += sce->ics.swb_sizes[swb]; } stack_len = 0; idx = 0; for (cb = 1; cb < CB_TOT_ALL; cb++) if (path[max_sfb][cb].cost < path[max_sfb][idx].cost) idx = cb; ppos = max_sfb; while (ppos > 0) { av_assert1(idx >= 0); cb = idx; stackrun[stack_len] = path[ppos][cb].run; stackcb [stack_len] = cb; idx = path[ppos-path[ppos][cb].run+1][cb].prev_idx; ppos -= path[ppos][cb].run; stack_len++; } start = 0; for (i = stack_len - 1; i >= 0; i--) { cb = aac_cb_out_map[stackcb[i]]; put_bits(&s->pb, 4, cb); count = stackrun[i]; memset(sce->zeroes + win*16 + start, !cb, count); for (j = 0; j < count; j++) { sce->band_type[win*16 + start] = cb; start++; } while (count >= run_esc) { put_bits(&s->pb, run_bits, run_esc); count -= run_esc; } put_bits(&s->pb, run_bits, count); } }<SPLIT>[0.21027592277004517, 1.6325847466299888, 0.0, 0.18995094088131478, 1.5086151433330108, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, -0.27925050329511203, 1.5072845643593127, 0.21894446904158188, 1.708805752747213, 0.0, 0.0, 0.30852482215402843, 1.3976966289308497, 0.19837465696559078, 1.5877846986198554, 1.670489222080552, 2.1126769231284435, 0.0, -0.08645738172306322, -0.16222078614455715, 2.116515534694454, 2.1997421530067625, 2.376048010053992, -0.21702784222394986, 1.8303027336851738, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, -0.27935383381430245, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, -0.28182971586402455]
0<SPLIT>static av_cold int init(AVFilterContext *ctx) { InterleaveContext *s = ctx->priv; const AVFilterPad *outpad = &ctx->filter->outputs[0]; int i; s->queues = av_calloc(s->nb_inputs, sizeof(s->queues[0])); if (!s->queues) return AVERROR(ENOMEM); for (i = 0; i < s->nb_inputs; i++) { AVFilterPad inpad = { 0 }; inpad.name = av_asprintf("input%d", i); if (!inpad.name) return AVERROR(ENOMEM); inpad.type = outpad->type; inpad.filter_frame = filter_frame; switch (outpad->type) { case AVMEDIA_TYPE_VIDEO: inpad.get_video_buffer = ff_null_get_video_buffer; break; case AVMEDIA_TYPE_AUDIO: inpad.get_audio_buffer = ff_null_get_audio_buffer; break; default: av_assert0(0); } ff_insert_inpad(ctx, i, &inpad); } return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.12985034128681952, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.152192975752131, -0.26569807294376846, -0.1128809368767459, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void usage(int ret) { fprintf(ret ? stderr : stdout, "Usage: seek_print file [command ...]\n" "Commands:\n" " read\n" " seek:stream:min_ts:ts:max_ts:flags\n" ); exit(ret); }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int iec61883_read_packet(AVFormatContext *context, AVPacket *pkt) { struct iec61883_data *dv = context->priv_data; int size; #if THREADS pthread_mutex_lock(&dv->mutex); while ((size = dv->parse_queue(dv, pkt)) == -1) if (!dv->eof) pthread_cond_wait(&dv->cond, &dv->mutex); else break; pthread_mutex_unlock(&dv->mutex); #else int result; while ((size = dv->parse_queue(dv, pkt)) == -1) { iec61883_receive_task((void *)dv); if (dv->receive_error) return dv->receive_error; } #endif return size; }<SPLIT>[0.21027592277004517, -0.17441590959510697, 0.0, 0.18995094088131478, -0.23624420392447085, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.13098384443277505, 0.21894446904158188, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, 0.19837465696559078, -0.44417943729816173, -0.270465503877335, -0.4084991676475909, 0.0, 0.6852718019606829, 1.5771521192305922, -0.3427350002065907, -0.3615192241061562, -0.22049944857796966, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int request_frame(AVFilterLink *outlink) { MergePlanesContext *s = outlink->src->priv; return ff_framesync_request_frame(&s->fs, outlink); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold int init(AVFilterContext *ctx) { ATADenoiseContext *s = ctx->priv; if (!(s->size & 1)) { av_log(ctx, AV_LOG_ERROR, "size %d is invalid. Must be an odd value.\n", s->size); return AVERROR(EINVAL); } s->mid = s->size / 2 + 1; return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int read_packet(AVFormatContext *s, AVPacket *pkt) { WtvContext *wtv = s->priv_data; AVIOContext *pb = wtv->pb; int stream_index, len, ret; stream_index = parse_chunks(s, SEEK_TO_DATA, 0, &len); if (stream_index < 0) return stream_index; ret = av_get_packet(pb, pkt, len - 32); if (ret < 0) return ret; pkt->stream_index = stream_index; pkt->pts = wtv->pts; avio_skip(pb, WTV_PAD8(len) - len); return 0; }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.270465503877335, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.03454968660237938, 0.005287286955244392, -0.21702784222394986, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int check_keyboard_interaction(int64_t cur_time) { int i, ret, key; static int64_t last_time; if (received_nb_signals) return AVERROR_EXIT; if(cur_time - last_time >= 100000 && !run_as_daemon){ key = read_key(); last_time = cur_time; }else key = -1; if (key == 'q') return AVERROR_EXIT; if (key == '+') av_log_set_level(av_log_get_level()+10); if (key == '-') av_log_set_level(av_log_get_level()-10); if (key == 's') qp_hist ^= 1; if (key == 'h'){ if (do_hex_dump){ do_hex_dump = do_pkt_dump = 0; } else if(do_pkt_dump){ do_hex_dump = 1; } else do_pkt_dump = 1; av_log_set_level(AV_LOG_DEBUG); } if (key == 'c' || key == 'C'){ char buf[4096], target[64], command[256], arg[256] = {0}; double time; int k, n = 0; fprintf(stderr, "\nEnter command: <target>|all <time>|-1 <command>[ <argument>]\n"); i = 0; set_tty_echo(1); while ((k = read_key()) != '\n' && k != '\r' && i < sizeof(buf)-1) if (k > 0) buf[i++] = k; buf[i] = 0; set_tty_echo(0); fprintf(stderr, "\n"); if (k > 0 && (n = sscanf(buf, "%63[^ ] %lf %255[^ ] %255[^\n]", target, &time, command, arg)) >= 3) { av_log(NULL, AV_LOG_DEBUG, "Processing command target:%s time:%f command:%s arg:%s", target, time, command, arg); for (i = 0; i < nb_filtergraphs; i++) { FilterGraph *fg = filtergraphs[i]; if (fg->graph) { if (time < 0) { ret = avfilter_graph_send_command(fg->graph, target, command, arg, buf, sizeof(buf), key == 'c' ? AVFILTER_CMD_FLAG_ONE : 0); fprintf(stderr, "Command reply for stream %d: ret:%d res:\n%s", i, ret, buf); } else if (key == 'c') { fprintf(stderr, "Queuing commands only on filters supporting the specific command is unsupported\n"); ret = AVERROR_PATCHWELCOME; } else { ret = avfilter_graph_queue_command(fg->graph, target, command, arg, 0, time); if (ret < 0) fprintf(stderr, "Queuing command failed with error %s\n", av_err2str(ret)); } } } } else { av_log(NULL, AV_LOG_ERROR, "Parse error, at least 3 arguments were expected, " "only %d given in string '%s'\n", n, buf); } } if (key == 'd' || key == 'D'){ int debug=0; if(key == 'D') { debug = input_streams[0]->st->codec->debug<<1; if(!debug) debug = 1; while(debug & (FF_DEBUG_DCT_COEFF|FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) debug += debug; }else{ char buf[32]; int k = 0; i = 0; set_tty_echo(1); while ((k = read_key()) != '\n' && k != '\r' && i < sizeof(buf)-1) if (k > 0) buf[i++] = k; buf[i] = 0; set_tty_echo(0); fprintf(stderr, "\n"); if (k <= 0 || sscanf(buf, "%d", &debug)!=1) fprintf(stderr,"error parsing debug value\n"); } for(i=0;i<nb_input_streams;i++) { input_streams[i]->st->codec->debug = debug; } for(i=0;i<nb_output_streams;i++) { OutputStream *ost = output_streams[i]; ost->enc_ctx->debug = debug; } if(debug) av_log_set_level(AV_LOG_DEBUG); fprintf(stderr,"debug=%d\n", debug); } if (key == '?'){ fprintf(stderr, "key function\n" "? show this help\n" "+ increase verbosity\n" "- decrease verbosity\n" "c Send command to first matching filter supporting it\n" "C Send/Queue command to all matching filters\n" "D cycle through available debug modes\n" "h dump packets/hex press to cycle through the 3 states\n" "q quit\n" "s Show QP histogram\n" ); } return 0; }<SPLIT>[-0.09900860198293619, 1.78684090021018, 0.0, -0.11436118199787926, 1.6575665510257227, 0.0, 2.360513103434668, 2.4085531756423553, 3.3935614271413295, -0.27925050329511203, 1.607178979529562, -0.09566541730555662, 1.868355914132735, 0.0, 0.0, 0.30852482215402843, 1.494564729223536, -0.11100716297398205, 1.7423906654831827, 1.4116952586195004, 3.647305847948638, 0.0, -0.08645738172306322, -0.16222078614455715, 1.3787403742241406, 2.4177218446759468, 1.9244745389875635, 0.6817979554923368, 2.485298138527594, 2.359577116822857, 2.4077474138188704, 3.392410325483354, -0.27935383381430245, 2.6191065950439585, 0.0, 2.3535618892272994, 2.4016960724561396, 3.3849076942860865, -0.28182971586402455]
0<SPLIT>const char* ff_fbdev_default_device() { const char *dev = getenv("FRAMEBUFFER"); if (!dev) dev = "/dev/fb0"; return dev; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void remove_avoptions(AVDictionary **a, AVDictionary *b) { AVDictionaryEntry *t = NULL; while ((t = av_dict_get(b, "", t, AV_DICT_IGNORE_SUFFIX))) { av_dict_set(a, t->key, NULL, AV_DICT_MATCH_CASE); } }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void *resample_child_next(void *obj, void *prev) { AResampleContext *s = obj; return prev ? NULL : s->swr; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>int avcodec_default_get_buffer(AVCodecContext *s, AVFrame *pic){ int i; int w= s->width; int h= s->height; InternalBuffer *buf; int *picture_number; assert(pic->data[0]==NULL); assert(INTERNAL_BUFFER_SIZE > s->internal_buffer_count); if(avcodec_check_dimensions(s,w,h)) return -1; if(s->internal_buffer==NULL){ s->internal_buffer= av_mallocz(INTERNAL_BUFFER_SIZE*sizeof(InternalBuffer)); } #if 0 s->internal_buffer= av_fast_realloc( s->internal_buffer, &s->internal_buffer_size, sizeof(InternalBuffer)*FFMAX(99, s->internal_buffer_count+1) ); #endif buf= &((InternalBuffer*)s->internal_buffer)[s->internal_buffer_count]; picture_number= &(((InternalBuffer*)s->internal_buffer)[INTERNAL_BUFFER_SIZE-1]).last_pic_num; (*picture_number)++; if(buf->base[0]){ pic->age= *picture_number - buf->last_pic_num; buf->last_pic_num= *picture_number; }else{ int h_chroma_shift, v_chroma_shift; int pixel_size, size[3]; AVPicture picture; avcodec_get_chroma_sub_sample(s->pix_fmt, &h_chroma_shift, &v_chroma_shift); avcodec_align_dimensions(s, &w, &h); if(!(s->flags&CODEC_FLAG_EMU_EDGE)){ w+= EDGE_WIDTH*2; h+= EDGE_WIDTH*2; } avpicture_fill(&picture, NULL, s->pix_fmt, w, h); pixel_size= picture.linesize[0]*8 / w; assert(pixel_size>=1); if(pixel_size == 3*8) w= ALIGN(w, STRIDE_ALIGN<<h_chroma_shift); else w= ALIGN(pixel_size*w, STRIDE_ALIGN<<(h_chroma_shift+3)) / pixel_size; size[1] = avpicture_fill(&picture, NULL, s->pix_fmt, w, h); size[0] = picture.linesize[0] * h; size[1] -= size[0]; if(picture.data[2]) size[1]= size[2]= size[1]/2; else size[2]= 0; buf->last_pic_num= -256*256*256*64; memset(buf->base, 0, sizeof(buf->base)); memset(buf->data, 0, sizeof(buf->data)); for(i=0; i<3 && size[i]; i++){ const int h_shift= i==0 ? 0 : h_chroma_shift; const int v_shift= i==0 ? 0 : v_chroma_shift; buf->linesize[i]= picture.linesize[i]; buf->base[i]= av_malloc(size[i]+16); if(buf->base[i]==NULL) return -1; memset(buf->base[i], 128, size[i]); if((s->flags&CODEC_FLAG_EMU_EDGE) || (s->pix_fmt == PIX_FMT_PAL8) || !size[2]) buf->data[i] = buf->base[i]; else buf->data[i] = buf->base[i] + ALIGN((buf->linesize[i]*EDGE_WIDTH>>v_shift) + (EDGE_WIDTH>>h_shift), STRIDE_ALIGN); } pic->age= 256*256*256*64; } pic->type= FF_BUFFER_TYPE_INTERNAL; for(i=0; i<4; i++){ pic->base[i]= buf->base[i]; pic->data[i]= buf->data[i]; pic->linesize[i]= buf->linesize[i]; } s->internal_buffer_count++; return 0; }<SPLIT>[2.529909858417405, 1.0155601323092245, 0.0, 2.47229186247527, 0.9128095125621635, 0.0, 1.3177536816088504, 1.3480932287791254, 1.403457588528521, 1.040052222782594, 1.2475590849166647, 2.5785186166451206, 0.9110549458196018, 0.0, 0.0, 0.30852482215402843, 1.1458395681698652, 2.5187383065123874, 0.8147548643032184, 1.4116952586195004, 1.2357461089454749, 0.0, 0.4647777494796126, 0.9973611507722091, 1.203079621731209, 1.4368132321646163, 1.3600077001545285, -0.21702784222394986, 1.3624488730834452, 1.3170847170463484, 1.3475072793347742, 1.4027960089845035, 1.039626388904333, 1.7623686513065309, 0.0, 1.3123839157220905, 1.3427725632242797, 1.3979248575624994, 1.0350888753871217]
0<SPLIT>static inline int get8(const uint8_t **pp, const uint8_t *p_end) { const uint8_t *p; int c; p = *pp; if (p >= p_end) return AVERROR_INVALIDDATA; c = *p++; *pp = p; return c; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>static int avi_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags) { AVIContext *avi = s->priv_data; AVStream *st; int i, index; int64_t pos, pos_min; AVIStream *ast; if (avi->dv_demux) stream_index = 0; if (!avi->index_loaded) { avi_load_index(s); avi->index_loaded |= 1; } av_assert0(stream_index >= 0); st = s->streams[stream_index]; ast = st->priv_data; index = av_index_search_timestamp(st, timestamp * FFMAX(ast->sample_size, 1), flags); if (index < 0) { if (st->nb_index_entries > 0) av_log(s, AV_LOG_DEBUG, "Failed to find timestamp %"PRId64 " in index %"PRId64 " .. %"PRId64 "\n", timestamp * FFMAX(ast->sample_size, 1), st->index_entries[0].timestamp, st->index_entries[st->nb_index_entries - 1].timestamp); return AVERROR_INVALIDDATA; } pos = st->index_entries[index].pos; timestamp = st->index_entries[index].timestamp / FFMAX(ast->sample_size, 1); av_log(s, AV_LOG_TRACE, "XX %"PRId64" %d %"PRId64"\n", timestamp, index, st->index_entries[index].timestamp); if (CONFIG_DV_DEMUXER && avi->dv_demux) { if (avio_seek(s->pb, pos, SEEK_SET) < 0) return -1; ff_dv_offset_reset(avi->dv_demux, timestamp); avi->stream_index = -1; return 0; } pos_min = pos; for (i = 0; i < s->nb_streams; i++) { AVStream *st2 = s->streams[i]; AVIStream *ast2 = st2->priv_data; ast2->packet_size = ast2->remaining = 0; if (ast2->sub_ctx) { seek_subtitle(st, st2, timestamp); continue; } if (st2->nb_index_entries <= 0) continue; av_assert0(fabs(av_q2d(st2->time_base) - ast2->scale / (double)ast2->rate) < av_q2d(st2->time_base) * 0.00000001); index = av_index_search_timestamp(st2, av_rescale_q(timestamp, st->time_base, st2->time_base) * FFMAX(ast2->sample_size, 1), flags | AVSEEK_FLAG_BACKWARD | (st2->codec->codec_type != AVMEDIA_TYPE_VIDEO ? AVSEEK_FLAG_ANY : 0)); if (index < 0) index = 0; ast2->seek_pos = st2->index_entries[index].pos; pos_min = FFMIN(pos_min,ast2->seek_pos); } for (i = 0; i < s->nb_streams; i++) { AVStream *st2 = s->streams[i]; AVIStream *ast2 = st2->priv_data; if (ast2->sub_ctx || st2->nb_index_entries <= 0) continue; index = av_index_search_timestamp( st2, av_rescale_q(timestamp, st->time_base, st2->time_base) * FFMAX(ast2->sample_size, 1), flags | AVSEEK_FLAG_BACKWARD | (st2->codec->codec_type != AVMEDIA_TYPE_VIDEO ? AVSEEK_FLAG_ANY : 0)); if (index < 0) index = 0; while (!avi->non_interleaved && index>0 && st2->index_entries[index-1].pos >= pos_min) index--; ast2->frame_offset = st2->index_entries[index].timestamp; } if (avio_seek(s->pb, pos_min, SEEK_SET) < 0) { av_log(s, AV_LOG_ERROR, "Seek failed\n"); return -1; } avi->stream_index = -1; avi->dts_max = INT_MIN; return 0; }<SPLIT>[4.230974744558803, 1.279999252732409, 0.0, 4.146008538310838, 1.1681547828925267, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 0.7102265412631674, 1.7070733946998113, 4.308872991554383, 1.3441196695803048, 0.0, 0.0, 0.30852482215402843, 1.5914328295162223, 4.220338316180038, 1.2343996315036785, 0.8941073316973973, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, 1.027418869238277, 0.7283792342397666, 0.7955408613214935, -0.21702784222394986, 0.6138826961206794, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 0.7098813332246741, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 0.7058592275743352]
0<SPLIT>int ff_alsa_extend_reorder_buf(AlsaData *s, int min_size) { int size = s->reorder_buf_size; void *r; av_assert0(size != 0); while (size < min_size) size *= 2; r = av_realloc_array(s->reorder_buf, size, s->frame_size); if (!r) return AVERROR(ENOMEM); s->reorder_buf = r; s->reorder_buf_size = size; return 0; }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.14106852214680915, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.1980344553542678, -0.22049944857796966, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void show_help_default(const char *opt, const char *arg) { const int per_file = OPT_SPEC | OPT_OFFSET | OPT_PERFILE; int show_advanced = 0, show_avoptions = 0; if (opt && *opt) { if (!strcmp(opt, "long")) show_advanced = 1; else if (!strcmp(opt, "full")) show_advanced = show_avoptions = 1; else av_log(NULL, AV_LOG_ERROR, "Unknown help option '%s'.\n", opt); } show_usage(); printf("Getting help:\n" " -h -- print basic options\n" " -h long -- print more options\n" " -h full -- print all options (including all format and codec specific options, very long)\n" " -h type=name -- print all options for the named decoder/encoder/demuxer/muxer/filter\n" " See man %s for detailed description of the options.\n" "\n", program_name); show_help_options(options, "Print help / information / capabilities:", OPT_EXIT, 0, 0); show_help_options(options, "Global options (affect whole program " "instead of just one file:", 0, per_file | OPT_EXIT | OPT_EXPERT, 0); if (show_advanced) show_help_options(options, "Advanced global options:", OPT_EXPERT, per_file | OPT_EXIT, 0); show_help_options(options, "Per-file main options:", 0, OPT_EXPERT | OPT_AUDIO | OPT_VIDEO | OPT_SUBTITLE | OPT_EXIT, per_file); if (show_advanced) show_help_options(options, "Advanced per-file options:", OPT_EXPERT, OPT_AUDIO | OPT_VIDEO | OPT_SUBTITLE, per_file); show_help_options(options, "Video options:", OPT_VIDEO, OPT_EXPERT | OPT_AUDIO, 0); if (show_advanced) show_help_options(options, "Advanced Video options:", OPT_EXPERT | OPT_VIDEO, OPT_AUDIO, 0); show_help_options(options, "Audio options:", OPT_AUDIO, OPT_EXPERT | OPT_VIDEO, 0); if (show_advanced) show_help_options(options, "Advanced Audio options:", OPT_EXPERT | OPT_AUDIO, OPT_VIDEO, 0); show_help_options(options, "Subtitle options:", OPT_SUBTITLE, 0, 0); printf("\n"); if (show_avoptions) { int flags = AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_ENCODING_PARAM; show_help_children(avcodec_get_class(), flags); show_help_children(avformat_get_class(), flags); #if CONFIG_SWSCALE show_help_children(sws_get_class(), flags); #endif show_help_children(swr_get_class(), AV_OPT_FLAG_AUDIO_PARAM); show_help_children(avfilter_get_class(), AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_FILTERING_PARAM); } }<SPLIT>[-0.09900860198293619, 0.6189014516744473, 0.0, -0.11436118199787926, 0.5297916070666188, 0.0, 0.27499425978303293, 0.2876332819158955, 0.4084056692221168, -0.27925050329511203, 0.5482981787249199, -0.09566541730555662, 0.5919546230485575, 0.0, 0.0, 0.30852482215402843, 0.4677628661210612, -0.11100716297398205, 0.5055429305765636, 0.7647103499668715, 0.7972807018539907, 0.0, 0.02378964451747194, 0.9973611507722091, 0.14911510677361828, 0.6738843113224704, 0.7955408613214935, 0.6817979554923368, 0.42674115187998785, 0.27459231726984007, 0.28726714485067795, 0.40798885073507796, -0.27935383381430245, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.4044334392007059, -0.28182971586402455]
0<SPLIT>static void apply_independent_coupling(AACContext *ac, SingleChannelElement *target, ChannelElement *cce, int index) { int i; const float gain = cce->coup.gain[index][0]; const float *src = cce->ch[0].ret; float *dest = target->ret; const int len = 1024 << (ac->oc[1].m4ac.sbr == 1); for (i = 0; i < len; i++) dest[i] += gain * src[i]; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, 0.11772544131424245, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.1980344553542678, -0.22049944857796966, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { AVFilterFormats *formats = NULL; AVFilterChannelLayouts *layouts = NULL; AVFilterLink *inlink = ctx->inputs[0]; AVFilterLink *outlink = ctx->outputs[0]; static const enum AVSampleFormat sample_fmts[] = { AV_SAMPLE_FMT_FLTP, AV_SAMPLE_FMT_NONE }; static const enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_RGBA, AV_PIX_FMT_NONE }; formats = ff_make_format_list(sample_fmts); if (!formats) return AVERROR(ENOMEM); ff_formats_ref(formats, &inlink->out_formats); layouts = ff_all_channel_layouts(); if (!layouts) return AVERROR(ENOMEM); ff_channel_layouts_ref(layouts, &inlink->out_channel_layouts); formats = ff_all_samplerates(); if (!formats) return AVERROR(ENOMEM); ff_formats_ref(formats, &inlink->out_samplerates); formats = ff_make_format_list(pix_fmts); if (!formats) return AVERROR(ENOMEM); ff_formats_ref(formats, &outlink->in_formats); return 0; }<SPLIT>[0.05563366039355449, -0.08626953612071205, 0.0, 0.037794879441717756, -0.12985034128681952, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.07104719533062549, 0.061639525868012635, -0.06903890269146298, 0.0, 0.0, 0.30852482215402843, -0.1134457356350565, 0.04368374699580437, -0.1128809368767459, 0.37651940477529405, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, -0.03454968660237938, 0.4568607580216725, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void compute_status(HTTPContext *c) { HTTPContext *c1; FFServerStream *stream; char *p; time_t ti; int i, len; AVIOContext *pb; if (avio_open_dyn_buf(&pb) < 0) { c->buffer_ptr = c->buffer; c->buffer_end = c->buffer; return; } avio_printf(pb, "HTTP/1.0 200 OK\r\n"); avio_printf(pb, "Content-type: text/html\r\n"); avio_printf(pb, "Pragma: no-cache\r\n"); avio_printf(pb, "\r\n"); avio_printf(pb, "<!DOCTYPE html>\n"); avio_printf(pb, "<html><head><title>%s Status</title>\n", program_name); if (c->stream->feed_filename[0]) avio_printf(pb, "<link rel=\"shortcut icon\" href=\"%s\">\n", c->stream->feed_filename); avio_printf(pb, "</head>\n<body>"); avio_printf(pb, "<h1>%s Status</h1>\n", program_name); avio_printf(pb, "<h2>Available Streams</h2>\n"); avio_printf(pb, "<table>\n"); avio_printf(pb, "<tr><th>Path<th>Served<br>Conns<th><br>bytes<th>Format<th>Bit rate<br>kbit/s<th>Video<br>kbit/s<th><br>Codec<th>Audio<br>kbit/s<th><br>Codec<th>Feed\n"); stream = config.first_stream; while (stream) { char sfilename[1024]; char *eosf; if (stream->feed == stream) { stream = stream->next; continue; } av_strlcpy(sfilename, stream->filename, sizeof(sfilename) - 10); eosf = sfilename + strlen(sfilename); if (eosf - sfilename >= 4) { if (strcmp(eosf - 4, ".asf") == 0) strcpy(eosf - 4, ".asx"); else if (strcmp(eosf - 3, ".rm") == 0) strcpy(eosf - 3, ".ram"); else if (stream->fmt && !strcmp(stream->fmt->name, "rtp")) { eosf = strrchr(sfilename, '.'); if (!eosf) eosf = sfilename + strlen(sfilename); if (stream->is_multicast) strcpy(eosf, ".sdp"); else strcpy(eosf, ".rtsp"); } } avio_printf(pb, "<tr><td><a href=\"/%s\">%s</a> ", sfilename, stream->filename); avio_printf(pb, "<td> %d <td> ", stream->conns_served); if (!config.bitexact) fmt_bytecount(pb, stream->bytes_served); switch(stream->stream_type) { case STREAM_TYPE_LIVE: { int audio_bit_rate = 0; int video_bit_rate = 0; const char *audio_codec_name = ""; const char *video_codec_name = ""; const char *audio_codec_name_extra = ""; const char *video_codec_name_extra = ""; for(i=0;i<stream->nb_streams;i++) { LayeredAVStream *st = stream->streams[i]; AVCodec *codec = avcodec_find_encoder(st->codecpar->codec_id); switch(st->codecpar->codec_type) { case AVMEDIA_TYPE_AUDIO: audio_bit_rate += st->codecpar->bit_rate; if (codec) { if (*audio_codec_name) audio_codec_name_extra = "..."; audio_codec_name = codec->name; } break; case AVMEDIA_TYPE_VIDEO: video_bit_rate += st->codecpar->bit_rate; if (codec) { if (*video_codec_name) video_codec_name_extra = "..."; video_codec_name = codec->name; } break; case AVMEDIA_TYPE_DATA: video_bit_rate += st->codecpar->bit_rate; break; default: abort(); } } avio_printf(pb, "<td> %s <td> %d <td> %d <td> %s %s <td> " "%d <td> %s %s", stream->fmt->name, stream->bandwidth, video_bit_rate / 1000, video_codec_name, video_codec_name_extra, audio_bit_rate / 1000, audio_codec_name, audio_codec_name_extra); if (stream->feed) avio_printf(pb, "<td>%s", stream->feed->filename); else avio_printf(pb, "<td>%s", stream->feed_filename); avio_printf(pb, "\n"); } break; default: avio_printf(pb, "<td> - <td> - " "<td> - <td><td> - <td>\n"); break; } stream = stream->next; } avio_printf(pb, "</table>\n"); stream = config.first_stream; while (stream) { if (stream->feed != stream) { stream = stream->next; continue; } avio_printf(pb, "<h2>Feed %s</h2>", stream->filename); if (stream->pid) { avio_printf(pb, "Running as pid %"PRId64".\n", (int64_t) stream->pid); #if defined(linux) { FILE *pid_stat; char ps_cmd[64]; snprintf(ps_cmd, sizeof(ps_cmd), "ps -o \"%%cpu,cputime\" --no-headers %"PRId64"", (int64_t) stream->pid); pid_stat = popen(ps_cmd, "r"); if (pid_stat) { char cpuperc[10]; char cpuused[64]; if (fscanf(pid_stat, "%9s %63s", cpuperc, cpuused) == 2) { avio_printf(pb, "Currently using %s%% of the cpu. " "Total time used %s.\n", cpuperc, cpuused); } fclose(pid_stat); } } #endif avio_printf(pb, "<p>"); } print_stream_params(pb, stream); stream = stream->next; } avio_printf(pb, "<h2>Connection Status</h2>\n"); avio_printf(pb, "Number of connections: %d / %d<br>\n", nb_connections, config.nb_max_connections); avio_printf(pb, "Bandwidth in use: %"PRIu64"k / %"PRIu64"k<br>\n", current_bandwidth, config.max_bandwidth); avio_printf(pb, "<table>\n"); avio_printf(pb, "<tr><th>#<th>File<th>IP<th>URL<th>Proto<th>State<th>Target " "bit/s<th>Actual bit/s<th>Bytes transferred\n"); c1 = first_http_ctx; i = 0; while (c1) { int bitrate; int j; bitrate = 0; if (c1->stream) { for (j = 0; j < c1->stream->nb_streams; j++) { if (!c1->stream->feed) bitrate += c1->stream->streams[j]->codecpar->bit_rate; else if (c1->feed_streams[j] >= 0) bitrate += c1->stream->feed->streams[c1->feed_streams[j]]->codecpar->bit_rate; } } i++; p = inet_ntoa(c1->from_addr.sin_addr); clean_html(c1->clean_url, sizeof(c1->clean_url), c1->url); avio_printf(pb, "<tr><td><b>%d</b><td>%s%s<td>%s<td>%s<td>%s<td>%s" "<td>", i, c1->stream ? c1->stream->filename : "", c1->state == HTTPSTATE_RECEIVE_DATA ? "(input)" : "", p, c1->clean_url, c1->protocol, http_state[c1->state]); fmt_bytecount(pb, bitrate); avio_printf(pb, "<td>"); fmt_bytecount(pb, compute_datarate(&c1->datarate, c1->data_count) * 8); avio_printf(pb, "<td>"); fmt_bytecount(pb, c1->data_count); avio_printf(pb, "\n"); c1 = c1->next; } avio_printf(pb, "</table>\n"); if (!config.bitexact) { ti = time(NULL); p = ctime(&ti); avio_printf(pb, "<hr>Generated at %s", p); } avio_printf(pb, "</body>\n</html>\n"); len = avio_close_dyn_buf(pb, &c->pb_buffer); c->buffer_ptr = c->pb_buffer; c->buffer_end = c->pb_buffer + len; }<SPLIT>[1.1381294970289892, 3.7260611166468682, 0.0, 1.102887309518897, 3.530098533448386, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 3.5251517507983476, 1.0054691849094282, 3.4182717675920933, 0.0, 0.0, 0.30852482215402843, 3.354432254843113, 0.9718292068145229, 3.2442772007269345, 3.093856021116336, 0.029966239443893296, 0.0, 2.0082361168471046, 0.9973611507722091, 3.3812729526435628, 1.273328463412728, 2.7147281133538126, -0.21702784222394986, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void parse_forced_key_frames(char *kf, OutputStream *ost, AVCodecContext *avctx) { char *p; int n = 1, i, size, index = 0; int64_t t, *pts; for (p = kf; *p; p++) if (*p == ',') n++; size = n; pts = av_malloc_array(size, sizeof(*pts)); if (!pts) { av_log(NULL, AV_LOG_FATAL, "Could not allocate forced key frames array.\n"); exit_program(1); } p = kf; for (i = 0; i < n; i++) { char *next = strchr(p, ','); if (next) *next++ = 0; if (!memcmp(p, "chapters", 8)) { AVFormatContext *avf = output_files[ost->file_index]->ctx; int j; if (avf->nb_chapters > INT_MAX - size || !(pts = av_realloc_f(pts, size += avf->nb_chapters - 1, sizeof(*pts)))) { av_log(NULL, AV_LOG_FATAL, "Could not allocate forced key frames array.\n"); exit_program(1); } t = p[8] ? parse_time_or_die("force_key_frames", p + 8, 1) : 0; t = av_rescale_q(t, AV_TIME_BASE_Q, avctx->time_base); for (j = 0; j < avf->nb_chapters; j++) { AVChapter *c = avf->chapters[j]; av_assert1(index < size); pts[index++] = av_rescale_q(c->start, c->time_base, avctx->time_base) + t; } } else { t = parse_time_or_die("force_key_frames", p, 1); av_assert1(index < size); pts[index++] = av_rescale_q(t, AV_TIME_BASE_Q, avctx->time_base); } p = next; } av_assert0(index == size); qsort(pts, size, sizeof(*pts), compare_int64); ost->forced_kf_count = size; ost->forced_kf_pts = pts; }<SPLIT>[-0.25365086435942685, 0.4426087047256575, 0.0, -0.2665172434374763, 0.3595614268463766, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, -0.27925050329511203, 0.3684882314184712, -0.25297036047912586, 0.4779902220588988, 0.0, 0.0, 0.30852482215402843, 0.29340028559422593, -0.26569807294376846, 0.39511009710275835, 1.1529012951584487, 1.454978812491217, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5004366117594818, 1.3823183092473201, 1.2471143323879217, -0.21702784222394986, 1.3624488730834452, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, -0.27935383381430245, 1.7623686513065309, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, -0.28182971586402455]
0<SPLIT>int av_frame_make_writable(AVFrame *frame) { AVFrame tmp; int ret; if (!frame->buf[0]) return AVERROR(EINVAL); if (av_frame_is_writable(frame)) return 0; memset(&tmp, 0, sizeof(tmp)); tmp.format = frame->format; tmp.width = frame->width; tmp.height = frame->height; tmp.channels = frame->channels; tmp.channel_layout = frame->channel_layout; tmp.nb_samples = frame->nb_samples; ret = av_frame_get_buffer(&tmp, 32); if (ret < 0) return ret; ret = av_frame_copy(&tmp, frame); if (ret < 0) { av_frame_unref(&tmp); return ret; } ret = av_frame_copy_props(&tmp, frame); if (ret < 0) { av_frame_unref(&tmp); return ret; } av_frame_unref(frame); *frame = tmp; if (tmp.data == tmp.extended_data) frame->extended_data = frame->data; return 0; }<SPLIT>[-0.25365086435942685, 0.0900232108280778, 0.0, -0.2665172434374763, 0.01910106640589235, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 1.040052222782594, 0.04882610287367361, -0.25297036047912586, 0.11330413889199094, 0.0, 0.0, 0.30852482215402843, -0.016577635342370212, -0.26569807294376846, 0.04172502998658149, 0.24712242304476825, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, 0.11398295627503194, 0.23792492798410134, 0.11818065472185141, -0.21702784222394986, 0.33317037975964214, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 1.039626388904333, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 1.0350888753871217]
0<SPLIT>static int inject_fake_duration_metadata(RTMPContext *rt) { uint8_t* p; uint8_t* old_flv_data = rt->flv_data; if (!(rt->flv_data = av_malloc(rt->flv_size + 55))) { rt->flv_data = old_flv_data; return AVERROR(ENOMEM); } memcpy(rt->flv_data, old_flv_data, 13); memcpy(rt->flv_data + 13 + 55, old_flv_data + 13, rt->flv_size - 13); rt->flv_size += 55; av_freep(&old_flv_data); p = rt->flv_data + 13; bytestream_put_byte(&p, FLV_TAG_TYPE_META); bytestream_put_be24(&p, 40); bytestream_put_be24(&p, 0); bytestream_put_be32(&p, 0); bytestream_put_byte(&p, AMF_DATA_TYPE_STRING); bytestream_put_be16(&p, 10); bytestream_put_buffer(&p, "onMetaData", 10); bytestream_put_byte(&p, AMF_DATA_TYPE_MIXEDARRAY); bytestream_put_be32(&p, 1); bytestream_put_be16(&p, 8); bytestream_put_buffer(&p, "duration", 8); bytestream_put_byte(&p, AMF_DATA_TYPE_NUMBER); bytestream_put_be64(&p, av_double2int(rt->duration)); bytestream_put_be16(&p, 0); bytestream_put_byte(&p, AMF_END_OF_OBJECT); bytestream_put_be32(&p, 40); return 0; }<SPLIT>[1.9113408089114425, 0.023913430722281605, 0.0, 1.863667616716882, -0.044735251176698444, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.268593816248222, 1.9492988439508436, 0.04492549829819571, 0.0, 0.0, 0.30852482215402843, 0.19653218530153962, 1.8999746666332415, -0.024534670097701678, 0.5059163865058198, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.21937940777079099, 0.01994523631491676, 0.4568607580216725, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void print_track_chunks(FILE *out, struct Tracks *tracks, int main, const char *type) { int i, j; int64_t pos = 0; struct Track *track = tracks->tracks[main]; int should_print_time_mismatch = 1; for (i = 0; i < track->chunks; i++) { for (j = main + 1; j < tracks->nb_tracks; j++) { if (tracks->tracks[j]->is_audio == track->is_audio) { if (track->offsets[i].duration != tracks->tracks[j]->offsets[i].duration) { fprintf(stderr, "Mismatched duration of %s chunk %d in %s (%d) and %s (%d)\n", type, i, track->name, main, tracks->tracks[j]->name, j); should_print_time_mismatch = 1; } if (track->offsets[i].time != tracks->tracks[j]->offsets[i].time) { if (should_print_time_mismatch) fprintf(stderr, "Mismatched (start) time of %s chunk %d in %s (%d) and %s (%d)\n", type, i, track->name, main, tracks->tracks[j]->name, j); should_print_time_mismatch = 0; } } } fprintf(out, "\t\t<c n=\"%d\" d=\"%"PRId64"\" ", i, track->offsets[i].duration); if (pos != track->offsets[i].time) { fprintf(out, "t=\"%"PRId64"\" ", track->offsets[i].time); pos = track->offsets[i].time; } pos += track->offsets[i].duration; fprintf(out, "/>\n"); } }<SPLIT>[-0.25365086435942685, 0.06798661745947907, 0.0, -0.2665172434374763, -0.0021777061216379156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.02884721983962376, -0.25297036047912586, 0.0905112586940592, 0.0, 0.0, 0.30852482215402843, -0.03595125540090747, -0.26569807294376846, 0.01963846329182043, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.3070243011888601, 0.005287286955244392, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int chr_planar_vscale(SwsContext *c, SwsFilterDescriptor *desc, int sliceY, int sliceH) { const int chrSkipMask = (1 << desc->dst->v_chr_sub_sample) - 1; if (sliceY & chrSkipMask) return 0; else { VScalerContext *inst = desc->instance; int dstW = FF_CEIL_RSHIFT(desc->dst->width, desc->dst->h_chr_sub_sample); int chrSliceY = sliceY >> desc->dst->v_chr_sub_sample; int first = FFMAX(1-inst->filter_size, inst->filter_pos[chrSliceY]); int sp1 = first - desc->src->plane[1].sliceY; int sp2 = first - desc->src->plane[2].sliceY; int dp1 = chrSliceY - desc->dst->plane[1].sliceY; int dp2 = chrSliceY - desc->dst->plane[2].sliceY; uint8_t **src1 = desc->src->plane[1].line + sp1; uint8_t **src2 = desc->src->plane[2].line + sp2; uint8_t **dst1 = desc->dst->plane[1].line + dp1; uint8_t **dst2 = desc->dst->plane[2].line + dp2; uint16_t *filter = inst->filter[0] + (inst->isMMX ? 0 : chrSliceY * inst->filter_size); if (c->yuv2nv12cX) { ((yuv2interleavedX_fn)inst->pfn)(c, filter, inst->filter_size, (const int16_t**)src1, (const int16_t**)src2, dst1[0], dstW); } else if (inst->filter_size == 1) { ((yuv2planar1_fn)inst->pfn)((const int16_t*)src1[0], dst1[0], dstW, c->chrDither8, 0); ((yuv2planar1_fn)inst->pfn)((const int16_t*)src2[0], dst2[0], dstW, c->chrDither8, 3); } else { ((yuv2planarX_fn)inst->pfn)(filter, inst->filter_size, (const int16_t**)src1, dst1[0], dstW, c->chrDither8, 0); ((yuv2planarX_fn)inst->pfn)(filter, inst->filter_size, (const int16_t**)src2, dst2[0], dstW, c->chrDither8, inst->isMMX ? (c->uv_offx2 >> 1) : 3); } } return 1; }<SPLIT>[-0.25365086435942685, 0.023913430722281605, 0.0, -0.2665172434374763, -0.044735251176698444, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.011110546228475942, -0.25297036047912586, 0.04492549829819571, 0.0, 0.0, 0.30852482215402843, -0.07469849551798198, -0.26569807294376846, -0.024534670097701678, 0.24712242304476825, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, 0.043718655277859224, 0.12893508214950905, 0.34396739025506545, -0.21702784222394986, -0.04111270872174079, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static inline double update_value(double new, double old, double aggressiveness) { av_assert0((aggressiveness >= 0.0) && (aggressiveness <= 1.0)); return aggressiveness * new + (1.0 - aggressiveness) * old; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.2549622769821527, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5250039928580447, -0.6720729196443977, -0.21702784222394986, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.2552159214312056, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *rst, unsigned int codec_data_size, const uint8_t *mime) { unsigned int v; int size; int64_t codec_pos; int ret; if (codec_data_size > INT_MAX) return AVERROR_INVALIDDATA; if (codec_data_size == 0) return 0; avpriv_set_pts_info(st, 64, 1, 1000); codec_pos = avio_tell(pb); v = avio_rb32(pb); if (v == MKTAG(0xfd, 'a', 'r', '.')) { if (rm_read_audio_stream_info(s, pb, st, rst, 0)) return -1; } else if (v == MKBETAG('L', 'S', 'D', ':')) { avio_seek(pb, -4, SEEK_CUR); if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0) return ret; st->codec->codec_type = AVMEDIA_TYPE_AUDIO; st->codec->codec_tag = AV_RL32(st->codec->extradata); st->codec->codec_id = ff_codec_get_id(ff_rm_codec_tags, st->codec->codec_tag); } else if(mime && !strcmp(mime, "logical-fileinfo")){ int stream_count, rule_count, property_count, i; ff_free_stream(s, st); if (avio_rb16(pb) != 0) { av_log(s, AV_LOG_WARNING, "Unsupported version\n"); goto skip; } stream_count = avio_rb16(pb); avio_skip(pb, 6*stream_count); rule_count = avio_rb16(pb); avio_skip(pb, 2*rule_count); property_count = avio_rb16(pb); for(i=0; i<property_count; i++){ uint8_t name[128], val[128]; avio_rb32(pb); if (avio_rb16(pb) != 0) { av_log(s, AV_LOG_WARNING, "Unsupported Name value property version\n"); goto skip; } get_str8(pb, name, sizeof(name)); switch(avio_rb32(pb)) { case 2: get_strl(pb, val, sizeof(val), avio_rb16(pb)); av_dict_set(&s->metadata, name, val, 0); break; default: avio_skip(pb, avio_rb16(pb)); } } } else { int fps; if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) { fail1: av_log(s, AV_LOG_WARNING, "Unsupported stream type %08x\n", v); goto skip; } st->codec->codec_tag = avio_rl32(pb); st->codec->codec_id = ff_codec_get_id(ff_rm_codec_tags, st->codec->codec_tag); av_log(s, AV_LOG_TRACE, "%X %X\n", st->codec->codec_tag, MKTAG('R', 'V', '2', '0')); if (st->codec->codec_id == AV_CODEC_ID_NONE) goto fail1; st->codec->width = avio_rb16(pb); st->codec->height = avio_rb16(pb); avio_skip(pb, 2); avio_skip(pb, 4); st->codec->codec_type = AVMEDIA_TYPE_VIDEO; st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS; fps = avio_rb32(pb); if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < 0) return ret; if (fps > 0) { av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num, 0x10000, fps, (1 << 30) - 1); #if FF_API_R_FRAME_RATE st->r_frame_rate = st->avg_frame_rate; #endif } else if (s->error_recognition & AV_EF_EXPLODE) { av_log(s, AV_LOG_ERROR, "Invalid framerate\n"); return AVERROR_INVALIDDATA; } } skip: size = avio_tell(pb) - codec_pos; if (codec_data_size >= size) { avio_skip(pb, codec_data_size - size); } else { av_log(s, AV_LOG_WARNING, "codec_data_size %u < size %d\n", codec_data_size, size); } return 0; }<SPLIT>[0.05563366039355449, 1.4342554063126, 0.0, 0.037794879441717756, 1.3171061905852386, 0.0, 2.186719866463698, 2.2318098511651505, 2.0668255347327906, 3.6786576749380067, 1.3074957340188142, 0.061639525868012635, 1.4352911903720318, 0.0, 0.0, 0.30852482215402843, 1.203960428345477, 0.04368374699580437, 1.3227458982827227, 2.7056650759247582, 1.674211516036959, 0.0, 0.02378964451747194, 0.9973611507722091, 1.3436082237255544, 2.472216767593243, 2.6018347455872055, 1.5806237532086234, 1.9238735058055194, 2.185828383526772, 2.231040724738188, 2.066000781150787, 3.6775868343416036, 1.7623686513065309, 0.0, 2.180032226976431, 2.225208820917496, 2.0602524698036953, 3.6689260578894145]
0<SPLIT>struct AVCAMELLIA *av_camellia_alloc(void) { return av_mallocz(sizeof(struct AVCAMELLIA)); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int parse_frame_header(AC3DecodeContext *s) { AC3HeaderInfo hdr, *phdr=&hdr; int err; err = avpriv_ac3_parse_header2(&s->gbc, &phdr); if (err) return err; s->bit_alloc_params.sr_code = hdr.sr_code; s->bitstream_id = hdr.bitstream_id; s->bitstream_mode = hdr.bitstream_mode; s->channel_mode = hdr.channel_mode; s->lfe_on = hdr.lfe_on; s->bit_alloc_params.sr_shift = hdr.sr_shift; s->sample_rate = hdr.sample_rate; s->bit_rate = hdr.bit_rate; s->channels = hdr.channels; s->fbw_channels = s->channels - s->lfe_on; s->lfe_ch = s->fbw_channels + 1; s->frame_size = hdr.frame_size; s->preferred_downmix = AC3_DMIXMOD_NOTINDICATED; s->center_mix_level = hdr.center_mix_level; s->center_mix_level_ltrt = 4; s->surround_mix_level = hdr.surround_mix_level; s->surround_mix_level_ltrt = 4; s->lfe_mix_level_exists = 0; s->num_blocks = hdr.num_blocks; s->frame_type = hdr.frame_type; s->substreamid = hdr.substreamid; s->dolby_surround_mode = hdr.dolby_surround_mode; s->dolby_surround_ex_mode = AC3_DSUREXMOD_NOTINDICATED; s->dolby_headphone_mode = AC3_DHEADPHONMOD_NOTINDICATED; if (s->lfe_on) { s->start_freq[s->lfe_ch] = 0; s->end_freq[s->lfe_ch] = 7; s->num_exp_groups[s->lfe_ch] = 2; s->channel_in_cpl[s->lfe_ch] = 0; } if (s->bitstream_id <= 10) { s->eac3 = 0; s->snr_offset_strategy = 2; s->block_switch_syntax = 1; s->dither_flag_syntax = 1; s->bit_allocation_syntax = 1; s->fast_gain_syntax = 0; s->first_cpl_leak = 0; s->dba_syntax = 1; s->skip_syntax = 1; memset(s->channel_uses_aht, 0, sizeof(s->channel_uses_aht)); return ac3_parse_header(s); } else if (CONFIG_EAC3_DECODER) { s->eac3 = 1; return ff_eac3_parse_header(s); } else { av_log(s->avctx, AV_LOG_ERROR, "E-AC-3 support not compiled in\n"); return AVERROR(ENOSYS); } }<SPLIT>[-0.09900860198293619, 0.5968648583058486, 0.0, -0.11436118199787926, 0.5085128345390885, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 0.52831929569087, -0.09566541730555662, 0.637540383444421, 0.0, 0.0, 0.30852482215402843, 0.44838924606252395, -0.11100716297398205, 0.5497160639660857, 0.11772544131424245, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, 0.9571545682411045, -0.03454968660237938, 0.005287286955244392, -0.21702784222394986, -0.04111270872174079, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static void apply_tns(INTFLOAT coef[1024], TemporalNoiseShaping *tns, IndividualChannelStream *ics, int decode) { const int mmm = FFMIN(ics->tns_max_bands, ics->max_sfb); int w, filt, m, i; int bottom, top, order, start, end, size, inc; INTFLOAT lpc[TNS_MAX_ORDER]; INTFLOAT tmp[TNS_MAX_ORDER+1]; for (w = 0; w < ics->num_windows; w++) { bottom = ics->num_swb; for (filt = 0; filt < tns->n_filt[w]; filt++) { top = bottom; bottom = FFMAX(0, top - tns->length[w][filt]); order = tns->order[w][filt]; if (order == 0) continue; AAC_RENAME(compute_lpc_coefs)(tns->coef[w][filt], order, lpc, 0, 0, 0); start = ics->swb_offset[FFMIN(bottom, mmm)]; end = ics->swb_offset[FFMIN( top, mmm)]; if ((size = end - start) <= 0) continue; if (tns->direction[w][filt]) { inc = -1; start = end - 1; } else { inc = 1; } start += w * 128; if (decode) { for (m = 0; m < size; m++, start += inc) for (i = 1; i <= FFMIN(m, order); i++) coef[start] -= AAC_MUL26(coef[start - i * inc], lpc[i - 1]); } else { for (m = 0; m < size; m++, start += inc) { tmp[0] = coef[start]; for (i = 1; i <= FFMIN(m, order); i++) coef[start] += AAC_MUL26(tmp[i], lpc[i - 1]); for (i = order; i > 0; i--) tmp[i] = tmp[i - 1]; } } } } }<SPLIT>[0.21027592277004517, 0.3103891445140651, 0.0, 0.18995094088131478, 0.231888791681195, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.3085515823163217, 0.21894446904158188, 0.34123294087130834, 0.0, 0.0, 0.30852482215402843, 0.23527942541861413, 0.19837465696559078, 0.262590696934192, 0.11772544131424245, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5707009127566546, 0.18343000506680518, 1.0213275968547075, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void ff_hcscale_fast_mmxext(SwsContext *c, int16_t *dst1, int16_t *dst2, int dstWidth, const uint8_t *src1, const uint8_t *src2, int srcW, int xInc) { int32_t *filterPos = c->hChrFilterPos; int16_t *filter = c->hChrFilter; void *mmxextFilterCode = c->chrMmxextFilterCode; int i; #if ARCH_X86_64 DECLARE_ALIGNED(8, uint64_t, retsave); #else #if defined(PIC) DECLARE_ALIGNED(8, uint64_t, ebxsave); #endif #endif __asm__ volatile( #if ARCH_X86_64 "mov -8(%%rsp), %%"REG_a" \n\t" "mov %%"REG_a", %7 \n\t" #else #if defined(PIC) "mov %%"REG_b", %7 \n\t" #endif #endif "pxor %%mm7, %%mm7 \n\t" "mov %0, %%"REG_c" \n\t" "mov %1, %%"REG_D" \n\t" "mov %2, %%"REG_d" \n\t" "mov %3, %%"REG_b" \n\t" "xor %%"REG_a", %%"REG_a" \n\t" PREFETCH" (%%"REG_c") \n\t" PREFETCH" 32(%%"REG_c") \n\t" PREFETCH" 64(%%"REG_c") \n\t" CALL_MMXEXT_FILTER_CODE CALL_MMXEXT_FILTER_CODE CALL_MMXEXT_FILTER_CODE CALL_MMXEXT_FILTER_CODE "xor %%"REG_a", %%"REG_a" \n\t" "mov %5, %%"REG_c" \n\t" "mov %6, %%"REG_D" \n\t" PREFETCH" (%%"REG_c") \n\t" PREFETCH" 32(%%"REG_c") \n\t" PREFETCH" 64(%%"REG_c") \n\t" CALL_MMXEXT_FILTER_CODE CALL_MMXEXT_FILTER_CODE CALL_MMXEXT_FILTER_CODE CALL_MMXEXT_FILTER_CODE #if ARCH_X86_64 "mov %7, %%"REG_a" \n\t" "mov %%"REG_a", -8(%%rsp) \n\t" #else #if defined(PIC) "mov %7, %%"REG_b" \n\t" #endif #endif :: "m" (src1), "m" (dst1), "m" (filter), "m" (filterPos), "m" (mmxextFilterCode), "m" (src2), "m"(dst2) #if ARCH_X86_64 ,"m"(retsave) #else #if defined(PIC) ,"m" (ebxsave) #endif #endif : "%"REG_a, "%"REG_c, "%"REG_d, "%"REG_S, "%"REG_D #if ARCH_X86_64 || !defined(PIC) ,"%"REG_b #endif ); for (i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) { dst1[i] = src1[srcW-1]*128; dst2[i] = src2[srcW-1]*128; } }<SPLIT>[-0.25365086435942685, 0.971486945572027, 0.0, -0.2665172434374763, 0.870251967507103, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.8479814242356677, -0.25297036047912586, 0.29564718047544486, 0.0, 0.0, 0.30852482215402843, 0.7583671669991201, -0.26569807294376846, 0.21841756354466993, -0.270465503877335, -0.4084991676475909, 0.0, 1.0160128806822883, 12.593180519939871, -0.30760284970800433, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>; pp_mode *pp_get_mode_by_name_and_quality(const char *name, int quality) { char temp[GET_MODE_BUFFER_SIZE]; char *p= temp; static const char filterDelimiters[] = ",/"; static const char optionDelimiters[] = ":|"; struct PPMode *ppMode; char *filterToken; if (!name) { av_log(NULL, AV_LOG_ERROR, "pp: Missing argument\n"); return NULL; } if (!strcmp(name, "help")) { const char *p; for (p = pp_help; strchr(p, '\n'); p = strchr(p, '\n') + 1) { av_strlcpy(temp, p, FFMIN(sizeof(temp), strchr(p, '\n') - p + 2)); av_log(NULL, AV_LOG_INFO, "%s", temp); } return NULL; } ppMode= av_malloc(sizeof(PPMode)); if (!ppMode) return NULL; ppMode->lumMode= 0; ppMode->chromMode= 0; ppMode->maxTmpNoise[0]= 700; ppMode->maxTmpNoise[1]= 1500; ppMode->maxTmpNoise[2]= 3000; ppMode->maxAllowedY= 234; ppMode->minAllowedY= 16; ppMode->baseDcDiff= 256/8; ppMode->flatnessThreshold= 56-16-1; ppMode->maxClippedThreshold= (AVRational){1,100}; ppMode->error=0; memset(temp, 0, GET_MODE_BUFFER_SIZE); av_strlcpy(temp, name, GET_MODE_BUFFER_SIZE - 1); av_log(NULL, AV_LOG_DEBUG, "pp: %s\n", name); for(;;){ const char *filterName; int q= 1000000; int chrom=-1; int luma=-1; const char *option; const char *options[OPTIONS_ARRAY_SIZE]; int i; int filterNameOk=0; int numOfUnknownOptions=0; int enable=1; char *tokstate; filterToken= av_strtok(p, filterDelimiters, &tokstate); if(!filterToken) break; p+= strlen(filterToken) + 1; filterName= av_strtok(filterToken, optionDelimiters, &tokstate); if (!filterName) { ppMode->error++; break; } av_log(NULL, AV_LOG_DEBUG, "pp: %s::%s\n", filterToken, filterName); if(*filterName == '-'){ enable=0; filterName++; } for(;;){ option= av_strtok(NULL, optionDelimiters, &tokstate); if(!option) break; av_log(NULL, AV_LOG_DEBUG, "pp: option: %s\n", option); if(!strcmp("autoq", option) || !strcmp("a", option)) q= quality; else if(!strcmp("nochrom", option) || !strcmp("y", option)) chrom=0; else if(!strcmp("chrom", option) || !strcmp("c", option)) chrom=1; else if(!strcmp("noluma", option) || !strcmp("n", option)) luma=0; else{ options[numOfUnknownOptions] = option; numOfUnknownOptions++; } if(numOfUnknownOptions >= OPTIONS_ARRAY_SIZE-1) break; } options[numOfUnknownOptions] = NULL; for(i=0; replaceTable[2*i]; i++){ if(!strcmp(replaceTable[2*i], filterName)){ size_t newlen = strlen(replaceTable[2*i + 1]); int plen; int spaceLeft; p--, *p=','; plen= strlen(p); spaceLeft= p - temp + plen; if(spaceLeft + newlen >= GET_MODE_BUFFER_SIZE - 1){ ppMode->error++; break; } memmove(p + newlen, p, plen+1); memcpy(p, replaceTable[2*i + 1], newlen); filterNameOk=1; } } for(i=0; filters[i].shortName; i++){ if( !strcmp(filters[i].longName, filterName) || !strcmp(filters[i].shortName, filterName)){ ppMode->lumMode &= ~filters[i].mask; ppMode->chromMode &= ~filters[i].mask; filterNameOk=1; if(!enable) break; if(q >= filters[i].minLumQuality && luma) ppMode->lumMode|= filters[i].mask; if(chrom==1 || (chrom==-1 && filters[i].chromDefault)) if(q >= filters[i].minChromQuality) ppMode->chromMode|= filters[i].mask; if(filters[i].mask == LEVEL_FIX){ int o; ppMode->minAllowedY= 16; ppMode->maxAllowedY= 234; for(o=0; options[o]; o++){ if( !strcmp(options[o],"fullyrange") ||!strcmp(options[o],"f")){ ppMode->minAllowedY= 0; ppMode->maxAllowedY= 255; numOfUnknownOptions--; } } } else if(filters[i].mask == TEMP_NOISE_FILTER) { int o; int numOfNoises=0; for(o=0; options[o]; o++){ char *tail; ppMode->maxTmpNoise[numOfNoises]= strtol(options[o], &tail, 0); if(tail!=options[o]){ numOfNoises++; numOfUnknownOptions--; if(numOfNoises >= 3) break; } } } else if(filters[i].mask == V_DEBLOCK || filters[i].mask == H_DEBLOCK || filters[i].mask == V_A_DEBLOCK || filters[i].mask == H_A_DEBLOCK){ int o; for(o=0; options[o] && o<2; o++){ char *tail; int val= strtol(options[o], &tail, 0); if(tail==options[o]) break; numOfUnknownOptions--; if(o==0) ppMode->baseDcDiff= val; else ppMode->flatnessThreshold= val; } } else if(filters[i].mask == FORCE_QUANT){ int o; ppMode->forcedQuant= 15; for(o=0; options[o] && o<1; o++){ char *tail; int val= strtol(options[o], &tail, 0); if(tail==options[o]) break; numOfUnknownOptions--; ppMode->forcedQuant= val; } } } } if(!filterNameOk) ppMode->error++; ppMode->error += numOfUnknownOptions; } av_log(NULL, AV_LOG_DEBUG, "pp: lumMode=%X, chromMode=%X\n", ppMode->lumMode, ppMode->chromMode); if(ppMode->error){ av_log(NULL, AV_LOG_ERROR, "%d errors in postprocess string \"%s\"\n", ppMode->error, name); av_free(ppMode); return NULL; } return ppMode; }<SPLIT>[-0.09900860198293619, 3.086999908957505, 0.0, -0.11436118199787926, 2.9130141301500085, 0.0, 2.186719866463698, 2.2318098511651505, 2.7301934809370603, 1.699703585821447, 2.7859330785385032, -0.09566541730555662, 3.2131358458107075, 0.0, 0.0, 0.30852482215402843, 2.6569819327357713, -0.11100716297398205, 3.045498100474085, 4.776016783613172, 3.208840440857154, 0.0, -0.08645738172306322, -0.16222078614455715, 3.8379909091251854, 3.8890847634429426, 4.408128629852918, 6.074752741790056, 2.391727366407248, 2.185828383526772, 2.231040724738188, 2.7292055533170707, 1.6991165002636506, 1.7623686513065309, 0.0, 2.180032226976431, 2.225208820917496, 2.722580082044891, 1.693548171012695]
0<SPLIT>static int get_system_header_size(AVFormatContext *ctx) { int buf_index, i, private_stream_coded; StreamInfo *stream; MpegMuxContext *s = ctx->priv_data; if (s->is_dvd) return 18; buf_index = 12; private_stream_coded = 0; for (i = 0; i < ctx->nb_streams; i++) { stream = ctx->streams[i]->priv_data; if (stream->id < 0xc0) { if (private_stream_coded) continue; private_stream_coded = 1; } buf_index += 3; } return buf_index; }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.6586564490689124, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.25252937827156396, -0.4462861841111837, -0.21702784222394986, -0.04111270872174079, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int klv_encode_ber_length(AVIOContext *pb, uint64_t len) { int size; if (len < 128) { avio_w8(pb, len); return 1; } size = (av_log2(len) >> 3) + 1; avio_w8(pb, 0x80 + size); while(size) { size--; avio_w8(pb, len >> 8 * size & 0xff); } return 0; }<SPLIT>[0.21027592277004517, -0.32867206317529807, 0.0, 0.18995094088131478, -0.3851956116171827, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.270836025671124, 0.21894446904158188, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, 0.19837465696559078, -0.37791973721387856, -0.39986248560786075, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.25252937827156396, -0.4462861841111837, -0.21702784222394986, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int parse_rule(uint16_t *born_rule, uint16_t *stay_rule, const char *rule_str, void *log_ctx) { char *tail; const char *p = rule_str; *born_rule = 0; *stay_rule = 0; if (strchr("bBsS", *p)) { do { uint16_t *rule = (*p == 'b' || *p == 'B') ? born_rule : stay_rule; p++; while (*p >= '0' && *p <= '8') { *rule += 1<<(*p - '0'); p++; } if (*p != '/') break; p++; } while (strchr("bBsS", *p)); if (*p) goto error; } else { long int rule = strtol(rule_str, &tail, 10); if (*tail) goto error; *born_rule = ((1<<9)-1) & rule; *stay_rule = rule >> 9; } return 0; error: av_log(log_ctx, AV_LOG_ERROR, "Invalid rule code '%s' provided\n", rule_str); return AVERROR(EINVAL); }<SPLIT>[0.36491818514653585, 0.06798661745947907, 0.0, 0.34210700232091185, 0.01910106640589235, 0.0, 0.6225807337249721, 0.6411199308703055, 0.7400896423242515, 1.3698779043020206, 0.10876275197582316, 0.3762494122151511, 0.0905112586940592, 0.0, 0.0, 0.30852482215402843, 0.060916844891778815, 0.35306556693537716, 0.04172502998658149, 0.24712242304476825, 1.3453624607183459, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, 0.5648944654878781, 0.23107402248845843, 0.6817979554923368, 0.7074534682410251, 0.6220897838620095, 0.6406805230120434, 0.7395912368182198, 1.3693714445839917, 1.7623686513065309, 0.0, 0.6182652667186178, 0.6368235570697065, 0.7355972453213037, 1.3643185231999084]
0<SPLIT>static int gen_seek(URLContext *s, RTMPContext *rt, int64_t timestamp) { RTMPPacket pkt; uint8_t *p; int ret; av_log(s, AV_LOG_DEBUG, "Sending seek command for timestamp %"PRId64"\n", timestamp); if ((ret = ff_rtmp_packet_create(&pkt, 3, RTMP_PT_INVOKE, 0, 26)) < 0) return ret; pkt.extra = rt->stream_id; p = pkt.data; ff_amf_write_string(&p, "seek"); ff_amf_write_number(&p, 0); ff_amf_write_null(&p); ff_amf_write_number(&p, timestamp); return rtmp_send_packet(rt, &pkt, 1); }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, 0.11772544131424245, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.1980344553542678, 0.005287286955244392, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int avfilter_copy_frame_props(AVFilterBufferRef *dst, const AVFrame *src) { dst->pts = src->pts; dst->pos = av_frame_get_pkt_pos(src); dst->format = src->format; av_dict_free(&dst->metadata); av_dict_copy(&dst->metadata, av_frame_get_metadata(src), 0); switch (dst->type) { case AVMEDIA_TYPE_VIDEO: dst->video->w = src->width; dst->video->h = src->height; dst->video->sample_aspect_ratio = src->sample_aspect_ratio; dst->video->interlaced = src->interlaced_frame; dst->video->top_field_first = src->top_field_first; dst->video->key_frame = src->key_frame; dst->video->pict_type = src->pict_type; break; case AVMEDIA_TYPE_AUDIO: dst->audio->sample_rate = src->sample_rate; dst->audio->channel_layout = src->channel_layout; break; default: return AVERROR(EINVAL); } return 0; }<SPLIT>[-0.25365086435942685, -0.08626953612071205, 0.0, -0.2665172434374763, -0.15112911381434976, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.1110049613987252, -0.25297036047912586, -0.06903890269146298, 0.0, 0.0, 0.30852482215402843, -0.17156659581066827, -0.26569807294376846, -0.13496750357150694, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.06167779621789984, -0.3615192241061562, -0.22049944857796966, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int av_parse_color(uint8_t *rgba_color, const char *color_string, int slen, void *log_ctx) { char *tail, color_string2[128]; const ColorEntry *entry; int len, hex_offset = 0; if (color_string[0] == '#') { hex_offset = 1; } else if (!strncmp(color_string, "0x", 2)) hex_offset = 2; if (slen < 0) slen = strlen(color_string); av_strlcpy(color_string2, color_string + hex_offset, FFMIN(slen-hex_offset+1, sizeof(color_string2))); if ((tail = strchr(color_string2, ALPHA_SEP))) *tail++ = 0; len = strlen(color_string2); rgba_color[3] = 255; if (!av_strcasecmp(color_string2, "random") || !av_strcasecmp(color_string2, "bikeshed")) { int rgba = av_get_random_seed(); rgba_color[0] = rgba >> 24; rgba_color[1] = rgba >> 16; rgba_color[2] = rgba >> 8; rgba_color[3] = rgba; } else if (hex_offset || strspn(color_string2, "0123456789ABCDEFabcdef") == len) { char *tail; unsigned int rgba = strtoul(color_string2, &tail, 16); if (*tail || (len != 6 && len != 8)) { av_log(log_ctx, AV_LOG_ERROR, "Invalid 0xRRGGBB[AA] color string: '%s'\n", color_string2); return AVERROR(EINVAL); } if (len == 8) { rgba_color[3] = rgba; rgba >>= 8; } rgba_color[0] = rgba >> 16; rgba_color[1] = rgba >> 8; rgba_color[2] = rgba; } else { entry = bsearch(color_string2, color_table, FF_ARRAY_ELEMS(color_table), sizeof(ColorEntry), color_table_compare); if (!entry) { av_log(log_ctx, AV_LOG_ERROR, "Cannot find color '%s'\n", color_string2); return AVERROR(EINVAL); } memcpy(rgba_color, entry->rgb_color, 3); } if (tail) { double alpha; const char *alpha_string = tail; if (!strncmp(alpha_string, "0x", 2)) { alpha = strtoul(alpha_string, &tail, 16); } else { double norm_alpha = strtod(alpha_string, &tail); if (norm_alpha < 0.0 || norm_alpha > 1.0) alpha = 256; else alpha = 255 * norm_alpha; } if (tail == alpha_string || *tail || alpha > 255 || alpha < 0) { av_log(log_ctx, AV_LOG_ERROR, "Invalid alpha value specifier '%s' in '%s'\n", alpha_string, color_string); return AVERROR(EINVAL); } rgba_color[3] = alpha; } return 0; }<SPLIT>[-0.25365086435942685, 0.9274137588348296, 0.0, -0.2665172434374763, 0.8276944224520424, 0.0, 1.8391333925217592, 1.8783232022107403, 3.0618774540391946, -0.27925050329511203, 0.8080236581675679, -0.25297036047912586, 0.9794335864133971, 0.0, 0.0, 0.30852482215402843, 0.7196199268820456, -0.26569807294376846, 0.8810145643875016, 2.0586801672721293, 3.208840440857154, 0.0, -0.08645738172306322, -0.16222078614455715, 0.6409652137538272, 2.0362573842548737, 2.1502612745207776, -0.21702784222394986, 1.736731961564828, 1.8383309169346027, 1.8776273465768223, 3.0608079394002123, -0.27935383381430245, 1.7623686513065309, 0.0, 1.832972902474695, 1.8722343178402097, 3.053743888165489, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *frame) { AVFilterContext *ctx = inlink->dst; CompandContext *s = ctx->priv; return s->compand(ctx, frame); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static MXFDescriptor* mxf_resolve_multidescriptor(MXFContext *mxf, MXFDescriptor *descriptor, int track_id) { MXFDescriptor *sub_descriptor = NULL; int i; if (!descriptor) return NULL; if (descriptor->type == MultipleDescriptor) { for (i = 0; i < descriptor->sub_descriptors_count; i++) { sub_descriptor = mxf_resolve_strong_ref(mxf, &descriptor->sub_descriptors_refs[i], Descriptor); if (!sub_descriptor) { av_log(mxf->fc, AV_LOG_ERROR, "could not resolve sub descriptor strong ref\n"); continue; } if (sub_descriptor->linked_track_id == track_id) { return sub_descriptor; } } } else if (descriptor->type == Descriptor) return descriptor; return NULL; }<SPLIT>[-0.25365086435942685, -0.1964525029637057, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.21089937656897445, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.41601414702345235, -0.4462861841111837, 0.6817979554923368, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_always_inline void yuv2mono_X_c_template(SwsContext *c, const int16_t *lumFilter, const int16_t **lumSrc, int lumFilterSize, const int16_t *chrFilter, const int16_t **chrUSrc, const int16_t **chrVSrc, int chrFilterSize, const int16_t **alpSrc, uint8_t *dest, int dstW, int y, enum AVPixelFormat target) { const uint8_t * const d128 = ff_dither_8x8_220[y&7]; int i; unsigned acc = 0; int err = 0; for (i = 0; i < dstW; i += 2) { int j; int Y1 = 1 << 18; int Y2 = 1 << 18; for (j = 0; j < lumFilterSize; j++) { Y1 += lumSrc[j][i] * lumFilter[j]; Y2 += lumSrc[j][i+1] * lumFilter[j]; } Y1 >>= 19; Y2 >>= 19; if ((Y1 | Y2) & 0x100) { Y1 = av_clip_uint8(Y1); Y2 = av_clip_uint8(Y2); } if (c->dither == SWS_DITHER_ED) { Y1 += (7*err + 1*c->dither_error[0][i] + 5*c->dither_error[0][i+1] + 3*c->dither_error[0][i+2] + 8 - 256)>>4; c->dither_error[0][i] = err; acc = 2*acc + (Y1 >= 128); Y1 -= 220*(acc&1); err = Y2 + ((7*Y1 + 1*c->dither_error[0][i+1] + 5*c->dither_error[0][i+2] + 3*c->dither_error[0][i+3] + 8 - 256)>>4); c->dither_error[0][i+1] = Y1; acc = 2*acc + (err >= 128); err -= 220*(acc&1); } else { accumulate_bit(acc, Y1 + d128[(i + 0) & 7]); accumulate_bit(acc, Y2 + d128[(i + 1) & 7]); } if ((i & 7) == 6) { output_pixel(*dest++, acc); } } c->dither_error[0][i] = err; if (i & 6) { output_pixel(*dest, acc); } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, 0.31700388179131606, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.2546530454771514, -0.26569807294376846, 0.35093696371323624, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3599080097651364, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void rtsp_cmd_describe(HTTPContext *c, const char *url) { FFServerStream *stream; char path1[1024]; const char *path; uint8_t *content; int content_length; socklen_t len; struct sockaddr_in my_addr; av_url_split(NULL, 0, NULL, 0, NULL, 0, NULL, path1, sizeof(path1), url); path = path1; if (*path == '/') path++; for(stream = config.first_stream; stream; stream = stream->next) { if (!stream->is_feed && stream->fmt && !strcmp(stream->fmt->name, "rtp") && !strcmp(path, stream->filename)) { goto found; } } rtsp_reply_error(c, RTSP_STATUS_NOT_FOUND); return; found: len = sizeof(my_addr); getsockname(c->fd, (struct sockaddr *)&my_addr, &len); content_length = prepare_sdp_description(stream, &content, my_addr.sin_addr); if (content_length < 0) { rtsp_reply_error(c, RTSP_STATUS_INTERNAL); return; } rtsp_reply_header(c, RTSP_STATUS_OK); avio_printf(c->pb, "Content-Base: %s/\r\n", url); avio_printf(c->pb, "Content-Type: application/sdp\r\n"); avio_printf(c->pb, "Content-Length: %d\r\n", content_length); avio_printf(c->pb, "\r\n"); avio_write(c->pb, content, content_length); av_free(content); }<SPLIT>[0.36491818514653585, 0.20020617767107143, 0.0, 0.34210700232091185, 0.12549492904354367, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.22863605018012226, 0.3762494122151511, 0.22726853988164963, 0.0, 0.0, 0.30852482215402843, 0.1577849451844651, 0.35306556693537716, 0.15215786346038676, 0.8941073316973973, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2545115582693773, 0.5648944654878781, 1.0213275968547075, 0.6817979554923368, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { AVFilterFormats *formats = NULL; int fmt; for (fmt = 0; av_pix_fmt_desc_get(fmt); fmt++) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(fmt); if (!(desc->flags & (AV_PIX_FMT_FLAG_HWACCEL | AV_PIX_FMT_FLAG_BITSTREAM | AV_PIX_FMT_FLAG_PAL)) && (desc->flags & AV_PIX_FMT_FLAG_PLANAR || desc->nb_components == 1) && (!(desc->flags & AV_PIX_FMT_FLAG_BE) == !HAVE_BIGENDIAN || desc->comp[0].depth_minus1 == 7)) ff_add_format(&formats, fmt); } return ff_set_common_formats(ctx, formats); }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.25252937827156396, -0.22049944857796966, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int config_out_props(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; AVFilterLink *inlink = outlink->src->inputs[0]; const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(outlink->format); TInterlaceContext *tinterlace = ctx->priv; int i; tinterlace->vsub = desc->log2_chroma_h; outlink->flags |= FF_LINK_FLAG_REQUEST_LOOP; outlink->w = inlink->w; outlink->h = tinterlace->mode == MODE_MERGE || tinterlace->mode == MODE_PAD ? inlink->h*2 : inlink->h; if (tinterlace->mode == MODE_MERGE || tinterlace->mode == MODE_PAD) outlink->sample_aspect_ratio = av_mul_q(inlink->sample_aspect_ratio, av_make_q(2, 1)); if (tinterlace->mode == MODE_PAD) { uint8_t black[4] = { 16, 128, 128, 16 }; int i, ret; if (ff_fmt_is_in(outlink->format, full_scale_yuvj_pix_fmts)) black[0] = black[3] = 0; ret = av_image_alloc(tinterlace->black_data, tinterlace->black_linesize, outlink->w, outlink->h, outlink->format, 1); if (ret < 0) return ret; for (i = 0; i < 4 && tinterlace->black_data[i]; i++) { int h = i == 1 || i == 2 ? FF_CEIL_RSHIFT(outlink->h, desc->log2_chroma_h) : outlink->h; memset(tinterlace->black_data[i], black[i], tinterlace->black_linesize[i] * h); } } if ((tinterlace->flags & TINTERLACE_FLAG_VLPF) && !(tinterlace->mode == MODE_INTERLEAVE_TOP || tinterlace->mode == MODE_INTERLEAVE_BOTTOM)) { av_log(ctx, AV_LOG_WARNING, "low_pass_filter flag ignored with mode %d\n", tinterlace->mode); tinterlace->flags &= ~TINTERLACE_FLAG_VLPF; } tinterlace->preout_time_base = inlink->time_base; if (tinterlace->mode == MODE_INTERLACEX2) { tinterlace->preout_time_base.den *= 2; outlink->frame_rate = av_mul_q(inlink->frame_rate, (AVRational){2,1}); outlink->time_base = av_mul_q(inlink->time_base , (AVRational){1,2}); } else if (tinterlace->mode != MODE_PAD) { outlink->frame_rate = av_mul_q(inlink->frame_rate, (AVRational){1,2}); outlink->time_base = av_mul_q(inlink->time_base , (AVRational){2,1}); } for (i = 0; i<FF_ARRAY_ELEMS(standard_tbs); i++){ if (!av_cmp_q(standard_tbs[i], outlink->time_base)) break; } if (i == FF_ARRAY_ELEMS(standard_tbs) || (tinterlace->flags & TINTERLACE_FLAG_EXACT_TB)) outlink->time_base = tinterlace->preout_time_base; if (tinterlace->flags & TINTERLACE_FLAG_VLPF) { tinterlace->lowpass_line = lowpass_line_c; if (ARCH_X86) ff_tinterlace_init_x86(tinterlace); } av_log(ctx, AV_LOG_VERBOSE, "mode:%d filter:%s h:%d -> h:%d\n", tinterlace->mode, (tinterlace->flags & TINTERLACE_FLAG_VLPF) ? "on" : "off", inlink->h, outlink->h); return 0; }<SPLIT>[-0.09900860198293619, 0.729084418517441, 0.0, -0.11436118199787926, 0.63618546970427, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 0.380400859743741, 0.6481925938951691, -0.09566541730555662, 0.7742976646320114, 0.0, 0.0, 0.30852482215402843, 0.5646309664137475, -0.11100716297398205, 0.6822354641346521, 0.8941073316973973, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5355687622580682, 0.6193893884051743, 1.0213275968547075, -0.21702784222394986, 0.23959960763929639, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 0.3801362775450152, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 0.3766295797615486]
0<SPLIT>static inline void blur(uint8_t *dst, int dst_step, const uint8_t *src, int src_step, int len, int radius, int pixsize) { if (pixsize == 1) blur8 (dst, dst_step , src, src_step , len, radius); else blur16((uint16_t*)dst, dst_step>>1, (const uint16_t*)src, src_step>>1, len, radius); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { static const enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_YUVA444P, AV_PIX_FMT_YUVA422P, AV_PIX_FMT_YUVA420P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUVJ440P, AV_PIX_FMT_YUVJ422P,AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ411P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUV440P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV411P, AV_PIX_FMT_YUV410P, AV_PIX_FMT_GBRP, AV_PIX_FMT_GBRAP, AV_PIX_FMT_GRAY8, AV_PIX_FMT_NONE }; ff_set_common_formats(ctx, ff_make_format_list(pix_fmts)); return 0; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void compute_bandwidth(void) { unsigned bandwidth; int i; FFServerStream *stream; for(stream = config.first_stream; stream; stream = stream->next) { bandwidth = 0; for(i=0;i<stream->nb_streams;i++) { LayeredAVStream *st = stream->streams[i]; switch(st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO: case AVMEDIA_TYPE_VIDEO: bandwidth += st->codec->bit_rate; break; default: break; } } stream->bandwidth = (bandwidth + 999) / 1000; } }<SPLIT>[-0.25365086435942685, -0.1964525029637057, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.21089937656897445, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int pick_format(AVFilterLink *link, AVFilterLink *ref) { if (!link || !link->in_formats) return 0; if (link->type == AVMEDIA_TYPE_VIDEO) { if(ref && ref->type == AVMEDIA_TYPE_VIDEO){ int has_alpha= av_pix_fmt_desc_get(ref->format)->nb_components % 2 == 0; enum AVPixelFormat best= AV_PIX_FMT_NONE; int i; for (i=0; i<link->in_formats->nb_formats; i++) { enum AVPixelFormat p = link->in_formats->formats[i]; best= av_find_best_pix_fmt_of_2(best, p, ref->format, has_alpha, NULL); } av_log(link->src,AV_LOG_DEBUG, "picking %s out of %d ref:%s alpha:%d\n", av_get_pix_fmt_name(best), link->in_formats->nb_formats, av_get_pix_fmt_name(ref->format), has_alpha); link->in_formats->formats[0] = best; } } else if (link->type == AVMEDIA_TYPE_AUDIO) { if(ref && ref->type == AVMEDIA_TYPE_AUDIO){ enum AVSampleFormat best= AV_SAMPLE_FMT_NONE; int i; for (i=0; i<link->in_formats->nb_formats; i++) { enum AVSampleFormat p = link->in_formats->formats[i]; best = find_best_sample_fmt_of_2(best, p, ref->format); } av_log(link->src,AV_LOG_DEBUG, "picking %s out of %d ref:%s\n", av_get_sample_fmt_name(best), link->in_formats->nb_formats, av_get_sample_fmt_name(ref->format)); link->in_formats->formats[0] = best; } } link->in_formats->nb_formats = 1; link->format = link->in_formats->formats[0]; if (link->type == AVMEDIA_TYPE_AUDIO) { if (!link->in_samplerates->nb_formats) { av_log(link->src, AV_LOG_ERROR, "Cannot select sample rate for" " the link between filters %s and %s.\n", link->src->name, link->dst->name); return AVERROR(EINVAL); } link->in_samplerates->nb_formats = 1; link->sample_rate = link->in_samplerates->formats[0]; if (link->in_channel_layouts->all_layouts) { av_log(link->src, AV_LOG_ERROR, "Cannot select channel layout for" " the link between filters %s and %s.\n", link->src->name, link->dst->name); if (!link->in_channel_layouts->all_counts) av_log(link->src, AV_LOG_ERROR, "Unknown channel layouts not " "supported, try specifying a channel layout using " "'aformat=channel_layouts=something'.\n"); return AVERROR(EINVAL); } link->in_channel_layouts->nb_channel_layouts = 1; link->channel_layout = link->in_channel_layouts->channel_layouts[0]; if ((link->channels = FF_LAYOUT2COUNT(link->channel_layout))) link->channel_layout = 0; else link->channels = av_get_channel_layout_nb_channels(link->channel_layout); } ff_formats_unref(&link->in_formats); ff_formats_unref(&link->out_formats); ff_formats_unref(&link->in_samplerates); ff_formats_unref(&link->out_samplerates); ff_channel_layouts_unref(&link->in_channel_layouts); ff_channel_layouts_unref(&link->out_channel_layouts); return 0; }<SPLIT>[-0.25365086435942685, 0.8392673853604347, 0.0, -0.2665172434374763, 0.7425793323419214, 0.0, 0.9701672076669112, 0.9946065798247155, 0.9059316288753189, -0.27925050329511203, 0.7281081260313685, -0.25297036047912586, 0.8882620656216701, 0.0, 0.0, 0.30852482215402843, 0.6421254466478965, -0.26569807294376846, 0.7926682976084574, 1.4116952586195004, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 0.6409652137538272, 0.9463589259089511, 1.4729010679211356, -0.21702784222394986, 0.42674115187998785, 0.969587250454179, 0.9940939011734088, 0.9053924298597907, -0.27935383381430245, 0.9056307075691036, 0.0, 0.9653245912203542, 0.9897980601469931, 0.9011791483816026, -0.28182971586402455]
1<SPLIT>static int ape_decode_frame(AVCodecContext *avctx, void *data, int *got_frame_ptr, AVPacket *avpkt) { AVFrame *frame = data; const uint8_t *buf = avpkt->data; APEContext *s = avctx->priv_data; uint8_t *sample8; int16_t *sample16; int32_t *sample24; int i, ch, ret; int blockstodecode; av_assert0(s->samples >= 0); if(!s->samples){ uint32_t nblocks, offset; int buf_size; if (!avpkt->size) { *got_frame_ptr = 0; return 0; } if (avpkt->size < 8) { av_log(avctx, AV_LOG_ERROR, "Packet is too small\n"); return AVERROR_INVALIDDATA; } buf_size = avpkt->size & ~3; if (buf_size != avpkt->size) { av_log(avctx, AV_LOG_WARNING, "packet size is not a multiple of 4. " "extra bytes at the end will be skipped.\n"); } if (s->fileversion < 3950) buf_size += 2; av_fast_padded_malloc(&s->data, &s->data_size, buf_size); if (!s->data) return AVERROR(ENOMEM); s->bdsp.bswap_buf((uint32_t *) s->data, (const uint32_t *) buf, buf_size >> 2); memset(s->data + (buf_size & ~3), 0, buf_size & 3); s->ptr = s->data; s->data_end = s->data + buf_size; nblocks = bytestream_get_be32(&s->ptr); offset = bytestream_get_be32(&s->ptr); if (s->fileversion >= 3900) { if (offset > 3) { av_log(avctx, AV_LOG_ERROR, "Incorrect offset passed\n"); s->data = NULL; return AVERROR_INVALIDDATA; } if (s->data_end - s->ptr < offset) { av_log(avctx, AV_LOG_ERROR, "Packet is too small\n"); return AVERROR_INVALIDDATA; } s->ptr += offset; } else { if ((ret = init_get_bits8(&s->gb, s->ptr, s->data_end - s->ptr)) < 0) return ret; if (s->fileversion > 3800) skip_bits_long(&s->gb, offset * 8); else skip_bits_long(&s->gb, offset); } if (!nblocks || nblocks > INT_MAX) { av_log(avctx, AV_LOG_ERROR, "Invalid sample count: %"PRIu32".\n", nblocks); return AVERROR_INVALIDDATA; } if (init_frame_decoder(s) < 0) { av_log(avctx, AV_LOG_ERROR, "Error reading frame header\n"); return AVERROR_INVALIDDATA; } s->samples = nblocks; } if (!s->data) { *got_frame_ptr = 0; return avpkt->size; } blockstodecode = FFMIN(s->blocks_per_loop, s->samples); if (s->fileversion < 3930) blockstodecode = s->samples; av_fast_malloc(&s->decoded_buffer, &s->decoded_size, 2 * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer)); if (!s->decoded_buffer) return AVERROR(ENOMEM); memset(s->decoded_buffer, 0, s->decoded_size); s->decoded[0] = s->decoded_buffer; s->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8); frame->nb_samples = blockstodecode; if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) return ret; s->error=0; if ((s->channels == 1) || (s->frameflags & APE_FRAMECODE_PSEUDO_STEREO)) ape_unpack_mono(s, blockstodecode); else ape_unpack_stereo(s, blockstodecode); emms_c(); if (s->error) { s->samples=0; av_log(avctx, AV_LOG_ERROR, "Error decoding frame\n"); return AVERROR_INVALIDDATA; } switch (s->bps) { case 8: for (ch = 0; ch < s->channels; ch++) { sample8 = (uint8_t *)frame->data[ch]; for (i = 0; i < blockstodecode; i++) *sample8++ = (s->decoded[ch][i] + 0x80) & 0xff; } break; case 16: for (ch = 0; ch < s->channels; ch++) { sample16 = (int16_t *)frame->data[ch]; for (i = 0; i < blockstodecode; i++) *sample16++ = s->decoded[ch][i]; } break; case 24: for (ch = 0; ch < s->channels; ch++) { sample24 = (int32_t *)frame->data[ch]; for (i = 0; i < blockstodecode; i++) *sample24++ = s->decoded[ch][i] << 8; } break; } s->samples -= blockstodecode; *got_frame_ptr = 1; return !s->samples ? avpkt->size : 0; }<SPLIT>[3.4577634326763493, 2.095353207370562, 0.0, 3.3852282311128525, 1.9554693664111464, 0.0, 2.012926629492729, 2.0550665266879453, 1.9009835481817232, 1.3698779043020206, 2.3463976517894065, 3.5223482756865363, 2.1874562369037793, 0.0, 0.0, 0.30852482215402843, 2.2113886713894146, 3.446883766331106, 2.0516025992098377, 1.9292831855416035, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, 2.186779835691627, 1.709287846751097, 1.6986878034543498, -0.21702784222394986, 1.5495904173241366, 2.0120796502306875, 2.054334035657505, 1.9001995881092162, 1.3693714445839917, 1.7623686513065309, 0.0, 2.006502564725563, 2.048721569378853, 1.8946705667433963, 1.3643185231999084]
0<SPLIT>static int lex_line_end(struct sbg_parser *p) { if (p->cursor < p->end && *p->cursor == '#') { p->cursor++; while (p->cursor < p->end && *p->cursor != '\n') p->cursor++; } if (p->cursor == p->end) return 1; if (*p->cursor != '\n') return 0; p->cursor++; p->line_no++; lex_space(p); return 1; }<SPLIT>[-0.09900860198293619, -0.30663546980669937, 0.0, -0.11436118199787926, -0.36391683908965244, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.380400859743741, -0.29081490870517385, -0.09566541730555662, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.11100716297398205, -0.3558331705191175, -0.6586564490689124, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.1980344553542678, -0.5591795518777907, -0.21702784222394986, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.3801362775450152, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.3766295797615486]
0<SPLIT>static int aeval_config_output(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; EvalContext *eval = ctx->priv; AVFilterLink *inlink = ctx->inputs[0]; int ret; if (eval->same_chlayout) { eval->chlayout = inlink->channel_layout; if ((ret = parse_channel_expressions(ctx, inlink->channels)) < 0) return ret; } eval->n = 0; eval->nb_in_channels = eval->var_values[VAR_NB_IN_CHANNELS] = inlink->channels; eval->var_values[VAR_NB_OUT_CHANNELS] = outlink->channels; eval->var_values[VAR_S] = inlink->sample_rate; eval->var_values[VAR_T] = NAN; eval->channel_values = av_realloc_f(eval->channel_values, inlink->channels, sizeof(*eval->channel_values)); if (!eval->channel_values) return AVERROR(ENOMEM); return 0; }<SPLIT>[-0.25365086435942685, -0.17441590959510697, 0.0, -0.2665172434374763, -0.23624420392447085, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.1909204935349246, -0.25297036047912586, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.26569807294376846, -0.22331377035055117, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.25252937827156396, -0.3333928163445767, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int load_font(AVFilterContext *ctx) { DrawTextContext *s = ctx->priv; int err; err = load_font_file(ctx, s->fontfile, 0); if (!err) return 0; #if CONFIG_LIBFONTCONFIG err = load_font_fontconfig(ctx); if (!err) return 0; #endif return err; }<SPLIT>[-0.09900860198293619, -0.3507086565438968, 0.0, -0.11436118199787926, -0.406474384144713, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.09566541730555662, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.11100716297398205, -0.5104391373824448, -0.5292594673383866, -0.1892664641018488, 0.0, 0.24428369699854227, 0.9973611507722091, -0.44813145170234975, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int analyze(const uint8_t *buf, int size, int packet_size, int *index, int probe) { int stat[TS_MAX_PACKET_SIZE]; int stat_all = 0; int i; int best_score = 0; memset(stat, 0, packet_size * sizeof(*stat)); for (i = 0; i < size - 3; i++) { if (buf[i] == 0x47 && (!probe || (!(buf[i + 1] & 0x80) && buf[i + 3] != 0x47))) { int x = i % packet_size; stat[x]++; stat_all++; if (stat[x] > best_score) { best_score = stat[x]; if (index) *index = x; } } } return best_score - FFMAX(stat_all - 10*best_score, 0)/10; }<SPLIT>[-0.25365086435942685, -0.15237931622650824, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, -0.17094161050087475, -0.25297036047912586, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, 0.24712242304476825, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, 0.18343000506680518, 0.005287286955244392, -0.21702784222394986, 0.33317037975964214, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 2.6191065950439585, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>int main(int argc, char **argv) { int ret = 0, got_frame; if (argc != 2) { fprintf(stderr, "Usage: %s <video>\n", argv[0]); exit(1); } src_filename = argv[1]; av_register_all(); if (avformat_open_input(&fmt_ctx, src_filename, NULL, NULL) < 0) { fprintf(stderr, "Could not open source file %s\n", src_filename); exit(1); } if (avformat_find_stream_info(fmt_ctx, NULL) < 0) { fprintf(stderr, "Could not find stream information\n"); exit(1); } if (open_codec_context(&video_stream_idx, fmt_ctx, AVMEDIA_TYPE_VIDEO) >= 0) { video_stream = fmt_ctx->streams[video_stream_idx]; video_dec_ctx = video_stream->codec; } av_dump_format(fmt_ctx, 0, src_filename, 0); if (!video_stream) { fprintf(stderr, "Could not find video stream in the input, aborting\n"); ret = 1; goto end; } frame = av_frame_alloc(); if (!frame) { fprintf(stderr, "Could not allocate frame\n"); ret = AVERROR(ENOMEM); goto end; } printf("framenum,source,blockw,blockh,srcx,srcy,dstx,dsty,flags\n"); av_init_packet(&pkt); pkt.data = NULL; pkt.size = 0; while (av_read_frame(fmt_ctx, &pkt) >= 0) { AVPacket orig_pkt = pkt; do { ret = decode_packet(&got_frame, 0); if (ret < 0) break; pkt.data += ret; pkt.size -= ret; } while (pkt.size > 0); av_free_packet(&orig_pkt); } pkt.data = NULL; pkt.size = 0; do { decode_packet(&got_frame, 1); } while (got_frame); end: avcodec_close(video_dec_ctx); avformat_close_input(&fmt_ctx); av_frame_free(&frame); return ret < 0; }<SPLIT>[0.21027592277004517, 0.6409380450430461, 0.0, 0.18995094088131478, 0.551070379594149, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, 1.3698779043020206, 0.6082348278270694, 0.21894446904158188, 0.6831261438402845, 0.0, 0.0, 0.30852482215402843, 0.525883726296673, 0.19837465696559078, 0.5938891973556079, 1.5410922403500262, 1.1261297571726039, 0.0, -0.08645738172306322, -0.16222078614455715, 0.6409652137538272, 1.3823183092473201, 1.4729010679211356, 0.6817979554923368, 1.081736556722408, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, 1.3693714445839917, 0.04889276383167627, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 1.3643185231999084]
0<SPLIT>static void *iec61883_receive_task(void *opaque) { struct iec61883_data *dv = (struct iec61883_data *)opaque; int result; #if THREADS while (dv->thread_loop) #endif { while ((result = poll(&dv->raw1394_poll, 1, 200)) < 0) { if (!(errno == EAGAIN || errno == EINTR)) { av_log(NULL, AV_LOG_ERROR, "Raw1394 poll error occurred.\n"); dv->receive_error = AVERROR(EIO); return NULL; } } if (result > 0 && ((dv->raw1394_poll.revents & POLLIN) || (dv->raw1394_poll.revents & POLLPRI))) { dv->receiving = 1; raw1394_loop_iterate(dv->raw1394); } else if (dv->receiving) { av_log(NULL, AV_LOG_ERROR, "No more input data available\n"); #if THREADS pthread_mutex_lock(&dv->mutex); dv->eof = 1; pthread_cond_broadcast(&dv->cond); pthread_mutex_unlock(&dv->mutex); #else dv->eof = 1; #endif return NULL; } } return NULL; }<SPLIT>[-0.25365086435942685, 0.0900232108280778, 0.0, -0.2665172434374763, 0.01910106640589235, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.04882610287367361, -0.25297036047912586, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.016577635342370212, -0.26569807294376846, -0.17914063696102905, -0.011671540416283347, -0.1892664641018488, 0.0, 0.4647777494796126, 2.736734056147358, -0.1670742477136589, -0.1980344553542678, 0.005287286955244392, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>^ P; AVBlowfish *av_blowfish_alloc(void) { return av_mallocz(sizeof(struct AVBlowfish)); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int filter_slice_rgb(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs) { FadeContext *s = ctx->priv; AVFrame *frame = arg; int slice_start = (frame->height * jobnr ) / nb_jobs; int slice_end = (frame->height * (jobnr+1)) / nb_jobs; if (s->alpha) filter_rgb(s, frame, slice_start, slice_end, 1, 4); else if (s->bpp == 3) filter_rgb(s, frame, slice_start, slice_end, 0, 3); else if (s->bpp == 4) filter_rgb(s, frame, slice_start, slice_end, 0, 4); else av_assert0(0); return 0; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.14106852214680915, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.03454968660237938, -0.3333928163445767, 2.47944955092491, -0.04111270872174079, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void amplify_frame(DynamicAudioNormalizerContext *s, AVFrame *frame) { int c, i; for (c = 0; c < s->channels; c++) { double *dst_ptr = (double *)frame->extended_data[c]; double current_amplification_factor; cqueue_dequeue(s->gain_history_smoothed[c], &current_amplification_factor); for (i = 0; i < frame->nb_samples; i++) { const double amplification_factor = fade(s->prev_amplification_factor[c], current_amplification_factor, i, s->fade_factors); dst_ptr[i] *= amplification_factor; if (fabs(dst_ptr[i]) > s->peak_value) dst_ptr[i] = copysign(s->peak_value, dst_ptr[i]); } s->prev_amplification_factor[c] = current_amplification_factor; } }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, 0.11772544131424245, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.1980344553542678, 0.23107402248845843, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold void opengl_get_texture_size(OpenGLContext *opengl, int in_width, int in_height, int *out_width, int *out_height) { if (opengl->non_pow_2_textures) { *out_width = in_width; *out_height = in_height; } else { int max = FFMIN(FFMAX(in_width, in_height), opengl->max_texture_size); unsigned power_of_2 = 1; while (power_of_2 < max) power_of_2 *= 2; *out_height = power_of_2; *out_width = power_of_2; av_log(opengl, AV_LOG_DEBUG, "Texture size calculated from %dx%d into %dx%d\n", in_width, in_height, *out_width, *out_height); } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static inline void doVertLowPass_altivec(uint8_t *src, int stride, PPContext *c) { uint8_t *src2 = src; const vector signed int zero = vec_splat_s32(0); const int properStride = (stride % 16); const int srcAlign = ((unsigned long)src2 % 16); DECLARE_ALIGNED(16, short, qp)[8] = {c->QP}; vector signed short vqp = vec_ld(0, qp); vector signed short vb0, vb1, vb2, vb3, vb4, vb5, vb6, vb7, vb8, vb9; vector unsigned char vbA0, av_uninit(vbA1), av_uninit(vbA2), av_uninit(vbA3), av_uninit(vbA4), av_uninit(vbA5), av_uninit(vbA6), av_uninit(vbA7), av_uninit(vbA8), vbA9; vector unsigned char vbB0, av_uninit(vbB1), av_uninit(vbB2), av_uninit(vbB3), av_uninit(vbB4), av_uninit(vbB5), av_uninit(vbB6), av_uninit(vbB7), av_uninit(vbB8), vbB9; vector unsigned char vbT0, vbT1, vbT2, vbT3, vbT4, vbT5, vbT6, vbT7, vbT8, vbT9; vector unsigned char perml0, perml1, perml2, perml3, perml4, perml5, perml6, perml7, perml8, perml9; register int j0 = 0, j1 = stride, j2 = 2 * stride, j3 = 3 * stride, j4 = 4 * stride, j5 = 5 * stride, j6 = 6 * stride, j7 = 7 * stride, j8 = 8 * stride, j9 = 9 * stride; vqp = vec_splat(vqp, 0); src2 += stride*3; #define LOAD_LINE(i) \ perml##i = vec_lvsl(i * stride, src2); \ vbA##i = vec_ld(i * stride, src2); \ vbB##i = vec_ld(i * stride + 16, src2); \ vbT##i = vec_perm(vbA##i, vbB##i, perml##i); \ vb##i = \ (vector signed short)vec_mergeh((vector unsigned char)zero, \ (vector unsigned char)vbT##i) #define LOAD_LINE_ALIGNED(i) \ vbT##i = vec_ld(j##i, src2); \ vb##i = \ (vector signed short)vec_mergeh((vector signed char)zero, \ (vector signed char)vbT##i) if (properStride && srcAlign) { LOAD_LINE_ALIGNED(0); LOAD_LINE_ALIGNED(1); LOAD_LINE_ALIGNED(2); LOAD_LINE_ALIGNED(3); LOAD_LINE_ALIGNED(4); LOAD_LINE_ALIGNED(5); LOAD_LINE_ALIGNED(6); LOAD_LINE_ALIGNED(7); LOAD_LINE_ALIGNED(8); LOAD_LINE_ALIGNED(9); } else { LOAD_LINE(0); LOAD_LINE(1); LOAD_LINE(2); LOAD_LINE(3); LOAD_LINE(4); LOAD_LINE(5); LOAD_LINE(6); LOAD_LINE(7); LOAD_LINE(8); LOAD_LINE(9); } #undef LOAD_LINE #undef LOAD_LINE_ALIGNED { const vector unsigned short v_2 = vec_splat_u16(2); const vector unsigned short v_4 = vec_splat_u16(4); const vector signed short v_diff01 = vec_sub(vb0, vb1); const vector unsigned short v_cmp01 = (const vector unsigned short) vec_cmplt(vec_abs(v_diff01), vqp); const vector signed short v_first = vec_sel(vb1, vb0, v_cmp01); const vector signed short v_diff89 = vec_sub(vb8, vb9); const vector unsigned short v_cmp89 = (const vector unsigned short) vec_cmplt(vec_abs(v_diff89), vqp); const vector signed short v_last = vec_sel(vb8, vb9, v_cmp89); const vector signed short temp01 = vec_mladd(v_first, (vector signed short)v_4, vb1); const vector signed short temp02 = vec_add(vb2, vb3); const vector signed short temp03 = vec_add(temp01, (vector signed short)v_4); const vector signed short v_sumsB0 = vec_add(temp02, temp03); const vector signed short temp11 = vec_sub(v_sumsB0, v_first); const vector signed short v_sumsB1 = vec_add(temp11, vb4); const vector signed short temp21 = vec_sub(v_sumsB1, v_first); const vector signed short v_sumsB2 = vec_add(temp21, vb5); const vector signed short temp31 = vec_sub(v_sumsB2, v_first); const vector signed short v_sumsB3 = vec_add(temp31, vb6); const vector signed short temp41 = vec_sub(v_sumsB3, v_first); const vector signed short v_sumsB4 = vec_add(temp41, vb7); const vector signed short temp51 = vec_sub(v_sumsB4, vb1); const vector signed short v_sumsB5 = vec_add(temp51, vb8); const vector signed short temp61 = vec_sub(v_sumsB5, vb2); const vector signed short v_sumsB6 = vec_add(temp61, v_last); const vector signed short temp71 = vec_sub(v_sumsB6, vb3); const vector signed short v_sumsB7 = vec_add(temp71, v_last); const vector signed short temp81 = vec_sub(v_sumsB7, vb4); const vector signed short v_sumsB8 = vec_add(temp81, v_last); const vector signed short temp91 = vec_sub(v_sumsB8, vb5); const vector signed short v_sumsB9 = vec_add(temp91, v_last); #define COMPUTE_VR(i, j, k) \ const vector signed short temps1##i = \ vec_add(v_sumsB##i, v_sumsB##k); \ const vector signed short temps2##i = \ vec_mladd(vb##j, (vector signed short)v_2, temps1##i); \ const vector signed short vr##j = vec_sra(temps2##i, v_4) COMPUTE_VR(0, 1, 2); COMPUTE_VR(1, 2, 3); COMPUTE_VR(2, 3, 4); COMPUTE_VR(3, 4, 5); COMPUTE_VR(4, 5, 6); COMPUTE_VR(5, 6, 7); COMPUTE_VR(6, 7, 8); COMPUTE_VR(7, 8, 9); const vector signed char neg1 = vec_splat_s8(-1); const vector unsigned char permHH = (const vector unsigned char){0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F}; #define PACK_AND_STORE(i) \ { const vector unsigned char perms##i = \ vec_lvsr(i * stride, src2); \ const vector unsigned char vf##i = \ vec_packsu(vr##i, (vector signed short)zero); \ const vector unsigned char vg##i = \ vec_perm(vf##i, vbT##i, permHH); \ const vector unsigned char mask##i = \ vec_perm((vector unsigned char)zero, (vector unsigned char)neg1, perms##i); \ const vector unsigned char vg2##i = \ vec_perm(vg##i, vg##i, perms##i); \ const vector unsigned char svA##i = \ vec_sel(vbA##i, vg2##i, mask##i); \ const vector unsigned char svB##i = \ vec_sel(vg2##i, vbB##i, mask##i); \ vec_st(svA##i, i * stride, src2); \ vec_st(svB##i, i * stride + 16, src2);} #define PACK_AND_STORE_ALIGNED(i) \ { const vector unsigned char vf##i = \ vec_packsu(vr##i, (vector signed short)zero); \ const vector unsigned char vg##i = \ vec_perm(vf##i, vbT##i, permHH); \ vec_st(vg##i, i * stride, src2);} if (properStride && srcAlign) { PACK_AND_STORE_ALIGNED(1) PACK_AND_STORE_ALIGNED(2) PACK_AND_STORE_ALIGNED(3) PACK_AND_STORE_ALIGNED(4) PACK_AND_STORE_ALIGNED(5) PACK_AND_STORE_ALIGNED(6) PACK_AND_STORE_ALIGNED(7) PACK_AND_STORE_ALIGNED(8) } else { PACK_AND_STORE(1) PACK_AND_STORE(2) PACK_AND_STORE(3) PACK_AND_STORE(4) PACK_AND_STORE(5) PACK_AND_STORE(6) PACK_AND_STORE(7) PACK_AND_STORE(8) } #undef PACK_AND_STORE #undef PACK_AND_STORE_ALIGNED } }<SPLIT>[1.9113408089114425, 2.844597381902919, 0.0, 1.863667616716882, 2.6789476323471755, 0.0, -0.07259221415890627, -0.06585336703851451, 0.24256368267104944, -0.27925050329511203, 2.825890844606603, 1.9492988439508436, 2.7116924814562093, 0.0, 0.0, 0.30852482215402843, 2.6763555527943086, 1.8999746666332415, 2.559593633189342, 1.0235043134279231, 1.1261297571726039, 0.0, -0.08645738172306322, 6.215479866897657, 2.573233491176077, 0.40140969673598975, 1.2471143323879217, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, 0.24218765769350709, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static inline void reset_predict_state(PredictorState *ps) { ps->r0 = 0.0f; ps->r1 = 0.0f; ps->k1 = 0.0f; ps->cor0 = 0.0f; ps->cor1 = 0.0f; ps->var0 = 1.0f; ps->var1 = 1.0f; ps->x_est = 0.0f; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int ff_dualinput_request_frame(FFDualInputContext *s, AVFilterLink *outlink) { return ff_framesync_request_frame(&s->fs, outlink); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void imdct_and_windowing_ld(AACContext *ac, SingleChannelElement *sce) { IndividualChannelStream *ics = &sce->ics; INTFLOAT *in = sce->coeffs; INTFLOAT *out = sce->ret; INTFLOAT *saved = sce->saved; INTFLOAT *buf = ac->buf_mdct; #if USE_FIXED int i; #endif ac->mdct.imdct_half(&ac->mdct_ld, buf, in); #if USE_FIXED for (i = 0; i < 1024; i++) buf[i] = (buf[i] + 2) >> 2; #endif if (ics->use_kb_window[1]) { memcpy(out, saved, 192 * sizeof(*out)); ac->fdsp->vector_fmul_window(out + 192, saved + 192, buf, AAC_RENAME(ff_sine_128), 64); memcpy( out + 320, buf + 64, 192 * sizeof(*out)); } else { ac->fdsp->vector_fmul_window(out, saved, buf, AAC_RENAME(ff_sine_512), 256); } memcpy(saved, buf + 256, 256 * sizeof(*saved)); }<SPLIT>[0.36491818514653585, -0.13034272285790952, 0.0, 0.34210700232091185, -0.1936866588694103, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.07104719533062549, 0.3762494122151511, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.13281935569359377, 0.35306556693537716, -0.33374660382435645, -0.5292594673383866, -0.2988828158747199, 0.0, 0.24428369699854227, 2.1569430876889752, -0.1670742477136589, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { VectorscopeContext *s = ctx->priv; const enum AVPixelFormat *out_pix_fmts; const AVPixFmtDescriptor *desc; AVFilterFormats *avff; int rgb, i; if (!ctx->inputs[0]->in_formats || !ctx->inputs[0]->in_formats->nb_formats) { return AVERROR(EAGAIN); } if (!ctx->inputs[0]->out_formats) { const enum AVPixelFormat *in_pix_fmts; if ((s->x == 1 && s->y == 2) || (s->x == 2 && s->y == 1)) in_pix_fmts = in2_pix_fmts; else in_pix_fmts = in1_pix_fmts; ff_formats_ref(ff_make_format_list(in_pix_fmts), &ctx->inputs[0]->out_formats); } avff = ctx->inputs[0]->in_formats; desc = av_pix_fmt_desc_get(avff->formats[0]); rgb = desc->flags & AV_PIX_FMT_FLAG_RGB; for (i = 1; i < avff->nb_formats; i++) { desc = av_pix_fmt_desc_get(avff->formats[i]); if (rgb != (desc->flags & AV_PIX_FMT_FLAG_RGB)) return AVERROR(EAGAIN); } if (rgb) out_pix_fmts = out_rgb_pix_fmts; else out_pix_fmts = out_yuv_pix_fmts; ff_formats_ref(ff_make_format_list(out_pix_fmts), &ctx->outputs[0]->in_formats); return 0; }<SPLIT>[-0.25365086435942685, 0.0900232108280778, 0.0, -0.2665172434374763, 0.01910106640589235, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.04882610287367361, -0.25297036047912586, 0.11330413889199094, 0.0, 0.0, 0.30852482215402843, -0.016577635342370212, -0.26569807294376846, 0.04172502998658149, 0.11772544131424245, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, 0.043718655277859224, 0.18343000506680518, 0.34396739025506545, -0.21702784222394986, 0.05245806339860493, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void check_black_end(AVFilterContext *ctx) { BlackDetectContext *blackdetect = ctx->priv; AVFilterLink *inlink = ctx->inputs[0]; if ((blackdetect->black_end - blackdetect->black_start) >= blackdetect->black_min_duration) { av_log(blackdetect, AV_LOG_INFO, "black_start:%s black_end:%s black_duration:%s\n", av_ts2timestr(blackdetect->black_start, &inlink->time_base), av_ts2timestr(blackdetect->black_end, &inlink->time_base), av_ts2timestr(blackdetect->black_end - blackdetect->black_start, &inlink->time_base)); } }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int is_ebml_id_valid(uint32_t id) { unsigned int bits = av_log2(id); return id && (bits + 7) / 8 == (8 - bits % 8); }<SPLIT>[0.21027592277004517, -0.5490379968612854, 0.0, 0.18995094088131478, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, 0.21894446904158188, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, 0.19837465696559078, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int mov_write_stsc_tag(AVIOContext *pb, MOVTrack *track) { int index = 0, oldval = -1, i; int64_t entryPos, curpos; int64_t pos = avio_tell(pb); avio_wb32(pb, 0); ffio_wfourcc(pb, "stsc"); avio_wb32(pb, 0); entryPos = avio_tell(pb); avio_wb32(pb, track->chunkCount); for (i = 0; i < track->entry; i++) { if (oldval != track->cluster[i].samples_in_chunk && track->cluster[i].chunkNum) { avio_wb32(pb, track->cluster[i].chunkNum); avio_wb32(pb, track->cluster[i].samples_in_chunk); avio_wb32(pb, 0x1); oldval = track->cluster[i].samples_in_chunk; index++; } } curpos = avio_tell(pb); avio_seek(pb, entryPos, SEEK_SET); avio_wb32(pb, index); avio_seek(pb, curpos, SEEK_SET); return update_size(pb, pos); }<SPLIT>[-0.25365086435942685, -0.10830612948931077, 0.0, -0.2665172434374763, -0.17240788634188003, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.13098384443277505, -0.25297036047912586, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, -0.26569807294376846, -0.157054070266268, -0.011671540416283347, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, -0.25252937827156396, 0.11818065472185141, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int allrgb_query_formats(AVFilterContext *ctx) { static const enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_RGB24, AV_PIX_FMT_NONE }; AVFilterFormats *fmts_list = ff_make_format_list(pix_fmts); if (!fmts_list) return AVERROR(ENOMEM); return ff_set_common_formats(ctx, fmts_list); }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int load_input_picture(MpegEncContext *s, const AVFrame *pic_arg) { Picture *pic = NULL; int64_t pts; int i, display_picture_number = 0, ret; const int encoding_delay = s->max_b_frames ? s->max_b_frames : (s->low_delay ? 0 : 1); int direct = 1; if (pic_arg) { pts = pic_arg->pts; display_picture_number = s->input_picture_number++; if (pts != AV_NOPTS_VALUE) { if (s->user_specified_pts != AV_NOPTS_VALUE) { int64_t last = s->user_specified_pts; if (pts <= last) { av_log(s->avctx, AV_LOG_ERROR, "Invalid pts (%"PRId64") <= last (%"PRId64")\n", pts, last); return AVERROR(EINVAL); } if (!s->low_delay && display_picture_number == 1) s->dts_delta = pts - last; } s->user_specified_pts = pts; } else { if (s->user_specified_pts != AV_NOPTS_VALUE) { s->user_specified_pts = pts = s->user_specified_pts + 1; av_log(s->avctx, AV_LOG_INFO, "Warning: AVFrame.pts=? trying to guess (%"PRId64")\n", pts); } else { pts = display_picture_number; } } } if (pic_arg) { if (!pic_arg->buf[0] || pic_arg->linesize[0] != s->linesize || pic_arg->linesize[1] != s->uvlinesize || pic_arg->linesize[2] != s->uvlinesize) direct = 0; if ((s->width & 15) || (s->height & 15)) direct = 0; if (((intptr_t)(pic_arg->data[0])) & (STRIDE_ALIGN-1)) direct = 0; if (s->linesize & (STRIDE_ALIGN-1)) direct = 0; ff_dlog(s->avctx, "%d %d %"PTRDIFF_SPECIFIER" %"PTRDIFF_SPECIFIER"\n", pic_arg->linesize[0], pic_arg->linesize[1], s->linesize, s->uvlinesize); i = ff_find_unused_picture(s->avctx, s->picture, direct); if (i < 0) return i; pic = &s->picture[i]; pic->reference = 3; if (direct) { if ((ret = av_frame_ref(pic->f, pic_arg)) < 0) return ret; } ret = alloc_picture(s, pic, direct); if (ret < 0) return ret; if (!direct) { if (pic->f->data[0] + INPLACE_OFFSET == pic_arg->data[0] && pic->f->data[1] + INPLACE_OFFSET == pic_arg->data[1] && pic->f->data[2] + INPLACE_OFFSET == pic_arg->data[2]) { } else { int h_chroma_shift, v_chroma_shift; av_pix_fmt_get_chroma_sub_sample(s->avctx->pix_fmt, &h_chroma_shift, &v_chroma_shift); for (i = 0; i < 3; i++) { int src_stride = pic_arg->linesize[i]; int dst_stride = i ? s->uvlinesize : s->linesize; int h_shift = i ? h_chroma_shift : 0; int v_shift = i ? v_chroma_shift : 0; int w = s->width >> h_shift; int h = s->height >> v_shift; uint8_t *src = pic_arg->data[i]; uint8_t *dst = pic->f->data[i]; int vpad = 16; if ( s->codec_id == AV_CODEC_ID_MPEG2VIDEO && !s->progressive_sequence && FFALIGN(s->height, 32) - s->height > 16) vpad = 32; if (!s->avctx->rc_buffer_size) dst += INPLACE_OFFSET; if (src_stride == dst_stride) memcpy(dst, src, src_stride * h); else { int h2 = h; uint8_t *dst2 = dst; while (h2--) { memcpy(dst2, src, w); dst2 += dst_stride; src += src_stride; } } if ((s->width & 15) || (s->height & (vpad-1))) { s->mpvencdsp.draw_edges(dst, dst_stride, w, h, 16 >> h_shift, vpad >> v_shift, EDGE_BOTTOM); } } } } ret = av_frame_copy_props(pic->f, pic_arg); if (ret < 0) return ret; pic->f->display_picture_number = display_picture_number; pic->f->pts = pts; } for (i = 1; i < MAX_PICTURE_COUNT ; i++) s->input_picture[i - 1] = s->input_picture[i]; s->input_picture[encoding_delay] = (Picture*) pic; return 0; }<SPLIT>[0.05563366039355449, 1.9631336471589698, 0.0, 0.037794879441717756, 1.8277967312459649, 0.0, 3.750858999202425, 3.8224997714599955, 3.559403413692397, 1.699703585821447, 1.7869889268360106, 0.061639525868012635, 2.050698955716189, 0.0, 0.0, 0.30852482215402843, 1.6689273097503714, 0.04368374699580437, 1.9190831990412711, 2.0586801672721293, 2.6607586819927986, 0.0, -0.08645738172306322, -0.16222078614455715, 1.3436082237255544, 2.581206613427835, 2.0373679067541706, 0.6817979554923368, 2.6724396827682853, 3.7495669831915346, 3.8214009264643316, 3.5582115185249252, 1.6991165002636506, 4.332582482518814, 0.0, 3.7417991872342444, 3.813594084765286, 3.5504895973463855, 1.693548171012695]
0<SPLIT>static void calc_thr_3gpp(const FFPsyWindowInfo *wi, const int num_bands, AacPsyChannel *pch, const uint8_t *band_sizes, const float *coefs) { int i, w, g; int start = 0; for (w = 0; w < wi->num_windows*16; w += 16) { for (g = 0; g < num_bands; g++) { AacPsyBand *band = &pch->band[w+g]; float form_factor = 0.0f; float Temp; band->energy = 0.0f; for (i = 0; i < band_sizes[g]; i++) { band->energy += coefs[start+i] * coefs[start+i]; form_factor += sqrtf(fabs(coefs[start+i])); } Temp = band->energy > 0 ? sqrtf((float)band_sizes[g] / band->energy) : 0; band->thr = band->energy * 0.001258925f; band->nz_lines = form_factor * sqrtf(Temp); start += band_sizes[g]; } } }<SPLIT>[-0.25365086435942685, -0.17441590959510697, 0.0, -0.2665172434374763, -0.23624420392447085, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.1909204935349246, -0.25297036047912586, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.26569807294376846, -0.22331377035055117, -0.011671540416283347, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.06167779621789984, -0.25252937827156396, 0.11818065472185141, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>FF_DISABLE_DEPRECATION_WARNINGS int avfilter_ref_get_channels(AVFilterBufferRef *ref) { return ref->audio ? ref->audio->channels : 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static double compute_frame_rms(AVFrame *frame, int channel) { double rms_value = 0.0; int c, i; if (channel == -1) { for (c = 0; c < av_frame_get_channels(frame); c++) { const double *data_ptr = (double *)frame->extended_data[c]; for (i = 0; i < frame->nb_samples; i++) { rms_value += pow2(data_ptr[i]); } } rms_value /= frame->nb_samples * av_frame_get_channels(frame); } else { const double *data_ptr = (double *)frame->extended_data[channel]; for (i = 0; i < frame->nb_samples; i++) { rms_value += pow2(data_ptr[i]); } rms_value /= frame->nb_samples; } return FFMAX(sqrt(rms_value), DBL_EPSILON); }<SPLIT>[-0.25365086435942685, -0.1964525029637057, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.21089937656897445, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, 0.11772544131424245, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, -0.14353953243697165, 0.23107402248845843, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int expect_tag(int32_t got_tag, int32_t expected_tag) { if (got_tag != expected_tag) { char got_tag_str[4], expected_tag_str[4]; AV_WB32(got_tag_str, got_tag); AV_WB32(expected_tag_str, expected_tag); fprintf(stderr, "wanted tag %.4s, got %.4s\n", expected_tag_str, got_tag_str); return -1; } return 0; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 3.3489446507317613, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, -0.14106852214680915, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, 0.0744401592322129, 0.11818065472185141, -0.21702784222394986, 0.05245806339860493, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.04739993194876201]
0<SPLIT>static int mov_auto_flush_fragment(AVFormatContext *s) { MOVMuxContext *mov = s->priv_data; int had_moov = mov->moov_written; int ret = mov_flush_fragment(s); if (ret < 0) return ret; if (!had_moov && mov->flags & FF_MOV_FLAG_DELAY_MOOV) ret = mov_flush_fragment(s); return ret; }<SPLIT>[0.05563366039355449, -0.416818436649693, 0.0, 0.037794879441717756, -0.47031070172730377, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.37073044084137324, 0.061639525868012635, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, 0.04368374699580437, -0.4662660039929228, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3615192241061562, -0.4462861841111837, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
1<SPLIT>static int process_frame_obj(SANMVideoContext *ctx) { uint16_t codec, top, left, w, h; codec = bytestream2_get_le16u(&ctx->gb); left = bytestream2_get_le16u(&ctx->gb); top = bytestream2_get_le16u(&ctx->gb); w = bytestream2_get_le16u(&ctx->gb); h = bytestream2_get_le16u(&ctx->gb); if (ctx->width < left + w || ctx->height < top + h) { ctx->avctx->width = FFMAX(left + w, ctx->width); ctx->avctx->height = FFMAX(top + h, ctx->height); init_sizes(ctx, left + w, top + h); if (init_buffers(ctx)) { av_log(ctx->avctx, AV_LOG_ERROR, "error resizing buffers\n"); return AVERROR(ENOMEM); } } bytestream2_skip(&ctx->gb, 4); av_dlog(ctx->avctx, "subcodec %d\n", codec); switch (codec) { case 1: case 3: return old_codec1(ctx, top, left, w, h); break; case 37: return old_codec37(ctx, top, left, w, h); break; case 47: return old_codec47(ctx, top, left, w, h); break; default: av_log_ask_for_sample(ctx->avctx, "unknown subcodec %d\n", codec); return AVERROR_PATCHWELCOME; } }<SPLIT>[0.21027592277004517, 0.11205980419667652, 0.0, 0.18995094088131478, 0.04037983893342262, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.128741635009873, 0.21894446904158188, 0.13609701908992267, 0.0, 0.0, 0.30852482215402843, 0.060916844891778815, 0.19837465696559078, 0.06381159668134254, 0.7647103499668715, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 0.043718655277859224, 0.0744401592322129, 0.5697541257882794, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int open_url(HLSContext *c, URLContext **uc, const char *url, AVDictionary *opts) { AVDictionary *tmp = NULL; int ret; av_dict_copy(&tmp, c->avio_opts, 0); av_dict_copy(&tmp, opts, 0); ret = ffurl_open(uc, url, AVIO_FLAG_READ, c->interrupt_callback, &tmp); av_dict_free(&tmp); return ret; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void av_sha512_update(AVSHA512* ctx, const uint8_t* data, unsigned int len) { unsigned int i, j; j = ctx->count & 127; ctx->count += len; #if CONFIG_SMALL for (i = 0; i < len; i++) { ctx->buffer[j++] = data[i]; if (128 == j) { sha512_transform(ctx->state, ctx->buffer); j = 0; } } #else if ((j + len) > 127) { memcpy(&ctx->buffer[j], data, (i = 128 - j)); sha512_transform(ctx->state, ctx->buffer); for (; i + 127 < len; i += 128) sha512_transform(ctx->state, &data[i]); j = 0; } else i = 0; memcpy(&ctx->buffer[j], &data[i], len - i); #endif }<SPLIT>[-0.25365086435942685, -0.10830612948931077, 0.0, -0.2665172434374763, -0.17240788634188003, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.13098384443277505, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, -0.26569807294376846, -0.37791973721387856, -0.39986248560786075, -0.07965011232897776, 0.0, 0.6852718019606829, 1.5771521192305922, -0.13194209721507255, -0.3070243011888601, -0.3333928163445767, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void vector_fmul_window_mips(float *dst, const float *src0, const float *src1, const float *win, int len) { float * dst_j, *win_j, *src0_i, *src1_j, *dst_i, *win_i; float temp, temp1, temp2, temp3; float s0, s01, s1, s11; float wi, wi1, wi2, wi3; float wj, wj1, wj2, wj3; const float * lp_end = win + len; win_i = (float *)win; win_j = (float *)(win + 2 * len -1); src1_j = (float *)(src1 + len - 1); src0_i = (float *)src0; dst_i = (float *)dst; dst_j = (float *)(dst + 2 * len -1); __asm__ volatile ( "1:" "lwc1 %[s1], 0(%[src1_j]) \n\t" "lwc1 %[wi], 0(%[win_i]) \n\t" "lwc1 %[wj], 0(%[win_j]) \n\t" "lwc1 %[s11], -4(%[src1_j]) \n\t" "lwc1 %[wi1], 4(%[win_i]) \n\t" "lwc1 %[wj1], -4(%[win_j]) \n\t" "lwc1 %[s0], 0(%[src0_i]) \n\t" "lwc1 %[s01], 4(%[src0_i]) \n\t" "mul.s %[temp], %[s1], %[wi] \n\t" "mul.s %[temp1], %[s1], %[wj] \n\t" "mul.s %[temp2], %[s11], %[wi1] \n\t" "mul.s %[temp3], %[s11], %[wj1] \n\t" "lwc1 %[s1], -8(%[src1_j]) \n\t" "lwc1 %[wi2], 8(%[win_i]) \n\t" "lwc1 %[wj2], -8(%[win_j]) \n\t" "lwc1 %[s11], -12(%[src1_j]) \n\t" "msub.s %[temp], %[temp], %[s0], %[wj] \n\t" "madd.s %[temp1], %[temp1], %[s0], %[wi] \n\t" "msub.s %[temp2], %[temp2], %[s01], %[wj1] \n\t" "madd.s %[temp3], %[temp3], %[s01], %[wi1] \n\t" "lwc1 %[wi3], 12(%[win_i]) \n\t" "lwc1 %[wj3], -12(%[win_j]) \n\t" "lwc1 %[s0], 8(%[src0_i]) \n\t" "lwc1 %[s01], 12(%[src0_i]) \n\t" PTR_ADDIU "%[src1_j],-16 \n\t" PTR_ADDIU "%[win_i],16 \n\t" PTR_ADDIU "%[win_j],-16 \n\t" PTR_ADDIU "%[src0_i],16 \n\t" "swc1 %[temp], 0(%[dst_i]) \n\t" "swc1 %[temp1], 0(%[dst_j]) \n\t" "swc1 %[temp2], 4(%[dst_i]) \n\t" "swc1 %[temp3], -4(%[dst_j]) \n\t" "mul.s %[temp], %[s1], %[wi2] \n\t" "mul.s %[temp1], %[s1], %[wj2] \n\t" "mul.s %[temp2], %[s11], %[wi3] \n\t" "mul.s %[temp3], %[s11], %[wj3] \n\t" "msub.s %[temp], %[temp], %[s0], %[wj2] \n\t" "madd.s %[temp1], %[temp1], %[s0], %[wi2] \n\t" "msub.s %[temp2], %[temp2], %[s01], %[wj3] \n\t" "madd.s %[temp3], %[temp3], %[s01], %[wi3] \n\t" "swc1 %[temp], 8(%[dst_i]) \n\t" "swc1 %[temp1], -8(%[dst_j]) \n\t" "swc1 %[temp2], 12(%[dst_i]) \n\t" "swc1 %[temp3], -12(%[dst_j]) \n\t" PTR_ADDIU "%[dst_i],16 \n\t" PTR_ADDIU "%[dst_j],-16 \n\t" "bne %[win_i], %[lp_end], 1b \n\t" : [temp]"=&f"(temp), [temp1]"=&f"(temp1), [temp2]"=&f"(temp2), [temp3]"=&f"(temp3), [src0_i]"+r"(src0_i), [win_i]"+r"(win_i), [src1_j]"+r"(src1_j), [win_j]"+r"(win_j), [dst_i]"+r"(dst_i), [dst_j]"+r"(dst_j), [s0] "=&f"(s0), [s01]"=&f"(s01), [s1] "=&f"(s1), [s11]"=&f"(s11), [wi] "=&f"(wi), [wj] "=&f"(wj), [wi2]"=&f"(wi2), [wj2]"=&f"(wj2), [wi3]"=&f"(wi3), [wj3]"=&f"(wj3), [wi1]"=&f"(wi1), [wj1]"=&f"(wj1) : [lp_end]"r"(lp_end) : "memory" ); }<SPLIT>[-0.09900860198293619, 0.9935235389406257, 0.0, -0.11436118199787926, 0.8915307400346333, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.8879391903037673, -0.09566541730555662, 1.0478122270071923, 0.0, 0.0, 0.30852482215402843, 0.7971144071161946, -0.11100716297398205, 0.9472742644717848, 0.11772544131424245, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, 0.8918640029916549, 1.8115811712209564, -0.21702784222394986, 0.05245806339860493, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int yae_adjust_position(ATempoContext *atempo) { const AudioFragment *prev = yae_prev_frag(atempo); AudioFragment *frag = yae_curr_frag(atempo); const double prev_output_position = (double)(prev->position[1] - atempo->origin[1] + atempo->window / 2); const double ideal_output_position = (double)(prev->position[0] - atempo->origin[0] + atempo->window / 2) / atempo->tempo; const int drift = (int)(prev_output_position - ideal_output_position); const int delta_max = atempo->window / 2; const int correction = yae_align(frag, prev, atempo->window, delta_max, drift, atempo->correlation, atempo->complex_to_real); if (correction) { frag->position[0] -= correction; frag->nsamples = 0; } return correction; }<SPLIT>[0.05563366039355449, -0.13034272285790952, 0.0, 0.037794879441717756, -0.1936866588694103, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1110049613987252, 0.061639525868012635, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.17156659581066827, 0.04368374699580437, -0.17914063696102905, 0.11772544131424245, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.08904460951967552, 0.23107402248845843, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int find_stream_in_feed(FFServerStream *feed, AVCodecParameters *codec, int bit_rate) { int i; int best_bitrate = 100000000; int best = -1; for (i = 0; i < feed->nb_streams; i++) { AVCodecParameters *feed_codec = feed->streams[i]->codecpar; if (feed_codec->codec_id != codec->codec_id || feed_codec->sample_rate != codec->sample_rate || feed_codec->width != codec->width || feed_codec->height != codec->height) continue; if (feed_codec->bit_rate <= bit_rate) { if (best_bitrate > bit_rate || feed_codec->bit_rate > best_bitrate) { best_bitrate = feed_codec->bit_rate; best = i; } continue; } if (feed_codec->bit_rate < best_bitrate) { best_bitrate = feed_codec->bit_rate; best = i; } } return best; }<SPLIT>[0.36491818514653585, -0.04219634938351458, 0.0, 0.34210700232091185, -0.10857156875928925, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.008868336805573909, 0.3762494122151511, -0.023453142295599506, 0.0, 0.0, 0.30852482215402843, -0.05532487545944473, 0.35306556693537716, -0.09079437018198484, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int ff_mpeg4_frame_end(AVCodecContext *avctx, const uint8_t *buf, int buf_size) { Mpeg4DecContext *ctx = avctx->priv_data; MpegEncContext *s = &ctx->m; if (s->divx_packed) { int current_pos = s->gb.buffer == s->bitstream_buffer ? 0 : (get_bits_count(&s->gb) >> 3); int startcode_found = 0; if (buf_size - current_pos > 7) { int i; for (i = current_pos; i < buf_size - 4; i++) if (buf[i] == 0 && buf[i + 1] == 0 && buf[i + 2] == 1 && buf[i + 3] == 0xB6) { startcode_found = !(buf[i + 4] & 0x40); break; } } if (startcode_found) { if (!ctx->showed_packed_warning) { av_log(s->avctx, AV_LOG_INFO, "Video uses a non-standard and " "wasteful way to store B-frames ('packed B-frames'). " "Consider using the mpeg4_unpack_bframes bitstream filter without encoding but stream copy to fix it.\n"); ctx->showed_packed_warning = 1; } av_fast_padded_malloc(&s->bitstream_buffer, &s->allocated_bitstream_buffer_size, buf_size - current_pos); if (!s->bitstream_buffer) { s->bitstream_buffer_size = 0; return AVERROR(ENOMEM); } memcpy(s->bitstream_buffer, buf + current_pos, buf_size - current_pos); s->bitstream_buffer_size = buf_size - current_pos; } } return 0; }<SPLIT>[0.21027592277004517, 0.20020617767107143, 0.0, 0.18995094088131478, 0.12549492904354367, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, 1.040052222782594, 0.2086571671460724, 0.21894446904158188, 0.22726853988164963, 0.0, 0.0, 0.30852482215402843, 0.13841132512592785, 0.19837465696559078, 0.15215786346038676, 0.11772544131424245, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, 0.3469147738186936, 0.11818065472185141, -0.21702784222394986, 0.5203119240003335, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, 1.039626388904333, 2.6191065950439585, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 1.0350888753871217]
1<SPLIT>static int asf_read_marker(AVFormatContext *s, int64_t size) { AVIOContext *pb = s->pb; ASFContext *asf = s->priv_data; int i, count, name_len, ret; char name[1024]; avio_rl64(pb); avio_rl64(pb); count = avio_rl32(pb); avio_rl16(pb); name_len = avio_rl16(pb); for (i = 0; i < name_len; i++) avio_r8(pb); for (i = 0; i < count; i++) { int64_t pres_time; int name_len; avio_rl64(pb); pres_time = avio_rl64(pb); pres_time -= asf->hdr.preroll * 10000; avio_rl16(pb); avio_rl32(pb); avio_rl32(pb); name_len = avio_rl32(pb); if ((ret = avio_get_str16le(pb, name_len * 2, name, sizeof(name))) < name_len) avio_skip(pb, name_len - ret); avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time, AV_NOPTS_VALUE, name); } return 0; }<SPLIT>[0.36491818514653585, 0.023913430722281605, 0.0, 0.34210700232091185, -0.044735251176698444, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.06880498590772346, 0.3762494122151511, 0.04492549829819571, 0.0, 0.0, 0.30852482215402843, 0.0027959847161670454, 0.35306556693537716, -0.024534670097701678, 0.5059163865058198, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.21937940777079099, 0.23792492798410134, 0.6826474935548865, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_cold int init(AVFilterContext *ctx) { DCShiftContext *s = ctx->priv; s->limiterthreshhold = INT32_MAX * (1.0 - (fabs(s->dcshift) - s->limitergain)); return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int audio_open(void *opaque, int64_t wanted_channel_layout, int wanted_nb_channels, int wanted_sample_rate, struct AudioParams *audio_hw_params) { SDL_AudioSpec wanted_spec, spec; const char *env; static const int next_nb_channels[] = {0, 0, 1, 6, 2, 6, 4, 6}; static const int next_sample_rates[] = {0, 44100, 48000, 96000, 192000}; int next_sample_rate_idx = FF_ARRAY_ELEMS(next_sample_rates) - 1; env = SDL_getenv("SDL_AUDIO_CHANNELS"); if (env) { wanted_nb_channels = atoi(env); wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels); } if (!wanted_channel_layout || wanted_nb_channels != av_get_channel_layout_nb_channels(wanted_channel_layout)) { wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels); wanted_channel_layout &= ~AV_CH_LAYOUT_STEREO_DOWNMIX; } wanted_nb_channels = av_get_channel_layout_nb_channels(wanted_channel_layout); wanted_spec.channels = wanted_nb_channels; wanted_spec.freq = wanted_sample_rate; if (wanted_spec.freq <= 0 || wanted_spec.channels <= 0) { av_log(NULL, AV_LOG_ERROR, "Invalid sample rate or channel count!\n"); return -1; } while (next_sample_rate_idx && next_sample_rates[next_sample_rate_idx] >= wanted_spec.freq) next_sample_rate_idx--; wanted_spec.format = AUDIO_S16SYS; wanted_spec.silence = 0; wanted_spec.samples = FFMAX(SDL_AUDIO_MIN_BUFFER_SIZE, 2 << av_log2(wanted_spec.freq / SDL_AUDIO_MAX_CALLBACKS_PER_SEC)); wanted_spec.callback = sdl_audio_callback; wanted_spec.userdata = opaque; while (SDL_OpenAudio(&wanted_spec, &spec) < 0) { av_log(NULL, AV_LOG_WARNING, "SDL_OpenAudio (%d channels, %d Hz): %s\n", wanted_spec.channels, wanted_spec.freq, SDL_GetError()); wanted_spec.channels = next_nb_channels[FFMIN(7, wanted_spec.channels)]; if (!wanted_spec.channels) { wanted_spec.freq = next_sample_rates[next_sample_rate_idx--]; wanted_spec.channels = wanted_nb_channels; if (!wanted_spec.freq) { av_log(NULL, AV_LOG_ERROR, "No more combinations to try, audio open failed\n"); return -1; } } wanted_channel_layout = av_get_default_channel_layout(wanted_spec.channels); } if (spec.format != AUDIO_S16SYS) { av_log(NULL, AV_LOG_ERROR, "SDL advised audio format %d is not supported!\n", spec.format); return -1; } if (spec.channels != wanted_spec.channels) { wanted_channel_layout = av_get_default_channel_layout(spec.channels); if (!wanted_channel_layout) { av_log(NULL, AV_LOG_ERROR, "SDL advised channel count %d is not supported!\n", spec.channels); return -1; } } audio_hw_params->fmt = AV_SAMPLE_FMT_S16; audio_hw_params->freq = spec.freq; audio_hw_params->channel_layout = wanted_channel_layout; audio_hw_params->channels = spec.channels; audio_hw_params->frame_size = av_samples_get_buffer_size(NULL, audio_hw_params->channels, 1, audio_hw_params->fmt, 1); audio_hw_params->bytes_per_sec = av_samples_get_buffer_size(NULL, audio_hw_params->channels, audio_hw_params->freq, audio_hw_params->fmt, 1); if (audio_hw_params->bytes_per_sec <= 0 || audio_hw_params->frame_size <= 0) { av_log(NULL, AV_LOG_ERROR, "av_samples_get_buffer_size failed\n"); return -1; } return spec.size; }<SPLIT>[-0.25365086435942685, 0.8833405720976321, 0.0, -0.2665172434374763, 0.7851368773969819, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, 1.3698779043020206, 0.7680658920994683, -0.25297036047912586, 0.9338478260175336, 0.0, 0.0, 0.30852482215402843, 0.680872686764971, -0.26569807294376846, 0.8368414309979795, 1.0235043134279231, 0.6876643500811196, 0.0, -0.08645738172306322, -0.16222078614455715, 0.7814938157481727, 0.9463589259089511, 1.1342209646213146, -0.21702784222394986, 0.7074534682410251, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, 1.3693714445839917, 0.9056307075691036, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 1.3643185231999084]
0<SPLIT>static int vc1_decode_b_mb_intfr(VC1Context *v) { MpegEncContext *s = &v->s; GetBitContext *gb = &s->gb; int i, j; int mb_pos = s->mb_x + s->mb_y * s->mb_stride; int cbp = 0; int mqdiff, mquant; int ttmb = v->ttfrm; int mvsw = 0; int mb_has_coeffs = 1; int dmv_x, dmv_y; int val; int first_block = 1; int dst_idx, off; int skipped, direct, twomv = 0; int block_cbp = 0, pat, block_tt = 0; int idx_mbmode = 0, mvbp; int stride_y, fieldtx; int bmvtype = BMV_TYPE_BACKWARD; int dir, dir2; mquant = v->pq; s->mb_intra = 0; if (v->skip_is_raw) skipped = get_bits1(gb); else skipped = v->s.mbskip_table[mb_pos]; if (!skipped) { idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_INTFR_NON4MV_MBMODE_VLC_BITS, 2); if (ff_vc1_mbmode_intfrp[0][idx_mbmode][0] == MV_PMODE_INTFR_2MV_FIELD) { twomv = 1; v->blk_mv_type[s->block_index[0]] = 1; v->blk_mv_type[s->block_index[1]] = 1; v->blk_mv_type[s->block_index[2]] = 1; v->blk_mv_type[s->block_index[3]] = 1; } else { v->blk_mv_type[s->block_index[0]] = 0; v->blk_mv_type[s->block_index[1]] = 0; v->blk_mv_type[s->block_index[2]] = 0; v->blk_mv_type[s->block_index[3]] = 0; } } if (v->dmb_is_raw) direct = get_bits1(gb); else direct = v->direct_mb_plane[mb_pos]; if (direct) { if (s->next_picture_ptr->field_picture) av_log(s->avctx, AV_LOG_WARNING, "Mixed frame/field direct mode not supported\n"); s->mv[0][0][0] = s->current_picture.motion_val[0][s->block_index[0]][0] = scale_mv(s->next_picture.motion_val[1][s->block_index[0]][0], v->bfraction, 0, s->quarter_sample); s->mv[0][0][1] = s->current_picture.motion_val[0][s->block_index[0]][1] = scale_mv(s->next_picture.motion_val[1][s->block_index[0]][1], v->bfraction, 0, s->quarter_sample); s->mv[1][0][0] = s->current_picture.motion_val[1][s->block_index[0]][0] = scale_mv(s->next_picture.motion_val[1][s->block_index[0]][0], v->bfraction, 1, s->quarter_sample); s->mv[1][0][1] = s->current_picture.motion_val[1][s->block_index[0]][1] = scale_mv(s->next_picture.motion_val[1][s->block_index[0]][1], v->bfraction, 1, s->quarter_sample); if (twomv) { s->mv[0][2][0] = s->current_picture.motion_val[0][s->block_index[2]][0] = scale_mv(s->next_picture.motion_val[1][s->block_index[2]][0], v->bfraction, 0, s->quarter_sample); s->mv[0][2][1] = s->current_picture.motion_val[0][s->block_index[2]][1] = scale_mv(s->next_picture.motion_val[1][s->block_index[2]][1], v->bfraction, 0, s->quarter_sample); s->mv[1][2][0] = s->current_picture.motion_val[1][s->block_index[2]][0] = scale_mv(s->next_picture.motion_val[1][s->block_index[2]][0], v->bfraction, 1, s->quarter_sample); s->mv[1][2][1] = s->current_picture.motion_val[1][s->block_index[2]][1] = scale_mv(s->next_picture.motion_val[1][s->block_index[2]][1], v->bfraction, 1, s->quarter_sample); for (i = 1; i < 4; i += 2) { s->mv[0][i][0] = s->current_picture.motion_val[0][s->block_index[i]][0] = s->mv[0][i-1][0]; s->mv[0][i][1] = s->current_picture.motion_val[0][s->block_index[i]][1] = s->mv[0][i-1][1]; s->mv[1][i][0] = s->current_picture.motion_val[1][s->block_index[i]][0] = s->mv[1][i-1][0]; s->mv[1][i][1] = s->current_picture.motion_val[1][s->block_index[i]][1] = s->mv[1][i-1][1]; } } else { for (i = 1; i < 4; i++) { s->mv[0][i][0] = s->current_picture.motion_val[0][s->block_index[i]][0] = s->mv[0][0][0]; s->mv[0][i][1] = s->current_picture.motion_val[0][s->block_index[i]][1] = s->mv[0][0][1]; s->mv[1][i][0] = s->current_picture.motion_val[1][s->block_index[i]][0] = s->mv[1][0][0]; s->mv[1][i][1] = s->current_picture.motion_val[1][s->block_index[i]][1] = s->mv[1][0][1]; } } } if (ff_vc1_mbmode_intfrp[0][idx_mbmode][0] == MV_PMODE_INTFR_INTRA) { for (i = 0; i < 4; i++) { s->mv[0][i][0] = s->current_picture.motion_val[0][s->block_index[i]][0] = 0; s->mv[0][i][1] = s->current_picture.motion_val[0][s->block_index[i]][1] = 0; s->mv[1][i][0] = s->current_picture.motion_val[1][s->block_index[i]][0] = 0; s->mv[1][i][1] = s->current_picture.motion_val[1][s->block_index[i]][1] = 0; } v->is_intra[s->mb_x] = 0x3f; s->mb_intra = 1; s->current_picture.mb_type[mb_pos] = MB_TYPE_INTRA; fieldtx = v->fieldtx_plane[mb_pos] = get_bits1(gb); mb_has_coeffs = get_bits1(gb); if (mb_has_coeffs) cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2); v->s.ac_pred = v->acpred_plane[mb_pos] = get_bits1(gb); GET_MQUANT(); s->current_picture.qscale_table[mb_pos] = mquant; s->y_dc_scale = s->y_dc_scale_table[mquant]; s->c_dc_scale = s->c_dc_scale_table[mquant]; dst_idx = 0; for (i = 0; i < 6; i++) { v->a_avail = v->c_avail = 0; v->mb_type[0][s->block_index[i]] = 1; s->dc_val[0][s->block_index[i]] = 0; dst_idx += i >> 2; val = ((cbp >> (5 - i)) & 1); if (i == 2 || i == 3 || !s->first_slice_line) v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]]; if (i == 1 || i == 3 || s->mb_x) v->c_avail = v->mb_type[0][s->block_index[i] - 1]; vc1_decode_intra_block(v, s->block[i], i, val, mquant, (i & 4) ? v->codingset2 : v->codingset); if (CONFIG_GRAY && i > 3 && (s->avctx->flags & AV_CODEC_FLAG_GRAY)) continue; v->vc1dsp.vc1_inv_trans_8x8(s->block[i]); if (i < 4) { stride_y = s->linesize << fieldtx; off = (fieldtx) ? ((i & 1) * 8) + ((i & 2) >> 1) * s->linesize : (i & 1) * 8 + 4 * (i & 2) * s->linesize; } else { stride_y = s->uvlinesize; off = 0; } s->idsp.put_signed_pixels_clamped(s->block[i], s->dest[dst_idx] + off, stride_y); } } else { s->mb_intra = v->is_intra[s->mb_x] = 0; if (!direct) { if (skipped || !s->mb_intra) { bmvtype = decode012(gb); switch (bmvtype) { case 0: bmvtype = (v->bfraction >= (B_FRACTION_DEN/2)) ? BMV_TYPE_BACKWARD : BMV_TYPE_FORWARD; break; case 1: bmvtype = (v->bfraction >= (B_FRACTION_DEN/2)) ? BMV_TYPE_FORWARD : BMV_TYPE_BACKWARD; break; case 2: bmvtype = BMV_TYPE_INTERPOLATED; } } if (twomv && bmvtype != BMV_TYPE_INTERPOLATED) mvsw = get_bits1(gb); } if (!skipped) { mb_has_coeffs = ff_vc1_mbmode_intfrp[0][idx_mbmode][3]; if (mb_has_coeffs) cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2); if (!direct) { if (bmvtype == BMV_TYPE_INTERPOLATED && twomv) { v->fourmvbp = get_vlc2(gb, v->fourmvbp_vlc->table, VC1_4MV_BLOCK_PATTERN_VLC_BITS, 1); } else if (bmvtype == BMV_TYPE_INTERPOLATED || twomv) { v->twomvbp = get_vlc2(gb, v->twomvbp_vlc->table, VC1_2MV_BLOCK_PATTERN_VLC_BITS, 1); } } for (i = 0; i < 6; i++) v->mb_type[0][s->block_index[i]] = 0; fieldtx = v->fieldtx_plane[mb_pos] = ff_vc1_mbmode_intfrp[0][idx_mbmode][1]; dst_idx = 0; if (direct) { if (twomv) { for (i = 0; i < 4; i++) { ff_vc1_mc_4mv_luma(v, i, 0, 0); ff_vc1_mc_4mv_luma(v, i, 1, 1); } ff_vc1_mc_4mv_chroma4(v, 0, 0, 0); ff_vc1_mc_4mv_chroma4(v, 1, 1, 1); } else { ff_vc1_mc_1mv(v, 0); ff_vc1_interp_mc(v); } } else if (twomv && bmvtype == BMV_TYPE_INTERPOLATED) { mvbp = v->fourmvbp; for (i = 0; i < 4; i++) { dir = i==1 || i==3; dmv_x = dmv_y = 0; val = ((mvbp >> (3 - i)) & 1); if (val) get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0); j = i > 1 ? 2 : 0; ff_vc1_pred_mv_intfr(v, j, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0], dir); ff_vc1_mc_4mv_luma(v, j, dir, dir); ff_vc1_mc_4mv_luma(v, j+1, dir, dir); } ff_vc1_mc_4mv_chroma4(v, 0, 0, 0); ff_vc1_mc_4mv_chroma4(v, 1, 1, 1); } else if (bmvtype == BMV_TYPE_INTERPOLATED) { mvbp = v->twomvbp; dmv_x = dmv_y = 0; if (mvbp & 2) get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0); ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 1, v->range_x, v->range_y, v->mb_type[0], 0); ff_vc1_mc_1mv(v, 0); dmv_x = dmv_y = 0; if (mvbp & 1) get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0); ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 1, v->range_x, v->range_y, v->mb_type[0], 1); ff_vc1_interp_mc(v); } else if (twomv) { dir = bmvtype == BMV_TYPE_BACKWARD; dir2 = dir; if (mvsw) dir2 = !dir; mvbp = v->twomvbp; dmv_x = dmv_y = 0; if (mvbp & 2) get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0); ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0], dir); dmv_x = dmv_y = 0; if (mvbp & 1) get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0); ff_vc1_pred_mv_intfr(v, 2, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0], dir2); if (mvsw) { for (i = 0; i < 2; i++) { s->mv[dir][i+2][0] = s->mv[dir][i][0] = s->current_picture.motion_val[dir][s->block_index[i+2]][0] = s->current_picture.motion_val[dir][s->block_index[i]][0]; s->mv[dir][i+2][1] = s->mv[dir][i][1] = s->current_picture.motion_val[dir][s->block_index[i+2]][1] = s->current_picture.motion_val[dir][s->block_index[i]][1]; s->mv[dir2][i+2][0] = s->mv[dir2][i][0] = s->current_picture.motion_val[dir2][s->block_index[i]][0] = s->current_picture.motion_val[dir2][s->block_index[i+2]][0]; s->mv[dir2][i+2][1] = s->mv[dir2][i][1] = s->current_picture.motion_val[dir2][s->block_index[i]][1] = s->current_picture.motion_val[dir2][s->block_index[i+2]][1]; } } else { ff_vc1_pred_mv_intfr(v, 0, 0, 0, 2, v->range_x, v->range_y, v->mb_type[0], !dir); ff_vc1_pred_mv_intfr(v, 2, 0, 0, 2, v->range_x, v->range_y, v->mb_type[0], !dir); } ff_vc1_mc_4mv_luma(v, 0, dir, 0); ff_vc1_mc_4mv_luma(v, 1, dir, 0); ff_vc1_mc_4mv_luma(v, 2, dir2, 0); ff_vc1_mc_4mv_luma(v, 3, dir2, 0); ff_vc1_mc_4mv_chroma4(v, dir, dir2, 0); } else { dir = bmvtype == BMV_TYPE_BACKWARD; mvbp = ff_vc1_mbmode_intfrp[0][idx_mbmode][2]; dmv_x = dmv_y = 0; if (mvbp) get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0); ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 1, v->range_x, v->range_y, v->mb_type[0], dir); v->blk_mv_type[s->block_index[0]] = 1; v->blk_mv_type[s->block_index[1]] = 1; v->blk_mv_type[s->block_index[2]] = 1; v->blk_mv_type[s->block_index[3]] = 1; ff_vc1_pred_mv_intfr(v, 0, 0, 0, 2, v->range_x, v->range_y, 0, !dir); for (i = 0; i < 2; i++) { s->mv[!dir][i+2][0] = s->mv[!dir][i][0] = s->current_picture.motion_val[!dir][s->block_index[i+2]][0] = s->current_picture.motion_val[!dir][s->block_index[i]][0]; s->mv[!dir][i+2][1] = s->mv[!dir][i][1] = s->current_picture.motion_val[!dir][s->block_index[i+2]][1] = s->current_picture.motion_val[!dir][s->block_index[i]][1]; } ff_vc1_mc_1mv(v, dir); } if (cbp) GET_MQUANT(); s->current_picture.qscale_table[mb_pos] = mquant; if (!v->ttmbf && cbp) ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2); for (i = 0; i < 6; i++) { s->dc_val[0][s->block_index[i]] = 0; dst_idx += i >> 2; val = ((cbp >> (5 - i)) & 1); if (!fieldtx) off = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize); else off = (i & 4) ? 0 : ((i & 1) * 8 + ((i > 1) * s->linesize)); if (val) { pat = vc1_decode_p_block(v, s->block[i], i, mquant, ttmb, first_block, s->dest[dst_idx] + off, (i & 4) ? s->uvlinesize : (s->linesize << fieldtx), CONFIG_GRAY && (i & 4) && (s->avctx->flags & AV_CODEC_FLAG_GRAY), &block_tt); block_cbp |= pat << (i << 2); if (!v->ttmbf && ttmb < 8) ttmb = -1; first_block = 0; } } } else { dir = 0; for (i = 0; i < 6; i++) { v->mb_type[0][s->block_index[i]] = 0; s->dc_val[0][s->block_index[i]] = 0; } s->current_picture.mb_type[mb_pos] = MB_TYPE_SKIP; s->current_picture.qscale_table[mb_pos] = 0; v->blk_mv_type[s->block_index[0]] = 0; v->blk_mv_type[s->block_index[1]] = 0; v->blk_mv_type[s->block_index[2]] = 0; v->blk_mv_type[s->block_index[3]] = 0; if (!direct) { if (bmvtype == BMV_TYPE_INTERPOLATED) { ff_vc1_pred_mv_intfr(v, 0, 0, 0, 1, v->range_x, v->range_y, v->mb_type[0], 0); ff_vc1_pred_mv_intfr(v, 0, 0, 0, 1, v->range_x, v->range_y, v->mb_type[0], 1); } else { dir = bmvtype == BMV_TYPE_BACKWARD; ff_vc1_pred_mv_intfr(v, 0, 0, 0, 1, v->range_x, v->range_y, v->mb_type[0], dir); if (mvsw) { int dir2 = dir; if (mvsw) dir2 = !dir; for (i = 0; i < 2; i++) { s->mv[dir][i+2][0] = s->mv[dir][i][0] = s->current_picture.motion_val[dir][s->block_index[i+2]][0] = s->current_picture.motion_val[dir][s->block_index[i]][0]; s->mv[dir][i+2][1] = s->mv[dir][i][1] = s->current_picture.motion_val[dir][s->block_index[i+2]][1] = s->current_picture.motion_val[dir][s->block_index[i]][1]; s->mv[dir2][i+2][0] = s->mv[dir2][i][0] = s->current_picture.motion_val[dir2][s->block_index[i]][0] = s->current_picture.motion_val[dir2][s->block_index[i+2]][0]; s->mv[dir2][i+2][1] = s->mv[dir2][i][1] = s->current_picture.motion_val[dir2][s->block_index[i]][1] = s->current_picture.motion_val[dir2][s->block_index[i+2]][1]; } } else { v->blk_mv_type[s->block_index[0]] = 1; v->blk_mv_type[s->block_index[1]] = 1; v->blk_mv_type[s->block_index[2]] = 1; v->blk_mv_type[s->block_index[3]] = 1; ff_vc1_pred_mv_intfr(v, 0, 0, 0, 2, v->range_x, v->range_y, 0, !dir); for (i = 0; i < 2; i++) { s->mv[!dir][i+2][0] = s->mv[!dir][i][0] = s->current_picture.motion_val[!dir][s->block_index[i+2]][0] = s->current_picture.motion_val[!dir][s->block_index[i]][0]; s->mv[!dir][i+2][1] = s->mv[!dir][i][1] = s->current_picture.motion_val[!dir][s->block_index[i+2]][1] = s->current_picture.motion_val[!dir][s->block_index[i]][1]; } } } } ff_vc1_mc_1mv(v, dir); if (direct || bmvtype == BMV_TYPE_INTERPOLATED) { ff_vc1_interp_mc(v); } } } if (s->mb_x == s->mb_width - 1) memmove(v->is_intra_base, v->is_intra, sizeof(v->is_intra_base[0]) * s->mb_stride); v->cbp[s->mb_x] = block_cbp; v->ttblk[s->mb_x] = block_tt; return 0; }<SPLIT>[0.05563366039355449, 6.348415727510117, 0.0, 0.037794879441717756, 6.062272464224487, 0.0, 6.705344027708907, 6.827136287572481, 6.54455917161161, 0.7102265412631674, 5.762786650611931, 0.061639525868012635, 6.586482115104604, 0.0, 0.0, 0.30852482215402843, 5.524277701399286, 0.04368374699580437, 6.31430997129872, 3.482046966307913, 8.141576270636351, 0.0, -0.08645738172306322, -0.16222078614455715, 7.316073808485235, 6.722820755142342, 4.182341894319704, -0.21702784222394986, 8.099544465748338, 6.703295449224975, 6.8254146408359375, 6.542632993273201, 0.7098813332246741, 4.332582482518814, 0.0, 6.691803445499003, 6.8138773609222225, 6.530963852431767, 0.7058592275743352]
0<SPLIT>static void set_pcr_pid(AVFormatContext *s, unsigned int programid, unsigned int pid) { int i; for (i = 0; i < s->nb_programs; i++) { if (s->programs[i]->id == programid) { s->programs[i]->pcr_pid = pid; break; } } }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>enum AVPixelFormat choose_pixel_fmt(AVStream *st, AVCodecContext *enc_ctx, AVCodec *codec, enum AVPixelFormat target) { if (codec && codec->pix_fmts) { const enum AVPixelFormat *p = codec->pix_fmts; const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(target); int has_alpha = desc ? desc->nb_components % 2 == 0 : 0; enum AVPixelFormat best= AV_PIX_FMT_NONE; if (enc_ctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) { p = get_compliance_unofficial_pix_fmts(enc_ctx->codec_id, p); } for (; *p != AV_PIX_FMT_NONE; p++) { best= avcodec_find_best_pix_fmt_of_2(best, *p, target, has_alpha, NULL); if (*p == target) break; } if (*p == AV_PIX_FMT_NONE) { if (target != AV_PIX_FMT_NONE) av_log(NULL, AV_LOG_WARNING, "Incompatible pixel format '%s' for codec '%s', auto-selecting format '%s'\n", av_get_pix_fmt_name(target), codec->name, av_get_pix_fmt_name(best)); return best; } } return target; }<SPLIT>[-0.25365086435942685, -0.06423294275211332, 0.0, -0.2665172434374763, -0.12985034128681952, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.09102607836467534, -0.25297036047912586, -0.04624602249353125, 0.0, 0.0, 0.30852482215402843, -0.152192975752131, -0.26569807294376846, -0.1128809368767459, 0.24712242304476825, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, 0.0744401592322129, 0.34396739025506545, -0.21702784222394986, -0.13468348084208653, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static int dash_write(void *opaque, uint8_t *buf, int buf_size) { OutputStream *os = opaque; if (os->out) ffurl_write(os->out, buf, buf_size); return buf_size; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int expand_tseq(void *log, struct sbg_script *s, int *nb_ev_max, int64_t t0, struct sbg_script_tseq *tseq) { int i, r; struct sbg_script_definition *def; struct sbg_script_tseq *be; struct sbg_script_event *ev; if (tseq->lock++) { av_log(log, AV_LOG_ERROR, "Recursion loop on \"%.*s\"\n", tseq->name_len, tseq->name); return AVERROR(EINVAL); } t0 += tseq->ts.t; for (i = 0; i < s->nb_def; i++) { if (s->def[i].name_len == tseq->name_len && !memcmp(s->def[i].name, tseq->name, tseq->name_len)) break; } if (i >= s->nb_def) { av_log(log, AV_LOG_ERROR, "Tone-set \"%.*s\" not defined\n", tseq->name_len, tseq->name); return AVERROR(EINVAL); } def = &s->def[i]; if (def->type == 'B') { be = s->block_tseq + def->elements; for (i = 0; i < def->nb_elements; i++) { r = expand_tseq(log, s, nb_ev_max, t0, &be[i]); if (r < 0) return r; } } else { ev = alloc_array_elem((void **)&s->events, sizeof(*ev), &s->nb_events, nb_ev_max); if (!ev) return AVERROR(ENOMEM); ev->ts = tseq->ts.t; ev->elements = def->elements; ev->nb_elements = def->nb_elements; ev->fade = tseq->fade; } tseq->lock--; return 0; }<SPLIT>[-0.25365086435942685, 0.3103891445140651, 0.0, -0.2665172434374763, 0.231888791681195, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.24861493321417213, -0.25297036047912586, 0.34123294087130834, 0.0, 0.0, 0.30852482215402843, 0.17715856524300236, -0.26569807294376846, 0.262590696934192, 0.37651940477529405, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.21937940777079099, 0.23792492798410134, 0.6826474935548865, -0.21702784222394986, -0.13468348084208653, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
1<SPLIT>static int msrle_decode_8_16_24_32(AVCodecContext *avctx, AVPicture *pic, int depth, GetByteContext *gb) { uint8_t *output, *output_end; int p1, p2, line=avctx->height - 1, pos=0, i; uint16_t pix16; uint32_t pix32; unsigned int width= FFABS(pic->linesize[0]) / (depth >> 3); output = pic->data[0] + (avctx->height - 1) * pic->linesize[0]; output_end = pic->data[0] + avctx->height * pic->linesize[0]; while (bytestream2_get_bytes_left(gb) > 0) { p1 = bytestream2_get_byteu(gb); if(p1 == 0) { p2 = bytestream2_get_byte(gb); if(p2 == 0) { output = pic->data[0] + (--line) * pic->linesize[0]; if (line < 0) { if (bytestream2_get_be16(gb) == 1) { return 0; } else { av_log(avctx, AV_LOG_ERROR, "Next line is beyond picture bounds (%d bytes left)\n", bytestream2_get_bytes_left(gb)); return AVERROR_INVALIDDATA; } } pos = 0; continue; } else if(p2 == 1) { return 0; } else if(p2 == 2) { p1 = bytestream2_get_byte(gb); p2 = bytestream2_get_byte(gb); line -= p2; pos += p1; if (line < 0 || pos >= width){ av_log(avctx, AV_LOG_ERROR, "Skip beyond picture bounds\n"); return -1; } output = pic->data[0] + line * pic->linesize[0] + pos * (depth >> 3); continue; } if ((pic->linesize[0] > 0 && output + p2 * (depth >> 3) > output_end) || (pic->linesize[0] < 0 && output + p2 * (depth >> 3) < output_end)) { bytestream2_skip(gb, 2 * (depth >> 3)); continue; } else if (bytestream2_get_bytes_left(gb) < p2 * (depth >> 3)) { av_log(avctx, AV_LOG_ERROR, "bytestream overrun\n"); return AVERROR_INVALIDDATA; } if ((depth == 8) || (depth == 24)) { for(i = 0; i < p2 * (depth >> 3); i++) { *output++ = bytestream2_get_byteu(gb); } if(depth == 8 && (p2 & 1)) { bytestream2_skip(gb, 1); } } else if (depth == 16) { for(i = 0; i < p2; i++) { *(uint16_t*)output = bytestream2_get_le16u(gb); output += 2; } } else if (depth == 32) { for(i = 0; i < p2; i++) { *(uint32_t*)output = bytestream2_get_le32u(gb); output += 4; } } pos += p2; } else { uint8_t pix[3]; switch(depth){ case 8: pix[0] = bytestream2_get_byte(gb); break; case 16: pix16 = bytestream2_get_le16(gb); break; case 24: pix[0] = bytestream2_get_byte(gb); pix[1] = bytestream2_get_byte(gb); pix[2] = bytestream2_get_byte(gb); break; case 32: pix32 = bytestream2_get_le32(gb); break; } if ((pic->linesize[0] > 0 && output + p1 * (depth >> 3) > output_end) || (pic->linesize[0] < 0 && output + p1 * (depth >> 3) < output_end)) continue; for(i = 0; i < p1; i++) { switch(depth){ case 8: *output++ = pix[0]; break; case 16: *(uint16_t*)output = pix16; output += 2; break; case 24: *output++ = pix[0]; *output++ = pix[1]; *output++ = pix[2]; break; case 32: *(uint32_t*)output = pix32; output += 4; break; } } pos += p1; } } av_log(avctx, AV_LOG_WARNING, "MS RLE warning: no end-of-picture code\n"); return 0; }<SPLIT>[0.5195604475230265, 1.7207311201043836, 0.0, 0.4942630637605089, 1.593730233443132, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 1.6271578625636118, 0.5335543553887203, 1.7999772735389399, 0.0, 0.0, 0.30852482215402843, 1.5139383492820733, 0.5077564769051636, 1.6761309653988996, 0.6353133682363457, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 1.7651940297085906, 0.18343000506680518, 0.9084342290881006, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static inline struct rgbvec lerp(const struct rgbvec *v0, const struct rgbvec *v1, float f) { struct rgbvec v = { lerpf(v0->r, v1->r, f), lerpf(v0->g, v1->g, f), lerpf(v0->b, v1->b, f) }; return v; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static inline int calc_lowcomp1(int a, int b0, int b1, int c) { if ((b0 + 256) == b1) { a = c; } else if (b0 > b1) { a = FFMAX(a - 64, 0); } return a; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.6586564490689124, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.3615192241061562, -0.6720729196443977, -0.21702784222394986, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int caca_write_packet(AVFormatContext *s, AVPacket *pkt) { CACAContext *c = s->priv_data; caca_dither_bitmap(c->canvas, 0, 0, c->window_width, c->window_height, c->dither, pkt->data); caca_refresh_display(c->display); return 0; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int config_output_props(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; SetTBContext *settb = ctx->priv; AVFilterLink *inlink = ctx->inputs[0]; AVRational time_base; int ret; double res; settb->var_values[VAR_AVTB] = av_q2d(AV_TIME_BASE_Q); settb->var_values[VAR_INTB] = av_q2d(inlink->time_base); settb->var_values[VAR_SR] = inlink->sample_rate; outlink->w = inlink->w; outlink->h = inlink->h; if ((ret = av_expr_parse_and_eval(&res, settb->tb_expr, var_names, settb->var_values, NULL, NULL, NULL, NULL, NULL, 0, NULL)) < 0) { av_log(ctx, AV_LOG_ERROR, "Invalid expression '%s' for timebase.\n", settb->tb_expr); return ret; } time_base = av_d2q(res, INT_MAX); if (time_base.num <= 0 || time_base.den <= 0) { av_log(ctx, AV_LOG_ERROR, "Invalid non-positive values for the timebase num:%d or den:%d.\n", time_base.num, time_base.den); return AVERROR(EINVAL); } outlink->time_base = time_base; av_log(outlink->src, AV_LOG_VERBOSE, "tb:%d/%d -> tb:%d/%d\n", inlink ->time_base.num, inlink ->time_base.den, outlink->time_base.num, outlink->time_base.den); return 0; }<SPLIT>[-0.25365086435942685, 0.023913430722281605, 0.0, -0.2665172434374763, -0.044735251176698444, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.011110546228475942, -0.25297036047912586, 0.04492549829819571, 0.0, 0.0, 0.30852482215402843, -0.07469849551798198, -0.26569807294376846, -0.024534670097701678, 0.11772544131424245, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, -0.08904460951967552, 0.005287286955244392, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *frame) { AVFilterContext *ctx = inlink->dst; AVFilterLink *outlink = ctx->outputs[0]; if (av_cmp_q(inlink->time_base, outlink->time_base)) { int64_t orig_pts = frame->pts; frame->pts = av_rescale_q(frame->pts, inlink->time_base, outlink->time_base); av_log(ctx, AV_LOG_DEBUG, "tb:%d/%d pts:%"PRId64" -> tb:%d/%d pts:%"PRId64"\n", inlink ->time_base.num, inlink ->time_base.den, orig_pts, outlink->time_base.num, outlink->time_base.den, frame->pts); } return ff_filter_frame(outlink, frame); }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int request_frame(AVFilterLink *outlink) { MPTestContext *test = outlink->src->priv; AVFrame *picref; int w = WIDTH, h = HEIGHT, cw = FF_CEIL_RSHIFT(w, test->hsub), ch = FF_CEIL_RSHIFT(h, test->vsub); unsigned int frame = outlink->frame_count; enum test_type tt = test->test; int i; if (test->max_pts >= 0 && test->pts > test->max_pts) return AVERROR_EOF; picref = ff_get_video_buffer(outlink, w, h); if (!picref) return AVERROR(ENOMEM); picref->pts = test->pts++; for (i = 0; i < h; i++) memset(picref->data[0] + i*picref->linesize[0], 0, w); for (i = 0; i < ch; i++) { memset(picref->data[1] + i*picref->linesize[1], 128, cw); memset(picref->data[2] + i*picref->linesize[2], 128, cw); } if (tt == TEST_ALL && frame%30) tt = (frame/30)%(TEST_NB-1); switch (tt) { case TEST_DC_LUMA: dc_test(picref->data[0], picref->linesize[0], 256, 256, frame%30); break; case TEST_DC_CHROMA: dc_test(picref->data[1], picref->linesize[1], 256, 256, frame%30); break; case TEST_FREQ_LUMA: freq_test(picref->data[0], picref->linesize[0], frame%30); break; case TEST_FREQ_CHROMA: freq_test(picref->data[1], picref->linesize[1], frame%30); break; case TEST_AMP_LUMA: amp_test(picref->data[0], picref->linesize[0], frame%30); break; case TEST_AMP_CHROMA: amp_test(picref->data[1], picref->linesize[1], frame%30); break; case TEST_CBP: cbp_test(picref->data , picref->linesize , frame%30); break; case TEST_MV: mv_test(picref->data[0], picref->linesize[0], frame%30); break; case TEST_RING1: ring1_test(picref->data[0], picref->linesize[0], frame%30); break; case TEST_RING2: ring2_test(picref->data[0], picref->linesize[0], frame%30); break; } return ff_filter_frame(outlink, picref); }<SPLIT>[-0.09900860198293619, 0.15613299093387398, 0.0, -0.11436118199787926, 0.08293738398848315, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.128741635009873, -0.09566541730555662, 0.18168277948578615, 0.0, 0.0, 0.30852482215402843, 0.060916844891778815, -0.11100716297398205, 0.10798473007086465, 1.2822982768889746, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 0.6760973642524136, 0.5648944654878781, 1.4729010679211356, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int config_props(AVFilterLink *inlink) { AVFilterContext *ctx = inlink->dst; LutContext *s = ctx->priv; const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format); uint8_t rgba_map[4]; int min[4], max[4]; int val, color, ret; s->hsub = desc->log2_chroma_w; s->vsub = desc->log2_chroma_h; s->var_values[VAR_W] = inlink->w; s->var_values[VAR_H] = inlink->h; s->is_16bit = desc->comp[0].depth_minus1 > 7; switch (inlink->format) { case AV_PIX_FMT_YUV410P: case AV_PIX_FMT_YUV411P: case AV_PIX_FMT_YUV420P: case AV_PIX_FMT_YUV422P: case AV_PIX_FMT_YUV440P: case AV_PIX_FMT_YUV444P: case AV_PIX_FMT_YUVA420P: case AV_PIX_FMT_YUVA422P: case AV_PIX_FMT_YUVA444P: case AV_PIX_FMT_YUV420P9LE: case AV_PIX_FMT_YUV422P9LE: case AV_PIX_FMT_YUV444P9LE: case AV_PIX_FMT_YUVA420P9LE: case AV_PIX_FMT_YUVA422P9LE: case AV_PIX_FMT_YUVA444P9LE: case AV_PIX_FMT_YUV420P10LE: case AV_PIX_FMT_YUV422P10LE: case AV_PIX_FMT_YUV440P10LE: case AV_PIX_FMT_YUV444P10LE: case AV_PIX_FMT_YUVA420P10LE: case AV_PIX_FMT_YUVA422P10LE: case AV_PIX_FMT_YUVA444P10LE: case AV_PIX_FMT_YUV420P12LE: case AV_PIX_FMT_YUV422P12LE: case AV_PIX_FMT_YUV440P12LE: case AV_PIX_FMT_YUV444P12LE: case AV_PIX_FMT_YUV420P14LE: case AV_PIX_FMT_YUV422P14LE: case AV_PIX_FMT_YUV444P14LE: case AV_PIX_FMT_YUV420P16LE: case AV_PIX_FMT_YUV422P16LE: case AV_PIX_FMT_YUV444P16LE: case AV_PIX_FMT_YUVA420P16LE: case AV_PIX_FMT_YUVA422P16LE: case AV_PIX_FMT_YUVA444P16LE: min[Y] = 16 * (1 << (desc->comp[0].depth_minus1 - 7)); min[U] = 16 * (1 << (desc->comp[1].depth_minus1 - 7)); min[V] = 16 * (1 << (desc->comp[2].depth_minus1 - 7)); min[A] = 0; max[Y] = 235 * (1 << (desc->comp[0].depth_minus1 - 7)); max[U] = 240 * (1 << (desc->comp[1].depth_minus1 - 7)); max[V] = 240 * (1 << (desc->comp[2].depth_minus1 - 7)); max[A] = (1 << (desc->comp[3].depth_minus1 + 1)) - 1; break; default: min[0] = min[1] = min[2] = min[3] = 0; max[0] = max[1] = max[2] = max[3] = 255; } s->is_yuv = s->is_rgb = 0; if (ff_fmt_is_in(inlink->format, yuv_pix_fmts)) s->is_yuv = 1; else if (ff_fmt_is_in(inlink->format, rgb_pix_fmts)) s->is_rgb = 1; if (s->is_rgb) { ff_fill_rgba_map(rgba_map, inlink->format); s->step = av_get_bits_per_pixel(desc) >> 3; } for (color = 0; color < desc->nb_components; color++) { double res; int comp = s->is_rgb ? rgba_map[color] : color; av_expr_free(s->comp_expr[color]); s->comp_expr[color] = NULL; ret = av_expr_parse(&s->comp_expr[color], s->comp_expr_str[color], var_names, funcs1_names, funcs1, NULL, NULL, 0, ctx); if (ret < 0) { av_log(ctx, AV_LOG_ERROR, "Error when parsing the expression '%s' for the component %d and color %d.\n", s->comp_expr_str[comp], comp, color); return AVERROR(EINVAL); } s->var_values[VAR_MAXVAL] = max[color]; s->var_values[VAR_MINVAL] = min[color]; for (val = 0; val < (1 << (desc->comp[0].depth_minus1 + 1)); val++) { s->var_values[VAR_VAL] = val; s->var_values[VAR_CLIPVAL] = av_clip(val, min[color], max[color]); s->var_values[VAR_NEGVAL] = av_clip(min[color] + max[color] - s->var_values[VAR_VAL], min[color], max[color]); res = av_expr_eval(s->comp_expr[color], s->var_values, s); if (isnan(res)) { av_log(ctx, AV_LOG_ERROR, "Error when evaluating the expression '%s' for the value %d for the component %d.\n", s->comp_expr_str[color], val, comp); return AVERROR(EINVAL); } s->lut[comp][val] = av_clip((int)res, min[color], max[color]); av_log(ctx, AV_LOG_DEBUG, "val[%d][%d] = %d\n", comp, val, s->lut[comp][val]); } } return 0; }<SPLIT>[0.05563366039355449, 1.6105481532613901, 0.0, 0.037794879441717756, 1.4873363708054808, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 1.467326798291213, 0.061639525868012635, 1.6860128725492811, 0.0, 0.0, 0.30852482215402843, 1.3589493888137751, 0.04368374699580437, 1.5656981319250942, 1.1529012951584487, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 1.027418869238277, 0.4559046196532859, 1.3600077001545285, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { static const enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV411P, AV_PIX_FMT_YUV410P, AV_PIX_FMT_YUV440P, AV_PIX_FMT_YUVA444P, AV_PIX_FMT_YUVA422P, AV_PIX_FMT_YUVA420P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUVJ440P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ411P, AV_PIX_FMT_GBRP, AV_PIX_FMT_GBRAP, AV_PIX_FMT_GRAY8, AV_PIX_FMT_NONE }; AVFilterFormats *fmts_list = ff_make_format_list(pix_fmts); if (!fmts_list) return AVERROR(ENOMEM); return ff_set_common_formats(ctx, fmts_list); }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static inline void compute_images_mse(PSNRContext *s, const uint8_t *main_data[4], const int main_linesizes[4], const uint8_t *ref_data[4], const int ref_linesizes[4], int w, int h, double mse[4]) { int i, c; for (c = 0; c < s->nb_components; c++) { const int outw = s->planewidth[c]; const int outh = s->planeheight[c]; const uint8_t *main_line = main_data[c]; const uint8_t *ref_line = ref_data[c]; const int ref_linesize = ref_linesizes[c]; const int main_linesize = main_linesizes[c]; uint64_t m = 0; for (i = 0; i < outh; i++) { m += s->dsp.sse_line(main_line, ref_line, outw); ref_line += ref_linesize; main_line += main_linesize; } mse[c] = m / (double)(outw * outh); } }<SPLIT>[-0.25365086435942685, -0.15237931622650824, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.17094161050087475, -0.25297036047912586, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, 0.5059163865058198, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, -0.25252937827156396, 0.11818065472185141, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void yuv2ya8_1_c(SwsContext *c, const int16_t *buf0, const int16_t *ubuf[2], const int16_t *vbuf[2], const int16_t *abuf0, uint8_t *dest, int dstW, int uvalpha, int y) { int hasAlpha = !!abuf0; int i; for (i = 0; i < dstW; i++) { int Y = (buf0[i] + 64) >> 7; int A; Y = av_clip_uint8(Y); if (hasAlpha) { A = (abuf0[i] + 64) >> 7; if (A & 0x100) A = av_clip_uint8(A); } dest[i * 2 ] = Y; dest[i * 2 + 1] = hasAlpha ? A : 255; } }<SPLIT>[-0.25365086435942685, -0.1964525029637057, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.21089937656897445, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, 0.24712242304476825, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.03454968660237938, -0.22049944857796966, -0.21702784222394986, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 1.7623686513065309, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void RENAME(yuv2rgb555_2)(SwsContext *c, const int16_t *buf[2], const int16_t *ubuf[2], const int16_t *vbuf[2], const int16_t *abuf[2], uint8_t *dest, int dstW, int yalpha, int uvalpha, int y) { const int16_t *buf0 = buf[0], *buf1 = buf[1], *ubuf0 = ubuf[0], *ubuf1 = ubuf[1]; __asm__ volatile( "mov %%"REG_b", "ESP_OFFSET"(%5) \n\t" "mov %4, %%"REG_b" \n\t" "push %%"REG_BP" \n\t" YSCALEYUV2RGB(%%REGBP, %5) "pxor %%mm7, %%mm7 \n\t" #ifdef DITHER1XBPP "paddusb "BLUE_DITHER"(%5), %%mm2 \n\t" "paddusb "GREEN_DITHER"(%5), %%mm4 \n\t" "paddusb "RED_DITHER"(%5), %%mm5 \n\t" #endif WRITERGB15(%%REGb, DSTW_OFFSET"(%5)", %%REGBP) "pop %%"REG_BP" \n\t" "mov "ESP_OFFSET"(%5), %%"REG_b" \n\t" :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest), "a" (&c->redDither) NAMED_CONSTRAINTS_ADD(bF8) ); }<SPLIT>[-0.09900860198293619, -0.08626953612071205, 0.0, -0.11436118199787926, -0.15112911381434976, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.09102607836467534, -0.09566541730555662, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.152192975752131, -0.11100716297398205, -0.24540033704531222, -0.6586564490689124, -0.518115519420462, 0.0, 0.24428369699854227, 0.9973611507722091, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *buf) { AVFilterContext *ctx = inlink->dst; FPSContext *s = ctx->priv; AVFilterLink *outlink = ctx->outputs[0]; int64_t delta; int i, ret; s->frames_in++; if (s->first_pts == AV_NOPTS_VALUE) { if (buf->pts != AV_NOPTS_VALUE) { ret = write_to_fifo(s->fifo, buf); if (ret < 0) return ret; if (s->start_time != DBL_MAX && s->start_time != AV_NOPTS_VALUE) { double first_pts = s->start_time * AV_TIME_BASE; first_pts = FFMIN(FFMAX(first_pts, INT64_MIN), INT64_MAX); s->first_pts = av_rescale_q(first_pts, AV_TIME_BASE_Q, inlink->time_base); av_log(ctx, AV_LOG_VERBOSE, "Set first pts to (in:%"PRId64" out:%"PRId64")\n", s->first_pts, av_rescale_q(first_pts, AV_TIME_BASE_Q, outlink->time_base)); } else { s->first_pts = buf->pts; } } else { av_log(ctx, AV_LOG_WARNING, "Discarding initial frame(s) with no " "timestamp.\n"); av_frame_free(&buf); s->drop++; } return 0; } if (buf->pts == AV_NOPTS_VALUE || av_fifo_size(s->fifo) <= 0) { return write_to_fifo(s->fifo, buf); } delta = av_rescale_q_rnd(buf->pts - s->first_pts, inlink->time_base, outlink->time_base, s->rounding) - s->frames_out ; if (delta < 1) { int drop = av_fifo_size(s->fifo)/sizeof(AVFrame*); av_log(ctx, AV_LOG_DEBUG, "Dropping %d frame(s).\n", drop); s->drop += drop; flush_fifo(s->fifo); ret = write_to_fifo(s->fifo, buf); return ret; } for (i = 0; i < delta; i++) { AVFrame *buf_out; av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL); if (!av_fifo_size(s->fifo) && i < delta - 1) { AVFrame *dup = av_frame_clone(buf_out); av_log(ctx, AV_LOG_DEBUG, "Duplicating frame.\n"); if (dup) ret = write_to_fifo(s->fifo, dup); else ret = AVERROR(ENOMEM); if (ret < 0) { av_frame_free(&buf_out); av_frame_free(&buf); return ret; } s->dup++; } buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base, outlink->time_base) + s->frames_out; if ((ret = ff_filter_frame(outlink, buf_out)) < 0) { av_frame_free(&buf); return ret; } s->frames_out++; } flush_fifo(s->fifo); ret = write_to_fifo(s->fifo, buf); return ret; }<SPLIT>[0.6742027098995172, 0.971486945572027, 0.0, 0.6464191252001059, 0.870251967507103, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 1.040052222782594, 0.9678547224399667, 0.6908592985622897, 1.0250193468092605, 0.0, 0.0, 0.30852482215402843, 0.8746088873503436, 0.66244738687495, 0.9251876977770237, 1.1529012951584487, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, 0.8517581167453454, 0.7828741571570628, 1.1342209646213146, -0.21702784222394986, 0.42674115187998785, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 1.039626388904333, 1.7623686513065309, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 1.0350888753871217]
0<SPLIT>static int parse_expr(AVExpr **e, Parser *p) { int ret; AVExpr *e0, *e1, *e2; if (p->stack_index <= 0) return AVERROR(EINVAL); p->stack_index--; if ((ret = parse_subexpr(&e0, p)) < 0) return ret; while (*p->s == ';') { p->s++; e1 = e0; if ((ret = parse_subexpr(&e2, p)) < 0) { av_expr_free(e1); return ret; } e0 = make_eval_expr(e_last, 1, e1, e2); if (!e0) { av_expr_free(e1); av_expr_free(e2); return AVERROR(ENOMEM); } }; p->stack_index++; *e = e0; return 0; }<SPLIT>[-0.25365086435942685, -0.06423294275211332, 0.0, -0.2665172434374763, -0.12985034128681952, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.09102607836467534, -0.25297036047912586, -0.04624602249353125, 0.0, 0.0, 0.30852482215402843, -0.152192975752131, -0.26569807294376846, -0.1128809368767459, -0.14106852214680915, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.1980344553542678, -0.22049944857796966, 0.6817979554923368, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int64_t mxf_essence_container_end(MXFContext *mxf, int body_sid) { int x; int64_t ret = 0; for (x = 0; x < mxf->partitions_count; x++) { MXFPartition *p = &mxf->partitions[x]; if (p->body_sid != body_sid) continue; if (!p->essence_length) return 0; ret = p->essence_offset + p->essence_length; } return ret; }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int iec61883_read_header(AVFormatContext *context) { struct iec61883_data *dv = context->priv_data; struct raw1394_portinfo pinf[16]; rom1394_directory rom_dir; char *endptr; int inport; int nb_ports; int port = -1; int response; int i, j = 0; uint64_t guid = 0; dv->input_port = -1; dv->output_port = -1; dv->channel = -1; dv->raw1394 = raw1394_new_handle(); if (!dv->raw1394) { av_log(context, AV_LOG_ERROR, "Failed to open IEEE1394 interface.\n"); return AVERROR(EIO); } if ((nb_ports = raw1394_get_port_info(dv->raw1394, pinf, 16)) < 0) { av_log(context, AV_LOG_ERROR, "Failed to get number of IEEE1394 ports.\n"); goto fail; } inport = strtol(context->filename, &endptr, 10); if (endptr != context->filename && *endptr == '\0') { av_log(context, AV_LOG_INFO, "Selecting IEEE1394 port: %d\n", inport); j = inport; nb_ports = inport + 1; } else if (strcmp(context->filename, "auto")) { av_log(context, AV_LOG_ERROR, "Invalid input \"%s\", you should specify " "\"auto\" for auto-detection, or the port number.\n", context->filename); goto fail; } if (dv->device_guid) { if (sscanf(dv->device_guid, "%"SCNu64, &guid) != 1) { av_log(context, AV_LOG_INFO, "Invalid dvguid parameter: %s\n", dv->device_guid); goto fail; } } for (; j < nb_ports && port==-1; ++j) { raw1394_destroy_handle(dv->raw1394); if (!(dv->raw1394 = raw1394_new_handle_on_port(j))) { av_log(context, AV_LOG_ERROR, "Failed setting IEEE1394 port.\n"); goto fail; } for (i=0; i<raw1394_get_nodecount(dv->raw1394); ++i) { if (guid > 1) { if (guid == rom1394_get_guid(dv->raw1394, i)) { dv->node = i; port = j; break; } } else { if (rom1394_get_directory(dv->raw1394, i, &rom_dir) < 0) continue; if (((rom1394_get_node_type(&rom_dir) == ROM1394_NODE_TYPE_AVC) && avc1394_check_subunit_type(dv->raw1394, i, AVC1394_SUBUNIT_TYPE_VCR)) || (rom_dir.unit_spec_id == MOTDCT_SPEC_ID)) { rom1394_free_directory(&rom_dir); dv->node = i; port = j; break; } rom1394_free_directory(&rom_dir); } } } if (port == -1) { av_log(context, AV_LOG_ERROR, "No AV/C devices found.\n"); goto fail; } iec61883_cmp_normalize_output(dv->raw1394, 0xffc0 | dv->node); if (dv->type == IEC61883_AUTO) { response = avc1394_transaction(dv->raw1394, dv->node, AVC1394_CTYPE_STATUS | AVC1394_SUBUNIT_TYPE_TAPE_RECORDER | AVC1394_SUBUNIT_ID_0 | AVC1394_VCR_COMMAND_OUTPUT_SIGNAL_MODE | 0xFF, 2); response = AVC1394_GET_OPERAND0(response); dv->type = (response == 0x10 || response == 0x90 || response == 0x1A || response == 0x9A) ? IEC61883_HDV : IEC61883_DV; } dv->channel = iec61883_cmp_connect(dv->raw1394, dv->node, &dv->output_port, raw1394_get_local_id(dv->raw1394), &dv->input_port, &dv->bandwidth); if (dv->channel < 0) dv->channel = 63; if (!dv->max_packets) dv->max_packets = 100; if (CONFIG_MPEGTS_DEMUXER && dv->type == IEC61883_HDV) { avformat_new_stream(context, NULL); dv->mpeg_demux = avpriv_mpegts_parse_open(context); if (!dv->mpeg_demux) goto fail; dv->parse_queue = iec61883_parse_queue_hdv; dv->iec61883_mpeg2 = iec61883_mpeg2_recv_init(dv->raw1394, (iec61883_mpeg2_recv_t)iec61883_callback, dv); dv->max_packets *= 766; } else { dv->dv_demux = avpriv_dv_init_demux(context); if (!dv->dv_demux) goto fail; dv->parse_queue = iec61883_parse_queue_dv; dv->iec61883_dv = iec61883_dv_fb_init(dv->raw1394, iec61883_callback, dv); } dv->raw1394_poll.fd = raw1394_get_fd(dv->raw1394); dv->raw1394_poll.events = POLLIN | POLLERR | POLLHUP | POLLPRI; if (dv->type == IEC61883_HDV) iec61883_mpeg2_recv_start(dv->iec61883_mpeg2, dv->channel); else iec61883_dv_fb_start(dv->iec61883_dv, dv->channel); #if THREADS dv->thread_loop = 1; if (pthread_mutex_init(&dv->mutex, NULL)) goto fail; if (pthread_cond_init(&dv->cond, NULL)) goto fail; if (pthread_create(&dv->receive_task_thread, NULL, iec61883_receive_task, dv)) goto fail; #endif return 0; fail: raw1394_destroy_handle(dv->raw1394); return AVERROR(EIO); }<SPLIT>[0.9834872346524985, 2.183499580844957, 0.0, 0.9507312480792999, 2.0405844565212674, 0.0, 1.8391333925217592, 1.8783232022107403, 1.9009835481817232, 3.34883199341858, 2.106651055380808, 1.0054691849094282, 2.073491835914121, 0.0, 0.0, 0.30852482215402843, 1.9789052306869674, 0.9718292068145229, 1.9411697657360323, 3.8702379114994905, 1.454978812491217, 0.0, 0.6852718019606829, 0.9973611507722091, 1.8354583307057633, 2.962671073848908, 3.730768423253276, 1.5806237532086234, 1.8303027336851738, 1.8383309169346027, 1.8776273465768223, 1.9001995881092162, 3.347841778661945, 0.9056307075691036, 0.0, 1.832972902474695, 1.8722343178402097, 1.8946705667433963, 3.339696410076628]
1<SPLIT>static int asf_write_packet(AVFormatContext *s, AVPacket *pkt) { ASFContext *asf = s->priv_data; AVIOContext *pb = s->pb; ASFStream *stream; AVCodecContext *codec; uint32_t packet_number; int64_t pts; int start_sec; int flags = pkt->flags; int ret; uint64_t offset = avio_tell(pb); codec = s->streams[pkt->stream_index]->codec; stream = &asf->streams[pkt->stream_index]; if (codec->codec_type == AVMEDIA_TYPE_AUDIO) flags &= ~AV_PKT_FLAG_KEY; pts = (pkt->pts != AV_NOPTS_VALUE) ? pkt->pts : pkt->dts; av_assert0(pts != AV_NOPTS_VALUE); pts *= 10000; asf->duration = FFMAX(asf->duration, pts + pkt->duration * 10000); packet_number = asf->nb_packets; put_frame(s, stream, s->streams[pkt->stream_index], pkt->dts, pkt->data, pkt->size, flags); start_sec = (int)((PREROLL_TIME * 10000 + pts + ASF_INDEXED_INTERVAL - 1) / ASF_INDEXED_INTERVAL); if ((!asf->is_streamed) && (flags & AV_PKT_FLAG_KEY)) { uint16_t packet_count = asf->nb_packets - packet_number; ret = update_index(s, start_sec, packet_number, packet_count, offset); if (ret < 0) return ret; } asf->end_sec = start_sec; return 0; }<SPLIT>[0.9834872346524985, 0.0900232108280778, 0.0, 0.9507312480792999, 0.01910106640589235, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, 0.2086571671460724, 1.0054691849094282, 0.11330413889199094, 0.0, 0.0, 0.30852482215402843, 0.13841132512592785, 0.9718292068145229, 0.04172502998658149, 0.11772544131424245, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 0.18424725727220465, -0.08904460951967552, 0.005287286955244392, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int swscale(SwsContext *c, const uint8_t *src[], int srcStride[], int srcSliceY, int srcSliceH, uint8_t *dst[], int dstStride[]) { #ifndef NEW_FILTER const int srcW = c->srcW; #endif const int dstW = c->dstW; const int dstH = c->dstH; #ifndef NEW_FILTER const int chrDstW = c->chrDstW; const int chrSrcW = c->chrSrcW; const int lumXInc = c->lumXInc; const int chrXInc = c->chrXInc; #endif const enum AVPixelFormat dstFormat = c->dstFormat; const int flags = c->flags; int32_t *vLumFilterPos = c->vLumFilterPos; int32_t *vChrFilterPos = c->vChrFilterPos; #ifndef NEW_FILTER int32_t *hLumFilterPos = c->hLumFilterPos; int32_t *hChrFilterPos = c->hChrFilterPos; int16_t *hLumFilter = c->hLumFilter; int16_t *hChrFilter = c->hChrFilter; int32_t *lumMmxFilter = c->lumMmxFilter; int32_t *chrMmxFilter = c->chrMmxFilter; #endif const int vLumFilterSize = c->vLumFilterSize; const int vChrFilterSize = c->vChrFilterSize; #ifndef NEW_FILTER const int hLumFilterSize = c->hLumFilterSize; const int hChrFilterSize = c->hChrFilterSize; int16_t **lumPixBuf = c->lumPixBuf; int16_t **chrUPixBuf = c->chrUPixBuf; int16_t **chrVPixBuf = c->chrVPixBuf; #endif int16_t **alpPixBuf = c->alpPixBuf; const int vLumBufSize = c->vLumBufSize; const int vChrBufSize = c->vChrBufSize; #ifndef NEW_FILTER uint8_t *formatConvBuffer = c->formatConvBuffer; uint32_t *pal = c->pal_yuv; #endif yuv2planar1_fn yuv2plane1 = c->yuv2plane1; yuv2planarX_fn yuv2planeX = c->yuv2planeX; yuv2interleavedX_fn yuv2nv12cX = c->yuv2nv12cX; yuv2packed1_fn yuv2packed1 = c->yuv2packed1; yuv2packed2_fn yuv2packed2 = c->yuv2packed2; yuv2packedX_fn yuv2packedX = c->yuv2packedX; yuv2anyX_fn yuv2anyX = c->yuv2anyX; const int chrSrcSliceY = srcSliceY >> c->chrSrcVSubSample; const int chrSrcSliceH = FF_CEIL_RSHIFT(srcSliceH, c->chrSrcVSubSample); int should_dither = is9_OR_10BPS(c->srcFormat) || is16BPS(c->srcFormat); int lastDstY; int dstY = c->dstY; int lumBufIndex = c->lumBufIndex; int chrBufIndex = c->chrBufIndex; int lastInLumBuf = c->lastInLumBuf; int lastInChrBuf = c->lastInChrBuf; int perform_gamma = c->is_internal_gamma; #ifdef NEW_FILTER int lumStart = 0; int lumEnd = c->descIndex[0]; int chrStart = lumEnd; int chrEnd = c->descIndex[1]; int vStart = chrEnd; int vEnd = c->numDesc; SwsSlice *src_slice = &c->slice[lumStart]; SwsSlice *hout_slice = &c->slice[c->numSlice-2]; SwsSlice *vout_slice = &c->slice[c->numSlice-1]; SwsFilterDescriptor *desc = c->desc; int hasLumHoles = 1; int hasChrHoles = 1; #endif #ifndef NEW_FILTER if (!usePal(c->srcFormat)) { pal = c->input_rgb2yuv_table; } #endif if (isPacked(c->srcFormat)) { src[0] = src[1] = src[2] = src[3] = src[0]; srcStride[0] = srcStride[1] = srcStride[2] = srcStride[3] = srcStride[0]; } srcStride[1] <<= c->vChrDrop; srcStride[2] <<= c->vChrDrop; DEBUG_BUFFERS("swscale() %p[%d] %p[%d] %p[%d] %p[%d] -> %p[%d] %p[%d] %p[%d] %p[%d]\n", src[0], srcStride[0], src[1], srcStride[1], src[2], srcStride[2], src[3], srcStride[3], dst[0], dstStride[0], dst[1], dstStride[1], dst[2], dstStride[2], dst[3], dstStride[3]); DEBUG_BUFFERS("srcSliceY: %d srcSliceH: %d dstY: %d dstH: %d\n", srcSliceY, srcSliceH, dstY, dstH); DEBUG_BUFFERS("vLumFilterSize: %d vLumBufSize: %d vChrFilterSize: %d vChrBufSize: %d\n", vLumFilterSize, vLumBufSize, vChrFilterSize, vChrBufSize); if (dstStride[0]&15 || dstStride[1]&15 || dstStride[2]&15 || dstStride[3]&15) { static int warnedAlready = 0; if (flags & SWS_PRINT_INFO && !warnedAlready) { av_log(c, AV_LOG_WARNING, "Warning: dstStride is not aligned!\n" " ->cannot do aligned memory accesses anymore\n"); warnedAlready = 1; } } if ( (uintptr_t)dst[0]&15 || (uintptr_t)dst[1]&15 || (uintptr_t)dst[2]&15 || (uintptr_t)src[0]&15 || (uintptr_t)src[1]&15 || (uintptr_t)src[2]&15 || dstStride[0]&15 || dstStride[1]&15 || dstStride[2]&15 || dstStride[3]&15 || srcStride[0]&15 || srcStride[1]&15 || srcStride[2]&15 || srcStride[3]&15 ) { static int warnedAlready=0; int cpu_flags = av_get_cpu_flags(); if (HAVE_MMXEXT && (cpu_flags & AV_CPU_FLAG_SSE2) && !warnedAlready){ av_log(c, AV_LOG_WARNING, "Warning: data is not aligned! This can lead to a speedloss\n"); warnedAlready=1; } } if (srcSliceY == 0) { lumBufIndex = -1; chrBufIndex = -1; dstY = 0; lastInLumBuf = -1; lastInChrBuf = -1; } if (!should_dither) { c->chrDither8 = c->lumDither8 = sws_pb_64; } lastDstY = dstY; #ifdef NEW_FILTER ff_init_vscale_pfn(c, yuv2plane1, yuv2planeX, yuv2nv12cX, yuv2packed1, yuv2packed2, yuv2packedX, yuv2anyX, c->use_mmx_vfilter); ff_init_slice_from_src(src_slice, (uint8_t**)src, srcStride, c->srcW, srcSliceY, srcSliceH, chrSrcSliceY, chrSrcSliceH); ff_init_slice_from_src(vout_slice, (uint8_t**)dst, dstStride, c->dstW, dstY, dstH, dstY >> c->chrDstVSubSample, FF_CEIL_RSHIFT(dstH, c->chrDstVSubSample)); hout_slice->plane[0].sliceY = lastInLumBuf + 1; hout_slice->plane[1].sliceY = lastInChrBuf + 1; hout_slice->plane[2].sliceY = lastInChrBuf + 1; hout_slice->plane[3].sliceY = lastInLumBuf + 1; hout_slice->plane[0].sliceH = hout_slice->plane[1].sliceH = hout_slice->plane[2].sliceH = hout_slice->plane[3].sliceH = 0; hout_slice->width = dstW; #endif for (; dstY < dstH; dstY++) { const int chrDstY = dstY >> c->chrDstVSubSample; #ifndef NEW_FILTER uint8_t *dest[4] = { dst[0] + dstStride[0] * dstY, dst[1] + dstStride[1] * chrDstY, dst[2] + dstStride[2] * chrDstY, (CONFIG_SWSCALE_ALPHA && alpPixBuf) ? dst[3] + dstStride[3] * dstY : NULL, }; #endif int use_mmx_vfilter= c->use_mmx_vfilter; const int firstLumSrcY = FFMAX(1 - vLumFilterSize, vLumFilterPos[dstY]); const int firstLumSrcY2 = FFMAX(1 - vLumFilterSize, vLumFilterPos[FFMIN(dstY | ((1 << c->chrDstVSubSample) - 1), dstH - 1)]); const int firstChrSrcY = FFMAX(1 - vChrFilterSize, vChrFilterPos[chrDstY]); int lastLumSrcY = FFMIN(c->srcH, firstLumSrcY + vLumFilterSize) - 1; int lastLumSrcY2 = FFMIN(c->srcH, firstLumSrcY2 + vLumFilterSize) - 1; int lastChrSrcY = FFMIN(c->chrSrcH, firstChrSrcY + vChrFilterSize) - 1; int enough_lines; #ifdef NEW_FILTER int i; int posY, cPosY, firstPosY, lastPosY, firstCPosY, lastCPosY; #endif if (firstLumSrcY > lastInLumBuf) { #ifdef NEW_FILTER hasLumHoles = lastInLumBuf != firstLumSrcY - 1; if (hasLumHoles) { hout_slice->plane[0].sliceY = lastInLumBuf + 1; hout_slice->plane[3].sliceY = lastInLumBuf + 1; hout_slice->plane[0].sliceH = hout_slice->plane[3].sliceH = 0; } #endif lastInLumBuf = firstLumSrcY - 1; } if (firstChrSrcY > lastInChrBuf) { #ifdef NEW_FILTER hasChrHoles = lastInChrBuf != firstChrSrcY - 1; if (hasChrHoles) { hout_slice->plane[1].sliceY = lastInChrBuf + 1; hout_slice->plane[2].sliceY = lastInChrBuf + 1; hout_slice->plane[1].sliceH = hout_slice->plane[2].sliceH = 0; } #endif lastInChrBuf = firstChrSrcY - 1; } av_assert0(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1); av_assert0(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1); DEBUG_BUFFERS("dstY: %d\n", dstY); DEBUG_BUFFERS("\tfirstLumSrcY: %d lastLumSrcY: %d lastInLumBuf: %d\n", firstLumSrcY, lastLumSrcY, lastInLumBuf); DEBUG_BUFFERS("\tfirstChrSrcY: %d lastChrSrcY: %d lastInChrBuf: %d\n", firstChrSrcY, lastChrSrcY, lastInChrBuf); enough_lines = lastLumSrcY2 < srcSliceY + srcSliceH && lastChrSrcY < FF_CEIL_RSHIFT(srcSliceY + srcSliceH, c->chrSrcVSubSample); if (!enough_lines) { lastLumSrcY = srcSliceY + srcSliceH - 1; lastChrSrcY = chrSrcSliceY + chrSrcSliceH - 1; DEBUG_BUFFERS("buffering slice: lastLumSrcY %d lastChrSrcY %d\n", lastLumSrcY, lastChrSrcY); } #ifdef NEW_FILTER posY = hout_slice->plane[0].sliceY + hout_slice->plane[0].sliceH; if (posY <= lastLumSrcY && !hasLumHoles) { firstPosY = FFMAX(firstLumSrcY, posY); lastPosY = FFMIN(lastLumSrcY + MAX_LINES_AHEAD, srcSliceY + srcSliceH - 1); } else { firstPosY = lastInLumBuf + 1; lastPosY = lastLumSrcY; } cPosY = hout_slice->plane[1].sliceY + hout_slice->plane[1].sliceH; if (cPosY <= lastChrSrcY && !hasChrHoles) { firstCPosY = FFMAX(firstChrSrcY, cPosY); lastCPosY = FFMIN(lastChrSrcY + MAX_LINES_AHEAD, FF_CEIL_RSHIFT(srcSliceY + srcSliceH, c->chrSrcVSubSample) - 1); } else { firstCPosY = lastInChrBuf + 1; lastCPosY = lastChrSrcY; } ff_rotate_slice(hout_slice, lastPosY, lastCPosY); if (posY < lastLumSrcY + 1) { for (i = lumStart; i < lumEnd; ++i) desc[i].process(c, &desc[i], firstPosY, lastPosY - firstPosY + 1); } lumBufIndex += lastLumSrcY - lastInLumBuf; lastInLumBuf = lastLumSrcY; if (cPosY < lastChrSrcY + 1) { for (i = chrStart; i < chrEnd; ++i) desc[i].process(c, &desc[i], firstCPosY, lastCPosY - firstCPosY + 1); } chrBufIndex += lastChrSrcY - lastInChrBuf; lastInChrBuf = lastChrSrcY; #else while (lastInLumBuf < lastLumSrcY) { const uint8_t *src1[4] = { src[0] + (lastInLumBuf + 1 - srcSliceY) * srcStride[0], src[1] + (lastInLumBuf + 1 - srcSliceY) * srcStride[1], src[2] + (lastInLumBuf + 1 - srcSliceY) * srcStride[2], src[3] + (lastInLumBuf + 1 - srcSliceY) * srcStride[3], }; lumBufIndex++; av_assert0(lumBufIndex < 2 * vLumBufSize); av_assert0(lastInLumBuf + 1 - srcSliceY < srcSliceH); av_assert0(lastInLumBuf + 1 - srcSliceY >= 0); if (perform_gamma) gamma_convert((uint8_t **)src1, srcW, c->inv_gamma); hyscale(c, lumPixBuf[lumBufIndex], dstW, src1, srcW, lumXInc, hLumFilter, hLumFilterPos, hLumFilterSize, formatConvBuffer, pal, 0); if (CONFIG_SWSCALE_ALPHA && alpPixBuf) hyscale(c, alpPixBuf[lumBufIndex], dstW, src1, srcW, lumXInc, hLumFilter, hLumFilterPos, hLumFilterSize, formatConvBuffer, pal, 1); lastInLumBuf++; DEBUG_BUFFERS("\t\tlumBufIndex %d: lastInLumBuf: %d\n", lumBufIndex, lastInLumBuf); } while (lastInChrBuf < lastChrSrcY) { const uint8_t *src1[4] = { src[0] + (lastInChrBuf + 1 - chrSrcSliceY) * srcStride[0], src[1] + (lastInChrBuf + 1 - chrSrcSliceY) * srcStride[1], src[2] + (lastInChrBuf + 1 - chrSrcSliceY) * srcStride[2], src[3] + (lastInChrBuf + 1 - chrSrcSliceY) * srcStride[3], }; chrBufIndex++; av_assert0(chrBufIndex < 2 * vChrBufSize); av_assert0(lastInChrBuf + 1 - chrSrcSliceY < (chrSrcSliceH)); av_assert0(lastInChrBuf + 1 - chrSrcSliceY >= 0); if (c->needs_hcscale) hcscale(c, chrUPixBuf[chrBufIndex], chrVPixBuf[chrBufIndex], chrDstW, src1, chrSrcW, chrXInc, hChrFilter, hChrFilterPos, hChrFilterSize, formatConvBuffer, pal); lastInChrBuf++; DEBUG_BUFFERS("\t\tchrBufIndex %d: lastInChrBuf: %d\n", chrBufIndex, lastInChrBuf); } #endif if (lumBufIndex >= vLumBufSize) lumBufIndex -= vLumBufSize; if (chrBufIndex >= vChrBufSize) chrBufIndex -= vChrBufSize; if (!enough_lines) break; #if HAVE_MMX_INLINE ff_updateMMXDitherTables(c, dstY, lumBufIndex, chrBufIndex, lastInLumBuf, lastInChrBuf); #endif if (should_dither) { c->chrDither8 = ff_dither_8x8_128[chrDstY & 7]; c->lumDither8 = ff_dither_8x8_128[dstY & 7]; } if (dstY >= dstH - 2) { ff_sws_init_output_funcs(c, &yuv2plane1, &yuv2planeX, &yuv2nv12cX, &yuv2packed1, &yuv2packed2, &yuv2packedX, &yuv2anyX); use_mmx_vfilter= 0; ff_init_vscale_pfn(c, yuv2plane1, yuv2planeX, yuv2nv12cX, yuv2packed1, yuv2packed2, yuv2packedX, yuv2anyX, use_mmx_vfilter); } { #ifdef NEW_FILTER for (i = vStart; i < vEnd; ++i) desc[i].process(c, &desc[i], dstY, 1); #else const int16_t **lumSrcPtr = (const int16_t **)(void*) lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize; const int16_t **chrUSrcPtr = (const int16_t **)(void*) chrUPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize; const int16_t **chrVSrcPtr = (const int16_t **)(void*) chrVPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize; const int16_t **alpSrcPtr = (CONFIG_SWSCALE_ALPHA && alpPixBuf) ? (const int16_t **)(void*) alpPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize : NULL; int16_t *vLumFilter = c->vLumFilter; int16_t *vChrFilter = c->vChrFilter; if (isPlanarYUV(dstFormat) || (isGray(dstFormat) && !isALPHA(dstFormat))) { const int chrSkipMask = (1 << c->chrDstVSubSample) - 1; vLumFilter += dstY * vLumFilterSize; vChrFilter += chrDstY * vChrFilterSize; if(use_mmx_vfilter){ vLumFilter= (int16_t *)c->lumMmxFilter; vChrFilter= (int16_t *)c->chrMmxFilter; } if (vLumFilterSize == 1) { yuv2plane1(lumSrcPtr[0], dest[0], dstW, c->lumDither8, 0); } else { yuv2planeX(vLumFilter, vLumFilterSize, lumSrcPtr, dest[0], dstW, c->lumDither8, 0); } if (!((dstY & chrSkipMask) || isGray(dstFormat))) { if (yuv2nv12cX) { yuv2nv12cX(c, vChrFilter, vChrFilterSize, chrUSrcPtr, chrVSrcPtr, dest[1], chrDstW); } else if (vChrFilterSize == 1) { yuv2plane1(chrUSrcPtr[0], dest[1], chrDstW, c->chrDither8, 0); yuv2plane1(chrVSrcPtr[0], dest[2], chrDstW, c->chrDither8, 3); } else { yuv2planeX(vChrFilter, vChrFilterSize, chrUSrcPtr, dest[1], chrDstW, c->chrDither8, 0); yuv2planeX(vChrFilter, vChrFilterSize, chrVSrcPtr, dest[2], chrDstW, c->chrDither8, use_mmx_vfilter ? (c->uv_offx2 >> 1) : 3); } } if (CONFIG_SWSCALE_ALPHA && alpPixBuf) { if(use_mmx_vfilter){ vLumFilter= (int16_t *)c->alpMmxFilter; } if (vLumFilterSize == 1) { yuv2plane1(alpSrcPtr[0], dest[3], dstW, c->lumDither8, 0); } else { yuv2planeX(vLumFilter, vLumFilterSize, alpSrcPtr, dest[3], dstW, c->lumDither8, 0); } } } else if (yuv2packedX) { av_assert1(lumSrcPtr + vLumFilterSize - 1 < (const int16_t **)lumPixBuf + vLumBufSize * 2); av_assert1(chrUSrcPtr + vChrFilterSize - 1 < (const int16_t **)chrUPixBuf + vChrBufSize * 2); if (c->yuv2packed1 && vLumFilterSize == 1 && vChrFilterSize <= 2) { int chrAlpha = vChrFilterSize == 1 ? 0 : vChrFilter[2 * dstY + 1]; yuv2packed1(c, *lumSrcPtr, chrUSrcPtr, chrVSrcPtr, alpPixBuf ? *alpSrcPtr : NULL, dest[0], dstW, chrAlpha, dstY); } else if (c->yuv2packed2 && vLumFilterSize == 2 && vChrFilterSize == 2) { int lumAlpha = vLumFilter[2 * dstY + 1]; int chrAlpha = vChrFilter[2 * dstY + 1]; lumMmxFilter[2] = lumMmxFilter[3] = vLumFilter[2 * dstY] * 0x10001; chrMmxFilter[2] = chrMmxFilter[3] = vChrFilter[2 * chrDstY] * 0x10001; yuv2packed2(c, lumSrcPtr, chrUSrcPtr, chrVSrcPtr, alpPixBuf ? alpSrcPtr : NULL, dest[0], dstW, lumAlpha, chrAlpha, dstY); } else { yuv2packedX(c, vLumFilter + dstY * vLumFilterSize, lumSrcPtr, vLumFilterSize, vChrFilter + dstY * vChrFilterSize, chrUSrcPtr, chrVSrcPtr, vChrFilterSize, alpSrcPtr, dest[0], dstW, dstY); } } else { av_assert1(!yuv2packed1 && !yuv2packed2); yuv2anyX(c, vLumFilter + dstY * vLumFilterSize, lumSrcPtr, vLumFilterSize, vChrFilter + dstY * vChrFilterSize, chrUSrcPtr, chrVSrcPtr, vChrFilterSize, alpSrcPtr, dest, dstW, dstY); } if (perform_gamma) gamma_convert(dest, dstW, c->gamma); #endif } } if (isPlanar(dstFormat) && isALPHA(dstFormat) && !alpPixBuf) { int length = dstW; int height = dstY - lastDstY; if (is16BPS(dstFormat) || isNBPS(dstFormat)) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(dstFormat); fillPlane16(dst[3], dstStride[3], length, height, lastDstY, 1, desc->comp[3].depth_minus1, isBE(dstFormat)); } else fillPlane(dst[3], dstStride[3], length, height, lastDstY, 255); } #if HAVE_MMXEXT_INLINE if (av_get_cpu_flags() & AV_CPU_FLAG_MMXEXT) __asm__ volatile ("sfence" ::: "memory"); #endif emms_c(); c->dstY = dstY; c->lumBufIndex = lumBufIndex; c->chrBufIndex = chrBufIndex; c->lastInLumBuf = lastInLumBuf; c->lastInChrBuf = lastInChrBuf; return dstY - lastDstY; }<SPLIT>[3.61240569505284, 8.838550778161773, 0.0, 3.5373842925524492, 8.466773759835407, 0.0, 5.3149981319411514, 5.41318969175484, 6.212875198509475, 0.380400859743741, 8.47991474324271, 3.6796532188601057, 6.586482115104604, 0.0, 0.0, 0.30852482215402843, 8.159090029360353, 3.601574676300892, 6.31430997129872, 9.175514162451048, 9.01850708481932, 0.0, 8.623057691279215, 19.550672141440465, 7.035016604496544, 8.03069890515745, 8.810969972750591, 1.5806237532086234, 6.321699795461768, 5.313305582856297, 5.411761128190476, 6.211030607190059, 0.3801362775450152, 2.6191065950439585, 0.0, 5.303566147492058, 5.401979348613075, 6.199800046311169, 0.3766295797615486]
0<SPLIT>static av_cold int decode_init(AVCodecContext *avctx) { FourXContext * const f = avctx->priv_data; int ret; if (avctx->extradata_size != 4 || !avctx->extradata) { av_log(avctx, AV_LOG_ERROR, "extradata wrong or missing\n"); return AVERROR_INVALIDDATA; } if((avctx->width % 16) || (avctx->height % 16)) { av_log(avctx, AV_LOG_ERROR, "unsupported width/height\n"); return AVERROR_INVALIDDATA; } ret = av_image_check_size(avctx->width, avctx->height, 0, avctx); if (ret < 0) return ret; f->frame_buffer = av_mallocz(avctx->width * avctx->height * 2); f->last_frame_buffer = av_mallocz(avctx->width * avctx->height * 2); if (!f->frame_buffer || !f->last_frame_buffer) { decode_end(avctx); return AVERROR(ENOMEM); } f->version = AV_RL32(avctx->extradata) >> 16; ff_blockdsp_init(&f->bdsp, avctx); ff_bswapdsp_init(&f->bbdsp); f->avctx = avctx; init_vlcs(f); if (f->version > 2) avctx->pix_fmt = AV_PIX_FMT_RGB565; else avctx->pix_fmt = AV_PIX_FMT_BGR555; return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.02345647864916818, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.05532487545944473, -0.26569807294376846, -0.0024481034029406237, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void vc1_decode_skip_blocks(VC1Context *v) { MpegEncContext *s = &v->s; if (!v->s.last_picture.f->data[0]) return; ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_width - 1, s->end_mb_y - 1, ER_MB_END); s->first_slice_line = 1; for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) { s->mb_x = 0; init_block_index(v); ff_update_block_index(s); memcpy(s->dest[0], s->last_picture.f->data[0] + s->mb_y * 16 * s->linesize, s->linesize * 16); memcpy(s->dest[1], s->last_picture.f->data[1] + s->mb_y * 8 * s->uvlinesize, s->uvlinesize * 8); memcpy(s->dest[2], s->last_picture.f->data[2] + s->mb_y * 8 * s->uvlinesize, s->uvlinesize * 8); ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16); s->first_slice_line = 0; } s->pict_type = AV_PICTURE_TYPE_P; }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, -0.14106852214680915, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, -0.3070243011888601, -0.22049944857796966, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void *writer_child_next(void *obj, void *prev) { WriterContext *ctx = obj; if (!prev && ctx->writer && ctx->writer->priv_class && ctx->priv) return ctx->priv; return NULL; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void fill_items(char *item_str, int *nb_items, float *items) { char *p, *saveptr = NULL; int i, new_nb_items = 0; p = item_str; for (i = 0; i < *nb_items; i++) { char *tstr = av_strtok(p, "|", &saveptr); p = NULL; new_nb_items += sscanf(tstr, "%f", &items[i]) == 1; } *nb_items = new_nb_items; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.270465503877335, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, 0.01994523631491676, 0.005287286955244392, -0.21702784222394986, 0.05245806339860493, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static inline void put_s_trace(AVIOContext *bc, int64_t v, const char *file, const char *func, int line) { av_log(NULL, AV_LOG_DEBUG, "put_s %5"PRId64" / %"PRIX64" in %s %s:%d\n", v, v, file, func, line); put_s(bc, v); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void reset_all_predictors(PredictorState *ps) { int i; for (i = 0; i < MAX_PREDICTORS; i++) reset_predict_state(&ps[i]); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int mov_write_moof_tag(AVIOContext *pb, MOVMuxContext *mov, int tracks, int64_t mdat_size) { AVIOContext *avio_buf; int ret, moof_size; if ((ret = ffio_open_null_buf(&avio_buf)) < 0) return ret; mov_write_moof_tag_internal(avio_buf, mov, tracks, 0); moof_size = ffio_close_null_buf(avio_buf); if (mov->flags & FF_MOV_FLAG_DASH && !(mov->flags & FF_MOV_FLAG_GLOBAL_SIDX)) mov_write_sidx_tags(pb, mov, tracks, moof_size + 8 + mdat_size); if ((ret = mov_add_tfra_entries(pb, mov, tracks, moof_size + 8 + mdat_size)) < 0) return ret; return mov_write_moof_tag_internal(pb, mov, tracks, moof_size); }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, 0.11772544131424245, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.08904460951967552, 0.005287286955244392, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int udp_read_packet(AVFormatContext *s, RTSPStream **prtsp_st, uint8_t *buf, int buf_size, int64_t wait_end) { RTSPState *rt = s->priv_data; RTSPStream *rtsp_st; int n, i, ret, tcp_fd, timeout_cnt = 0; int max_p = 0; struct pollfd *p = rt->p; int *fds = NULL, fdsnum, fdsidx; for (;;) { if (ff_check_interrupt(&s->interrupt_callback)) return AVERROR_EXIT; if (wait_end && wait_end - av_gettime_relative() < 0) return AVERROR(EAGAIN); max_p = 0; if (rt->rtsp_hd) { tcp_fd = ffurl_get_file_handle(rt->rtsp_hd); p[max_p].fd = tcp_fd; p[max_p++].events = POLLIN; } else { tcp_fd = -1; } for (i = 0; i < rt->nb_rtsp_streams; i++) { rtsp_st = rt->rtsp_streams[i]; if (rtsp_st->rtp_handle) { if (ret = ffurl_get_multi_file_handle(rtsp_st->rtp_handle, &fds, &fdsnum)) { av_log(s, AV_LOG_ERROR, "Unable to recover rtp ports\n"); return ret; } if (fdsnum != 2) { av_log(s, AV_LOG_ERROR, "Number of fds %d not supported\n", fdsnum); return AVERROR_INVALIDDATA; } for (fdsidx = 0; fdsidx < fdsnum; fdsidx++) { p[max_p].fd = fds[fdsidx]; p[max_p++].events = POLLIN; } av_freep(&fds); } } n = poll(p, max_p, POLL_TIMEOUT_MS); if (n > 0) { int j = 1 - (tcp_fd == -1); timeout_cnt = 0; for (i = 0; i < rt->nb_rtsp_streams; i++) { rtsp_st = rt->rtsp_streams[i]; if (rtsp_st->rtp_handle) { if (p[j].revents & POLLIN || p[j+1].revents & POLLIN) { ret = ffurl_read(rtsp_st->rtp_handle, buf, buf_size); if (ret > 0) { *prtsp_st = rtsp_st; return ret; } } j+=2; } } #if CONFIG_RTSP_DEMUXER if (tcp_fd != -1 && p[0].revents & POLLIN) { if (rt->rtsp_flags & RTSP_FLAG_LISTEN) { if (rt->state == RTSP_STATE_STREAMING) { if (!ff_rtsp_parse_streaming_commands(s)) return AVERROR_EOF; else av_log(s, AV_LOG_WARNING, "Unable to answer to TEARDOWN\n"); } else return 0; } else { RTSPMessageHeader reply; ret = ff_rtsp_read_reply(s, &reply, NULL, 0, NULL); if (ret < 0) return ret; if (rt->state != RTSP_STATE_STREAMING) return 0; } } #endif } else if (n == 0 && ++timeout_cnt >= MAX_TIMEOUTS) { return AVERROR(ETIMEDOUT); } else if (n < 0 && errno != EINTR) return AVERROR(errno); } }<SPLIT>[-0.09900860198293619, 1.2359260659952118, 0.0, -0.11436118199787926, 1.1255972378374661, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 1.1077069036783158, -0.25297036047912586, 0.8198834250278749, 0.0, 0.0, 0.30852482215402843, 1.0102242277601043, -0.26569807294376846, 0.7264085975241742, 1.1529012951584487, 0.7972807018539907, 0.0, 2.11848314308764, 0.9973611507722091, 0.9220224177425181, 1.0008538488262473, 1.5857944356877427, 3.3782753486411963, 0.05245806339860493, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static int64_t nut_read_timestamp(AVFormatContext *s, int stream_index, int64_t *pos_arg, int64_t pos_limit) { NUTContext *nut = s->priv_data; AVIOContext *bc = s->pb; int64_t pos, pts, back_ptr; av_log(s, AV_LOG_DEBUG, "read_timestamp(X,%d,%"PRId64",%"PRId64")\n", stream_index, *pos_arg, pos_limit); pos = *pos_arg; do { pos = find_startcode(bc, SYNCPOINT_STARTCODE, pos) + 1; if (pos < 1) { av_log(s, AV_LOG_ERROR, "read_timestamp failed.\n"); return AV_NOPTS_VALUE; } } while (decode_syncpoint(nut, &pts, &back_ptr) < 0); *pos_arg = pos - 1; av_assert0(nut->last_syncpoint_pos == *pos_arg); av_log(s, AV_LOG_DEBUG, "return %"PRId64" %"PRId64"\n", pts, back_ptr); if (stream_index == -2) return back_ptr; av_assert0(stream_index == -1); return pts; }<SPLIT>[-0.25365086435942685, -0.13034272285790952, 0.0, -0.2665172434374763, -0.1936866588694103, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.1509627274668249, -0.25297036047912586, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.21031383592774278, -0.26569807294376846, -0.17914063696102905, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void imdct_and_windowing(AACContext *ac, SingleChannelElement *sce) { IndividualChannelStream *ics = &sce->ics; INTFLOAT *in = sce->coeffs; INTFLOAT *out = sce->ret; INTFLOAT *saved = sce->saved; const INTFLOAT *swindow = ics->use_kb_window[0] ? AAC_RENAME(ff_aac_kbd_short_128) : AAC_RENAME(ff_sine_128); const INTFLOAT *lwindow_prev = ics->use_kb_window[1] ? AAC_RENAME(ff_aac_kbd_long_1024) : AAC_RENAME(ff_sine_1024); const INTFLOAT *swindow_prev = ics->use_kb_window[1] ? AAC_RENAME(ff_aac_kbd_short_128) : AAC_RENAME(ff_sine_128); INTFLOAT *buf = ac->buf_mdct; INTFLOAT *temp = ac->temp; int i; if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) { for (i = 0; i < 1024; i += 128) ac->mdct_small.imdct_half(&ac->mdct_small, buf + i, in + i); } else { ac->mdct.imdct_half(&ac->mdct, buf, in); #if USE_FIXED for (i=0; i<1024; i++) buf[i] = (buf[i] + 4) >> 3; #endif } if ((ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE) && (ics->window_sequence[0] == ONLY_LONG_SEQUENCE || ics->window_sequence[0] == LONG_START_SEQUENCE)) { ac->fdsp->vector_fmul_window( out, saved, buf, lwindow_prev, 512); } else { memcpy( out, saved, 448 * sizeof(*out)); if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) { ac->fdsp->vector_fmul_window(out + 448 + 0*128, saved + 448, buf + 0*128, swindow_prev, 64); ac->fdsp->vector_fmul_window(out + 448 + 1*128, buf + 0*128 + 64, buf + 1*128, swindow, 64); ac->fdsp->vector_fmul_window(out + 448 + 2*128, buf + 1*128 + 64, buf + 2*128, swindow, 64); ac->fdsp->vector_fmul_window(out + 448 + 3*128, buf + 2*128 + 64, buf + 3*128, swindow, 64); ac->fdsp->vector_fmul_window(temp, buf + 3*128 + 64, buf + 4*128, swindow, 64); memcpy( out + 448 + 4*128, temp, 64 * sizeof(*out)); } else { ac->fdsp->vector_fmul_window(out + 448, saved + 448, buf, swindow_prev, 64); memcpy( out + 576, buf + 64, 448 * sizeof(*out)); } } if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) { memcpy( saved, temp + 64, 64 * sizeof(*saved)); ac->fdsp->vector_fmul_window(saved + 64, buf + 4*128 + 64, buf + 5*128, swindow, 64); ac->fdsp->vector_fmul_window(saved + 192, buf + 5*128 + 64, buf + 6*128, swindow, 64); ac->fdsp->vector_fmul_window(saved + 320, buf + 6*128 + 64, buf + 7*128, swindow, 64); memcpy( saved + 448, buf + 7*128 + 64, 64 * sizeof(*saved)); } else if (ics->window_sequence[0] == LONG_START_SEQUENCE) { memcpy( saved, buf + 512, 448 * sizeof(*saved)); memcpy( saved + 448, buf + 7*128 + 64, 64 * sizeof(*saved)); } else { memcpy( saved, buf + 512, 512 * sizeof(*saved)); } }<SPLIT>[0.9834872346524985, 0.48668189146285495, 0.0, 0.9507312480792999, 0.40211897190143714, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, -0.27925050329511203, 0.5682770617589697, 1.0054691849094282, 0.4324044616630353, 0.0, 0.0, 0.30852482215402843, 0.4871364861795985, 0.9718292068145229, 0.35093696371323624, -0.14106852214680915, 0.13958259121676436, 0.0, 0.13403667075800713, 0.9973611507722091, 0.5355687622580682, -0.08904460951967552, -0.10760608081136262, -0.21702784222394986, -0.04111270872174079, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, -0.27935383381430245, 0.9056307075691036, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, -0.28182971586402455]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { SabContext *s = ctx->priv; close_filter_param(&s->luma); close_filter_param(&s->chroma); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int write_streaminfo(NUTContext *nut, AVIOContext *bc, int stream_id) { AVFormatContext *s= nut->avf; AVStream* st = s->streams[stream_id]; AVDictionaryEntry *t = NULL; AVIOContext *dyn_bc; uint8_t *dyn_buf=NULL; int count=0, dyn_size, i; int ret = avio_open_dyn_buf(&dyn_bc); if (ret < 0) return ret; while ((t = av_dict_get(st->metadata, "", t, AV_DICT_IGNORE_SUFFIX))) count += add_info(dyn_bc, t->key, t->value); for (i=0; ff_nut_dispositions[i].flag; ++i) { if (st->disposition & ff_nut_dispositions[i].flag) count += add_info(dyn_bc, "Disposition", ff_nut_dispositions[i].str); } if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { uint8_t buf[256]; if (st->r_frame_rate.num>0 && st->r_frame_rate.den>0) snprintf(buf, sizeof(buf), "%d/%d", st->r_frame_rate.num, st->r_frame_rate.den); else snprintf(buf, sizeof(buf), "%d/%d", st->codec->time_base.den, st->codec->time_base.num); count += add_info(dyn_bc, "r_frame_rate", buf); } dyn_size = avio_close_dyn_buf(dyn_bc, &dyn_buf); if (count) { ff_put_v(bc, stream_id + 1); ff_put_v(bc, 0); ff_put_v(bc, 0); ff_put_v(bc, 0); ff_put_v(bc, count); avio_write(bc, dyn_buf, dyn_size); } av_free(dyn_buf); return count; }<SPLIT>[-0.25365086435942685, 0.13409639756527525, 0.0, -0.2665172434374763, 0.06165861146095288, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.08878386894177331, -0.25297036047912586, 0.1588898992878544, 0.0, 0.0, 0.30852482215402843, 0.022169604774704303, -0.26569807294376846, 0.08589816337610359, 0.37651940477529405, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, 0.18424725727220465, 0.23792492798410134, 0.5697541257882794, -0.21702784222394986, -0.04111270872174079, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static int rtmp_calc_swfhash(URLContext *s) { RTMPContext *rt = s->priv_data; uint8_t *in_data = NULL, *out_data = NULL, *swfdata; int64_t in_size, out_size; URLContext *stream; char swfhash[32]; int swfsize; int ret = 0; if ((ret = ffurl_open(&stream, rt->swfverify, AVIO_FLAG_READ, &s->interrupt_callback, NULL)) < 0) { av_log(s, AV_LOG_ERROR, "Cannot open connection %s.\n", rt->swfverify); goto fail; } if ((in_size = ffurl_seek(stream, 0, AVSEEK_SIZE)) < 0) { ret = AVERROR(EIO); goto fail; } if (!(in_data = av_malloc(in_size))) { ret = AVERROR(ENOMEM); goto fail; } if ((ret = ffurl_read_complete(stream, in_data, in_size)) < 0) goto fail; if (in_size < 3) { ret = AVERROR_INVALIDDATA; goto fail; } if (!memcmp(in_data, "CWS", 3)) { if (!(out_data = av_malloc(8))) { ret = AVERROR(ENOMEM); goto fail; } *in_data = 'F'; memcpy(out_data, in_data, 8); out_size = 8; #if CONFIG_ZLIB if ((ret = rtmp_uncompress_swfplayer(in_data + 8, in_size - 8, &out_data, &out_size)) < 0) goto fail; #else av_log(s, AV_LOG_ERROR, "Zlib is required for decompressing the SWF player file.\n"); ret = AVERROR(EINVAL); goto fail; #endif swfsize = out_size; swfdata = out_data; } else { swfsize = in_size; swfdata = in_data; } if ((ret = ff_rtmp_calc_digest(swfdata, swfsize, 0, "Genuine Adobe Flash Player 001", 30, swfhash)) < 0) goto fail; av_opt_set_bin(rt, "rtmp_swfhash", swfhash, 32, 0); rt->swfsize = swfsize; fail: av_freep(&in_data); av_freep(&out_data); ffurl_close(stream); return ret; }<SPLIT>[0.36491818514653585, 0.7511210118860397, 0.0, 0.34210700232091185, 0.6574642422318003, 0.0, 0.9701672076669112, 0.9946065798247155, 0.9059316288753189, 2.3593549488603003, 0.7281081260313685, 0.3762494122151511, 0.6603332636423527, 0.0, 0.0, 0.30852482215402843, 0.6421254466478965, 0.35306556693537716, 0.5718026306608468, 1.1529012951584487, 1.3453624607183459, 0.0, 0.24428369699854227, 1.5771521192305922, 0.5707009127566546, 1.1643386175781356, 1.0213275968547075, 0.6817979554923368, 1.081736556722408, 0.969587250454179, 0.9940939011734088, 0.9053924298597907, 2.3586066116229683, 0.9056307075691036, 0.0, 0.9653245912203542, 0.9897980601469931, 0.9011791483816026, 2.352007466638268]
0<SPLIT>static void count_mantissa_bits_update_ch(AC3EncodeContext *s, int ch, uint16_t mant_cnt[AC3_MAX_BLOCKS][16], int start, int end) { int blk; for (blk = 0; blk < s->num_blocks; blk++) { AC3Block *block = &s->blocks[blk]; if (ch == CPL_CH && !block->cpl_in_use) continue; s->ac3dsp.update_bap_counts(mant_cnt[blk], s->ref_bap[ch][blk] + start, FFMIN(end, block->end_freq[ch]) - start); } }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int decode_video(InputStream *ist, AVPacket *pkt, int *got_output, int eof, int *decode_failed) { AVFrame *decoded_frame; int i, ret = 0, err = 0; int64_t best_effort_timestamp; int64_t dts = AV_NOPTS_VALUE; AVPacket avpkt; if (!eof && pkt && pkt->size == 0) return 0; if (!ist->decoded_frame && !(ist->decoded_frame = av_frame_alloc())) return AVERROR(ENOMEM); if (!ist->filter_frame && !(ist->filter_frame = av_frame_alloc())) return AVERROR(ENOMEM); decoded_frame = ist->decoded_frame; if (ist->dts != AV_NOPTS_VALUE) dts = av_rescale_q(ist->dts, AV_TIME_BASE_Q, ist->st->time_base); if (pkt) { avpkt = *pkt; avpkt.dts = dts; } if (eof) { void *new = av_realloc_array(ist->dts_buffer, ist->nb_dts_buffer + 1, sizeof(ist->dts_buffer[0])); if (!new) return AVERROR(ENOMEM); ist->dts_buffer = new; ist->dts_buffer[ist->nb_dts_buffer++] = dts; } update_benchmark(NULL); ret = decode(ist->dec_ctx, decoded_frame, got_output, pkt ? &avpkt : NULL); update_benchmark("decode_video %d.%d", ist->file_index, ist->st->index); if (ret < 0) *decode_failed = 1; if (ist->st->codecpar->video_delay < ist->dec_ctx->has_b_frames) { if (ist->dec_ctx->codec_id == AV_CODEC_ID_H264) { ist->st->codecpar->video_delay = ist->dec_ctx->has_b_frames; } else av_log(ist->dec_ctx, AV_LOG_WARNING, "video_delay is larger in decoder than demuxer %d > %d.\n" "If you want to help, upload a sample " "of this file to ftp: "and contact the ffmpeg-devel mailing list. (ffmpeg-devel@ffmpeg.org)\n", ist->dec_ctx->has_b_frames, ist->st->codecpar->video_delay); } if (ret != AVERROR_EOF) check_decode_result(ist, got_output, ret); if (*got_output && ret >= 0) { if (ist->dec_ctx->width != decoded_frame->width || ist->dec_ctx->height != decoded_frame->height || ist->dec_ctx->pix_fmt != decoded_frame->format) { av_log(NULL, AV_LOG_DEBUG, "Frame parameters mismatch context %d,%d,%d != %d,%d,%d\n", decoded_frame->width, decoded_frame->height, decoded_frame->format, ist->dec_ctx->width, ist->dec_ctx->height, ist->dec_ctx->pix_fmt); } } if (!*got_output || ret < 0) return ret; if(ist->top_field_first>=0) decoded_frame->top_field_first = ist->top_field_first; ist->frames_decoded++; if (ist->hwaccel_retrieve_data && decoded_frame->format == ist->hwaccel_pix_fmt) { err = ist->hwaccel_retrieve_data(ist->dec_ctx, decoded_frame); if (err < 0) goto fail; } ist->hwaccel_retrieved_pix_fmt = decoded_frame->format; best_effort_timestamp= av_frame_get_best_effort_timestamp(decoded_frame); if (ist->framerate.num) best_effort_timestamp = ist->cfr_next_pts++; if (eof && best_effort_timestamp == AV_NOPTS_VALUE && ist->nb_dts_buffer > 0) { best_effort_timestamp = ist->dts_buffer[0]; for (i = 0; i < ist->nb_dts_buffer - 1; i++) ist->dts_buffer[i] = ist->dts_buffer[i + 1]; ist->nb_dts_buffer--; } if(best_effort_timestamp != AV_NOPTS_VALUE) { int64_t ts = av_rescale_q(decoded_frame->pts = best_effort_timestamp, ist->st->time_base, AV_TIME_BASE_Q); if (ts != AV_NOPTS_VALUE) ist->next_pts = ist->pts = ts; } if (debug_ts) { av_log(NULL, AV_LOG_INFO, "decoder -> ist_index:%d type:video " "frame_pts:%s frame_pts_time:%s best_effort_ts:%"PRId64" best_effort_ts_time:%s keyframe:%d frame_type:%d time_base:%d/%d\n", ist->st->index, av_ts2str(decoded_frame->pts), av_ts2timestr(decoded_frame->pts, &ist->st->time_base), best_effort_timestamp, av_ts2timestr(best_effort_timestamp, &ist->st->time_base), decoded_frame->key_frame, decoded_frame->pict_type, ist->st->time_base.num, ist->st->time_base.den); } if (ist->st->sample_aspect_ratio.num) decoded_frame->sample_aspect_ratio = ist->st->sample_aspect_ratio; err = send_frame_to_filters(ist, decoded_frame); fail: av_frame_unref(ist->filter_frame); av_frame_unref(decoded_frame); return err < 0 ? err : ret; }<SPLIT>[0.8288449722760078, 1.6105481532613901, 0.0, 0.798575186639703, 1.4873363708054808, 0.0, 2.186719866463698, 2.2318098511651505, 2.3985095078349254, 1.040052222782594, 1.5672212134614623, 0.8481642417358589, 1.6860128725492811, 0.0, 0.0, 0.30852482215402843, 1.4558174891064615, 0.8171382968447365, 1.5656981319250942, 0.8941073316973973, 0.9068970536268617, 0.0, -0.08645738172306322, -0.16222078614455715, 0.8868902672439317, 1.327823386330024, 1.0213275968547075, 1.5806237532086234, 1.2688781009630994, 2.185828383526772, 2.231040724738188, 2.3976031672339286, 1.039626388904333, 0.9056307075691036, 0.0, 2.180032226976431, 2.225208820917496, 2.391416275924293, 1.0350888753871217]
0<SPLIT>static av_cold int init(AVFilterContext *ctx) { TileContext *tile = ctx->priv; if (tile->w > REASONABLE_SIZE || tile->h > REASONABLE_SIZE) { av_log(ctx, AV_LOG_ERROR, "Tile size %ux%u is insane.\n", tile->w, tile->h); return AVERROR(EINVAL); } if (tile->nb_frames == 0) { tile->nb_frames = tile->w * tile->h; } else if (tile->nb_frames > tile->w * tile->h) { av_log(ctx, AV_LOG_ERROR, "nb_frames must be less than or equal to %dx%d=%d\n", tile->w, tile->h, tile->w * tile->h); return AVERROR(EINVAL); } return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>int av_hmac_calc(AVHMAC *c, const uint8_t *data, unsigned int len, const uint8_t *key, unsigned int keylen, uint8_t *out, unsigned int outlen) { av_hmac_init(c, key, keylen); av_hmac_update(c, data, len); return av_hmac_final(c, out, outlen); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.14106852214680915, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int get_private_data(struct Track *track, AVCodecContext *codec) { track->codec_private_size = 0; track->codec_private = av_mallocz(codec->extradata_size); if (!track->codec_private) return AVERROR(ENOMEM); track->codec_private_size = codec->extradata_size; memcpy(track->codec_private, codec->extradata, codec->extradata_size); return 0; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int build_filter(ResampleContext *c, double factor) { int ph, i; double x, y, w; double *tab; int tap_count = c->filter_length; int phase_count = 1 << c->phase_shift; const int center = (tap_count - 1) / 2; tab = av_malloc(tap_count * sizeof(*tab)); if (!tab) return AVERROR(ENOMEM); for (ph = 0; ph < phase_count; ph++) { double norm = 0; for (i = 0; i < tap_count; i++) { x = M_PI * ((double)(i - center) - (double)ph / phase_count) * factor; if (x == 0) y = 1.0; else y = sin(x) / x; switch (c->filter_type) { case AV_RESAMPLE_FILTER_TYPE_CUBIC: { const float d = -0.5; x = fabs(((double)(i - center) - (double)ph / phase_count) * factor); if (x < 1.0) y = 1 - 3 * x*x + 2 * x*x*x + d * ( -x*x + x*x*x); else y = d * (-4 + 8 * x - 5 * x*x + x*x*x); break; } case AV_RESAMPLE_FILTER_TYPE_BLACKMAN_NUTTALL: w = 2.0 * x / (factor * tap_count) + M_PI; y *= 0.3635819 - 0.4891775 * cos( w) + 0.1365995 * cos(2 * w) - 0.0106411 * cos(3 * w); break; case AV_RESAMPLE_FILTER_TYPE_KAISER: w = 2.0 * x / (factor * tap_count * M_PI); y *= bessel(c->kaiser_beta * sqrt(FFMAX(1 - w * w, 0))); break; } tab[i] = y; norm += y; } for (i = 0; i < tap_count; i++) tab[i] = tab[i] / norm; c->set_filter(c->filter_bank, tab, ph, tap_count); } av_free(tab); return 0; }<SPLIT>[-0.09900860198293619, 0.35446233125126253, 0.0, -0.11436118199787926, 0.2744463367362555, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 0.3085515823163217, -0.09566541730555662, 0.3868187012671718, 0.0, 0.0, 0.30852482215402843, 0.23527942541861413, -0.11100716297398205, 0.3067638303237141, 1.1529012951584487, 0.9068970536268617, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5355687622580682, 1.3823183092473201, 1.4729010679211356, -0.21702784222394986, 1.1753073288427536, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 1.7623686513065309, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static int mxf_probe(AVProbeData *p) { const uint8_t *bufp = p->buf; const uint8_t *end = p->buf + p->buf_size; if (p->buf_size < sizeof(mxf_header_partition_pack_key)) return 0; end -= sizeof(mxf_header_partition_pack_key); for (; bufp < end;) { if (!((bufp[13] - 1) & 0xF2)){ if (AV_RN32(bufp ) == AV_RN32(mxf_header_partition_pack_key ) && AV_RN32(bufp+ 4) == AV_RN32(mxf_header_partition_pack_key+ 4) && AV_RN32(bufp+ 8) == AV_RN32(mxf_header_partition_pack_key+ 8) && AV_RN16(bufp+12) == AV_RN16(mxf_header_partition_pack_key+12)) return AVPROBE_SCORE_MAX; bufp ++; } else bufp += 10; } return 0; }<SPLIT>[-0.09900860198293619, -0.24052568970090316, 0.0, -0.11436118199787926, -0.30008052150706166, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.2308782596030243, -0.09566541730555662, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.11100716297398205, -0.28957347043483433, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.3070243011888601, -0.3333928163445767, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static long int read_seek_range(const char *string_with_number) { long int number; char *end_of_string = NULL; number = strtol(string_with_number, &end_of_string, 10); if ((strlen(string_with_number) != end_of_string - string_with_number) || (number < 0)) { av_log(NULL, AV_LOG_ERROR, "Incorrect input ranges of seeking\n"); return -1; } else if ((number == LONG_MAX) || (number == LONG_MIN)) { if (errno == ERANGE) { av_log(NULL, AV_LOG_ERROR, "Incorrect input ranges of seeking\n"); return -1; } } return number; }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.14106852214680915, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.08904460951967552, -0.22049944857796966, -0.21702784222394986, 0.05245806339860493, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>av_cold void ff_get_unscaled_swscale_ppc(SwsContext *c) { #if HAVE_ALTIVEC if (!(av_get_cpu_flags() & AV_CPU_FLAG_ALTIVEC)) return; if (!(c->srcW & 15) && !(c->flags & SWS_BITEXACT) && c->srcFormat == AV_PIX_FMT_YUV420P) { enum AVPixelFormat dstFormat = c->dstFormat; if (dstFormat == AV_PIX_FMT_YUYV422) c->swscale = yv12toyuy2_unscaled_altivec; else if (dstFormat == AV_PIX_FMT_UYVY422) c->swscale = yv12touyvy_unscaled_altivec; } #endif }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.11436118199787926, -0.3851956116171827, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.36530279639604085, -0.26569807294376846, -0.6429585375510112, -0.917450412529964, -0.518115519420462, 0.0, 1.1262599069228236, 0.9973611507722091, -0.5535279031981089, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static av_cold int bktr_init(const char *video_device, int width, int height, int format, int *video_fd, int *tuner_fd, int idev, double frequency) { struct meteor_geomet geo; int h_max; long ioctl_frequency; char *arg; int c; struct sigaction act = { {0} }, old; int ret; char errbuf[128]; if (idev < 0 || idev > 4) { arg = getenv ("BKTR_DEV"); if (arg) idev = atoi (arg); if (idev < 0 || idev > 4) idev = 1; } if (format < 1 || format > 6) { arg = getenv ("BKTR_FORMAT"); if (arg) format = atoi (arg); if (format < 1 || format > 6) format = VIDEO_FORMAT; } if (frequency <= 0) { arg = getenv ("BKTR_FREQUENCY"); if (arg) frequency = atof (arg); if (frequency <= 0) frequency = 0.0; } sigemptyset(&act.sa_mask); act.sa_handler = catchsignal; sigaction(SIGUSR1, &act, &old); *tuner_fd = avpriv_open("/dev/tuner0", O_RDONLY); if (*tuner_fd < 0) av_log(NULL, AV_LOG_ERROR, "Warning. Tuner not opened, continuing: %s\n", strerror(errno)); *video_fd = avpriv_open(video_device, O_RDONLY); if (*video_fd < 0) { ret = AVERROR(errno); av_strerror(ret, errbuf, sizeof(errbuf)); av_log(NULL, AV_LOG_ERROR, "%s: %s\n", video_device, errbuf); return ret; } geo.rows = height; geo.columns = width; geo.frames = 1; geo.oformat = METEOR_GEO_YUV_422 | METEOR_GEO_YUV_12; switch (format) { case PAL: h_max = PAL_HEIGHT; c = BT848_IFORM_F_PALBDGHI; break; case PALN: h_max = PAL_HEIGHT; c = BT848_IFORM_F_PALN; break; case PALM: h_max = PAL_HEIGHT; c = BT848_IFORM_F_PALM; break; case SECAM: h_max = SECAM_HEIGHT; c = BT848_IFORM_F_SECAM; break; case NTSC: h_max = NTSC_HEIGHT; c = BT848_IFORM_F_NTSCM; break; case NTSCJ: h_max = NTSC_HEIGHT; c = BT848_IFORM_F_NTSCJ; break; default: h_max = PAL_HEIGHT; c = BT848_IFORM_F_PALBDGHI; break; } if (height <= h_max / 2) geo.oformat |= METEOR_GEO_EVEN_ONLY; if (ioctl(*video_fd, METEORSETGEO, &geo) < 0) { ret = AVERROR(errno); av_strerror(ret, errbuf, sizeof(errbuf)); av_log(NULL, AV_LOG_ERROR, "METEORSETGEO: %s\n", errbuf); return ret; } if (ioctl(*video_fd, BT848SFMT, &c) < 0) { ret = AVERROR(errno); av_strerror(ret, errbuf, sizeof(errbuf)); av_log(NULL, AV_LOG_ERROR, "BT848SFMT: %s\n", errbuf); return ret; } c = bktr_dev[idev]; if (ioctl(*video_fd, METEORSINPUT, &c) < 0) { ret = AVERROR(errno); av_strerror(ret, errbuf, sizeof(errbuf)); av_log(NULL, AV_LOG_ERROR, "METEORSINPUT: %s\n", errbuf); return ret; } video_buf_size = width * height * 12 / 8; video_buf = (uint8_t *)mmap((caddr_t)0, video_buf_size, PROT_READ, MAP_SHARED, *video_fd, (off_t)0); if (video_buf == MAP_FAILED) { ret = AVERROR(errno); av_strerror(ret, errbuf, sizeof(errbuf)); av_log(NULL, AV_LOG_ERROR, "mmap: %s\n", errbuf); return ret; } if (frequency != 0.0) { ioctl_frequency = (unsigned long)(frequency*16); if (ioctl(*tuner_fd, TVTUNER_SETFREQ, &ioctl_frequency) < 0) av_log(NULL, AV_LOG_ERROR, "TVTUNER_SETFREQ: %s\n", strerror(errno)); } c = AUDIO_UNMUTE; if (ioctl(*tuner_fd, BT848_SAUDIO, &c) < 0) av_log(NULL, AV_LOG_ERROR, "TVTUNER_SAUDIO: %s\n", strerror(errno)); c = METEOR_CAP_CONTINOUS; ioctl(*video_fd, METEORCAPTUR, &c); c = SIGUSR1; ioctl(*video_fd, METEORSSIGNAL, &c); return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, 1.5298939158605411, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 1.3589493888137751, -0.26569807294376846, 1.6098712653146163, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 2.1516476851930406, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static av_cold int write_header(AVFormatContext *s1) { int res = 0, flags = O_RDWR; struct v4l2_format fmt = { .type = V4L2_BUF_TYPE_VIDEO_OUTPUT }; V4L2Context *s = s1->priv_data; AVCodecContext *enc_ctx; uint32_t v4l2_pixfmt; if (s1->flags & AVFMT_FLAG_NONBLOCK) flags |= O_NONBLOCK; s->fd = open(s1->filename, flags); if (s->fd < 0) { res = AVERROR(errno); av_log(s1, AV_LOG_ERROR, "Unable to open V4L2 device '%s'\n", s1->filename); return res; } if (s1->nb_streams != 1 || s1->streams[0]->codec->codec_type != AVMEDIA_TYPE_VIDEO || s1->streams[0]->codec->codec_id != AV_CODEC_ID_RAWVIDEO) { av_log(s1, AV_LOG_ERROR, "V4L2 output device supports only a single raw video stream\n"); return AVERROR(EINVAL); } enc_ctx = s1->streams[0]->codec; v4l2_pixfmt = ff_fmt_ff2v4l(enc_ctx->pix_fmt, AV_CODEC_ID_RAWVIDEO); if (!v4l2_pixfmt) { av_log(s1, AV_LOG_ERROR, "Unknown V4L2 pixel format equivalent for %s\n", av_get_pix_fmt_name(enc_ctx->pix_fmt)); return AVERROR(EINVAL); } if (ioctl(s->fd, VIDIOC_G_FMT, &fmt) < 0) { res = AVERROR(errno); av_log(s1, AV_LOG_ERROR, "ioctl(VIDIOC_G_FMT): %s\n", av_err2str(res)); return res; } fmt.fmt.pix.width = enc_ctx->width; fmt.fmt.pix.height = enc_ctx->height; fmt.fmt.pix.pixelformat = v4l2_pixfmt; fmt.fmt.pix.sizeimage = av_image_get_buffer_size(enc_ctx->pix_fmt, enc_ctx->width, enc_ctx->height, 1); if (ioctl(s->fd, VIDIOC_S_FMT, &fmt) < 0) { res = AVERROR(errno); av_log(s1, AV_LOG_ERROR, "ioctl(VIDIOC_S_FMT): %s\n", av_err2str(res)); return res; } return res; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, 0.2957251092637858, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.23527942541861413, -0.26569807294376846, 0.3288503970184752, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2545115582693773, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void ripemd320_transform(uint32_t *state, const uint8_t buffer[64]) { uint32_t a, b, c, d, e, f, g, h, i, j, av_unused t; uint32_t block[16]; int n; a = state[0]; b = state[1]; c = state[2]; d = state[3]; e = state[4]; f = state[5]; g = state[6]; h = state[7]; i = state[8]; j = state[9]; for (n = 0; n < 16; n++) block[n] = AV_RL32(buffer + 4 * n); n = 0; #if CONFIG_SMALL for (; n < 16;) { ROUND160_0_TO_15(a,b,c,d,e,f,g,h,i,j); t = e; e = d; d = c; c = b; b = a; a = t; t = j; j = i; i = h; h = g; g = f; f = t; } FFSWAP(uint32_t, b, g); for (; n < 32;) { ROUND160_16_TO_31(a,b,c,d,e,f,g,h,i,j); t = e; e = d; d = c; c = b; b = a; a = t; t = j; j = i; i = h; h = g; g = f; f = t; } FFSWAP(uint32_t, d, i); for (; n < 48;) { ROUND160_32_TO_47(a,b,c,d,e,f,g,h,i,j); t = e; e = d; d = c; c = b; b = a; a = t; t = j; j = i; i = h; h = g; g = f; f = t; } FFSWAP(uint32_t, a, f); for (; n < 64;) { ROUND160_48_TO_63(a,b,c,d,e,f,g,h,i,j); t = e; e = d; d = c; c = b; b = a; a = t; t = j; j = i; i = h; h = g; g = f; f = t; } FFSWAP(uint32_t, c, h); for (; n < 80;) { ROUND160_64_TO_79(a,b,c,d,e,f,g,h,i,j); t = e; e = d; d = c; c = b; b = a; a = t; t = j; j = i; i = h; h = g; g = f; f = t; } FFSWAP(uint32_t, e, j); #else R160_0; R160_0; R160_0; ROUND160_0_TO_15(a,b,c,d,e,f,g,h,i,j); FFSWAP(uint32_t, a, f); R160_16; R160_16; R160_16; ROUND160_16_TO_31(e,a,b,c,d,j,f,g,h,i); FFSWAP(uint32_t, b, g); R160_32; R160_32; R160_32; ROUND160_32_TO_47(d,e,a,b,c,i,j,f,g,h); FFSWAP(uint32_t, c, h); R160_48; R160_48; R160_48; ROUND160_48_TO_63(c,d,e,a,b,h,i,j,f,g); FFSWAP(uint32_t, d, i); R160_64; R160_64; R160_64; ROUND160_64_TO_79(b,c,d,e,a,g,h,i,j,f); FFSWAP(uint32_t, e, j); #endif state[0] += a; state[1] += b; state[2] += c; state[3] += d; state[4] += e; state[5] += f; state[6] += g; state[7] += h; state[8] += i; state[9] += j; }<SPLIT>[-0.25365086435942685, 0.6850112317802435, 0.0, -0.2665172434374763, 0.5936279246492095, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.5882559447930196, -0.25297036047912586, -0.023453142295599506, 0.0, 0.0, 0.30852482215402843, 0.5065101062381357, -0.26569807294376846, -0.09079437018198484, 0.24712242304476825, -0.4084991676475909, 0.0, 3.2209534054929914, 1.5771521192305922, 3.9433873606209446, -0.1980344553542678, 0.11818065472185141, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int sdl_write_header(AVFormatContext *s) { SDLContext *sdl = s->priv_data; AVStream *st = s->streams[0]; AVCodecContext *encctx = st->codec; int i, ret; if (!sdl->window_title) sdl->window_title = av_strdup(s->filename); if (!sdl->icon_title) sdl->icon_title = av_strdup(sdl->window_title); if (SDL_WasInit(SDL_INIT_VIDEO)) { av_log(s, AV_LOG_ERROR, "SDL video subsystem was already inited, aborting\n"); sdl->sdl_was_already_inited = 1; ret = AVERROR(EINVAL); goto fail; } if ( s->nb_streams > 1 || encctx->codec_type != AVMEDIA_TYPE_VIDEO || encctx->codec_id != AV_CODEC_ID_RAWVIDEO) { av_log(s, AV_LOG_ERROR, "Only supports one rawvideo stream\n"); ret = AVERROR(EINVAL); goto fail; } for (i = 0; sdl_overlay_pix_fmt_map[i].pix_fmt != AV_PIX_FMT_NONE; i++) { if (sdl_overlay_pix_fmt_map[i].pix_fmt == encctx->pix_fmt) { sdl->overlay_fmt = sdl_overlay_pix_fmt_map[i].overlay_fmt; break; } } if (!sdl->overlay_fmt) { av_log(s, AV_LOG_ERROR, "Unsupported pixel format '%s', choose one of yuv420p, yuyv422, or uyvy422\n", av_get_pix_fmt_name(encctx->pix_fmt)); ret = AVERROR(EINVAL); goto fail; } compute_overlay_rect(s); sdl->init_cond = SDL_CreateCond(); if (!sdl->init_cond) { av_log(s, AV_LOG_ERROR, "Could not create SDL condition variable: %s\n", SDL_GetError()); ret = AVERROR_EXTERNAL; goto fail; } sdl->mutex = SDL_CreateMutex(); if (!sdl->mutex) { av_log(s, AV_LOG_ERROR, "Could not create SDL mutex: %s\n", SDL_GetError()); ret = AVERROR_EXTERNAL; goto fail; } sdl->event_thread = SDL_CreateThread(event_thread, s); if (!sdl->event_thread) { av_log(s, AV_LOG_ERROR, "Could not create SDL event thread: %s\n", SDL_GetError()); ret = AVERROR_EXTERNAL; goto fail; } SDL_LockMutex(sdl->mutex); while (!sdl->inited) { SDL_CondWait(sdl->init_cond, sdl->mutex); } SDL_UnlockMutex(sdl->mutex); if (sdl->init_ret < 0) { ret = sdl->init_ret; goto fail; } return 0; fail: sdl_write_trailer(s); return ret; }<SPLIT>[0.05563366039355449, 0.8833405720976321, 0.0, 0.037794879441717756, 0.7851368773969819, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, 2.0295292673408736, 0.8080236581675679, 0.061639525868012635, 0.9338478260175336, 0.0, 0.0, 0.30852482215402843, 0.7196199268820456, 0.04368374699580437, 0.8368414309979795, 1.1529012951584487, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, 0.7463616652495864, 1.1643386175781356, 1.1342209646213146, 0.6817979554923368, 0.9881657846020622, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, 2.0288615559433096, 0.04889276383167627, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 2.0227778188254817]
0<SPLIT>static int parse_synth_channel_bell(struct sbg_parser *p, struct sbg_script_synth *synth) { double carrierf; int carrier, vol; if (!lex_fixed(p, "bell", 4)) return 0; if (!lex_double(p, &carrierf)) return AVERROR_INVALIDDATA; FORWARD_ERROR(parse_volume(p, &vol)); if (scale_double(p->log, carrierf, 1, &carrier) < 0) return AVERROR(EDOM); synth->type = SBG_TYPE_BELL; synth->carrier = carrier; synth->vol = vol; return 1; }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, 0.24712242304476825, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, 0.12893508214950905, 0.4568607580216725, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int config_input_main(AVFilterLink *inlink) { AlphaMergeContext *merge = inlink->dst->priv; merge->is_packed_rgb = ff_fill_rgba_map(merge->rgba_map, inlink->format) >= 0; return 0; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int request_frame(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; TileContext *tile = ctx->priv; AVFilterLink *inlink = ctx->inputs[0]; int r; r = ff_request_frame(inlink); if (r == AVERROR_EOF && tile->current) r = end_last_frame(ctx); return r; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void uninit_parse_context(OptionParseContext *octx) { int i, j; for (i = 0; i < octx->nb_groups; i++) { OptionGroupList *l = &octx->groups[i]; for (j = 0; j < l->nb_groups; j++) { av_freep(&l->groups[j].opts); av_dict_free(&l->groups[j].codec_opts); av_dict_free(&l->groups[j].format_opts); av_dict_free(&l->groups[j].resample_opts); av_dict_free(&l->groups[j].sws_dict); av_dict_free(&l->groups[j].swr_opts); } av_freep(&l->groups); } av_freep(&octx->groups); av_freep(&octx->cur_group.opts); av_freep(&octx->global_opts.opts); uninit_opts(); }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.3615192241061562, -0.22049944857796966, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int mov_flush_fragment_interleaving(AVFormatContext *s, MOVTrack *track) { MOVMuxContext *mov = s->priv_data; int ret, buf_size; uint8_t *buf; int i, offset; if (!track->mdat_buf) return 0; if (!mov->mdat_buf) { if ((ret = avio_open_dyn_buf(&mov->mdat_buf)) < 0) return ret; } buf_size = avio_close_dyn_buf(track->mdat_buf, &buf); track->mdat_buf = NULL; offset = avio_tell(mov->mdat_buf); avio_write(mov->mdat_buf, buf, buf_size); av_free(buf); for (i = track->entries_flushed; i < track->entry; i++) track->cluster[i].pos += offset; track->entries_flushed = track->entry; return 0; }<SPLIT>[-0.25365086435942685, -0.17441590959510697, 0.0, -0.2665172434374763, -0.23624420392447085, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, -0.1909204935349246, -0.25297036047912586, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.26569807294376846, -0.22331377035055117, 0.11772544131424245, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, 0.12893508214950905, 0.23107402248845843, -0.21702784222394986, 0.05245806339860493, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static void fixstride(AVFilterLink *link, AVFrame *f) { AVFrame *dst = ff_default_get_video_buffer(link, f->width, f->height); if(!dst) return; av_frame_copy_props(dst, f); av_image_copy(dst->data, dst->linesize, (const uint8_t **)f->data, f->linesize, dst->format, dst->width, dst->height); av_frame_unref(f); av_frame_move_ref(f, dst); av_frame_free(&dst); }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.011671540416283347, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.25252937827156396, -0.10760608081136262, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int create_sink(Stream *st, AVFilterGraph *graph, AVFilterContext *f, int idx) { enum AVMediaType type = avfilter_pad_get_type(f->output_pads, idx); const char *sink_name; int ret; switch (type) { case AVMEDIA_TYPE_VIDEO: sink_name = "buffersink"; break; case AVMEDIA_TYPE_AUDIO: sink_name = "abuffersink"; break; default: av_log(NULL, AV_LOG_ERROR, "Stream type not supported\n"); return AVERROR(EINVAL); } ret = avfilter_graph_create_filter(&st->sink, avfilter_get_by_name(sink_name), NULL, NULL, NULL, graph); if (ret < 0) return ret; ret = avfilter_link(f, idx, st->sink, 0); if (ret < 0) return ret; st->link = st->sink->inputs[0]; return 0; }<SPLIT>[-0.25365086435942685, -0.13034272285790952, 0.0, -0.2665172434374763, -0.1936866588694103, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.1509627274668249, -0.25297036047912586, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.21031383592774278, -0.26569807294376846, -0.17914063696102905, 0.37651940477529405, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, 0.5103995425705821, 0.34396739025506545, 0.6817979554923368, 0.5203119240003335, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static void init_idct(void) { int i, j; for (i = 0; i < 8; i++) { double s = i == 0 ? sqrt(0.125) : 0.5; for (j = 0; j < 8; j++) c[i*8+j] = s*cos((M_PI/8.0)*i*(j+0.5)); } }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.1980344553542678, -0.10760608081136262, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>void ffserver_free_child_args(void *argsp) { int i; char **args; if (!argsp) return; args = *(char ***)argsp; if (!args) return; for (i = 0; i < MAX_CHILD_ARGS; i++) av_free(args[i]); av_freep(argsp); }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.270465503877335, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.14353953243697165, -0.3333928163445767, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int decode_packet(int *got_frame, int cached) { int ret = 0; int decoded = pkt.size; *got_frame = 0; if (pkt.stream_index == video_stream_idx) { ret = avcodec_decode_video2(video_dec_ctx, frame, got_frame, &pkt); if (ret < 0) { fprintf(stderr, "Error decoding video frame (%s)\n", av_err2str(ret)); return ret; } if (*got_frame) { if (frame->width != width || frame->height != height || frame->format != pix_fmt) { fprintf(stderr, "Error: Width, height and pixel format have to be " "constant in a rawvideo file, but the width, height or " "pixel format of the input video changed:\n" "old: width = %d, height = %d, format = %s\n" "new: width = %d, height = %d, format = %s\n", width, height, av_get_pix_fmt_name(pix_fmt), frame->width, frame->height, av_get_pix_fmt_name(frame->format)); return -1; } printf("video_frame%s n:%d coded_n:%d pts:%s\n", cached ? "(cached)" : "", video_frame_count++, frame->coded_picture_number, av_ts2timestr(frame->pts, &video_dec_ctx->time_base)); av_image_copy(video_dst_data, video_dst_linesize, (const uint8_t **)(frame->data), frame->linesize, pix_fmt, width, height); fwrite(video_dst_data[0], 1, video_dst_bufsize, video_dst_file); } } else if (pkt.stream_index == audio_stream_idx) { ret = avcodec_decode_audio4(audio_dec_ctx, frame, got_frame, &pkt); if (ret < 0) { fprintf(stderr, "Error decoding audio frame (%s)\n", av_err2str(ret)); return ret; } decoded = FFMIN(ret, pkt.size); if (*got_frame) { size_t unpadded_linesize = frame->nb_samples * av_get_bytes_per_sample(frame->format); printf("audio_frame%s n:%d nb_samples:%d pts:%s\n", cached ? "(cached)" : "", audio_frame_count++, frame->nb_samples, av_ts2timestr(frame->pts, &audio_dec_ctx->time_base)); fwrite(frame->extended_data[0], 1, unpadded_linesize, audio_dst_file); } } if (*got_frame && api_mode == API_MODE_NEW_API_REF_COUNT) av_frame_unref(frame); return decoded; }<SPLIT>[2.9938366455468772, 0.5087184848314537, 0.0, 2.9287600467940615, 0.4446765169564977, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, 1.699703585821447, 0.8479814242356677, 3.0504334461658287, 0.546368862652694, 0.0, 0.0, 0.30852482215402843, 0.7777407870576574, 2.9828110364217464, 0.4834563638818026, 1.0235043134279231, 0.6876643500811196, 0.0, -0.08645738172306322, -0.16222078614455715, 0.043718655277859224, 0.7828741571570628, 1.0213275968547075, -0.21702784222394986, 0.5203119240003335, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, 1.6991165002636506, 1.7623686513065309, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 1.693548171012695]
0<SPLIT>static void init_rtp_handler(RTPDynamicProtocolHandler *handler, RTSPStream *rtsp_st, AVStream *st) { AVCodecContext *codec = st ? st->codec : NULL; if (!handler) return; if (codec) codec->codec_id = handler->codec_id; rtsp_st->dynamic_handler = handler; if (st) st->need_parsing = handler->need_parsing; if (handler->priv_data_size) { rtsp_st->dynamic_protocol_context = av_mallocz(handler->priv_data_size); if (!rtsp_st->dynamic_protocol_context) rtsp_st->dynamic_handler = NULL; } }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.4705090699407485, -0.6720729196443977, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>const AVOption *av_set_q(void *obj, const char *name, AVRational n) { const AVOption *o = av_opt_find(obj, name, NULL, 0, 0); if (set_number(obj, name, n.num, n.den, 1, 0) < 0) return NULL; return o; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int mov_write_tapt_tag(AVIOContext *pb, MOVTrack *track) { int32_t width = av_rescale(track->enc->sample_aspect_ratio.num, track->enc->width, track->enc->sample_aspect_ratio.den); int64_t pos = avio_tell(pb); avio_wb32(pb, 0); ffio_wfourcc(pb, "tapt"); avio_wb32(pb, 20); ffio_wfourcc(pb, "clef"); avio_wb32(pb, 0); avio_wb32(pb, width << 16); avio_wb32(pb, track->enc->height << 16); avio_wb32(pb, 20); ffio_wfourcc(pb, "prof"); avio_wb32(pb, 0); avio_wb32(pb, width << 16); avio_wb32(pb, track->enc->height << 16); avio_wb32(pb, 20); ffio_wfourcc(pb, "enof"); avio_wb32(pb, 0); avio_wb32(pb, track->enc->width << 16); avio_wb32(pb, track->enc->height << 16); return update_size(pb, pos); }<SPLIT>[-0.25365086435942685, -0.13034272285790952, 0.0, -0.2665172434374763, -0.1936866588694103, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.1509627274668249, -0.25297036047912586, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.21031383592774278, -0.26569807294376846, -0.17914063696102905, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static const OptionDef *find_option(const OptionDef *po, const char *name) { const char *p = strchr(name, ':'); int len = p ? p - name : strlen(name); while (po->name) { if (!strncmp(name, po->name, len) && strlen(po->name) == len) break; po++; } return po; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, -0.8078451799057511, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_cold void RENAME(sws_init_swscale)(SwsContext *c) { enum AVPixelFormat dstFormat = c->dstFormat; c->use_mmx_vfilter= 0; if (!is16BPS(dstFormat) && !is9_OR_10BPS(dstFormat) && dstFormat != AV_PIX_FMT_NV12 && dstFormat != AV_PIX_FMT_NV21 && !(c->flags & SWS_BITEXACT)) { if (c->flags & SWS_ACCURATE_RND) { if (!(c->flags & SWS_FULL_CHR_H_INT)) { switch (c->dstFormat) { case AV_PIX_FMT_RGB32: c->yuv2packedX = RENAME(yuv2rgb32_X_ar); break; #if HAVE_6REGS case AV_PIX_FMT_BGR24: c->yuv2packedX = RENAME(yuv2bgr24_X_ar); break; #endif case AV_PIX_FMT_RGB555: c->yuv2packedX = RENAME(yuv2rgb555_X_ar); break; case AV_PIX_FMT_RGB565: c->yuv2packedX = RENAME(yuv2rgb565_X_ar); break; case AV_PIX_FMT_YUYV422: c->yuv2packedX = RENAME(yuv2yuyv422_X_ar); break; default: break; } } } else { c->use_mmx_vfilter= 1; c->yuv2planeX = RENAME(yuv2yuvX ); if (!(c->flags & SWS_FULL_CHR_H_INT)) { switch (c->dstFormat) { case AV_PIX_FMT_RGB32: c->yuv2packedX = RENAME(yuv2rgb32_X); break; case AV_PIX_FMT_BGR32: c->yuv2packedX = RENAME(yuv2bgr32_X); break; #if HAVE_6REGS case AV_PIX_FMT_BGR24: c->yuv2packedX = RENAME(yuv2bgr24_X); break; #endif case AV_PIX_FMT_RGB555: c->yuv2packedX = RENAME(yuv2rgb555_X); break; case AV_PIX_FMT_RGB565: c->yuv2packedX = RENAME(yuv2rgb565_X); break; case AV_PIX_FMT_YUYV422: c->yuv2packedX = RENAME(yuv2yuyv422_X); break; default: break; } } } if (!(c->flags & SWS_FULL_CHR_H_INT)) { switch (c->dstFormat) { case AV_PIX_FMT_RGB32: c->yuv2packed1 = RENAME(yuv2rgb32_1); c->yuv2packed2 = RENAME(yuv2rgb32_2); break; case AV_PIX_FMT_BGR24: c->yuv2packed1 = RENAME(yuv2bgr24_1); c->yuv2packed2 = RENAME(yuv2bgr24_2); break; case AV_PIX_FMT_RGB555: c->yuv2packed1 = RENAME(yuv2rgb555_1); c->yuv2packed2 = RENAME(yuv2rgb555_2); break; case AV_PIX_FMT_RGB565: c->yuv2packed1 = RENAME(yuv2rgb565_1); c->yuv2packed2 = RENAME(yuv2rgb565_2); break; case AV_PIX_FMT_YUYV422: c->yuv2packed1 = RENAME(yuv2yuyv422_1); c->yuv2packed2 = RENAME(yuv2yuyv422_2); break; default: break; } } } if (c->srcBpc == 8 && c->dstBpc <= 14) { #if COMPILE_TEMPLATE_MMXEXT if (c->flags & SWS_FAST_BILINEAR && c->canMMXEXTBeUsed) { c->hyscale_fast = ff_hyscale_fast_mmxext; c->hcscale_fast = ff_hcscale_fast_mmxext; } else { #endif c->hyscale_fast = NULL; c->hcscale_fast = NULL; #if COMPILE_TEMPLATE_MMXEXT } #endif } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.11436118199787926, 0.9340882850896938, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.8358616472332691, -0.11100716297398205, 0.660148897439891, -0.917450412529964, -0.518115519420462, 0.0, 0.6852718019606829, 4.4761069615225075, 0.9922867187396908, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void yvy2ToUV_c(uint8_t *dstU, uint8_t *dstV, const uint8_t *unused0, const uint8_t *src1, const uint8_t *src2, int width, uint32_t *unused) { int i; for (i = 0; i < width; i++) { dstV[i] = src1[4 * i + 1]; dstU[i] = src1[4 * i + 3]; } av_assert1(src1 == src2); }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void frame_list_remove_samples(FrameList *frame_list, int nb_samples) { if (nb_samples >= frame_list->nb_samples) { frame_list_clear(frame_list); } else { int samples = nb_samples; while (samples > 0) { FrameInfo *info = frame_list->list; av_assert0(info); if (info->nb_samples <= samples) { samples -= info->nb_samples; frame_list->list = info->next; if (!frame_list->list) frame_list->end = NULL; frame_list->nb_frames--; frame_list->nb_samples -= info->nb_samples; av_free(info); } else { info->nb_samples -= samples; info->pts += samples; frame_list->nb_samples -= samples; samples = 0; } } } }<SPLIT>[-0.25365086435942685, -0.08626953612071205, 0.0, -0.2665172434374763, -0.15112911381434976, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.1110049613987252, -0.25297036047912586, -0.06903890269146298, 0.0, 0.0, 0.30852482215402843, -0.17156659581066827, -0.26569807294376846, -0.13496750357150694, -0.270465503877335, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.25252937827156396, -0.3333928163445767, -0.21702784222394986, -0.13468348084208653, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 1.7623686513065309, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void psy_3gpp_analyze_channel(FFPsyContext *ctx, int channel, const float *coefs, const FFPsyWindowInfo *wi) { AacPsyContext *pctx = (AacPsyContext*) ctx->model_priv_data; AacPsyChannel *pch = &pctx->ch[channel]; int i, w, g; float desired_bits, desired_pe, delta_pe, reduction= NAN, spread_en[128] = {0}; float a = 0.0f, active_lines = 0.0f, norm_fac = 0.0f; float pe = pctx->chan_bitrate > 32000 ? 0.0f : FFMAX(50.0f, 100.0f - pctx->chan_bitrate * 100.0f / 32000.0f); const int num_bands = ctx->num_bands[wi->num_windows == 8]; const uint8_t *band_sizes = ctx->bands[wi->num_windows == 8]; AacPsyCoeffs *coeffs = pctx->psy_coef[wi->num_windows == 8]; const float avoid_hole_thr = wi->num_windows == 8 ? PSY_3GPP_AH_THR_SHORT : PSY_3GPP_AH_THR_LONG; calc_thr_3gpp(wi, num_bands, pch, band_sizes, coefs); for (w = 0; w < wi->num_windows*16; w += 16) { AacPsyBand *bands = &pch->band[w]; spread_en[0] = bands[0].energy; for (g = 1; g < num_bands; g++) { bands[g].thr = FFMAX(bands[g].thr, bands[g-1].thr * coeffs[g].spread_hi[0]); spread_en[w+g] = FFMAX(bands[g].energy, spread_en[w+g-1] * coeffs[g].spread_hi[1]); } for (g = num_bands - 2; g >= 0; g--) { bands[g].thr = FFMAX(bands[g].thr, bands[g+1].thr * coeffs[g].spread_low[0]); spread_en[w+g] = FFMAX(spread_en[w+g], spread_en[w+g+1] * coeffs[g].spread_low[1]); } for (g = 0; g < num_bands; g++) { AacPsyBand *band = &bands[g]; band->thr_quiet = band->thr = FFMAX(band->thr, coeffs[g].ath); if (!(wi->window_type[0] == LONG_STOP_SEQUENCE || (wi->window_type[1] == LONG_START_SEQUENCE && !w))) band->thr = FFMAX(PSY_3GPP_RPEMIN*band->thr, FFMIN(band->thr, PSY_3GPP_RPELEV*pch->prev_band[w+g].thr_quiet)); pe += calc_pe_3gpp(band); a += band->pe_const; active_lines += band->active_lines; if (spread_en[w+g] * avoid_hole_thr > band->energy || coeffs[g].min_snr > 1.0f) band->avoid_holes = PSY_3GPP_AH_NONE; else band->avoid_holes = PSY_3GPP_AH_INACTIVE; } } ctx->ch[channel].entropy = pe; desired_bits = calc_bit_demand(pctx, pe, ctx->bitres.bits, ctx->bitres.size, wi->num_windows == 8); desired_pe = PSY_3GPP_BITS_TO_PE(desired_bits); if (ctx->bitres.bits > 0) desired_pe *= av_clipf(pctx->pe.previous / PSY_3GPP_BITS_TO_PE(ctx->bitres.bits), 0.85f, 1.15f); pctx->pe.previous = PSY_3GPP_BITS_TO_PE(desired_bits); if (desired_pe < pe) { for (w = 0; w < wi->num_windows*16; w += 16) { reduction = calc_reduction_3gpp(a, desired_pe, pe, active_lines); pe = 0.0f; a = 0.0f; active_lines = 0.0f; for (g = 0; g < num_bands; g++) { AacPsyBand *band = &pch->band[w+g]; band->thr = calc_reduced_thr_3gpp(band, coeffs[g].min_snr, reduction); pe += calc_pe_3gpp(band); a += band->pe_const; active_lines += band->active_lines; } } for (i = 0; i < 2; i++) { float pe_no_ah = 0.0f, desired_pe_no_ah; active_lines = a = 0.0f; for (w = 0; w < wi->num_windows*16; w += 16) { for (g = 0; g < num_bands; g++) { AacPsyBand *band = &pch->band[w+g]; if (band->avoid_holes != PSY_3GPP_AH_ACTIVE) { pe_no_ah += band->pe; a += band->pe_const; active_lines += band->active_lines; } } } desired_pe_no_ah = FFMAX(desired_pe - (pe - pe_no_ah), 0.0f); if (active_lines > 0.0f) reduction = calc_reduction_3gpp(a, desired_pe_no_ah, pe_no_ah, active_lines); pe = 0.0f; for (w = 0; w < wi->num_windows*16; w += 16) { for (g = 0; g < num_bands; g++) { AacPsyBand *band = &pch->band[w+g]; if (active_lines > 0.0f) band->thr = calc_reduced_thr_3gpp(band, coeffs[g].min_snr, reduction); pe += calc_pe_3gpp(band); if (band->thr > 0.0f) band->norm_fac = band->active_lines / band->thr; else band->norm_fac = 0.0f; norm_fac += band->norm_fac; } } delta_pe = desired_pe - pe; if (fabs(delta_pe) > 0.05f * desired_pe) break; } if (pe < 1.15f * desired_pe) { norm_fac = 1.0f / norm_fac; for (w = 0; w < wi->num_windows*16; w += 16) { for (g = 0; g < num_bands; g++) { AacPsyBand *band = &pch->band[w+g]; if (band->active_lines > 0.5f) { float delta_sfb_pe = band->norm_fac * norm_fac * delta_pe; float thr = band->thr; thr *= exp2f(delta_sfb_pe / band->active_lines); if (thr > coeffs[g].min_snr * band->energy && band->avoid_holes == PSY_3GPP_AH_INACTIVE) thr = FFMAX(band->thr, coeffs[g].min_snr * band->energy); band->thr = thr; } } } } else { g = num_bands; while (pe > desired_pe && g--) { for (w = 0; w < wi->num_windows*16; w+= 16) { AacPsyBand *band = &pch->band[w+g]; if (band->avoid_holes != PSY_3GPP_AH_NONE && coeffs[g].min_snr < PSY_SNR_1DB) { coeffs[g].min_snr = PSY_SNR_1DB; band->thr = band->energy * PSY_SNR_1DB; pe += band->active_lines * 1.5f - band->pe; } } } } } for (w = 0; w < wi->num_windows*16; w += 16) { for (g = 0; g < num_bands; g++) { AacPsyBand *band = &pch->band[w+g]; FFPsyBand *psy_band = &ctx->ch[channel].psy_bands[w+g]; psy_band->threshold = band->thr; psy_band->energy = band->energy; psy_band->spread = band->active_lines * 2.0f / band_sizes[g]; } } memcpy(pch->prev_band, pch->band, sizeof(pch->band)); }<SPLIT>[2.529909858417405, 2.315719141056549, 0.0, 2.47229186247527, 2.168257091686449, 0.0, 0.44878749675400254, 0.46437660639310047, 0.5742476557731842, 0.7102265412631674, 2.426313183925606, 2.5785186166451206, 2.415385038883097, 0.0, 0.0, 0.30852482215402843, 2.2888831516235637, 2.5187383065123874, 2.272468266157448, 2.0586801672721293, 1.3453624607183459, 0.0, -0.08645738172306322, -0.16222078614455715, 3.0299514476576994, 1.8182776925856894, 2.7147281133538126, -0.21702784222394986, 0.8945950124817165, 0.4483410505659248, 0.46397383393136066, 0.5737900437766489, 0.7098813332246741, 1.7623686513065309, 0.0, 0.4447356044677496, 0.4603363055310632, 0.5700153422610048, 0.7058592275743352]
0<SPLIT>static int nut_read_header(AVFormatContext *s) { NUTContext *nut = s->priv_data; AVIOContext *bc = s->pb; int64_t pos; int initialized_stream_count; nut->avf = s; pos = 0; do { pos = find_startcode(bc, MAIN_STARTCODE, pos) + 1; if (pos < 0 + 1) { av_log(s, AV_LOG_ERROR, "No main startcode found.\n"); goto fail; } } while (decode_main_header(nut) < 0); pos = 0; for (initialized_stream_count = 0; initialized_stream_count < s->nb_streams;) { pos = find_startcode(bc, STREAM_STARTCODE, pos) + 1; if (pos < 0 + 1) { av_log(s, AV_LOG_ERROR, "Not all stream headers found.\n"); goto fail; } if (decode_stream_header(nut) >= 0) initialized_stream_count++; } pos = 0; for (;;) { uint64_t startcode = find_any_startcode(bc, pos); pos = avio_tell(bc); if (startcode == 0) { av_log(s, AV_LOG_ERROR, "EOF before video frames\n"); goto fail; } else if (startcode == SYNCPOINT_STARTCODE) { nut->next_startcode = startcode; break; } else if (startcode != INFO_STARTCODE) { continue; } decode_info_header(nut); } s->internal->data_offset = pos - 8; if (bc->seekable) { int64_t orig_pos = avio_tell(bc); find_and_decode_index(nut); avio_seek(bc, orig_pos, SEEK_SET); } av_assert0(nut->next_startcode == SYNCPOINT_STARTCODE); ff_metadata_conv_ctx(s, NULL, ff_nut_metadata_conv); return 0; fail: nut_read_close(s); return AVERROR_INVALIDDATA; }<SPLIT>[0.21027592277004517, 0.5087184848314537, 0.0, 0.18995094088131478, 0.4233977444289674, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, 1.040052222782594, 0.48836152962277035, 0.21894446904158188, 0.546368862652694, 0.0, 0.0, 0.30852482215402843, 0.40964200594544947, 0.19837465696559078, 0.4613697971870415, 0.7647103499668715, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, 0.6058330632552409, 0.6738843113224704, 0.6826474935548865, 3.3782753486411963, 0.23959960763929639, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, 1.039626388904333, 0.9056307075691036, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 1.0350888753871217]
0<SPLIT>static av_always_inline void update(SilenceDetectContext *s, AVFrame *insamples, int is_silence, int64_t nb_samples_notify, AVRational time_base) { if (is_silence) { if (!s->start) { s->nb_null_samples++; if (s->nb_null_samples >= nb_samples_notify) { s->start = insamples->pts - (int64_t)(s->duration / av_q2d(time_base) + .5); av_dict_set(&insamples->metadata, "lavfi.silence_start", av_ts2timestr(s->start, &time_base), 0); av_log(s, AV_LOG_INFO, "silence_start: %s\n", get_metadata_val(insamples, "lavfi.silence_start")); } } } else { if (s->start) { av_dict_set(&insamples->metadata, "lavfi.silence_end", av_ts2timestr(insamples->pts, &time_base), 0); av_dict_set(&insamples->metadata, "lavfi.silence_duration", av_ts2timestr(insamples->pts - s->start, &time_base), 0); av_log(s, AV_LOG_INFO, "silence_end: %s | silence_duration: %s\n", get_metadata_val(insamples, "lavfi.silence_end"), get_metadata_val(insamples, "lavfi.silence_duration")); } s->nb_null_samples = s->start = 0; } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.08729279623175898, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.1134457356350565, -0.26569807294376846, -0.06870780348722379, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { LADSPAContext *s = ctx->priv; int i; for (i = 0; i < s->nb_handles; i++) { if (s->desc->deactivate) s->desc->deactivate(s->handles[i]); if (s->desc->cleanup) s->desc->cleanup(s->handles[i]); } if (s->dl_handle) dlclose(s->dl_handle); av_freep(&s->ipmap); av_freep(&s->opmap); av_freep(&s->icmap); av_freep(&s->ocmap); av_freep(&s->ictlv); av_freep(&s->octlv); av_freep(&s->handles); av_freep(&s->ctl_needs_value); if (ctx->nb_inputs) av_freep(&ctx->input_pads[0].name); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static av_cold int init(AVFilterContext *ctx) { APadContext *s = ctx->priv; s->next_pts = AV_NOPTS_VALUE; if (s->whole_len >= 0 && s->pad_len >= 0) { av_log(ctx, AV_LOG_ERROR, "Both whole and pad length are set, this is not possible\n"); return AVERROR(EINVAL); } s->pad_len_left = s->pad_len; s->whole_len_left = s->whole_len; return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int set_string_sample_fmt(void *obj, const AVOption *o, const char *val, uint8_t *dst) { return set_string_fmt(obj, o, val, dst, AV_SAMPLE_FMT_NB, av_get_sample_fmt, "sample format"); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int ebml_read_ascii(AVIOContext *pb, int size, char **str) { char *res; if (!(res = av_malloc(size + 1))) return AVERROR(ENOMEM); if (avio_read(pb, (uint8_t *) res, size) != size) { av_free(res); return AVERROR(EIO); } (res)[size] = '\0'; av_free(*str); *str = res; return 0; }<SPLIT>[0.05563366039355449, -0.3507086565438968, 0.0, 0.037794879441717756, -0.406474384144713, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3107937917392237, 0.061639525868012635, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, 0.04368374699580437, -0.4000063039086396, -0.14106852214680915, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.08904460951967552, -0.22049944857796966, -0.21702784222394986, 0.05245806339860493, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int mxf_get_essence_container_ul_index(enum AVCodecID id) { int i; for (i = 0; mxf_essence_mappings[i].id; i++) if (mxf_essence_mappings[i].id == id) return mxf_essence_mappings[i].index; return -1; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void av_blowfish_crypt(AVBlowfish *ctx, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt) { uint32_t v0, v1; int i; if (decrypt) { while (count--) { v0 = AV_RB32(src); v1 = AV_RB32(src + 4); av_blowfish_crypt_ecb(ctx, &v0, &v1, decrypt); if (iv) { v0 ^= AV_RB32(iv); v1 ^= AV_RB32(iv + 4); memcpy(iv, src, 8); } AV_WB32(dst, v0); AV_WB32(dst + 4, v1); src += 8; dst += 8; } } else { while (count--) { if (iv) { for (i = 0; i < 8; i++) dst[i] = src[i] ^ iv[i]; v0 = AV_RB32(dst); v1 = AV_RB32(dst + 4); } else { v0 = AV_RB32(src); v1 = AV_RB32(src + 4); } av_blowfish_crypt_ecb(ctx, &v0, &v1, decrypt); AV_WB32(dst, v0); AV_WB32(dst + 4, v1); if (iv) memcpy(iv, dst, 8); src += 8; dst += 8; } } }<SPLIT>[-0.25365086435942685, 0.24427936440826892, 0.0, -0.2665172434374763, 0.16805247409860422, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, -0.27925050329511203, 0.18867828411202256, -0.25297036047912586, 0.2728543002775131, 0.0, 0.0, 0.30852482215402843, 0.11903770506739059, -0.26569807294376846, 0.19633099684990887, -0.011671540416283347, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, 0.18424725727220465, -0.14353953243697165, -0.22049944857796966, -0.21702784222394986, -0.04111270872174079, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, -0.27935383381430245, 1.7623686513065309, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, -0.28182971586402455]
0<SPLIT>static void eval_expr(AVFilterContext *ctx) { OverlayContext *s = ctx->priv; s->var_values[VAR_X] = av_expr_eval(s->x_pexpr, s->var_values, NULL); s->var_values[VAR_Y] = av_expr_eval(s->y_pexpr, s->var_values, NULL); s->var_values[VAR_X] = av_expr_eval(s->x_pexpr, s->var_values, NULL); s->x = normalize_xy(s->var_values[VAR_X], s->hsub); s->y = normalize_xy(s->var_values[VAR_Y], s->vsub); }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void run_tomcrypt_camellia(uint8_t *output, const uint8_t *input, unsigned size) { symmetric_key camellia; unsigned i; camellia_setup(hardcoded_key, 16, 0, &camellia); size -= 15; for (i = 0; i < size; i += 16) camellia_ecb_encrypt(input + i, output + i, &camellia); }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int opengl_create_window(AVFormatContext *h) { OpenGLContext *opengl = h->priv_data; int ret; if (!opengl->no_window) { #if HAVE_SDL if ((ret = opengl_sdl_create_window(h)) < 0) { av_log(opengl, AV_LOG_ERROR, "Cannot create default SDL window.\n"); return ret; } #else av_log(opengl, AV_LOG_ERROR, "FFmpeg is compiled without SDL. Cannot create default window.\n"); return AVERROR(ENOSYS); #endif } else { AVDeviceRect message; message.x = message.y = 0; message.width = opengl->window_width; message.height = opengl->window_height; if ((ret = avdevice_dev_to_app_control_message(h, AV_DEV_TO_APP_CREATE_WINDOW_BUFFER, &message , sizeof(message))) < 0) { av_log(opengl, AV_LOG_ERROR, "Application failed to create window buffer.\n"); return ret; } if ((ret = avdevice_dev_to_app_control_message(h, AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER, NULL , 0)) < 0) { av_log(opengl, AV_LOG_ERROR, "Application failed to prepare window buffer.\n"); return ret; } } return 0; }<SPLIT>[-0.25365086435942685, 0.023913430722281605, 0.0, -0.2665172434374763, -0.044735251176698444, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, -0.011110546228475942, -0.25297036047912586, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.07469849551798198, -0.26569807294376846, -0.17914063696102905, -0.270465503877335, 0.029966239443893296, 0.0, 0.3545307232390774, 1.5771521192305922, -0.1670742477136589, -0.14353953243697165, -0.3333928163445767, -0.21702784222394986, 0.05245806339860493, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
1<SPLIT>static void format_line(void *ptr, int level, const char *fmt, va_list vl, char part, int part_size, int *print_prefix, int type[2]) { AVClass* avc = ptr ? *(AVClass **) ptr : NULL; part[0][0] = part[1][0] = part[2][0] = 0; if(type) type[0] = type[1] = AV_CLASS_CATEGORY_NA + 16; if (*print_prefix && avc) { if (avc->parent_log_context_offset) { AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) + avc->parent_log_context_offset); if (parent && *parent) { snprintf(part[0], part_size, "[%s @ %p] ", (*parent)->item_name(parent), parent); if(type) type[0] = get_category(((uint8_t *) ptr) + avc->parent_log_context_offset); } } snprintf(part[1], part_size, "[%s @ %p] ", avc->item_name(ptr), ptr); if(type) type[1] = get_category(ptr); } vsnprintf(part[2], part_size, fmt, vl); *print_prefix = strlen(part[2]) && part[2][strlen(part[2]) - 1] == '\n'; }<SPLIT>[0.05563366039355449, -0.15237931622650824, 0.0, 0.037794879441717756, -0.21496543139694058, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, -0.13098384443277505, 0.061639525868012635, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, 0.04368374699580437, -0.2012272036557901, -0.14106852214680915, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.1980344553542678, -0.3333928163445767, -0.21702784222394986, -0.04111270872174079, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 1.7623686513065309, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>int main(void) { ps_tableinit(); write_fileheader(); printf("static const %s pd_re_smooth[8*8*8] = {\n", TYPE_NAME); ARRAY_RENAME(array)(pd_re_smooth, 8*8*8); printf("};\n"); printf("static const %s pd_im_smooth[8*8*8] = {\n", TYPE_NAME); ARRAY_RENAME(array)(pd_im_smooth, 8*8*8); printf("};\n"); printf("static const %s HA[46][8][4] = {\n", TYPE_NAME); ARRAY_RENAME(3d_array)(HA, 46, 8, 4); printf("};\n"); printf("static const %s HB[46][8][4] = {\n", TYPE_NAME); ARRAY_RENAME(3d_array)(HB, 46, 8, 4); printf("};\n"); printf("static const DECLARE_ALIGNED(16, %s, f20_0_8)[8][8][2] = {\n", TYPE_NAME); ARRAY_RENAME(3d_array)(f20_0_8, 8, 8, 2); printf("};\n"); printf("static const DECLARE_ALIGNED(16, %s, f34_0_12)[12][8][2] = {\n", TYPE_NAME); ARRAY_RENAME(3d_array)(f34_0_12, 12, 8, 2); printf("};\n"); printf("static const DECLARE_ALIGNED(16, %s, f34_1_8)[8][8][2] = {\n", TYPE_NAME); ARRAY_RENAME(3d_array)(f34_1_8, 8, 8, 2); printf("};\n"); printf("static const DECLARE_ALIGNED(16, %s, f34_2_4)[4][8][2] = {\n", TYPE_NAME); ARRAY_RENAME(3d_array)(f34_2_4, 4, 8, 2); printf("};\n"); printf("static const DECLARE_ALIGNED(16, %s, Q_fract_allpass)[2][50][3][2] = {\n", TYPE_NAME); ARRAY_RENAME(4d_array)(Q_fract_allpass, 2, 50, 3, 2); printf("};\n"); printf("static const DECLARE_ALIGNED(16, %s, phi_fract)[2][50][2] = {\n", TYPE_NAME); ARRAY_RENAME(3d_array)(phi_fract, 2, 50, 2); printf("};\n"); return 0; }<SPLIT>[-0.25365086435942685, 0.13409639756527525, 0.0, -0.2665172434374763, 0.06165861146095288, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.08878386894177331, -0.25297036047912586, 0.1588898992878544, 0.0, 0.0, 0.30852482215402843, 0.022169604774704303, -0.26569807294376846, 0.08589816337610359, -0.270465503877335, 0.9068970536268617, 0.0, -0.08645738172306322, -0.16222078614455715, 0.4653044612608955, 0.23792492798410134, -0.3333928163445767, -0.21702784222394986, 0.7074534682410251, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>static int mjpeg_decode_app(MJpegDecodeContext *s) { int len, id, i; len = get_bits(&s->gb, 16); if (len < 6) return AVERROR_INVALIDDATA; if (8 * len > get_bits_left(&s->gb)) return AVERROR_INVALIDDATA; id = get_bits_long(&s->gb, 32); len -= 6; if (s->avctx->debug & FF_DEBUG_STARTCODE) { char id_str[32]; av_get_codec_tag_string(id_str, sizeof(id_str), av_bswap32(id)); av_log(s->avctx, AV_LOG_DEBUG, "APPx (%s / %8X) len=%d\n", id_str, id, len); } if (id == AV_RB32("AVI1")) { s->buggy_avid = 1; i = get_bits(&s->gb, 8); len--; av_log(s->avctx, AV_LOG_DEBUG, "polarity %d\n", i); #if 0 skip_bits(&s->gb, 8); skip_bits(&s->gb, 32); skip_bits(&s->gb, 32); len -= 10; #endif goto out; } if (id == AV_RB32("JFIF")) { int t_w, t_h, v1, v2; skip_bits(&s->gb, 8); v1 = get_bits(&s->gb, 8); v2 = get_bits(&s->gb, 8); skip_bits(&s->gb, 8); s->avctx->sample_aspect_ratio.num = get_bits(&s->gb, 16); s->avctx->sample_aspect_ratio.den = get_bits(&s->gb, 16); ff_set_sar(s->avctx, s->avctx->sample_aspect_ratio); if (s->avctx->debug & FF_DEBUG_PICT_INFO) av_log(s->avctx, AV_LOG_INFO, "mjpeg: JFIF header found (version: %x.%x) SAR=%d/%d\n", v1, v2, s->avctx->sample_aspect_ratio.num, s->avctx->sample_aspect_ratio.den); t_w = get_bits(&s->gb, 8); t_h = get_bits(&s->gb, 8); if (t_w && t_h) { if (len -10 - (t_w * t_h * 3) > 0) len -= t_w * t_h * 3; } len -= 10; goto out; } if (id == AV_RB32("Adob") && (get_bits(&s->gb, 8) == 'e')) { skip_bits(&s->gb, 16); skip_bits(&s->gb, 16); skip_bits(&s->gb, 16); s->adobe_transform = get_bits(&s->gb, 8); if (s->avctx->debug & FF_DEBUG_PICT_INFO) av_log(s->avctx, AV_LOG_INFO, "mjpeg: Adobe header found, transform=%d\n", s->adobe_transform); len -= 7; goto out; } if (id == AV_RB32("LJIF")) { if (s->avctx->debug & FF_DEBUG_PICT_INFO) av_log(s->avctx, AV_LOG_INFO, "Pegasus lossless jpeg header found\n"); skip_bits(&s->gb, 16); skip_bits(&s->gb, 16); skip_bits(&s->gb, 16); skip_bits(&s->gb, 16); switch (i=get_bits(&s->gb, 8)) { case 1: s->rgb = 1; s->pegasus_rct = 0; break; case 2: s->rgb = 1; s->pegasus_rct = 1; break; default: av_log(s->avctx, AV_LOG_ERROR, "unknown colorspace %d\n", i); } len -= 9; goto out; } if (id == AV_RL32("colr") && len > 0) { s->colr = get_bits(&s->gb, 8); if (s->avctx->debug & FF_DEBUG_PICT_INFO) av_log(s->avctx, AV_LOG_INFO, "COLR %d\n", s->colr); len --; goto out; } if (id == AV_RL32("xfrm") && len > 0) { s->xfrm = get_bits(&s->gb, 8); if (s->avctx->debug & FF_DEBUG_PICT_INFO) av_log(s->avctx, AV_LOG_INFO, "XFRM %d\n", s->xfrm); len --; goto out; } if (s->start_code == APP3 && id == AV_RB32("_JPS") && len >= 10) { int flags, layout, type; if (s->avctx->debug & FF_DEBUG_PICT_INFO) av_log(s->avctx, AV_LOG_INFO, "_JPSJPS_\n"); skip_bits(&s->gb, 32); len -= 4; skip_bits(&s->gb, 16); len -= 2; skip_bits(&s->gb, 8); flags = get_bits(&s->gb, 8); layout = get_bits(&s->gb, 8); type = get_bits(&s->gb, 8); len -= 4; s->stereo3d = av_stereo3d_alloc(); if (!s->stereo3d) { goto out; } if (type == 0) { s->stereo3d->type = AV_STEREO3D_2D; } else if (type == 1) { switch (layout) { case 0x01: s->stereo3d->type = AV_STEREO3D_LINES; break; case 0x02: s->stereo3d->type = AV_STEREO3D_SIDEBYSIDE; break; case 0x03: s->stereo3d->type = AV_STEREO3D_TOPBOTTOM; break; } if (!(flags & 0x04)) { s->stereo3d->flags = AV_STEREO3D_FLAG_INVERT; } } goto out; } if (s->start_code == APP1 && id == AV_RB32("Exif") && len >= 2) { GetByteContext gbytes; int ret, le, ifd_offset, bytes_read; const uint8_t *aligned; skip_bits(&s->gb, 16); len -= 2; aligned = align_get_bits(&s->gb); bytestream2_init(&gbytes, aligned, len); ret = ff_tdecode_header(&gbytes, &le, &ifd_offset); if (ret) { av_log(s->avctx, AV_LOG_ERROR, "mjpeg: invalid TIFF header in EXIF data\n"); } else { bytestream2_seek(&gbytes, ifd_offset, SEEK_SET); ret = avpriv_exif_decode_ifd(s->avctx, &gbytes, le, 0, &s->exif_metadata); if (ret < 0) { av_log(s->avctx, AV_LOG_ERROR, "mjpeg: error decoding EXIF data\n"); } } bytes_read = bytestream2_tell(&gbytes); skip_bits(&s->gb, bytes_read << 3); len -= bytes_read; goto out; } if ((s->start_code == APP1) && (len > (0x28 - 8))) { id = get_bits_long(&s->gb, 32); len -= 4; if (id == AV_RB32("mjpg")) { #if 0 skip_bits(&s->gb, 32); skip_bits(&s->gb, 32); skip_bits(&s->gb, 32); skip_bits(&s->gb, 32); skip_bits(&s->gb, 32); skip_bits(&s->gb, 32); skip_bits(&s->gb, 32); skip_bits(&s->gb, 32); #endif if (s->avctx->debug & FF_DEBUG_PICT_INFO) av_log(s->avctx, AV_LOG_INFO, "mjpeg: Apple MJPEG-A header found\n"); } } out: if (len < 0) av_log(s->avctx, AV_LOG_ERROR, "mjpeg: error, decode_app parser read over the end\n"); while (--len > 0) skip_bits(&s->gb, 8); return 0; }<SPLIT>[6.705250942582653, 3.3514390293806895, 0.0, 6.5805055213443895, 3.1683594004803717, 0.0, 3.4032725252604856, 3.1155264735511756, 3.7252454002434643, 2.689180630379727, 3.904750528445295, 6.8257520823314906, 3.121964325018981, 0.0, 0.0, 0.30852482215402843, 3.7225310359553205, 6.695392875696621, 2.9571518336950406, 2.0586801672721293, 4.743469365677349, 0.0, 1.2365069331633587, 2.1569430876889752, 3.275876501147804, 4.161559378029423, 3.053408216653634, 3.3782753486411963, 4.2631428088141625, 3.402069516599365, 3.114574170141601, 3.724012711566496, 2.6883516673026273, 1.7623686513065309, 0.0, 3.394739862732508, 3.107645078610713, 3.7160715004066844, 2.6812371144510547]
0<SPLIT>static av_always_inline void get_bits1_vector(GetBitContext *gb, uint8_t *vec, int elements) { int i; for (i = 0; i < elements; i++) { vec[i] = get_bits1(gb); } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int get_asf_string(AVIOContext *pb, int maxlen, char *buf, int buflen) { char *q = buf; int ret = 0; if (buflen <= 0) return AVERROR(EINVAL); while (ret + 1 < maxlen) { uint8_t tmp; uint32_t ch; GET_UTF16(ch, (ret += 2) <= maxlen ? avio_rl16(pb) : 0, break;); PUT_UTF8(ch, tmp, if (q - buf < buflen - 1) *q++ = tmp;) } *q = 0; return ret; }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.14106852214680915, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.1980344553542678, -0.10760608081136262, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static inline int RENAME(yuv420_rgb15)(SwsContext *c, const uint8_t *src[], int srcStride[], int srcSliceY, int srcSliceH, uint8_t *dst[], int dstStride[]) { int y, h_size, vshift; YUV2RGB_LOOP(2) #ifdef DITHER1XBPP c->blueDither = ff_dither8[y & 1]; c->greenDither = ff_dither8[y & 1]; c->redDither = ff_dither8[(y + 1) & 1]; #endif YUV2RGB_INITIAL_LOAD YUV2RGB RGB_PACK_INTERLEAVE #ifdef DITHER1XBPP DITHER_RGB #endif RGB_PACK16(pb_03, 1) YUV2RGB_ENDLOOP(2) YUV2RGB_OPERANDS YUV2RGB_ENDFUNC }<SPLIT>[-0.25365086435942685, -0.15237931622650824, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.17094161050087475, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, -0.26569807294376846, -0.37791973721387856, -0.5292594673383866, -0.4084991676475909, 0.0, 0.3545307232390774, 2.1569430876889752, -0.5535279031981089, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>static void lpc_prediction(int32_t *error_buffer, int32_t *buffer_out, int nb_samples, int bps, int16_t *lpc_coefs, int lpc_order, int lpc_quant) { int i; int32_t *pred = buffer_out; *buffer_out = *error_buffer; if (nb_samples <= 1) return; if (!lpc_order) { memcpy(&buffer_out[1], &error_buffer[1], (nb_samples - 1) * sizeof(*buffer_out)); return; } if (lpc_order == 31) { for (i = 1; i < nb_samples; i++) { buffer_out[i] = sign_extend(buffer_out[i - 1] + error_buffer[i], bps); } return; } for (i = 1; i <= lpc_order && i < nb_samples; i++) buffer_out[i] = sign_extend(buffer_out[i - 1] + error_buffer[i], bps); for (; i < nb_samples; i++) { int j; int val = 0; int error_val = error_buffer[i]; int error_sign; int d = *pred++; for (j = 0; j < lpc_order; j++) val += (pred[j] - d) * lpc_coefs[j]; val = (val + (1 << (lpc_quant - 1))) >> lpc_quant; val += d + error_val; buffer_out[i] = sign_extend(val, bps); error_sign = sign_only(error_val); if (error_sign) { for (j = 0; j < lpc_order && error_val * error_sign > 0; j++) { int sign; val = d - pred[j]; sign = sign_only(val) * error_sign; lpc_coefs[j] -= sign; val *= sign; error_val -= (val >> lpc_quant) * (j + 1); } } } }<SPLIT>[2.065983071287933, 0.3764989246198613, 0.0, 2.015823678156479, 0.2957251092637858, 0.0, 0.7963739706959416, 0.8178632553475105, 0.9059316288753189, 0.7102265412631674, 0.6082348278270694, 2.106603787124413, 0.40961158146510357, 0.0, 0.0, 0.30852482215402843, 0.525883726296673, 2.054665576603028, 0.3288503970184752, 0.7647103499668715, 1.2357461089454749, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5355687622580682, 1.0008538488262473, 0.34396739025506545, 0.6817979554923368, 1.3624488730834452, 0.7958385171580944, 0.8173872120927261, 0.9053924298597907, 0.7098813332246741, 1.7623686513065309, 0.0, 0.791794928969486, 0.8133108086083498, 0.9011791483816026, 0.7058592275743352]
0<SPLIT>static void list_standards(AVFormatContext *ctx) { int ret; struct video_data *s = ctx->priv_data; struct v4l2_standard standard; if (s->std_id == 0) return; for (standard.index = 0; ; standard.index++) { if (v4l2_ioctl(s->fd, VIDIOC_ENUMSTD, &standard) < 0) { ret = AVERROR(errno); if (ret == AVERROR(EINVAL)) { break; } else { av_log(ctx, AV_LOG_ERROR, "ioctl(VIDIOC_ENUMSTD): %s\n", av_err2str(ret)); return; } } av_log(ctx, AV_LOG_INFO, "%2d, %16"PRIx64", %s\n", standard.index, (uint64_t)standard.id, standard.name); } }<SPLIT>[-0.25365086435942685, -0.1964525029637057, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 1.040052222782594, -0.21089937656897445, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, -0.011671540416283347, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, 0.29241985090139744, 0.23107402248845843, 2.47944955092491, 0.05245806339860493, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 1.039626388904333, 1.7623686513065309, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 1.0350888753871217]
0<SPLIT>static inline void blur8(uint8_t *dst, int dst_step, const uint8_t *src, int src_step, int len, int radius) { const int length = radius*2 + 1; const int inv = ((1<<16) + length/2)/length; int x, sum = src[radius*src_step]; for (x = 0; x < radius; x++) sum += src[x*src_step]<<1; sum = sum*inv + (1<<15); for (x = 0; x <= radius; x++) { sum += (src[(radius+x)*src_step] - src[(radius-x)*src_step])*inv; dst[x*dst_step] = sum>>16; } for (; x < len-radius; x++) { sum += (src[(radius+x)*src_step] - src[(x-radius-1)*src_step])*inv; dst[x*dst_step] = sum >>16; } for (; x < len; x++) { sum += (src[(2*len-radius-x-1)*src_step] - src[(x-radius-1)*src_step])*inv; dst[x*dst_step] = sum>>16; } }<SPLIT>[1.9113408089114425, -0.17441590959510697, 0.0, 1.863667616716882, -0.23624420392447085, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.08878386894177331, 1.9492988439508436, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, 0.022169604774704303, 1.8999746666332415, -0.22331377035055117, -0.270465503877335, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, 0.0744401592322129, -0.3333928163445767, 1.5806237532086234, 0.23959960763929639, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>void ff_acelp_high_pass_filter(int16_t* out, int hpf_f[2], const int16_t* in, int length) { int i; int tmp; for (i = 0; i < length; i++) { tmp = (hpf_f[0]* 15836LL) >> 13; tmp += (hpf_f[1]* -7667LL) >> 13; tmp += 7699 * (in[i] - 2*in[i-1] + in[i-2]); out[i] = av_clip_int16((tmp + 0x800) >> 12); hpf_f[1] = hpf_f[0]; hpf_f[0] = tmp; } }<SPLIT>[0.05563366039355449, -0.3507086565438968, 0.0, 0.037794879441717756, -0.406474384144713, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3107937917392237, 0.061639525868012635, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, 0.04368374699580437, -0.4000063039086396, -0.270465503877335, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.14353953243697165, -0.4462861841111837, -0.21702784222394986, 0.14602883551895066, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int av_log2(unsigned v) { return ff_log2(v); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void apply_intensity_stereo(AACContext *ac, ChannelElement *cpe, int ms_present) { const IndividualChannelStream *ics = &cpe->ch[1].ics; SingleChannelElement *sce1 = &cpe->ch[1]; INTFLOAT *coef0 = cpe->ch[0].coeffs, *coef1 = cpe->ch[1].coeffs; const uint16_t *offsets = ics->swb_offset; int g, group, i, idx = 0; int c; INTFLOAT scale; for (g = 0; g < ics->num_window_groups; g++) { for (i = 0; i < ics->max_sfb;) { if (sce1->band_type[idx] == INTENSITY_BT || sce1->band_type[idx] == INTENSITY_BT2) { const int bt_run_end = sce1->band_type_run_end[idx]; for (; i < bt_run_end; i++, idx++) { c = -1 + 2 * (sce1->band_type[idx] - 14); if (ms_present) c *= 1 - 2 * cpe->ms_mask[idx]; scale = c * sce1->sf[idx]; for (group = 0; group < ics->group_len[g]; group++) #if USE_FIXED ac->subband_scale(coef1 + group * 128 + offsets[i], coef0 + group * 128 + offsets[i], scale, 23, offsets[i + 1] - offsets[i]); #else ac->fdsp->vector_fmul_scalar(coef1 + group * 128 + offsets[i], coef0 + group * 128 + offsets[i], scale, offsets[i + 1] - offsets[i]); #endif } } else { int bt_run_end = sce1->band_type_run_end[idx]; idx += bt_run_end - i; i = bt_run_end; } } coef0 += ics->group_len[g] * 128; coef1 += ics->group_len[g] * 128; } }<SPLIT>[-0.25365086435942685, 0.3103891445140651, 0.0, -0.2665172434374763, 0.231888791681195, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.24861493321417213, -0.25297036047912586, 0.1588898992878544, 0.0, 0.0, 0.30852482215402843, 0.17715856524300236, -0.26569807294376846, 0.08589816337610359, 0.11772544131424245, -0.4084991676475909, 0.0, 0.4647777494796126, 1.5771521192305922, 0.21937940777079099, -0.1980344553542678, 0.23107402248845843, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void ps_hybrid_synthesis_deint_c(INTFLOAT out[2][38][64], INTFLOAT (*in)[32][2], int i, int len) { int n; for (; i < 64; i++) { for (n = 0; n < len; n++) { out[0][n][i] = in[i][n][0]; out[1][n][i] = in[i][n][1]; } } }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 3.3489446507317613, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, 0.11772544131424245, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, 0.12893508214950905, -0.4462861841111837, 1.5806237532086234, 0.42674115187998785, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 0.04739993194876201]
0<SPLIT>int main(void){ SoftFloat one= av_int2sf(1, 0); SoftFloat sf1, sf2, sf3; double d1, d2, d3; int i, j; av_log_set_level(AV_LOG_DEBUG); d1= 1; for(i= 0; i<10; i++){ d1= 1/(d1+1); } printf("test1 double=%d\n", (int)(d1 * (1<<24))); sf1= one; for(i= 0; i<10; i++){ sf1= av_div_sf(one, av_normalize_sf(av_add_sf(one, sf1))); } printf("test1 sf =%d\n", av_sf2int(sf1, 24)); for(i= 0; i<100; i++){ START_TIMER d1= i; d2= i/100.0; for(j= 0; j<1000; j++){ d1= (d1+1)*d2; } STOP_TIMER("float add mul") } printf("test2 double=%d\n", (int)(d1 * (1<<24))); for(i= 0; i<100; i++){ START_TIMER sf1= av_int2sf(i, 0); sf2= av_div_sf(av_int2sf(i, 2), av_int2sf(200, 3)); for(j= 0; j<1000; j++){ sf1= av_mul_sf(av_add_sf(sf1, one),sf2); } STOP_TIMER("softfloat add mul") } printf("test2 sf =%d (%d %d)\n", av_sf2int(sf1, 24), sf1.exp, sf1.mant); d1 = 0.0177764893; d2 = 1374.40625; d3 = 0.1249694824; d2 += d1; d3 += d2; printf("test3 double: %.10lf\n", d3); sf1 = FLOAT_0_017776489257; sf2 = FLOAT_1374_40625; sf3 = FLOAT_0_1249694824218; sf2 = av_add_sf(sf1, sf2); sf3 = av_add_sf(sf3, sf2); printf("test3 softfloat: %.10lf (0x%08x %d)\n", (double)av_sf2double(sf3), sf3.mant, sf3.exp); sf1 = av_int2sf(0xFFFFFFF0, 0); printf("test4 softfloat: %.10lf (0x%08x %d)\n", (double)av_sf2double(sf1), sf1.mant, sf1.exp); sf1 = av_int2sf(0x00000010, 0); printf("test4 softfloat: %.10lf (0x%08x %d)\n", (double)av_sf2double(sf1), sf1.mant, sf1.exp); sf1 = av_int2sf(0x1FFFFFFF, 0); printf("test4 softfloat: %.10lf (0x%08x %d)\n", (double)av_sf2double(sf1), sf1.mant, sf1.exp); sf1 = av_int2sf(0xE0000001, 0); printf("test4 softfloat: %.10lf (0x%08x %d)\n", (double)av_sf2double(sf1), sf1.mant, sf1.exp); for(i= 0; i<4*36; i++){ int s, c; double errs, errc; av_sincos_sf(i*(1ULL<<32)/36/4, &s, &c); errs = (double)s/ (1<<30) - sin(i*M_PI/36); errc = (double)c/ (1<<30) - cos(i*M_PI/36); if (fabs(errs) > 0.00000002 || fabs(errc) >0.001) { printf("sincos FAIL %d %f %f %f %f\n", i, (float)s/ (1<<30), (float)c/ (1<<30), sin(i*M_PI/36), cos(i*M_PI/36)); } } return 0; }<SPLIT>[-0.25365086435942685, 0.8392673853604347, 0.0, -0.2665172434374763, 0.7425793323419214, 0.0, 0.9701672076669112, 0.9946065798247155, 1.0717736154263862, -0.27925050329511203, 0.7281081260313685, -0.25297036047912586, 0.8882620656216701, 0.0, 0.0, 0.30852482215402843, 0.6421254466478965, -0.26569807294376846, 0.7926682976084574, 1.2822982768889746, 2.1126769231284435, 0.0, -0.08645738172306322, -0.16222078614455715, 1.413872524722727, 2.6357015363451315, 1.8115811712209564, -0.21702784222394986, 3.046722771249668, 0.969587250454179, 0.9940939011734088, 1.0711936229013617, -0.27935383381430245, 0.9056307075691036, 0.0, 0.9653245912203542, 0.9897980601469931, 1.0667610514419015, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { static const enum AVPixelFormat in_pixfmts[] = { AV_PIX_FMT_YUV410P, AV_PIX_FMT_YUV411P, AV_PIX_FMT_YUV440P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUVA420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUVA422P, AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ440P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUVJ411P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUVA444P, AV_PIX_FMT_YUV420P16LE, AV_PIX_FMT_YUVA420P16LE, AV_PIX_FMT_YUV420P16BE, AV_PIX_FMT_YUVA420P16BE, AV_PIX_FMT_YUV422P16LE, AV_PIX_FMT_YUVA422P16LE, AV_PIX_FMT_YUV422P16BE, AV_PIX_FMT_YUVA422P16BE, AV_PIX_FMT_YUV444P16LE, AV_PIX_FMT_YUVA444P16LE, AV_PIX_FMT_YUV444P16BE, AV_PIX_FMT_YUVA444P16BE, AV_PIX_FMT_GRAY8, AV_PIX_FMT_GRAY8A, AV_PIX_FMT_YA16LE, AV_PIX_FMT_YA16BE, AV_PIX_FMT_GRAY16LE, AV_PIX_FMT_GRAY16BE, AV_PIX_FMT_RGB24, AV_PIX_FMT_BGR24, AV_PIX_FMT_RGBA, AV_PIX_FMT_BGRA, AV_PIX_FMT_ARGB, AV_PIX_FMT_ABGR, AV_PIX_FMT_RGB48LE, AV_PIX_FMT_BGR48LE, AV_PIX_FMT_RGB48BE, AV_PIX_FMT_BGR48BE, AV_PIX_FMT_RGBA64LE, AV_PIX_FMT_BGRA64LE, AV_PIX_FMT_RGBA64BE, AV_PIX_FMT_BGRA64BE, AV_PIX_FMT_GBRP, AV_PIX_FMT_GBRAP, AV_PIX_FMT_GBRP16LE, AV_PIX_FMT_GBRP16BE, AV_PIX_FMT_GBRAP16LE, AV_PIX_FMT_GBRAP16BE, AV_PIX_FMT_NONE, }; static const enum AVPixelFormat out8_pixfmts[] = { AV_PIX_FMT_GRAY8, AV_PIX_FMT_NONE }; static const enum AVPixelFormat out16le_pixfmts[] = { AV_PIX_FMT_GRAY16LE, AV_PIX_FMT_NONE }; static const enum AVPixelFormat out16be_pixfmts[] = { AV_PIX_FMT_GRAY16BE, AV_PIX_FMT_NONE }; const enum AVPixelFormat *out_pixfmts; const AVPixFmtDescriptor *desc; AVFilterFormats *avff; int i, depth = 0, be = 0; if (!ctx->inputs[0]->in_formats || !ctx->inputs[0]->in_formats->nb_formats) { return AVERROR(EAGAIN); } if (!ctx->inputs[0]->out_formats) ff_formats_ref(ff_make_format_list(in_pixfmts), &ctx->inputs[0]->out_formats); avff = ctx->inputs[0]->in_formats; desc = av_pix_fmt_desc_get(avff->formats[0]); depth = desc->comp[0].depth_minus1; be = desc->flags & AV_PIX_FMT_FLAG_BE; for (i = 1; i < avff->nb_formats; i++) { desc = av_pix_fmt_desc_get(avff->formats[i]); if (depth != desc->comp[0].depth_minus1 || be != (desc->flags & AV_PIX_FMT_FLAG_BE)) { return AVERROR(EAGAIN); } } if (depth == 7) out_pixfmts = out8_pixfmts; else if (be) out_pixfmts = out16be_pixfmts; else out_pixfmts = out16le_pixfmts; for (i = 0; i < ctx->nb_outputs; i++) ff_formats_ref(ff_make_format_list(out_pixfmts), &ctx->outputs[i]->in_formats); return 0; }<SPLIT>[-0.25365086435942685, 0.8172307919918359, 0.0, -0.2665172434374763, 0.7425793323419214, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.7081292429973187, -0.25297036047912586, 0.8654691854237383, 0.0, 0.0, 0.30852482215402843, 0.6421254466478965, -0.26569807294376846, 0.7926682976084574, 0.6353133682363457, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, 0.21937940777079099, 0.5103995425705821, 0.9084342290881006, -0.21702784222394986, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static av_cold int allyuv_init(AVFilterContext *ctx) { TestSourceContext *test = ctx->priv; test->w = test->h = 4096; test->draw_once = 1; test->fill_picture_fn = allyuv_fill_picture; return init(ctx); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static inline int16_t *scalarproduct(const int16_t *in, const int16_t *endin, int16_t *out) { int32_t sample; int16_t j; while (in < endin) { sample = 0; for (j = 0; j < NUMTAPS; j++) sample += in[j] * filt[j]; *out = av_clip_int16(sample >> 6); out++; in++; } return out; }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>av_cold void ff_sws_init_swscale_ppc(SwsContext *c) { #if HAVE_ALTIVEC enum AVPixelFormat dstFormat = c->dstFormat; if (!(av_get_cpu_flags() & AV_CPU_FLAG_ALTIVEC)) return; if (c->srcBpc == 8 && c->dstBpc <= 14) { c->hyScale = c->hcScale = hScale_altivec_real; } if (!is16BPS(dstFormat) && !is9_OR_10BPS(dstFormat) && dstFormat != AV_PIX_FMT_NV12 && dstFormat != AV_PIX_FMT_NV21 && !c->alpPixBuf) { c->yuv2planeX = yuv2planeX_altivec; } if (!(c->flags & (SWS_BITEXACT | SWS_FULL_CHR_H_INT)) && !c->alpPixBuf) { switch (c->dstFormat) { case AV_PIX_FMT_ABGR: c->yuv2packedX = ff_yuv2abgr_X_altivec; break; case AV_PIX_FMT_BGRA: c->yuv2packedX = ff_yuv2bgra_X_altivec; break; case AV_PIX_FMT_ARGB: c->yuv2packedX = ff_yuv2argb_X_altivec; break; case AV_PIX_FMT_RGBA: c->yuv2packedX = ff_yuv2rgba_X_altivec; break; case AV_PIX_FMT_BGR24: c->yuv2packedX = ff_yuv2bgr24_X_altivec; break; case AV_PIX_FMT_RGB24: c->yuv2packedX = ff_yuv2rgb24_X_altivec; break; } } #endif }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.037794879441717756, 0.10421615651601342, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.09966408500885333, -0.26569807294376846, -0.6429585375510112, -0.917450412529964, -0.518115519420462, 0.0, 3.7721885366956673, 0.9973611507722091, -0.13194209721507255, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int gdigrab_read_packet(AVFormatContext *s1, AVPacket *pkt) { struct gdigrab *gdigrab = s1->priv_data; HDC dest_hdc = gdigrab->dest_hdc; HDC source_hdc = gdigrab->source_hdc; RECT clip_rect = gdigrab->clip_rect; AVRational time_base = gdigrab->time_base; int64_t time_frame = gdigrab->time_frame; BITMAPFILEHEADER bfh; int file_size = gdigrab->header_size + gdigrab->frame_size; int64_t curtime, delay; time_frame += INT64_C(1000000); if (gdigrab->show_region) gdigrab_region_wnd_update(s1, gdigrab); for (;;) { curtime = av_gettime(); delay = time_frame * av_q2d(time_base) - curtime; if (delay <= 0) { if (delay < INT64_C(-1000000) * av_q2d(time_base)) { time_frame += INT64_C(1000000); } break; } if (s1->flags & AVFMT_FLAG_NONBLOCK) { return AVERROR(EAGAIN); } else { av_usleep(delay); } } if (av_new_packet(pkt, file_size) < 0) return AVERROR(ENOMEM); pkt->pts = curtime; if (!BitBlt(dest_hdc, 0, 0, clip_rect.right - clip_rect.left, clip_rect.bottom - clip_rect.top, source_hdc, clip_rect.left, clip_rect.top, SRCCOPY | CAPTUREBLT)) { WIN32_API_ERROR("Failed to capture image"); return AVERROR(EIO); } if (gdigrab->draw_mouse) paint_mouse_pointer(s1, gdigrab); bfh.bfType = 0x4d42; bfh.bfSize = file_size; bfh.bfReserved1 = 0; bfh.bfReserved2 = 0; bfh.bfOffBits = gdigrab->header_size; memcpy(pkt->data, &bfh, sizeof(bfh)); memcpy(pkt->data + sizeof(bfh), &gdigrab->bmi.bmiHeader, sizeof(gdigrab->bmi.bmiHeader)); if (gdigrab->bmi.bmiHeader.biBitCount <= 8) GetDIBColorTable(dest_hdc, 0, 1 << gdigrab->bmi.bmiHeader.biBitCount, (RGBQUAD *) (pkt->data + sizeof(bfh) + sizeof(gdigrab->bmi.bmiHeader))); memcpy(pkt->data + gdigrab->header_size, gdigrab->buffer, gdigrab->frame_size); gdigrab->time_frame = time_frame; return gdigrab->header_size + gdigrab->frame_size; }<SPLIT>[0.5195604475230265, 0.5748282649372498, 0.0, 0.4942630637605089, 0.48723406201155817, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, 0.380400859743741, 0.5882559447930196, 0.5335543553887203, 0.6147475032464892, 0.0, 0.0, 0.30852482215402843, 0.5065101062381357, 0.5077564769051636, 0.5276294972713247, 1.0235043134279231, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5355687622580682, 0.6193893884051743, 0.9084342290881006, 2.47944955092491, 0.05245806339860493, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, 0.3801362775450152, 1.7623686513065309, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 0.3766295797615486]
0<SPLIT>static int config_props(AVFilterLink *link) { DeshakeContext *deshake = link->dst->priv; deshake->ref = NULL; deshake->last.vec.x = 0; deshake->last.vec.y = 0; deshake->last.angle = 0; deshake->last.zoom = 0; return 0; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.7880534307994381, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void ini_print_str(WriterContext *wctx, const char *key, const char *value) { AVBPrint buf; av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED); printf("%s=", ini_escape_str(&buf, key)); av_bprint_clear(&buf); printf("%s\n", ini_escape_str(&buf, value)); av_bprint_finalize(&buf, NULL); }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int pulse_flash_stream(PulseData *s) { pa_operation *op; pa_threaded_mainloop_lock(s->mainloop); op = pa_stream_flush(s->stream, pulse_stream_result, s); return pulse_finish_stream_operation(s, op, "pa_stream_flush"); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { FOCContext *foc = ctx->priv; int i; for (i = 0; i < MAX_MIPMAPS; i++) { av_frame_free(&foc->needle_frame[i]); av_frame_free(&foc->haystack_frame[i]); } if (foc->obj_frame) av_freep(&foc->obj_frame->data[0]); av_frame_free(&foc->obj_frame); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int join_config_output(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; JoinContext *s = ctx->priv; uint64_t *inputs; int i, ret = 0; if (!(inputs = av_mallocz_array(ctx->nb_inputs, sizeof(*inputs)))) return AVERROR(ENOMEM); for (i = 0; i < s->nb_channels; i++) { ChannelMap *ch = &s->channels[i]; AVFilterLink *inlink; if (ch->input < 0) continue; inlink = ctx->inputs[ch->input]; if (!ch->in_channel) ch->in_channel = av_channel_layout_extract_channel(inlink->channel_layout, ch->in_channel_idx); if (!(ch->in_channel & inlink->channel_layout)) { av_log(ctx, AV_LOG_ERROR, "Requested channel %s is not present in " "input stream #%d.\n", av_get_channel_name(ch->in_channel), ch->input); ret = AVERROR(EINVAL); goto fail; } inputs[ch->input] |= ch->in_channel; } for (i = 0; i < s->nb_channels; i++) { ChannelMap *ch = &s->channels[i]; if (ch->input < 0) guess_map_matching(ctx, ch, inputs); } for (i = 0; i < s->nb_channels; i++) { ChannelMap *ch = &s->channels[i]; if (ch->input < 0) guess_map_any(ctx, ch, inputs); if (ch->input < 0) { av_log(ctx, AV_LOG_ERROR, "Could not find input channel for " "output channel '%s'.\n", av_get_channel_name(ch->out_channel)); goto fail; } ch->in_channel_idx = av_get_channel_layout_channel_index(ctx->inputs[ch->input]->channel_layout, ch->in_channel); } av_log(ctx, AV_LOG_VERBOSE, "mappings: "); for (i = 0; i < s->nb_channels; i++) { ChannelMap *ch = &s->channels[i]; av_log(ctx, AV_LOG_VERBOSE, "%d.%s => %s ", ch->input, av_get_channel_name(ch->in_channel), av_get_channel_name(ch->out_channel)); } av_log(ctx, AV_LOG_VERBOSE, "\n"); for (i = 0; i < ctx->nb_inputs; i++) { if (!inputs[i]) av_log(ctx, AV_LOG_WARNING, "No channels are used from input " "stream %d.\n", i); } fail: av_freep(&inputs); return ret; }<SPLIT>[0.5195604475230265, 0.6850112317802435, 0.0, 0.4942630637605089, 0.5936279246492095, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.6881503599632689, 0.5335543553887203, 0.728711904236148, 0.0, 0.0, 0.30852482215402843, 0.603378206530822, 0.5077564769051636, 0.63806233074513, 0.5059163865058198, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.6409652137538272, 0.0744401592322129, 0.5697541257882794, 0.6817979554923368, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void butterflies_float_mips(float *av_restrict v1, float *av_restrict v2, int len) { float temp0, temp1, temp2, temp3, temp4; float temp5, temp6, temp7, temp8, temp9; float temp10, temp11, temp12, temp13, temp14, temp15; int pom; pom = (len >> 2)-1; __asm__ volatile ( "lwc1 %[temp0], 0(%[v1]) \n\t" "lwc1 %[temp1], 4(%[v1]) \n\t" "lwc1 %[temp2], 8(%[v1]) \n\t" "lwc1 %[temp3], 12(%[v1]) \n\t" "lwc1 %[temp4], 0(%[v2]) \n\t" "lwc1 %[temp5], 4(%[v2]) \n\t" "lwc1 %[temp6], 8(%[v2]) \n\t" "lwc1 %[temp7], 12(%[v2]) \n\t" "beq %[pom], $zero, 2f \n\t" "1: \n\t" "sub.s %[temp8], %[temp0], %[temp4] \n\t" "add.s %[temp9], %[temp0], %[temp4] \n\t" "sub.s %[temp10], %[temp1], %[temp5] \n\t" "add.s %[temp11], %[temp1], %[temp5] \n\t" "sub.s %[temp12], %[temp2], %[temp6] \n\t" "add.s %[temp13], %[temp2], %[temp6] \n\t" "sub.s %[temp14], %[temp3], %[temp7] \n\t" "add.s %[temp15], %[temp3], %[temp7] \n\t" PTR_ADDIU "%[v1], %[v1], 16 \n\t" PTR_ADDIU "%[v2], %[v2], 16 \n\t" "addiu %[pom], %[pom], -1 \n\t" "lwc1 %[temp0], 0(%[v1]) \n\t" "lwc1 %[temp1], 4(%[v1]) \n\t" "lwc1 %[temp2], 8(%[v1]) \n\t" "lwc1 %[temp3], 12(%[v1]) \n\t" "lwc1 %[temp4], 0(%[v2]) \n\t" "lwc1 %[temp5], 4(%[v2]) \n\t" "lwc1 %[temp6], 8(%[v2]) \n\t" "lwc1 %[temp7], 12(%[v2]) \n\t" "swc1 %[temp9], -16(%[v1]) \n\t" "swc1 %[temp8], -16(%[v2]) \n\t" "swc1 %[temp11], -12(%[v1]) \n\t" "swc1 %[temp10], -12(%[v2]) \n\t" "swc1 %[temp13], -8(%[v1]) \n\t" "swc1 %[temp12], -8(%[v2]) \n\t" "swc1 %[temp15], -4(%[v1]) \n\t" "swc1 %[temp14], -4(%[v2]) \n\t" "bgtz %[pom], 1b \n\t" "2: \n\t" "sub.s %[temp8], %[temp0], %[temp4] \n\t" "add.s %[temp9], %[temp0], %[temp4] \n\t" "sub.s %[temp10], %[temp1], %[temp5] \n\t" "add.s %[temp11], %[temp1], %[temp5] \n\t" "sub.s %[temp12], %[temp2], %[temp6] \n\t" "add.s %[temp13], %[temp2], %[temp6] \n\t" "sub.s %[temp14], %[temp3], %[temp7] \n\t" "add.s %[temp15], %[temp3], %[temp7] \n\t" "swc1 %[temp9], 0(%[v1]) \n\t" "swc1 %[temp8], 0(%[v2]) \n\t" "swc1 %[temp11], 4(%[v1]) \n\t" "swc1 %[temp10], 4(%[v2]) \n\t" "swc1 %[temp13], 8(%[v1]) \n\t" "swc1 %[temp12], 8(%[v2]) \n\t" "swc1 %[temp15], 12(%[v1]) \n\t" "swc1 %[temp14], 12(%[v2]) \n\t" : [v1]"+r"(v1), [v2]"+r"(v2), [pom]"+r"(pom), [temp0] "=&f" (temp0), [temp1]"=&f"(temp1), [temp2]"=&f"(temp2), [temp3]"=&f"(temp3), [temp4]"=&f"(temp4), [temp5]"=&f"(temp5), [temp6]"=&f"(temp6), [temp7]"=&f"(temp7), [temp8]"=&f"(temp8), [temp9]"=&f"(temp9), [temp10]"=&f"(temp10), [temp11]"=&f"(temp11), [temp12]"=&f"(temp12), [temp13]"=&f"(temp13), [temp14]"=&f"(temp14), [temp15]"=&f"(temp15) : : "memory" ); }<SPLIT>[-0.09900860198293619, 0.971486945572027, 0.0, -0.11436118199787926, 0.870251967507103, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.8679603072697175, -0.09566541730555662, 1.0250193468092605, 0.0, 0.0, 0.30852482215402843, 0.7777407870576574, -0.11100716297398205, 0.9251876977770237, -0.14106852214680915, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, 0.23792492798410134, 1.1342209646213146, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int av_opt_serialize(void *obj, int opt_flags, int flags, char **buffer, const char key_val_sep, const char pairs_sep) { const AVOption *o = NULL; uint8_t *buf; AVBPrint bprint; int ret, cnt = 0; const char special_chars[] = {pairs_sep, key_val_sep, '\0'}; if (pairs_sep == '\0' || key_val_sep == '\0' || pairs_sep == key_val_sep || pairs_sep == '\\' || key_val_sep == '\\') { av_log(obj, AV_LOG_ERROR, "Invalid separator(s) found."); return AVERROR(EINVAL); } if (!obj || !buffer) return AVERROR(EINVAL); *buffer = NULL; av_bprint_init(&bprint, 64, AV_BPRINT_SIZE_UNLIMITED); while (o = av_opt_next(obj, o)) { if (o->type == AV_OPT_TYPE_CONST) continue; if ((flags & AV_OPT_SERIALIZE_OPT_FLAGS_EXACT) && o->flags != opt_flags) continue; else if (((o->flags & opt_flags) != opt_flags)) continue; if (flags & AV_OPT_SERIALIZE_SKIP_DEFAULTS && av_opt_is_set_to_default(obj, o) > 0) continue; if ((ret = av_opt_get(obj, o->name, 0, &buf)) < 0) { av_bprint_finalize(&bprint, NULL); return ret; } if (buf) { if (cnt++) av_bprint_append_data(&bprint, &pairs_sep, 1); av_bprint_escape(&bprint, o->name, special_chars, AV_ESCAPE_MODE_BACKSLASH, 0); av_bprint_append_data(&bprint, &key_val_sep, 1); av_bprint_escape(&bprint, buf, special_chars, AV_ESCAPE_MODE_BACKSLASH, 0); av_freep(&buf); } } av_bprint_finalize(&bprint, buffer); return 0; }<SPLIT>[-0.25365086435942685, 0.2663159577768676, 0.0, -0.2665172434374763, 0.1893312466261345, 0.0, -0.24638545112987587, -0.2425966915157195, 0.4084056692221168, -0.27925050329511203, 0.2086571671460724, -0.25297036047912586, 0.29564718047544486, 0.0, 0.0, 0.30852482215402843, 0.13841132512592785, -0.26569807294376846, 0.21841756354466993, 1.0235043134279231, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, 0.11398295627503194, 0.18343000506680518, 0.7955408613214935, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, 0.40798885073507796, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, 0.4044334392007059, -0.28182971586402455]
0<SPLIT>static void reset_block_bap(AC3EncodeContext *s) { int blk, ch; uint8_t *ref_bap; if (s->ref_bap[0][0] == s->bap_buffer && s->ref_bap_set) return; ref_bap = s->bap_buffer; for (ch = 0; ch <= s->channels; ch++) { for (blk = 0; blk < s->num_blocks; blk++) s->ref_bap[ch][blk] = ref_bap + AC3_MAX_COEFS * s->exp_ref_block[ch][blk]; ref_bap += AC3_MAX_COEFS * s->num_blocks; } s->ref_bap_set = 1; }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.6586564490689124, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>AVInteger av_add_i(AVInteger a, AVInteger b){ int i, carry=0; for(i=0; i<AV_INTEGER_SIZE; i++){ carry= (carry>>16) + a.v[i] + b.v[i]; a.v[i]= carry; } return a; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int v4l2_set_parameters(AVFormatContext *ctx) { struct video_data *s = ctx->priv_data; struct v4l2_standard standard = { 0 }; struct v4l2_streamparm streamparm = { 0 }; struct v4l2_fract *tpf; AVRational framerate_q = { 0 }; int i, ret; if (s->framerate && (ret = av_parse_video_rate(&framerate_q, s->framerate)) < 0) { av_log(ctx, AV_LOG_ERROR, "Could not parse framerate '%s'.\n", s->framerate); return ret; } if (s->standard) { if (s->std_id) { ret = 0; av_log(ctx, AV_LOG_DEBUG, "Setting standard: %s\n", s->standard); for (i = 0; ; i++) { standard.index = i; if (v4l2_ioctl(s->fd, VIDIOC_ENUMSTD, &standard) < 0) { ret = AVERROR(errno); break; } if (!av_strcasecmp(standard.name, s->standard)) break; } if (ret < 0) { av_log(ctx, AV_LOG_ERROR, "Unknown or unsupported standard '%s'\n", s->standard); return ret; } if (v4l2_ioctl(s->fd, VIDIOC_S_STD, &standard.id) < 0) { ret = AVERROR(errno); av_log(ctx, AV_LOG_ERROR, "ioctl(VIDIOC_S_STD): %s\n", av_err2str(ret)); return ret; } } else { av_log(ctx, AV_LOG_WARNING, "This device does not support any standard\n"); } } if (v4l2_ioctl(s->fd, VIDIOC_G_STD, &s->std_id) == 0) { tpf = &standard.frameperiod; for (i = 0; ; i++) { standard.index = i; if (v4l2_ioctl(s->fd, VIDIOC_ENUMSTD, &standard) < 0) { ret = AVERROR(errno); if (ret == AVERROR(EINVAL) #ifdef ENODATA || ret == AVERROR(ENODATA) #endif ) { tpf = &streamparm.parm.capture.timeperframe; break; } av_log(ctx, AV_LOG_ERROR, "ioctl(VIDIOC_ENUMSTD): %s\n", av_err2str(ret)); return ret; } if (standard.id == s->std_id) { av_log(ctx, AV_LOG_DEBUG, "Current standard: %s, id: %"PRIx64", frameperiod: %d/%d\n", standard.name, (uint64_t)standard.id, tpf->numerator, tpf->denominator); break; } } } else { tpf = &streamparm.parm.capture.timeperframe; } streamparm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; if (v4l2_ioctl(s->fd, VIDIOC_G_PARM, &streamparm) < 0) { ret = AVERROR(errno); av_log(ctx, AV_LOG_ERROR, "ioctl(VIDIOC_G_PARM): %s\n", av_err2str(ret)); return ret; } if (framerate_q.num && framerate_q.den) { if (streamparm.parm.capture.capability & V4L2_CAP_TIMEPERFRAME) { tpf = &streamparm.parm.capture.timeperframe; av_log(ctx, AV_LOG_DEBUG, "Setting time per frame to %d/%d\n", framerate_q.den, framerate_q.num); tpf->numerator = framerate_q.den; tpf->denominator = framerate_q.num; if (v4l2_ioctl(s->fd, VIDIOC_S_PARM, &streamparm) < 0) { ret = AVERROR(errno); av_log(ctx, AV_LOG_ERROR, "ioctl(VIDIOC_S_PARM): %s\n", av_err2str(ret)); return ret; } if (framerate_q.num != tpf->denominator || framerate_q.den != tpf->numerator) { av_log(ctx, AV_LOG_INFO, "The driver changed the time per frame from " "%d/%d to %d/%d\n", framerate_q.den, framerate_q.num, tpf->numerator, tpf->denominator); } } else { av_log(ctx, AV_LOG_WARNING, "The driver does not permit changing the time per frame\n"); } } if (tpf->denominator > 0 && tpf->numerator > 0) { ctx->streams[0]->avg_frame_rate.num = tpf->denominator; ctx->streams[0]->avg_frame_rate.den = tpf->numerator; ctx->streams[0]->r_frame_rate = ctx->streams[0]->avg_frame_rate; } else av_log(ctx, AV_LOG_WARNING, "Time per frame unknown\n"); return 0; }<SPLIT>[0.05563366039355449, 1.7207311201043836, 0.0, 0.037794879441717756, 1.593730233443132, 0.0, 2.8818928143475766, 2.9387831490739704, 2.7301934809370603, 5.327786082535139, 1.5672212134614623, 0.061639525868012635, 1.7315986329451447, 0.0, 0.0, 0.30852482215402843, 1.4558174891064615, 0.04368374699580437, 1.6098712653146163, 0.6353133682363457, 1.674211516036959, 0.0, 0.02378964451747194, 0.9973611507722091, 1.1328153207340361, 2.145247230089466, 1.0213275968547075, 2.47944955092491, 2.5788689106479397, 2.880823316711111, 2.937867481060918, 2.7292055533170707, 5.326312112739897, 2.6191065950439585, 0.0, 2.8741508759799035, 2.9311578270720693, 2.722580082044891, 5.315074296953347]
0<SPLIT>void ff_vector_fmul_reverse_vsx(float *dst, const float *src0, const float *src1, int len) { int i; vec_f d, s0, s1, h0, l0, s2, s3; vec_f zero = (vec_f)vec_splat_u32(0); src1 += len - 4; for (i = 0; i < len - 7; i += 8) { s1 = vec_vsx_ld(0, src1 - i); s0 = vec_vsx_ld(0, src0 + i); l0 = vec_mergel(s1, s1); s3 = vec_vsx_ld(-16, src1 - i); h0 = vec_mergeh(s1, s1); s2 = vec_vsx_ld(16, src0 + i); s1 = vec_mergeh(vec_mergel(l0, h0), vec_mergeh(l0, h0)); l0 = vec_mergel(s3, s3); d = vec_madd(s0, s1, zero); h0 = vec_mergeh(s3, s3); vec_vsx_st(d, 0, dst + i); s3 = vec_mergeh(vec_mergel(l0, h0), vec_mergeh(l0, h0)); d = vec_madd(s2, s3, zero); vec_vsx_st(d, 16, dst + i); } }<SPLIT>[-0.09900860198293619, -0.08626953612071205, 0.0, -0.11436118199787926, -0.15112911381434976, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.09102607836467534, -0.09566541730555662, -0.06903890269146298, 0.0, 0.0, 0.30852482215402843, -0.152192975752131, -0.11100716297398205, -0.13496750357150694, 0.11772544131424245, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, -0.14353953243697165, -0.10760608081136262, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int avdevice_list_output_sinks(AVOutputFormat *device, const char *device_name, AVDictionary *device_options, AVDeviceInfoList **device_list) { AVFormatContext *s = NULL; int ret; if ((ret = avformat_alloc_output_context2(&s, device, device_name, NULL)) < 0) return ret; return list_devices_for_context(s, device_options, device_list); }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.41601414702345235, -0.4462861841111837, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void set_downmix_coeffs(AC3DecodeContext *s) { int i; float cmix = gain_levels[s-> center_mix_level]; float smix = gain_levels[s->surround_mix_level]; float norm0, norm1; float downmix_coeffs[AC3_MAX_CHANNELS][2]; for (i = 0; i < s->fbw_channels; i++) { downmix_coeffs[i][0] = gain_levels[ac3_default_coeffs[s->channel_mode][i][0]]; downmix_coeffs[i][1] = gain_levels[ac3_default_coeffs[s->channel_mode][i][1]]; } if (s->channel_mode > 1 && s->channel_mode & 1) { downmix_coeffs[1][0] = downmix_coeffs[1][1] = cmix; } if (s->channel_mode == AC3_CHMODE_2F1R || s->channel_mode == AC3_CHMODE_3F1R) { int nf = s->channel_mode - 2; downmix_coeffs[nf][0] = downmix_coeffs[nf][1] = smix * LEVEL_MINUS_3DB; } if (s->channel_mode == AC3_CHMODE_2F2R || s->channel_mode == AC3_CHMODE_3F2R) { int nf = s->channel_mode - 4; downmix_coeffs[nf][0] = downmix_coeffs[nf+1][1] = smix; } norm0 = norm1 = 0.0; for (i = 0; i < s->fbw_channels; i++) { norm0 += downmix_coeffs[i][0]; norm1 += downmix_coeffs[i][1]; } norm0 = 1.0f / norm0; norm1 = 1.0f / norm1; for (i = 0; i < s->fbw_channels; i++) { downmix_coeffs[i][0] *= norm0; downmix_coeffs[i][1] *= norm1; } if (s->output_mode == AC3_CHMODE_MONO) { for (i = 0; i < s->fbw_channels; i++) downmix_coeffs[i][0] = (downmix_coeffs[i][0] + downmix_coeffs[i][1]) * LEVEL_MINUS_3DB; } for (i = 0; i < s->fbw_channels; i++) { s->downmix_coeffs[i][0] = FIXR12(downmix_coeffs[i][0]); s->downmix_coeffs[i][1] = FIXR12(downmix_coeffs[i][1]); } }<SPLIT>[-0.09900860198293619, 0.2883525511454664, 0.0, -0.11436118199787926, 0.21061001915366473, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 0.24861493321417213, -0.09566541730555662, 0.3184400606733766, 0.0, 0.0, 0.30852482215402843, 0.17715856524300236, -0.11100716297398205, 0.24050413023943099, 0.11772544131424245, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 0.4301723107623091, 0.18343000506680518, 0.23107402248845843, -0.21702784222394986, 0.14602883551895066, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static int getopt(int argc, char *argv[], char *opts) { static int sp = 1; int c; char *cp; if (sp == 1) { if (optind >= argc || argv[optind][0] != '-' || argv[optind][1] == '\0') return EOF; else if (!strcmp(argv[optind], "--")) { optind++; return EOF; } } optopt = c = argv[optind][sp]; if (c == ':' || !(cp = strchr(opts, c))) { fprintf(stderr, ": illegal option -- %c\n", c); if (argv[optind][++sp] == '\0') { optind++; sp = 1; } return '?'; } if (*++cp == ':') { if (argv[optind][sp+1] != '\0') optarg = &argv[optind++][sp+1]; else if(++optind >= argc) { fprintf(stderr, ": option requires an argument -- %c\n", c); sp = 1; return '?'; } else optarg = argv[optind++]; sp = 1; } else { if (argv[optind][++sp] == '\0') { sp = 1; optind++; } optarg = NULL; } return c; }<SPLIT>[-0.25365086435942685, 0.2663159577768676, 0.0, -0.2665172434374763, 0.21061001915366473, 0.0, 1.1439604446378808, 1.1713499043019204, 1.2376156019774536, 1.040052222782594, 0.2086571671460724, -0.25297036047912586, 0.29564718047544486, 0.0, 0.0, 0.30852482215402843, 0.1577849451844651, -0.26569807294376846, 0.24050413023943099, 0.11772544131424245, 1.2357461089454749, 0.0, -0.08645738172306322, -0.16222078614455715, 0.07885080577644558, 0.7283792342397666, 0.005287286955244392, 2.47944955092491, 0.9881657846020622, 1.143335983750264, 1.1708005902540914, 1.2369948159429325, 1.039626388904333, 0.9056307075691036, 0.0, 1.1388542534712223, 1.1662853116856364, 1.2323429545022004, 1.0350888753871217]
0<SPLIT>static int func_eval_expr_int_format(AVFilterContext *ctx, AVBPrint *bp, char *fct, unsigned argc, char **argv, int tag) { DrawTextContext *s = ctx->priv; double res; int intval; int ret; unsigned int positions = 0; char fmt_str[30] = "%"; ret = av_expr_parse_and_eval(&res, argv[0], var_names, s->var_values, NULL, NULL, fun2_names, fun2, &s->prng, 0, ctx); if (ret < 0) { av_log(ctx, AV_LOG_ERROR, "Expression '%s' for the expr text expansion function is not valid\n", argv[0]); return ret; } if (!strchr("xXdu", argv[1][0])) { av_log(ctx, AV_LOG_ERROR, "Invalid format '%c' specified," " allowed values: 'x', 'X', 'd', 'u'\n", argv[1][0]); return AVERROR(EINVAL); } if (argc == 3) { ret = sscanf(argv[2], "%u", &positions); if (ret != 1) { av_log(ctx, AV_LOG_ERROR, "expr_int_format(): Invalid number of positions" " to print: '%s'\n", argv[2]); return AVERROR(EINVAL); } } feclearexcept(FE_ALL_EXCEPT); intval = res; if ((ret = fetestexcept(FE_INVALID|FE_OVERFLOW|FE_UNDERFLOW))) { av_log(ctx, AV_LOG_ERROR, "Conversion of floating-point result to int failed. Control register: 0x%08x. Conversion result: %d\n", ret, intval); return AVERROR(EINVAL); } if (argc == 3) av_strlcatf(fmt_str, sizeof(fmt_str), "0%u", positions); av_strlcatf(fmt_str, sizeof(fmt_str), "%c", argv[1][0]); av_log(ctx, AV_LOG_DEBUG, "Formatting value %f (expr '%s') with spec '%s'\n", res, argv[0], fmt_str); av_bprintf(bp, fmt_str, intval); return 0; }<SPLIT>[0.5195604475230265, 0.33242573788266383, 0.0, 0.4942630637605089, 0.25316756420872527, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, -0.27925050329511203, 0.3684882314184712, 0.5335543553887203, 0.3640258210692401, 0.0, 0.0, 0.30852482215402843, 0.29340028559422593, 0.5077564769051636, 0.28467726362895307, 1.1529012951584487, 1.0165134053997327, 0.0, -0.08645738172306322, -0.16222078614455715, 0.11398295627503194, 0.7283792342397666, 0.7955408613214935, -0.21702784222394986, 0.6138826961206794, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, -0.27935383381430245, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, -0.28182971586402455]
0<SPLIT>static int assign_pair(struct elem_to_channel e2c_vec[MAX_ELEM_ID], uint8_t (*layout_map)[3], int offset, uint64_t left, uint64_t right, int pos) { if (layout_map[offset][0] == TYPE_CPE) { e2c_vec[offset] = (struct elem_to_channel) { .av_position = left | right, .syn_ele = TYPE_CPE, .elem_id = layout_map[offset][1], .aac_position = pos }; return 1; } else { e2c_vec[offset] = (struct elem_to_channel) { .av_position = left, .syn_ele = TYPE_SCE, .elem_id = layout_map[offset][1], .aac_position = pos }; e2c_vec[offset + 1] = (struct elem_to_channel) { .av_position = right, .syn_ele = TYPE_SCE, .elem_id = layout_map[offset + 1][1], .aac_position = pos }; return 2; } }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, 0.14677370157107394, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 3.3489446507317613, 0.09966408500885333, -0.26569807294376846, 0.17424443015514782, -0.14106852214680915, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.25252937827156396, -0.3333928163445767, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.04739993194876201]
0<SPLIT>void av_bprint_channel_layout(struct AVBPrint *bp, int nb_channels, uint64_t channel_layout) { int i; if (nb_channels <= 0) nb_channels = av_get_channel_layout_nb_channels(channel_layout); for (i = 0; i < FF_ARRAY_ELEMS(channel_layout_map); i++) if (nb_channels == channel_layout_map[i].nb_channels && channel_layout == channel_layout_map[i].layout) { av_bprintf(bp, "%s", channel_layout_map[i].name); return; } av_bprintf(bp, "%d channels", nb_channels); if (channel_layout) { int i, ch; av_bprintf(bp, " ("); for (i = 0, ch = 0; i < 64; i++) { if ((channel_layout & (UINT64_C(1) << i))) { const char *name = get_channel_name(i); if (name) { if (ch > 0) av_bprintf(bp, "+"); av_bprintf(bp, "%s", name); } ch++; } } av_bprintf(bp, ")"); } }<SPLIT>[-0.25365086435942685, 0.0018768373536828752, 0.0, -0.2665172434374763, -0.06601402370422871, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, -0.27925050329511203, -0.031089429262525795, -0.25297036047912586, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, -0.09407211557651925, -0.26569807294376846, -0.04662123679246273, 0.24712242304476825, 0.6876643500811196, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, 0.5648944654878781, 0.34396739025506545, -0.21702784222394986, 0.7074534682410251, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, -0.27935383381430245, 3.475844538781386, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, -0.28182971586402455]
0<SPLIT>static AVFrame *alloc_audio_frame(enum AVSampleFormat sample_fmt, uint64_t channel_layout, int sample_rate, int nb_samples) { AVFrame *frame = av_frame_alloc(); int ret; if (!frame) { fprintf(stderr, "Error allocating an audio frame\n"); exit(1); } frame->format = sample_fmt; frame->channel_layout = channel_layout; frame->sample_rate = sample_rate; frame->nb_samples = nb_samples; if (nb_samples) { ret = av_frame_get_buffer(frame, 0); if (ret < 0) { fprintf(stderr, "Error allocating an audio buffer\n"); exit(1); } } return frame; }<SPLIT>[-0.25365086435942685, -0.15237931622650824, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, -0.17094161050087475, -0.25297036047912586, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, -0.14106852214680915, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.08904460951967552, -0.10760608081136262, -0.21702784222394986, -0.04111270872174079, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static av_always_inline void dither_8to16(const uint8_t *srcDither, int rot) { if (rot) { __asm__ volatile("pxor %%mm0, %%mm0\n\t" "movq (%0), %%mm3\n\t" "movq %%mm3, %%mm4\n\t" "psrlq $24, %%mm3\n\t" "psllq $40, %%mm4\n\t" "por %%mm4, %%mm3\n\t" "movq %%mm3, %%mm4\n\t" "punpcklbw %%mm0, %%mm3\n\t" "punpckhbw %%mm0, %%mm4\n\t" :: "r"(srcDither) ); } else { __asm__ volatile("pxor %%mm0, %%mm0\n\t" "movq (%0), %%mm3\n\t" "movq %%mm3, %%mm4\n\t" "punpcklbw %%mm0, %%mm3\n\t" "punpckhbw %%mm0, %%mm4\n\t" :: "r"(srcDither) ); } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.17240788634188003, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.19094021586920554, -0.26569807294376846, -0.157054070266268, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>int ff_acelp_decode_9bit_to_1st_delay6(int ac_index) { if(ac_index < 463) return ac_index + 105; else return 6 * (ac_index - 368); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5250039928580447, -0.7849662874110047, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void check_options(const OptionDef *po) { while (po->name) { if (po->flags & OPT_PERFILE) av_assert0(po->flags & (OPT_INPUT | OPT_OUTPUT)); po++; } }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>static int ws_snd_decode_frame(AVCodecContext *avctx, void *data, int *got_frame_ptr, AVPacket *avpkt) { WSSndContext *s = avctx->priv_data; const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; int in_size, out_size, ret; int sample = 128; uint8_t *samples; uint8_t *samples_end; if (!buf_size) return 0; if (buf_size < 4) { av_log(avctx, AV_LOG_ERROR, "packet is too small\n"); return AVERROR(EINVAL); } out_size = AV_RL16(&buf[0]); in_size = AV_RL16(&buf[2]); buf += 4; if (in_size > buf_size) { av_log(avctx, AV_LOG_ERROR, "Frame data is larger than input buffer\n"); return -1; } s->frame.nb_samples = out_size; if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return ret; } samples = s->frame.data[0]; samples_end = samples + out_size; if (in_size == out_size) { memcpy(samples, buf, out_size); *got_frame_ptr = 1; *(AVFrame *)data = s->frame; return buf_size; } while (samples < samples_end && buf - avpkt->data < buf_size) { int code, smp, size; uint8_t count; code = *buf >> 6; count = *buf & 0x3F; buf++; switch (code) { case 0: smp = 4*(count+1); break; case 1: smp = 2*(count+1); break; case 2: smp = (count & 0x20) ? 1 : count + 1; break; default: smp = count + 1; break; } if (samples_end - samples < smp) break; size = ((code == 2 && (count & 0x20)) || code == 3) ? 0 : count + 1; if ((buf - avpkt->data) + size > buf_size) break; switch (code) { case 0: for (count++; count > 0; count--) { code = *buf++; sample += ( code & 0x3) - 2; sample = av_clip_uint8(sample); *samples++ = sample; sample += ((code >> 2) & 0x3) - 2; sample = av_clip_uint8(sample); *samples++ = sample; sample += ((code >> 4) & 0x3) - 2; sample = av_clip_uint8(sample); *samples++ = sample; sample += (code >> 6) - 2; sample = av_clip_uint8(sample); *samples++ = sample; } break; case 1: for (count++; count > 0; count--) { code = *buf++; sample += ws_adpcm_4bit[code & 0xF]; sample = av_clip_uint8(sample); *samples++ = sample; sample += ws_adpcm_4bit[code >> 4]; sample = av_clip_uint8(sample); *samples++ = sample; } break; case 2: if (count & 0x20) { int8_t t; t = count; t <<= 3; sample += t >> 3; sample = av_clip_uint8(sample); *samples++ = sample; } else { memcpy(samples, buf, smp); samples += smp; buf += smp; sample = buf[-1]; } break; default: memset(samples, sample, smp); samples += smp; } } s->frame.nb_samples = samples - s->frame.data[0]; *got_frame_ptr = 1; *(AVFrame *)data = s->frame; return buf_size; }<SPLIT>[2.2206253336644237, 1.698694526735785, 0.0, 2.167979739596076, 1.5724514609156017, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, 1.040052222782594, 1.8269466929041103, 2.2639087302979823, 1.777184393341008, 0.0, 0.0, 0.30852482215402843, 1.707674549867446, 2.2093564865728146, 1.6540443987041384, 0.7647103499668715, 0.9068970536268617, 0.0, -0.08645738172306322, -0.16222078614455715, 2.221911986190213, 0.7828741571570628, 0.9084342290881006, -0.21702784222394986, 0.6138826961206794, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, 1.039626388904333, 0.04889276383167627, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 1.0350888753871217]
0<SPLIT>void av_opencl_free_external_env(AVOpenCLExternalEnv **ext_opencl_env) { av_freep(ext_opencl_env); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void paint_mouse_pointer(XImage *image, AVFormatContext *s1) { X11GrabContext *s = s1->priv_data; int x_off = s->x_off; int y_off = s->y_off; int width = s->width; int height = s->height; Display *dpy = s->dpy; XFixesCursorImage *xcim; int x, y; int line, column; int to_line, to_column; int pixstride = image->bits_per_pixel >> 3; uint8_t *pix = image->data; Window root; XSetWindowAttributes attr; if (image->bits_per_pixel != 24 && image->bits_per_pixel != 32) return; if (!s->c) s->c = XCreateFontCursor(dpy, XC_left_ptr); root = DefaultRootWindow(dpy); attr.cursor = s->c; XChangeWindowAttributes(dpy, root, CWCursor, &attr); xcim = XFixesGetCursorImage(dpy); if (!xcim) { av_log(s1, AV_LOG_WARNING, "XFixesGetCursorImage failed\n"); return; } x = xcim->x - xcim->xhot; y = xcim->y - xcim->yhot; to_line = FFMIN((y + xcim->height), (height + y_off)); to_column = FFMIN((x + xcim->width), (width + x_off)); for (line = FFMAX(y, y_off); line < to_line; line++) { for (column = FFMAX(x, x_off); column < to_column; column++) { int xcim_addr = (line - y) * xcim->width + column - x; int image_addr = ((line - y_off) * width + column - x_off) * pixstride; int r = (uint8_t)(xcim->pixels[xcim_addr] >> 0); int g = (uint8_t)(xcim->pixels[xcim_addr] >> 8); int b = (uint8_t)(xcim->pixels[xcim_addr] >> 16); int a = (uint8_t)(xcim->pixels[xcim_addr] >> 24); if (a == 255) { pix[image_addr + 0] = r; pix[image_addr + 1] = g; pix[image_addr + 2] = b; } else if (a) { pix[image_addr + 0] = r + (pix[image_addr + 0] * (255 - a) + 255 / 2) / 255; pix[image_addr + 1] = g + (pix[image_addr + 1] * (255 - a) + 255 / 2) / 255; pix[image_addr + 2] = b + (pix[image_addr + 2] * (255 - a) + 255 / 2) / 255; } } } XFree(xcim); xcim = NULL; }<SPLIT>[0.6742027098995172, 0.5527916715686512, 0.0, 0.6464191252001059, 0.4659552894840279, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 0.380400859743741, 0.5882559447930196, 0.6908592985622897, 0.5919546230485575, 0.0, 0.0, 0.30852482215402843, 0.5065101062381357, 0.66244738687495, 0.5055429305765636, 2.0586801672721293, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, 0.8517581167453454, 1.327823386330024, 2.0373679067541706, 1.5806237532086234, 0.42674115187998785, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 0.3801362775450152, 1.7623686513065309, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 0.3766295797615486]
0<SPLIT>void ff_aac_encode_main_pred(AACEncContext *s, SingleChannelElement *sce) { int sfb; IndividualChannelStream *ics = &sce->ics; const int pmax = FFMIN(ics->max_sfb, ff_aac_pred_sfb_max[s->samplerate_index]); if (!ics->predictor_present) return; put_bits(&s->pb, 1, !!ics->predictor_reset_group); if (ics->predictor_reset_group) put_bits(&s->pb, 5, ics->predictor_reset_group); for (sfb = 0; sfb < pmax; sfb++) put_bits(&s->pb, 1, ics->prediction_used[sfb]); }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.3615192241061562, -0.3333928163445767, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void ff_dither_free(DitherContext **cp) { DitherContext *c = *cp; int ch; if (!c) return; ff_audio_data_free(&c->flt_data); ff_audio_data_free(&c->s16_data); ff_audio_convert_free(&c->ac_in); ff_audio_convert_free(&c->ac_out); for (ch = 0; ch < c->channels; ch++) av_free(c->state[ch].noise_buf); av_free(c->state); av_freep(cp); }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.14106852214680915, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.3070243011888601, -0.22049944857796966, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void *child_next(void *obj, void *prev) { SPPContext *s = obj; return prev ? NULL : s->dct; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static const char* opengl_get_fragment_shader_code(enum AVPixelFormat format) { int i; for (i = 0; i < FF_ARRAY_ELEMS(opengl_format_desc); i++) { if (opengl_format_desc[i].fixel_format == format) return *opengl_format_desc[i].fragment_shader; } return NULL; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int decode_pce(AVCodecContext *avctx, MPEG4AudioConfig *m4ac, uint8_t (*layout_map)[3], GetBitContext *gb) { int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc; int sampling_index; int comment_len; int tags; skip_bits(gb, 2); sampling_index = get_bits(gb, 4); if (m4ac->sampling_index != sampling_index) av_log(avctx, AV_LOG_WARNING, "Sample rate index in program config element does not " "match the sample rate index configured by the container.\n"); num_front = get_bits(gb, 4); num_side = get_bits(gb, 4); num_back = get_bits(gb, 4); num_lfe = get_bits(gb, 2); num_assoc_data = get_bits(gb, 3); num_cc = get_bits(gb, 4); if (get_bits1(gb)) skip_bits(gb, 4); if (get_bits1(gb)) skip_bits(gb, 4); if (get_bits1(gb)) skip_bits(gb, 3); if (get_bits_left(gb) < 4 * (num_front + num_side + num_back + num_lfe + num_assoc_data + num_cc)) { av_log(avctx, AV_LOG_ERROR, "decode_pce: " overread_err); return -1; } decode_channel_map(layout_map , AAC_CHANNEL_FRONT, gb, num_front); tags = num_front; decode_channel_map(layout_map + tags, AAC_CHANNEL_SIDE, gb, num_side); tags += num_side; decode_channel_map(layout_map + tags, AAC_CHANNEL_BACK, gb, num_back); tags += num_back; decode_channel_map(layout_map + tags, AAC_CHANNEL_LFE, gb, num_lfe); tags += num_lfe; skip_bits_long(gb, 4 * num_assoc_data); decode_channel_map(layout_map + tags, AAC_CHANNEL_CC, gb, num_cc); tags += num_cc; align_get_bits(gb); comment_len = get_bits(gb, 8) * 8; if (get_bits_left(gb) < comment_len) { av_log(avctx, AV_LOG_ERROR, "decode_pce: " overread_err); return AVERROR_INVALIDDATA; } skip_bits_long(gb, comment_len); return tags; }<SPLIT>[-0.09900860198293619, 0.4426087047256575, 0.0, -0.11436118199787926, 0.3595614268463766, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.3884671144525211, -0.09566541730555662, 0.4779902220588988, 0.0, 0.0, 0.30852482215402843, 0.31277390565276314, -0.11100716297398205, 0.39511009710275835, 1.0235043134279231, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5355687622580682, 0.7283792342397666, 1.1342209646213146, -0.21702784222394986, 0.33317037975964214, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>int av_opt_set_sample_fmt(void *obj, const char *name, enum AVSampleFormat fmt, int search_flags) { return set_format(obj, name, fmt, search_flags, AV_OPT_TYPE_SAMPLE_FMT, "sample", AV_SAMPLE_FMT_NB); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void vector_fmul_scalar_c(float *dst, const float *src, float mul, int len) { int i; for (i = 0; i < len; i++) dst[i] = src[i] * mul; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.41601414702345235, -0.6720729196443977, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int dv1394_read_header(AVFormatContext * context) { struct dv1394_data *dv = context->priv_data; dv->dv_demux = avpriv_dv_init_demux(context); if (!dv->dv_demux) goto failed; dv->fd = avpriv_open(context->filename, O_RDONLY); if (dv->fd < 0) { av_log(context, AV_LOG_ERROR, "Failed to open DV interface: %s\n", strerror(errno)); goto failed; } if (dv1394_reset(dv) < 0) { av_log(context, AV_LOG_ERROR, "Failed to initialize DV interface: %s\n", strerror(errno)); goto failed; } dv->ring = mmap(NULL, DV1394_PAL_FRAME_SIZE * DV1394_RING_FRAMES, PROT_READ, MAP_PRIVATE, dv->fd, 0); if (dv->ring == MAP_FAILED) { av_log(context, AV_LOG_ERROR, "Failed to mmap DV ring buffer: %s\n", strerror(errno)); goto failed; } if (dv1394_start(dv) < 0) goto failed; return 0; failed: close(dv->fd); return AVERROR(EIO); }<SPLIT>[-0.09900860198293619, -0.04219634938351458, 0.0, -0.11436118199787926, -0.10857156875928925, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, 1.3698779043020206, -0.051068312296575644, -0.09566541730555662, -0.023453142295599506, 0.0, 0.0, 0.30852482215402843, -0.1134457356350565, -0.11100716297398205, -0.09079437018198484, 0.37651940477529405, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, 0.6193893884051743, 0.5697541257882794, 0.6817979554923368, 0.5203119240003335, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, 1.3693714445839917, 0.04889276383167627, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 1.3643185231999084]
0<SPLIT>static int parse_optarg(struct sbg_parser *p, char o, struct sbg_string *r) { if (!lex_wsword(p, r)) { snprintf(p->err_msg, sizeof(p->err_msg), "option '%c' requires an argument", o); return AVERROR_INVALIDDATA; } return 1; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.3615192241061562, -0.3333928163445767, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_cold int audio_write_header(AVFormatContext *s1) { AlsaData *s = s1->priv_data; AVStream *st = NULL; unsigned int sample_rate; enum AVCodecID codec_id; int res; if (s1->nb_streams != 1 || s1->streams[0]->codec->codec_type != AVMEDIA_TYPE_AUDIO) { av_log(s1, AV_LOG_ERROR, "Only a single audio stream is supported.\n"); return AVERROR(EINVAL); } st = s1->streams[0]; sample_rate = st->codec->sample_rate; codec_id = st->codec->codec_id; res = ff_alsa_open(s1, SND_PCM_STREAM_PLAYBACK, &sample_rate, st->codec->channels, &codec_id); if (sample_rate != st->codec->sample_rate) { av_log(s1, AV_LOG_ERROR, "sample rate %d not available, nearest is %d\n", st->codec->sample_rate, sample_rate); goto fail; } avpriv_set_pts_info(st, 64, 1, sample_rate); return res; fail: snd_pcm_close(s->h); return AVERROR(EIO); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.10857156875928925, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.13281935569359377, -0.26569807294376846, -0.09079437018198484, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>struct AVTEA *av_tea_alloc(void) { return av_mallocz(sizeof(struct AVTEA)); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static double eval_expr(Parser *p, AVExpr *e) { switch (e->type) { case e_value: return e->value; case e_const: return e->value * p->const_values[e->a.const_index]; case e_func0: return e->value * e->a.func0(eval_expr(p, e->param[0])); case e_func1: return e->value * e->a.func1(p->opaque, eval_expr(p, e->param[0])); case e_func2: return e->value * e->a.func2(p->opaque, eval_expr(p, e->param[0]), eval_expr(p, e->param[1])); case e_squish: return 1/(1+exp(4*eval_expr(p, e->param[0]))); case e_gauss: { double d = eval_expr(p, e->param[0]); return exp(-d*d/2)/sqrt(2*M_PI); } case e_ld: return e->value * p->var[av_clip(eval_expr(p, e->param[0]), 0, VARS-1)]; case e_isnan: return e->value * !!isnan(eval_expr(p, e->param[0])); case e_isinf: return e->value * !!isinf(eval_expr(p, e->param[0])); case e_floor: return e->value * floor(eval_expr(p, e->param[0])); case e_ceil : return e->value * ceil (eval_expr(p, e->param[0])); case e_trunc: return e->value * trunc(eval_expr(p, e->param[0])); case e_sqrt: return e->value * sqrt (eval_expr(p, e->param[0])); case e_not: return e->value * (eval_expr(p, e->param[0]) == 0); case e_if: return e->value * (eval_expr(p, e->param[0]) ? eval_expr(p, e->param[1]) : e->param[2] ? eval_expr(p, e->param[2]) : 0); case e_ifnot: return e->value * (!eval_expr(p, e->param[0]) ? eval_expr(p, e->param[1]) : e->param[2] ? eval_expr(p, e->param[2]) : 0); case e_clip: { double x = eval_expr(p, e->param[0]); double min = eval_expr(p, e->param[1]), max = eval_expr(p, e->param[2]); if (isnan(min) || isnan(max) || isnan(x) || min > max) return NAN; return e->value * av_clipd(eval_expr(p, e->param[0]), min, max); } case e_between: { double d = eval_expr(p, e->param[0]); return e->value * (d >= eval_expr(p, e->param[1]) && d <= eval_expr(p, e->param[2])); } case e_print: { double x = eval_expr(p, e->param[0]); int level = e->param[1] ? av_clip(eval_expr(p, e->param[1]), INT_MIN, INT_MAX) : AV_LOG_INFO; av_log(p, level, "%f\n", x); return x; } case e_random:{ int idx= av_clip(eval_expr(p, e->param[0]), 0, VARS-1); uint64_t r= isnan(p->var[idx]) ? 0 : p->var[idx]; r= r*1664525+1013904223; p->var[idx]= r; return e->value * (r * (1.0/UINT64_MAX)); } case e_while: { double d = NAN; while (eval_expr(p, e->param[0])) d=eval_expr(p, e->param[1]); return d; } case e_taylor: { double t = 1, d = 0, v; double x = eval_expr(p, e->param[1]); int id = e->param[2] ? av_clip(eval_expr(p, e->param[2]), 0, VARS-1) : 0; int i; double var0 = p->var[id]; for(i=0; i<1000; i++) { double ld = d; p->var[id] = i; v = eval_expr(p, e->param[0]); d += t*v; if(ld==d && v) break; t *= x / (i+1); } p->var[id] = var0; return d; } case e_root: { int i, j; double low = -1, high = -1, v, low_v = -DBL_MAX, high_v = DBL_MAX; double var0 = p->var[0]; double x_max = eval_expr(p, e->param[1]); for(i=-1; i<1024; i++) { if(i<255) { p->var[0] = ff_reverse[i&255]*x_max/255; } else { p->var[0] = x_max*pow(0.9, i-255); if (i&1) p->var[0] *= -1; if (i&2) p->var[0] += low; else p->var[0] += high; } v = eval_expr(p, e->param[0]); if (v<=0 && v>low_v) { low = p->var[0]; low_v = v; } if (v>=0 && v<high_v) { high = p->var[0]; high_v = v; } if (low>=0 && high>=0){ for (j=0; j<1000; j++) { p->var[0] = (low+high)*0.5; if (low == p->var[0] || high == p->var[0]) break; v = eval_expr(p, e->param[0]); if (v<=0) low = p->var[0]; if (v>=0) high= p->var[0]; if (isnan(v)) { low = high = v; break; } } break; } } p->var[0] = var0; return -low_v<high_v ? low : high; } default: { double d = eval_expr(p, e->param[0]); double d2 = eval_expr(p, e->param[1]); switch (e->type) { case e_mod: return e->value * (d - floor((!CONFIG_FTRAPV || d2) ? d / d2 : d * INFINITY) * d2); case e_gcd: return e->value * av_gcd(d,d2); case e_max: return e->value * (d > d2 ? d : d2); case e_min: return e->value * (d < d2 ? d : d2); case e_eq: return e->value * (d == d2 ? 1.0 : 0.0); case e_gt: return e->value * (d > d2 ? 1.0 : 0.0); case e_gte: return e->value * (d >= d2 ? 1.0 : 0.0); case e_lt: return e->value * (d < d2 ? 1.0 : 0.0); case e_lte: return e->value * (d <= d2 ? 1.0 : 0.0); case e_pow: return e->value * pow(d, d2); case e_mul: return e->value * (d * d2); case e_div: return e->value * ((!CONFIG_FTRAPV || d2 ) ? (d / d2) : d * INFINITY); case e_add: return e->value * (d + d2); case e_last:return e->value * d2; case e_st : return e->value * (p->var[av_clip(d, 0, VARS-1)]= d2); case e_hypot:return e->value * (sqrt(d*d + d2*d2)); case e_bitand: return isnan(d) || isnan(d2) ? NAN : e->value * ((long int)d & (long int)d2); case e_bitor: return isnan(d) || isnan(d2) ? NAN : e->value * ((long int)d | (long int)d2); } } } return NAN; }<SPLIT>[-0.25365086435942685, 2.425902107899543, 0.0, -0.2665172434374763, 2.2746509543241005, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 2.166587704482958, -0.25297036047912586, 2.5293494398727554, 0.0, 0.0, 0.30852482215402843, 2.0370260908625792, -0.26569807294376846, 2.3829010996312534, 3.2232530028468616, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 2.8191585446661813, 1.4913081550819125, 3.730768423253276, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int run_test(int cbc, int decrypt) { AVDES d; int delay = cbc && !decrypt ? 2 : 1; uint64_t res; AV_WB64(large_buffer[0], 0x4e6f772069732074ULL); AV_WB64(large_buffer[1], 0x1234567890abcdefULL); AV_WB64(tmp, 0x1234567890abcdefULL); av_des_init(&d, cbc_key, 192, decrypt); av_des_crypt(&d, large_buffer[delay], large_buffer[0], 10000, cbc ? tmp : NULL, decrypt); res = AV_RB64(large_buffer[9999 + delay]); if (cbc) { if (decrypt) return res == 0xc5cecf63ecec514cULL; else return res == 0xcb191f85d1ed8439ULL; } else { if (decrypt) return res == 0x8325397644091a0aULL; else return res == 0xdd17e8b8b437d232ULL; } }<SPLIT>[-0.25365086435942685, -0.17441590959510697, 0.0, -0.2665172434374763, -0.23624420392447085, 0.0, -0.07259221415890627, -0.06585336703851451, 0.07672169611998206, -0.27925050329511203, -0.1909204935349246, -0.25297036047912586, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.26569807294376846, -0.22331377035055117, -0.14106852214680915, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.3615192241061562, -0.22049944857796966, -0.21702784222394986, -0.4153957972031237, -0.07290514932232937, -0.06614623331068743, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>int av_opencl_buffer_create(cl_mem *cl_buf, size_t cl_buf_size, int flags, void *host_ptr) { cl_int status; *cl_buf = clCreateBuffer(opencl_ctx.context, flags, cl_buf_size, host_ptr, &status); if (status != CL_SUCCESS) { av_log(&opencl_ctx, AV_LOG_ERROR, "Could not create OpenCL buffer: %s\n", av_opencl_errstr(status)); return AVERROR_EXTERNAL; } return 0; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.41601414702345235, -0.4462861841111837, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static enum AVSampleFormat find_best_sample_fmt_of_2(enum AVSampleFormat dst_fmt1, enum AVSampleFormat dst_fmt2, enum AVSampleFormat src_fmt) { int score1, score2; score1 = get_fmt_score(dst_fmt1, src_fmt); score2 = get_fmt_score(dst_fmt2, src_fmt); return score1 < score2 ? dst_fmt1 : dst_fmt2; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.39986248560786075, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.3070243011888601, -0.3333928163445767, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, -0.8078451799057511, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { int i; PaletteUseContext *s = ctx->priv; ff_dualinput_uninit(&s->dinput); for (i = 0; i < CACHE_SIZE; i++) av_freep(&s->cache[i].entries); av_frame_free(&s->last_in); av_frame_free(&s->last_out); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>void ff_aac_encode_tns_info(AACEncContext *s, SingleChannelElement *sce) { uint8_t u_coef; const uint8_t coef_res = TNS_Q_BITS == 4; int i, w, filt, coef_len, coef_compress = 0; const int is8 = sce->ics.window_sequence[0] == EIGHT_SHORT_SEQUENCE; TemporalNoiseShaping *tns = &sce->tns; if (!sce->tns.present) return; for (i = 0; i < sce->ics.num_windows; i++) { put_bits(&s->pb, 2 - is8, sce->tns.n_filt[i]); if (tns->n_filt[i]) { put_bits(&s->pb, 1, coef_res); for (filt = 0; filt < tns->n_filt[i]; filt++) { put_bits(&s->pb, 6 - 2 * is8, tns->length[i][filt]); put_bits(&s->pb, 5 - 2 * is8, tns->order[i][filt]); if (tns->order[i][filt]) { put_bits(&s->pb, 1, !!tns->direction[i][filt]); put_bits(&s->pb, 1, !!coef_compress); coef_len = coef_res + 3 - coef_compress; for (w = 0; w < tns->order[i][filt]; w++) { u_coef = (tns->coef_idx[i][filt][w])&(~(~0<<coef_len)); put_bits(&s->pb, coef_len, u_coef); } } } } } }<SPLIT>[-0.25365086435942685, -0.020159756014915854, 0.0, -0.2665172434374763, -0.08729279623175898, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.051068312296575644, -0.25297036047912586, -0.0006602620976677653, 0.0, 0.0, 0.30852482215402843, -0.1134457356350565, -0.26569807294376846, -0.06870780348722379, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.043718655277859224, -0.14353953243697165, 0.11818065472185141, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { static const enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_GRAY8, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUVA420P, AV_PIX_FMT_YUVA422P, AV_PIX_FMT_YUVA444P, AV_PIX_FMT_YUV440P, AV_PIX_FMT_YUV411P, AV_PIX_FMT_YUV410P, AV_PIX_FMT_YUVJ411P, AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ440P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_GBRP, AV_PIX_FMT_GBRAP, AV_PIX_FMT_NONE }; AVFilterFormats *fmts_list = ff_make_format_list(pix_fmts); if (!fmts_list) return AVERROR(ENOMEM); return ff_set_common_formats(ctx, fmts_list); }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.14106852214680915, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.3615192241061562, -0.10760608081136262, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void handle_rtp_info(RTSPState *rt, const char *url, uint32_t seq, uint32_t rtptime) { int i; if (!rtptime || !url[0]) return; if (rt->transport != RTSP_TRANSPORT_RTP) return; for (i = 0; i < rt->nb_rtsp_streams; i++) { RTSPStream *rtsp_st = rt->rtsp_streams[i]; RTPDemuxContext *rtpctx = rtsp_st->transport_priv; if (!rtpctx) continue; if (!strcmp(rtsp_st->control_url, url)) { rtpctx->base_timestamp = rtptime; break; } } }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, -0.39986248560786075, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.3615192241061562, -0.5591795518777907, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static av_always_inline void yuv2422_X_c_template(SwsContext *c, const int16_t *lumFilter, const int16_t **lumSrc, int lumFilterSize, const int16_t *chrFilter, const int16_t **chrUSrc, const int16_t **chrVSrc, int chrFilterSize, const int16_t **alpSrc, uint8_t *dest, int dstW, int y, enum AVPixelFormat target) { int i; for (i = 0; i < ((dstW + 1) >> 1); i++) { int j; int Y1 = 1 << 18; int Y2 = 1 << 18; int U = 1 << 18; int V = 1 << 18; for (j = 0; j < lumFilterSize; j++) { Y1 += lumSrc[j][i * 2] * lumFilter[j]; Y2 += lumSrc[j][i * 2 + 1] * lumFilter[j]; } for (j = 0; j < chrFilterSize; j++) { U += chrUSrc[j][i] * chrFilter[j]; V += chrVSrc[j][i] * chrFilter[j]; } Y1 >>= 19; Y2 >>= 19; U >>= 19; V >>= 19; if ((Y1 | Y2 | U | V) & 0x100) { Y1 = av_clip_uint8(Y1); Y2 = av_clip_uint8(Y2); U = av_clip_uint8(U); V = av_clip_uint8(V); } output_pixels(4*i, Y1, U, Y2, V); } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, 0.06165861146095288, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.022169604774704303, -0.26569807294376846, 0.08589816337610359, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.18424725727220465, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
1<SPLIT>int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt, const char *filename, void *logctx, unsigned int offset, unsigned int max_probe_size) { AVProbeData pd = { filename ? filename : "", NULL, -offset }; unsigned char *buf = NULL; int ret = 0, probe_size, buf_offset = 0; if (!max_probe_size) { max_probe_size = PROBE_BUF_MAX; } else if (max_probe_size > PROBE_BUF_MAX) { max_probe_size = PROBE_BUF_MAX; } else if (max_probe_size < PROBE_BUF_MIN) { return AVERROR(EINVAL); } if (offset >= max_probe_size) { return AVERROR(EINVAL); } for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt; probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) { int score = probe_size < max_probe_size ? AVPROBE_SCORE_MAX/4 : 0; int buf_offset = (probe_size == PROBE_BUF_MIN) ? 0 : probe_size>>1; void *buftmp; if (probe_size < offset) { continue; } buftmp = av_realloc(buf, probe_size + AVPROBE_PADDING_SIZE); if(!buftmp){ av_free(buf); return AVERROR(ENOMEM); } buf=buftmp; if ((ret = avio_read(pb, buf + buf_offset, probe_size - buf_offset)) < 0) { if (ret != AVERROR_EOF) { av_free(buf); return ret; } score = 0; ret = 0; } pd.buf_size = buf_offset += ret; pd.buf = &buf[offset]; memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE); *fmt = av_probe_input_format2(&pd, 1, &score); if(*fmt){ if(score <= AVPROBE_SCORE_MAX/4){ av_log(logctx, AV_LOG_WARNING, "Format %s detected only with low score of %d, misdetection possible!\n", (*fmt)->name, score); }else av_log(logctx, AV_LOG_DEBUG, "Format %s probed with size=%d and score=%d\n", (*fmt)->name, probe_size, score); } } if (!*fmt) { av_free(buf); return AVERROR_INVALIDDATA; } if ((ret = ffio_rewind_with_probe_data(pb, buf, pd.buf_size)) < 0) av_free(buf); return ret; }<SPLIT>[1.9113408089114425, 0.6189014516744473, 0.0, 1.863667616716882, 0.5297916070666188, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, -0.27925050329511203, 0.8080236581675679, 1.9492988439508436, 0.6603332636423527, 0.0, 0.0, 0.30852482215402843, 0.7196199268820456, 1.8999746666332415, 0.5718026306608468, 1.2822982768889746, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3950401602637228, 0.5648944654878781, 1.1342209646213146, -0.21702784222394986, 0.05245806339860493, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, -0.27935383381430245, 0.04889276383167627, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, -0.28182971586402455]
0<SPLIT>static int mxf_read_strong_ref_array(AVIOContext *pb, UID **refs, int *count) { *count = avio_rb32(pb); *refs = av_calloc(*count, sizeof(UID)); if (!*refs) { *count = 0; return AVERROR(ENOMEM); } avio_skip(pb, 4); avio_read(pb, (uint8_t *)*refs, *count * sizeof(UID)); return 0; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.14106852214680915, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.25252937827156396, -0.22049944857796966, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int alac_encode_frame(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *got_packet_ptr) { AlacEncodeContext *s = avctx->priv_data; int out_bytes, max_frame_size, ret; s->frame_size = frame->nb_samples; if (frame->nb_samples < DEFAULT_FRAME_SIZE) max_frame_size = get_max_frame_size(s->frame_size, avctx->channels, avctx->bits_per_raw_sample); else max_frame_size = s->max_coded_frame_size; if ((ret = ff_alloc_packet2(avctx, avpkt, 2 * max_frame_size, 0)) < 0) return ret; if (s->compression_level) { s->verbatim = 0; s->extra_bits = avctx->bits_per_raw_sample - 16; } else { s->verbatim = 1; s->extra_bits = 0; } out_bytes = write_frame(s, avpkt, frame->extended_data); if (out_bytes > max_frame_size) { s->verbatim = 1; s->extra_bits = 0; out_bytes = write_frame(s, avpkt, frame->extended_data); } avpkt->size = out_bytes; *got_packet_ptr = 1; return 0; }<SPLIT>[0.05563366039355449, 0.0018768373536828752, 0.0, 0.037794879441717756, -0.06601402370422871, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.008868336805573909, 0.061639525868012635, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, -0.05532487545944473, 0.04368374699580437, -0.04662123679246273, -0.14106852214680915, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.03454968660237938, -0.10760608081136262, -0.21702784222394986, 0.05245806339860493, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static int modify_current_stream(HTTPContext *c, char *rates) { int i; FFServerStream *req = c->stream; int action_required = 0; if (!req->feed) return 0; for (i = 0; i < req->nb_streams; i++) { AVCodecParameters *codec = req->streams[i]->codecpar; switch(rates[i]) { case 0: c->switch_feed_streams[i] = req->feed_streams[i]; break; case 1: c->switch_feed_streams[i] = find_stream_in_feed(req->feed, codec, codec->bit_rate / 2); break; case 2: c->switch_feed_streams[i] = find_stream_in_feed(req->feed, codec, codec->bit_rate / 4); #ifdef WANTS_OFF c->switch_feed_streams[i] = -2; c->feed_streams[i] = -2; #endif break; } if (c->switch_feed_streams[i] >= 0 && c->switch_feed_streams[i] != c->feed_streams[i]) { action_required = 1; } } return action_required; }<SPLIT>[0.21027592277004517, 0.023913430722281605, 0.0, 0.18995094088131478, -0.044735251176698444, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.04882610287367361, 0.061639525868012635, -0.04624602249353125, 0.0, 0.0, 0.30852482215402843, -0.016577635342370212, 0.04368374699580437, -0.1128809368767459, -0.39986248560786075, -0.07965011232897776, 0.0, 0.24428369699854227, 0.9973611507722091, -0.0968099467164862, -0.3615192241061562, -0.4462861841111837, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int lum_h_scale(SwsContext *c, SwsFilterDescriptor *desc, int sliceY, int sliceH) { FilterContext *instance = desc->instance; int srcW = desc->src->width; int dstW = desc->dst->width; int xInc = instance->xInc; int i; for (i = 0; i < sliceH; ++i) { uint8_t ** src = desc->src->plane[0].line; uint8_t ** dst = desc->dst->plane[0].line; int src_pos = sliceY+i - desc->src->plane[0].sliceY; int dst_pos = sliceY+i - desc->dst->plane[0].sliceY; if (c->hyscale_fast) { c->hyscale_fast(c, (int16_t*)dst[dst_pos], dstW, src[src_pos], srcW, xInc); } else { c->hyScale(c, (int16_t*)dst[dst_pos], dstW, (const uint8_t *)src[src_pos], instance->filter, instance->filter_pos, instance->filter_size); } if (c->lumConvertRange) c->lumConvertRange((int16_t*)dst[dst_pos], dstW); desc->dst->plane[0].sliceH += 1; if (desc->alpha) { src = desc->src->plane[3].line; dst = desc->dst->plane[3].line; src_pos = sliceY+i - desc->src->plane[3].sliceY; dst_pos = sliceY+i - desc->dst->plane[3].sliceY; desc->dst->plane[3].sliceH += 1; if (c->hyscale_fast) { c->hyscale_fast(c, (int16_t*)dst[dst_pos], dstW, src[src_pos], srcW, xInc); } else { c->hyScale(c, (int16_t*)dst[dst_pos], dstW, (const uint8_t *)src[src_pos], instance->filter, instance->filter_pos, instance->filter_size); } } } return sliceH; }<SPLIT>[-0.25365086435942685, 0.15613299093387398, 0.0, -0.2665172434374763, 0.08293738398848315, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 0.10876275197582316, -0.25297036047912586, 0.18168277948578615, 0.0, 0.0, 0.30852482215402843, 0.04154322483324156, -0.26569807294376846, 0.10798473007086465, -0.011671540416283347, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, 0.11398295627503194, 0.01994523631491676, -0.10760608081136262, -0.21702784222394986, 0.14602883551895066, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 1.7623686513065309, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static int read_random(uint32_t *dst, const char *file) { #if HAVE_UNISTD_H int fd = avpriv_open(file, O_RDONLY); int err = -1; if (fd == -1) return -1; err = read(fd, dst, sizeof(*dst)); close(fd); return err; #else return -1; #endif }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.4084991676475909, 0.0, 0.6852718019606829, 1.5771521192305922, -0.44813145170234975, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static inline void RENAME(vertX1Filter)(uint8_t *src, int stride, PPContext *co) { #if TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW src+= stride*3; __asm__ volatile( "pxor %%mm7, %%mm7 \n\t" "lea (%0, %1), %%"REG_a" \n\t" "lea (%%"REG_a", %1, 4), %%"REG_c" \n\t" "movq (%%"REG_a", %1, 2), %%mm0 \n\t" "movq (%0, %1, 4), %%mm1 \n\t" "movq %%mm1, %%mm2 \n\t" "psubusb %%mm0, %%mm1 \n\t" "psubusb %%mm2, %%mm0 \n\t" "por %%mm1, %%mm0 \n\t" "movq (%%"REG_c"), %%mm3 \n\t" "movq (%%"REG_c", %1), %%mm4 \n\t" "movq %%mm3, %%mm5 \n\t" "psubusb %%mm4, %%mm3 \n\t" "psubusb %%mm5, %%mm4 \n\t" "por %%mm4, %%mm3 \n\t" PAVGB(%%mm3, %%mm0) "movq %%mm2, %%mm1 \n\t" "psubusb %%mm5, %%mm2 \n\t" "movq %%mm2, %%mm4 \n\t" "pcmpeqb %%mm7, %%mm2 \n\t" "psubusb %%mm1, %%mm5 \n\t" "por %%mm5, %%mm4 \n\t" "psubusb %%mm0, %%mm4 \n\t" "movq %%mm4, %%mm3 \n\t" "movq %2, %%mm0 \n\t" "paddusb %%mm0, %%mm0 \n\t" "psubusb %%mm0, %%mm4 \n\t" "pcmpeqb %%mm7, %%mm4 \n\t" "psubusb "MANGLE(b01)", %%mm3 \n\t" "pand %%mm4, %%mm3 \n\t" PAVGB(%%mm7, %%mm3) "movq %%mm3, %%mm1 \n\t" PAVGB(%%mm7, %%mm3) PAVGB(%%mm1, %%mm3) "movq (%0, %1, 4), %%mm0 \n\t" "pxor %%mm2, %%mm0 \n\t" "psubusb %%mm3, %%mm0 \n\t" "pxor %%mm2, %%mm0 \n\t" "movq %%mm0, (%0, %1, 4) \n\t" "movq (%%"REG_c"), %%mm0 \n\t" "pxor %%mm2, %%mm0 \n\t" "paddusb %%mm3, %%mm0 \n\t" "pxor %%mm2, %%mm0 \n\t" "movq %%mm0, (%%"REG_c") \n\t" PAVGB(%%mm7, %%mm1) "movq (%%"REG_a", %1, 2), %%mm0 \n\t" "pxor %%mm2, %%mm0 \n\t" "psubusb %%mm1, %%mm0 \n\t" "pxor %%mm2, %%mm0 \n\t" "movq %%mm0, (%%"REG_a", %1, 2) \n\t" "movq (%%"REG_c", %1), %%mm0 \n\t" "pxor %%mm2, %%mm0 \n\t" "paddusb %%mm1, %%mm0 \n\t" "pxor %%mm2, %%mm0 \n\t" "movq %%mm0, (%%"REG_c", %1) \n\t" PAVGB(%%mm7, %%mm1) "movq (%%"REG_a", %1), %%mm0 \n\t" "pxor %%mm2, %%mm0 \n\t" "psubusb %%mm1, %%mm0 \n\t" "pxor %%mm2, %%mm0 \n\t" "movq %%mm0, (%%"REG_a", %1) \n\t" "movq (%%"REG_c", %1, 2), %%mm0 \n\t" "pxor %%mm2, %%mm0 \n\t" "paddusb %%mm1, %%mm0 \n\t" "pxor %%mm2, %%mm0 \n\t" "movq %%mm0, (%%"REG_c", %1, 2) \n\t" : : "r" (src), "r" ((x86_reg)stride), "m" (co->pQPb) NAMED_CONSTRAINTS_ADD(b01) : "%"REG_a, "%"REG_c ); #else const int l1= stride; const int l2= stride + l1; const int l3= stride + l2; const int l4= stride + l3; const int l5= stride + l4; const int l6= stride + l5; const int l7= stride + l6; int x; src+= stride*3; for(x=0; x<BLOCK_SIZE; x++){ int a= src[l3] - src[l4]; int b= src[l4] - src[l5]; int c= src[l5] - src[l6]; int d= FFABS(b) - ((FFABS(a) + FFABS(c))>>1); d= FFMAX(d, 0); if(d < co->QP*2){ int v = d * FFSIGN(-b); src[l2] +=v>>3; src[l3] +=v>>2; src[l4] +=(3*v)>>3; src[l5] -=(3*v)>>3; src[l6] -=v>>2; src[l7] -=v>>3; } src++; } #endif }<SPLIT>[0.36491818514653585, 1.6546213399985874, 0.0, 0.34210700232091185, 1.5298939158605411, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 1.5472423304274125, 0.061639525868012635, -0.0006602620976677653, 0.0, 0.0, 0.30852482215402843, 1.4364438690479242, 0.04368374699580437, -0.06870780348722379, 1.0235043134279231, -0.518115519420462, 0.0, 8.182069586317073, 1.5771521192305922, 0.21937940777079099, 0.18343000506680518, 1.0213275968547075, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int av_samples_copy(uint8_t **dst, uint8_t * const *src, int dst_offset, int src_offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt) { int planar = av_sample_fmt_is_planar(sample_fmt); int planes = planar ? nb_channels : 1; int block_align = av_get_bytes_per_sample(sample_fmt) * (planar ? 1 : nb_channels); int data_size = nb_samples * block_align; int i; dst_offset *= block_align; src_offset *= block_align; if((dst[0] < src[0] ? src[0] - dst[0] : dst[0] - src[0]) >= data_size) { for (i = 0; i < planes; i++) memcpy(dst[i] + dst_offset, src[i] + src_offset, data_size); } else { for (i = 0; i < planes; i++) memmove(dst[i] + dst_offset, src[i] + src_offset, data_size); } return 0; }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, 0.37651940477529405, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, 0.0744401592322129, 0.34396739025506545, -0.21702784222394986, -0.13468348084208653, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void copy_rev (FFTSample *dest, int w, int w2) { int i; for (i = w; i < w + (w2-w)/2; i++) dest[i] = dest[2*w - i - 1]; for (; i < w2; i++) dest[i] = dest[w2 - i]; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int read_int(char *arg) { int ret; if (!arg || !*arg) return -1; ret = strtol(arg, &arg, 0); if (*arg) return -1; return ret; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.07259221415890627, -0.06585336703851451, 0.07672169611998206, 0.380400859743741, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.5292594673383866, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.25252937827156396, -0.5591795518777907, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, 0.07638646465193619, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, 0.07326963308010803, 0.3766295797615486]
0<SPLIT>int opt_loglevel(void *optctx, const char *opt, const char *arg) { const struct { const char *name; int level; } log_levels[] = { { "quiet" , AV_LOG_QUIET }, { "panic" , AV_LOG_PANIC }, { "fatal" , AV_LOG_FATAL }, { "error" , AV_LOG_ERROR }, { "warning", AV_LOG_WARNING }, { "info" , AV_LOG_INFO }, { "verbose", AV_LOG_VERBOSE }, { "debug" , AV_LOG_DEBUG }, { "trace" , AV_LOG_TRACE }, };<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.4705090699407485, -0.3333928163445767, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int parse_cube(AVFilterContext *ctx, FILE *f) { LUT3DContext *lut3d = ctx->priv; char line[MAX_LINE_SIZE]; float min[3] = {0.0, 0.0, 0.0}; float max[3] = {1.0, 1.0, 1.0}; while (fgets(line, sizeof(line), f)) { if (!strncmp(line, "LUT_3D_SIZE ", 12)) { int i, j, k; const int size = strtol(line + 12, NULL, 0); if (size < 2 || size > MAX_LEVEL) { av_log(ctx, AV_LOG_ERROR, "Too large or invalid 3D LUT size\n"); return AVERROR(EINVAL); } lut3d->lutsize = size; for (k = 0; k < size; k++) { for (j = 0; j < size; j++) { for (i = 0; i < size; i++) { struct rgbvec *vec = &lut3d->lut[i][j][k]; do { NEXT_LINE(0); if (!strncmp(line, "DOMAIN_", 7)) { float *vals = NULL; if (!strncmp(line + 7, "MIN ", 4)) vals = min; else if (!strncmp(line + 7, "MAX ", 4)) vals = max; if (!vals) return AVERROR_INVALIDDATA; sscanf(line + 11, "%f %f %f", vals, vals + 1, vals + 2); av_log(ctx, AV_LOG_DEBUG, "min: %f %f %f | max: %f %f %f\n", min[0], min[1], min[2], max[0], max[1], max[2]); continue; } } while (skip_line(line)); if (sscanf(line, "%f %f %f", &vec->r, &vec->g, &vec->b) != 3) return AVERROR_INVALIDDATA; vec->r *= max[0] - min[0]; vec->g *= max[1] - min[1]; vec->b *= max[2] - min[2]; } } } break; } } return 0; }<SPLIT>[-0.25365086435942685, 0.35446233125126253, 0.0, -0.2665172434374763, 0.2744463367362555, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.2885726992822718, -0.25297036047912586, 0.3868187012671718, 0.0, 0.0, 0.30852482215402843, 0.21590580536007686, -0.26569807294376846, 0.3067638303237141, 1.0235043134279231, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3950401602637228, 0.3469147738186936, 1.2471143323879217, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void format_date_now(char *buf, int size) { time_t t = time(NULL); struct tm *ptm, tmbuf; ptm = gmtime_r(&t, &tmbuf); if (ptm) { if (!strftime(buf, size, "%Y-%m-%dT%H:%M:%S", ptm)) buf[0] = '\0'; } }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.14353953243697165, 0.005287286955244392, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *frame) { AVFilterContext *ctx = inlink->dst; SelectContext *select = ctx->priv; select_frame(ctx, frame); if (select->select) return ff_filter_frame(ctx->outputs[select->select_out], frame); av_frame_free(&frame); return 0; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int config_output(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; StackContext *s = ctx->priv; AVRational time_base = ctx->inputs[0]->time_base; AVRational frame_rate = ctx->inputs[0]->frame_rate; int height = ctx->inputs[0]->h; int width = ctx->inputs[0]->w; FFFrameSyncIn *in; int i, ret; if (s->is_vertical) { for (i = 1; i < s->nb_inputs; i++) { if (ctx->inputs[i]->w != width) { av_log(ctx, AV_LOG_ERROR, "Input %d width %d does not match input %d width %d.\n", i, ctx->inputs[i]->w, 0, width); return AVERROR(EINVAL); } height += ctx->inputs[i]->h; } } else { for (i = 1; i < s->nb_inputs; i++) { if (ctx->inputs[i]->h != height) { av_log(ctx, AV_LOG_ERROR, "Input %d height %d does not match input %d height %d.\n", i, ctx->inputs[i]->h, 0, height); return AVERROR(EINVAL); } width += ctx->inputs[i]->w; } } s->desc = av_pix_fmt_desc_get(outlink->format); if (!s->desc) return AVERROR_BUG; s->nb_planes = av_pix_fmt_count_planes(outlink->format); outlink->w = width; outlink->h = height; outlink->time_base = time_base; outlink->frame_rate = frame_rate; if ((ret = ff_framesync_init(&s->fs, ctx, s->nb_inputs)) < 0) return ret; in = s->fs.in; s->fs.opaque = s; s->fs.on_event = process_frame; for (i = 0; i < s->nb_inputs; i++) { AVFilterLink *inlink = ctx->inputs[i]; in[i].time_base = inlink->time_base; in[i].sync = 1; in[i].before = EXT_STOP; in[i].after = EXT_INFINITY; } return ff_framesync_configure(&s->fs); }<SPLIT>[-0.25365086435942685, 0.42057211135705874, 0.0, -0.2665172434374763, 0.33828265431884635, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.3485093483844214, -0.25297036047912586, 0.45519734186096705, 0.0, 0.0, 0.30852482215402843, 0.27402666553568866, -0.26569807294376846, 0.3730235304079973, 0.37651940477529405, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.6058330632552409, 0.01994523631491676, 0.34396739025506545, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { AssContext *ass = ctx->priv; if (ass->track) ass_free_track(ass->track); if (ass->renderer) ass_renderer_done(ass->renderer); if (ass->library) ass_library_done(ass->library); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int read_interval_packets(WriterContext *w, InputFile *ifile, const ReadInterval *interval, int64_t *cur_ts) { AVFormatContext *fmt_ctx = ifile->fmt_ctx; AVPacket pkt, pkt1; AVFrame *frame = NULL; int ret = 0, i = 0, frame_count = 0; int64_t start = -INT64_MAX, end = interval->end; int has_start = 0, has_end = interval->has_end && !interval->end_is_offset; av_init_packet(&pkt); av_log(NULL, AV_LOG_VERBOSE, "Processing read interval "); log_read_interval(interval, NULL, AV_LOG_VERBOSE); if (interval->has_start) { int64_t target; if (interval->start_is_offset) { if (*cur_ts == AV_NOPTS_VALUE) { av_log(NULL, AV_LOG_ERROR, "Could not seek to relative position since current " "timestamp is not defined\n"); ret = AVERROR(EINVAL); goto end; } target = *cur_ts + interval->start; } else { target = interval->start; } av_log(NULL, AV_LOG_VERBOSE, "Seeking to read interval start point %s\n", av_ts2timestr(target, &AV_TIME_BASE_Q)); if ((ret = avformat_seek_file(fmt_ctx, -1, -INT64_MAX, target, INT64_MAX, 0)) < 0) { av_log(NULL, AV_LOG_ERROR, "Could not seek to position %"PRId64": %s\n", interval->start, av_err2str(ret)); goto end; } } frame = av_frame_alloc(); if (!frame) { ret = AVERROR(ENOMEM); goto end; } while (!av_read_frame(fmt_ctx, &pkt)) { if (ifile->nb_streams > nb_streams) { REALLOCZ_ARRAY_STREAM(nb_streams_frames, nb_streams, fmt_ctx->nb_streams); REALLOCZ_ARRAY_STREAM(nb_streams_packets, nb_streams, fmt_ctx->nb_streams); REALLOCZ_ARRAY_STREAM(selected_streams, nb_streams, fmt_ctx->nb_streams); nb_streams = ifile->nb_streams; } if (selected_streams[pkt.stream_index]) { AVRational tb = ifile->streams[pkt.stream_index].st->time_base; if (pkt.pts != AV_NOPTS_VALUE) *cur_ts = av_rescale_q(pkt.pts, tb, AV_TIME_BASE_Q); if (!has_start && *cur_ts != AV_NOPTS_VALUE) { start = *cur_ts; has_start = 1; } if (has_start && !has_end && interval->end_is_offset) { end = start + interval->end; has_end = 1; } if (interval->end_is_offset && interval->duration_frames) { if (frame_count >= interval->end) break; } else if (has_end && *cur_ts != AV_NOPTS_VALUE && *cur_ts >= end) { break; } frame_count++; if (do_read_packets) { if (do_show_packets) show_packet(w, ifile, &pkt, i++); nb_streams_packets[pkt.stream_index]++; } if (do_read_frames) { pkt1 = pkt; while (pkt1.size && process_frame(w, ifile, frame, &pkt1) > 0); } } av_packet_unref(&pkt); } av_init_packet(&pkt); pkt.data = NULL; pkt.size = 0; for (i = 0; i < fmt_ctx->nb_streams; i++) { pkt.stream_index = i; if (do_read_frames) while (process_frame(w, ifile, frame, &pkt) > 0); } end: av_frame_free(&frame); if (ret < 0) { av_log(NULL, AV_LOG_ERROR, "Could not read packets in interval "); log_read_interval(interval, NULL, AV_LOG_ERROR); } return ret; }<SPLIT>[-0.09900860198293619, 1.3901822195754028, 0.0, -0.11436118199787926, 1.274548645530178, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 1.3698779043020206, 1.2475590849166647, -0.09566541730555662, 1.4580840705699636, 0.0, 0.0, 0.30852482215402843, 1.1458395681698652, -0.11100716297398205, 1.3448324649774837, 1.4116952586195004, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, 1.0625510197368635, 1.0008538488262473, 1.4729010679211356, 0.6817979554923368, 0.42674115187998785, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 1.3693714445839917, 1.7623686513065309, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 1.3643185231999084]
1<SPLIT>static int decode_slice_header(H264Context *h, H264Context *h0){ MpegEncContext * const s = &h->s; MpegEncContext * const s0 = &h0->s; unsigned int first_mb_in_slice; unsigned int pps_id; int num_ref_idx_active_override_flag; unsigned int slice_type, tmp, i, j; int default_ref_list_done = 0; int last_pic_structure; s->dropable= h->nal_ref_idc == 0; if((s->avctx->flags2 & CODEC_FLAG2_FAST) && !h->nal_ref_idc && !h->pixel_shift){ s->me.qpel_put= s->dsp.put_2tap_qpel_pixels_tab; s->me.qpel_avg= s->dsp.avg_2tap_qpel_pixels_tab; }else{ s->me.qpel_put= s->dsp.put_h264_qpel_pixels_tab; s->me.qpel_avg= s->dsp.avg_h264_qpel_pixels_tab; } first_mb_in_slice= get_ue_golomb_long(&s->gb); if(first_mb_in_slice == 0){ if(h0->current_slice && FIELD_PICTURE){ field_end(h, 1); } h0->current_slice = 0; if (!s0->first_field) s->current_picture_ptr= NULL; } slice_type= get_ue_golomb_31(&s->gb); if(slice_type > 9){ av_log(h->s.avctx, AV_LOG_ERROR, "slice type too large (%d) at %d %d\n", h->slice_type, s->mb_x, s->mb_y); return -1; } if(slice_type > 4){ slice_type -= 5; h->slice_type_fixed=1; }else h->slice_type_fixed=0; slice_type= golomb_to_pict_type[ slice_type ]; if (slice_type == AV_PICTURE_TYPE_I || (h0->current_slice != 0 && slice_type == h0->last_slice_type) ) { default_ref_list_done = 1; } h->slice_type= slice_type; h->slice_type_nos= slice_type & 3; s->pict_type= h->slice_type; pps_id= get_ue_golomb(&s->gb); if(pps_id>=MAX_PPS_COUNT){ av_log(h->s.avctx, AV_LOG_ERROR, "pps_id out of range\n"); return -1; } if(!h0->pps_buffers[pps_id]) { av_log(h->s.avctx, AV_LOG_ERROR, "non-existing PPS %u referenced\n", pps_id); return -1; } h->pps= *h0->pps_buffers[pps_id]; if(!h0->sps_buffers[h->pps.sps_id]) { av_log(h->s.avctx, AV_LOG_ERROR, "non-existing SPS %u referenced\n", h->pps.sps_id); return -1; } h->sps = *h0->sps_buffers[h->pps.sps_id]; s->avctx->profile = ff_h264_get_profile(&h->sps); s->avctx->level = h->sps.level_idc; s->avctx->refs = h->sps.ref_frame_count; if(h == h0 && h->dequant_coeff_pps != pps_id){ h->dequant_coeff_pps = pps_id; init_dequant_tables(h); } s->mb_width= h->sps.mb_width; s->mb_height= h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag); h->b_stride= s->mb_width*4; s->chroma_y_shift = h->sps.chroma_format_idc <= 1; s->width = 16*s->mb_width; s->height= 16*s->mb_height; if (s->context_initialized && ( s->width != s->avctx->coded_width || s->height != s->avctx->coded_height || s->avctx->bits_per_raw_sample != h->sps.bit_depth_luma || h->cur_chroma_format_idc != h->sps.chroma_format_idc || av_cmp_q(h->sps.sar, s->avctx->sample_aspect_ratio))) { if(h != h0) { av_log_missing_feature(s->avctx, "Width/height/bit depth/chroma idc changing with threads is", 0); return -1; } free_tables(h, 0); flush_dpb(s->avctx); MPV_common_end(s); h->list_count = 0; } if (!s->context_initialized) { if (h != h0) { av_log(h->s.avctx, AV_LOG_ERROR, "Cannot (re-)initialize context during parallel decoding.\n"); return -1; } avcodec_set_dimensions(s->avctx, s->width, s->height); s->avctx->width -= (2>>CHROMA444)*FFMIN(h->sps.crop_right, (8<<CHROMA444)-1); s->avctx->height -= (1<<s->chroma_y_shift)*FFMIN(h->sps.crop_bottom, (16>>s->chroma_y_shift)-1) * (2 - h->sps.frame_mbs_only_flag); s->avctx->sample_aspect_ratio= h->sps.sar; av_assert0(s->avctx->sample_aspect_ratio.den); if (s->avctx->bits_per_raw_sample != h->sps.bit_depth_luma || h->cur_chroma_format_idc != h->sps.chroma_format_idc) { if (h->sps.bit_depth_luma >= 8 && h->sps.bit_depth_luma <= 10 && (h->sps.bit_depth_luma != 9 || !CHROMA422)) { s->avctx->bits_per_raw_sample = h->sps.bit_depth_luma; h->cur_chroma_format_idc = h->sps.chroma_format_idc; h->pixel_shift = h->sps.bit_depth_luma > 8; ff_h264dsp_init(&h->h264dsp, h->sps.bit_depth_luma, h->sps.chroma_format_idc); ff_h264_pred_init(&h->hpc, s->codec_id, h->sps.bit_depth_luma, h->sps.chroma_format_idc); s->dsp.dct_bits = h->sps.bit_depth_luma > 8 ? 32 : 16; dsputil_init(&s->dsp, s->avctx); } else { av_log(s->avctx, AV_LOG_ERROR, "Unsupported bit depth: %d chroma_idc: %d\n", h->sps.bit_depth_luma, h->sps.chroma_format_idc); return -1; } } if(h->sps.video_signal_type_present_flag){ s->avctx->color_range = h->sps.full_range>0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; if(h->sps.colour_description_present_flag){ s->avctx->color_primaries = h->sps.color_primaries; s->avctx->color_trc = h->sps.color_trc; s->avctx->colorspace = h->sps.colorspace; } } if(h->sps.timing_info_present_flag){ int64_t den= h->sps.time_scale; if(h->x264_build < 44U) den *= 2; av_reduce(&s->avctx->time_base.num, &s->avctx->time_base.den, h->sps.num_units_in_tick, den, 1<<30); } switch (h->sps.bit_depth_luma) { case 9 : if (CHROMA444) { if (s->avctx->colorspace == AVCOL_SPC_RGB) { s->avctx->pix_fmt = PIX_FMT_GBRP9; } else s->avctx->pix_fmt = PIX_FMT_YUV444P9; } else if (CHROMA422) s->avctx->pix_fmt = PIX_FMT_YUV422P9; else s->avctx->pix_fmt = PIX_FMT_YUV420P9; break; case 10 : if (CHROMA444) { if (s->avctx->colorspace == AVCOL_SPC_RGB) { s->avctx->pix_fmt = PIX_FMT_GBRP10; } else s->avctx->pix_fmt = PIX_FMT_YUV444P10; } else if (CHROMA422) s->avctx->pix_fmt = PIX_FMT_YUV422P10; else s->avctx->pix_fmt = PIX_FMT_YUV420P10; break; default: if (CHROMA444){ s->avctx->pix_fmt = s->avctx->color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P; if (s->avctx->colorspace == AVCOL_SPC_RGB) { s->avctx->pix_fmt = PIX_FMT_GBR24P; av_log(h->s.avctx, AV_LOG_DEBUG, "Detected GBR colorspace.\n"); } else if (s->avctx->colorspace == AVCOL_SPC_YCGCO) { av_log(h->s.avctx, AV_LOG_WARNING, "Detected unsupported YCgCo colorspace.\n"); } } else if (CHROMA422) { s->avctx->pix_fmt = s->avctx->color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P; }else{ s->avctx->pix_fmt = s->avctx->get_format(s->avctx, s->avctx->codec->pix_fmts ? s->avctx->codec->pix_fmts : s->avctx->color_range == AVCOL_RANGE_JPEG ? hwaccel_pixfmt_list_h264_jpeg_420 : ff_hwaccel_pixfmt_list_420); } } s->avctx->hwaccel = ff_find_hwaccel(s->avctx->codec->id, s->avctx->pix_fmt); if (MPV_common_init(s) < 0) { av_log(h->s.avctx, AV_LOG_ERROR, "MPV_common_init() failed.\n"); return -1; } s->first_field = 0; h->prev_interlaced_frame = 1; init_scan_tables(h); if (ff_h264_alloc_tables(h) < 0) { av_log(h->s.avctx, AV_LOG_ERROR, "Could not allocate memory for h264\n"); return AVERROR(ENOMEM); } if (!HAVE_THREADS || !(s->avctx->active_thread_type&FF_THREAD_SLICE)) { if (context_init(h) < 0) { av_log(h->s.avctx, AV_LOG_ERROR, "context_init() failed.\n"); return -1; } } else { for(i = 1; i < s->avctx->thread_count; i++) { H264Context *c; c = h->thread_context[i] = av_malloc(sizeof(H264Context)); memcpy(c, h->s.thread_context[i], sizeof(MpegEncContext)); memset(&c->s + 1, 0, sizeof(H264Context) - sizeof(MpegEncContext)); c->h264dsp = h->h264dsp; c->sps = h->sps; c->pps = h->pps; c->pixel_shift = h->pixel_shift; c->cur_chroma_format_idc = h->cur_chroma_format_idc; init_scan_tables(c); clone_tables(c, h, i); } for(i = 0; i < s->avctx->thread_count; i++) if (context_init(h->thread_context[i]) < 0) { av_log(h->s.avctx, AV_LOG_ERROR, "context_init() failed.\n"); return -1; } } } h->frame_num= get_bits(&s->gb, h->sps.log2_max_frame_num); h->mb_mbaff = 0; h->mb_aff_frame = 0; last_pic_structure = s0->picture_structure; if(h->sps.frame_mbs_only_flag){ s->picture_structure= PICT_FRAME; }else{ if(!h->sps.direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B){ av_log(h->s.avctx, AV_LOG_ERROR, "This stream was generated by a broken encoder, invalid 8x8 inference\n"); return -1; } if(get_bits1(&s->gb)) { s->picture_structure= PICT_TOP_FIELD + get_bits1(&s->gb); } else { s->picture_structure= PICT_FRAME; h->mb_aff_frame = h->sps.mb_aff; } } h->mb_field_decoding_flag= s->picture_structure != PICT_FRAME; if(h0->current_slice == 0){ if(h->frame_num != h->prev_frame_num && h->prev_frame_num >= 0) { int unwrap_prev_frame_num = h->prev_frame_num, max_frame_num = 1<<h->sps.log2_max_frame_num; if (unwrap_prev_frame_num > h->frame_num) unwrap_prev_frame_num -= max_frame_num; if ((h->frame_num - unwrap_prev_frame_num) > h->sps.ref_frame_count) { unwrap_prev_frame_num = (h->frame_num - h->sps.ref_frame_count) - 1; if (unwrap_prev_frame_num < 0) unwrap_prev_frame_num += max_frame_num; h->prev_frame_num = unwrap_prev_frame_num; } } while(h->frame_num != h->prev_frame_num && h->prev_frame_num >= 0 && h->frame_num != (h->prev_frame_num+1)%(1<<h->sps.log2_max_frame_num)){ Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL; av_log(h->s.avctx, AV_LOG_DEBUG, "Frame num gap %d %d\n", h->frame_num, h->prev_frame_num); if (ff_h264_frame_start(h) < 0) return -1; h->prev_frame_num++; h->prev_frame_num %= 1<<h->sps.log2_max_frame_num; s->current_picture_ptr->frame_num= h->prev_frame_num; ff_thread_report_progress((AVFrame*)s->current_picture_ptr, INT_MAX, 0); ff_thread_report_progress((AVFrame*)s->current_picture_ptr, INT_MAX, 1); ff_generate_sliding_window_mmcos(h); if (ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index) < 0 && (s->avctx->err_recognition & AV_EF_EXPLODE)) return AVERROR_INVALIDDATA; if (h->short_ref_count) { if (prev) { av_image_copy(h->short_ref[0]->f.data, h->short_ref[0]->f.linesize, (const uint8_t**)prev->f.data, prev->f.linesize, s->avctx->pix_fmt, s->mb_width*16, s->mb_height*16); h->short_ref[0]->poc = prev->poc+2; } h->short_ref[0]->frame_num = h->prev_frame_num; } } if (s0->first_field) { assert(s0->current_picture_ptr); assert(s0->current_picture_ptr->f.data[0]); assert(s0->current_picture_ptr->f.reference != DELAYED_PIC_REF); if (!FIELD_PICTURE || s->picture_structure == last_pic_structure) { s0->current_picture_ptr = NULL; s0->first_field = FIELD_PICTURE; } else { if (s0->current_picture_ptr->frame_num != h->frame_num) { s0->first_field = 1; s0->current_picture_ptr = NULL; } else { s0->first_field = 0; } } } else { assert(!s0->current_picture_ptr); s0->first_field = FIELD_PICTURE; } if(!FIELD_PICTURE || s0->first_field) { if (ff_h264_frame_start(h) < 0) { s0->first_field = 0; return -1; } } else { ff_release_unused_pictures(s, 0); } } if(h != h0) clone_slice(h, h0); s->current_picture_ptr->frame_num= h->frame_num; assert(s->mb_num == s->mb_width * s->mb_height); if(first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s->mb_num || first_mb_in_slice >= s->mb_num){ av_log(h->s.avctx, AV_LOG_ERROR, "first_mb_in_slice overflow\n"); return -1; } s->resync_mb_x = s->mb_x = first_mb_in_slice % s->mb_width; s->resync_mb_y = s->mb_y = (first_mb_in_slice / s->mb_width) << FIELD_OR_MBAFF_PICTURE; if (s->picture_structure == PICT_BOTTOM_FIELD) s->resync_mb_y = s->mb_y = s->mb_y + 1; assert(s->mb_y < s->mb_height); if(s->picture_structure==PICT_FRAME){ h->curr_pic_num= h->frame_num; h->max_pic_num= 1<< h->sps.log2_max_frame_num; }else{ h->curr_pic_num= 2*h->frame_num + 1; h->max_pic_num= 1<<(h->sps.log2_max_frame_num + 1); } if(h->nal_unit_type == NAL_IDR_SLICE){ get_ue_golomb(&s->gb); } if(h->sps.poc_type==0){ h->poc_lsb= get_bits(&s->gb, h->sps.log2_max_poc_lsb); if(h->pps.pic_order_present==1 && s->picture_structure==PICT_FRAME){ h->delta_poc_bottom= get_se_golomb(&s->gb); } } if(h->sps.poc_type==1 && !h->sps.delta_pic_order_always_zero_flag){ h->delta_poc[0]= get_se_golomb(&s->gb); if(h->pps.pic_order_present==1 && s->picture_structure==PICT_FRAME) h->delta_poc[1]= get_se_golomb(&s->gb); } init_poc(h); if(h->pps.redundant_pic_cnt_present){ h->redundant_pic_count= get_ue_golomb(&s->gb); } h->ref_count[0]= h->pps.ref_count[0]; h->ref_count[1]= h->pps.ref_count[1]; if(h->slice_type_nos != AV_PICTURE_TYPE_I){ unsigned max= (16<<(s->picture_structure != PICT_FRAME))-1; if(h->slice_type_nos == AV_PICTURE_TYPE_B){ h->direct_spatial_mv_pred= get_bits1(&s->gb); } num_ref_idx_active_override_flag= get_bits1(&s->gb); if(num_ref_idx_active_override_flag){ h->ref_count[0]= get_ue_golomb(&s->gb) + 1; if(h->slice_type_nos==AV_PICTURE_TYPE_B) h->ref_count[1]= get_ue_golomb(&s->gb) + 1; } if(h->ref_count[0]-1 > max || h->ref_count[1]-1 > max){ av_log(h->s.avctx, AV_LOG_ERROR, "reference overflow\n"); h->ref_count[0]= h->ref_count[1]= 1; return -1; } if(h->slice_type_nos == AV_PICTURE_TYPE_B) h->list_count= 2; else h->list_count= 1; }else h->ref_count[1]= h->ref_count[0]= h->list_count= 0; if(!default_ref_list_done){ ff_h264_fill_default_ref_list(h); } if(h->slice_type_nos!=AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering(h) < 0) { h->ref_count[1]= h->ref_count[0]= 0; return -1; } if(h->slice_type_nos!=AV_PICTURE_TYPE_I){ s->last_picture_ptr= &h->ref_list[0][0]; ff_copy_picture(&s->last_picture, s->last_picture_ptr); } if(h->slice_type_nos==AV_PICTURE_TYPE_B){ s->next_picture_ptr= &h->ref_list[1][0]; ff_copy_picture(&s->next_picture, s->next_picture_ptr); } if( (h->pps.weighted_pred && h->slice_type_nos == AV_PICTURE_TYPE_P ) || (h->pps.weighted_bipred_idc==1 && h->slice_type_nos== AV_PICTURE_TYPE_B ) ) pred_weight_table(h); else if(h->pps.weighted_bipred_idc==2 && h->slice_type_nos== AV_PICTURE_TYPE_B){ implicit_weight_table(h, -1); }else { h->use_weight = 0; for (i = 0; i < 2; i++) { h->luma_weight_flag[i] = 0; h->chroma_weight_flag[i] = 0; } } if(h->nal_ref_idc && ff_h264_decode_ref_pic_marking(h0, &s->gb) < 0 && (s->avctx->err_recognition & AV_EF_EXPLODE)) return AVERROR_INVALIDDATA; if(FRAME_MBAFF){ ff_h264_fill_mbaff_ref_list(h); if(h->pps.weighted_bipred_idc==2 && h->slice_type_nos== AV_PICTURE_TYPE_B){ implicit_weight_table(h, 0); implicit_weight_table(h, 1); } } if(h->slice_type_nos==AV_PICTURE_TYPE_B && !h->direct_spatial_mv_pred) ff_h264_direct_dist_scale_factor(h); ff_h264_direct_ref_list_init(h); if( h->slice_type_nos != AV_PICTURE_TYPE_I && h->pps.cabac ){ tmp = get_ue_golomb_31(&s->gb); if(tmp > 2){ av_log(s->avctx, AV_LOG_ERROR, "cabac_init_idc overflow\n"); return -1; } h->cabac_init_idc= tmp; } h->last_qscale_diff = 0; tmp = h->pps.init_qp + get_se_golomb(&s->gb); if(tmp>51+6*(h->sps.bit_depth_luma-8)){ av_log(s->avctx, AV_LOG_ERROR, "QP %u out of range\n", tmp); return -1; } s->qscale= tmp; h->chroma_qp[0] = get_chroma_qp(h, 0, s->qscale); h->chroma_qp[1] = get_chroma_qp(h, 1, s->qscale); if(h->slice_type == AV_PICTURE_TYPE_SP){ get_bits1(&s->gb); } if(h->slice_type==AV_PICTURE_TYPE_SP || h->slice_type == AV_PICTURE_TYPE_SI){ get_se_golomb(&s->gb); } h->deblocking_filter = 1; h->slice_alpha_c0_offset = 52; h->slice_beta_offset = 52; if( h->pps.deblocking_filter_parameters_present ) { tmp= get_ue_golomb_31(&s->gb); if(tmp > 2){ av_log(s->avctx, AV_LOG_ERROR, "deblocking_filter_idc %u out of range\n", tmp); return -1; } h->deblocking_filter= tmp; if(h->deblocking_filter < 2) h->deblocking_filter^= 1; if( h->deblocking_filter ) { h->slice_alpha_c0_offset += get_se_golomb(&s->gb) << 1; h->slice_beta_offset += get_se_golomb(&s->gb) << 1; if( h->slice_alpha_c0_offset > 104U || h->slice_beta_offset > 104U){ av_log(s->avctx, AV_LOG_ERROR, "deblocking filter parameters %d %d out of range\n", h->slice_alpha_c0_offset, h->slice_beta_offset); return -1; } } } if( s->avctx->skip_loop_filter >= AVDISCARD_ALL ||(s->avctx->skip_loop_filter >= AVDISCARD_NONKEY && h->slice_type_nos != AV_PICTURE_TYPE_I) ||(s->avctx->skip_loop_filter >= AVDISCARD_BIDIR && h->slice_type_nos == AV_PICTURE_TYPE_B) ||(s->avctx->skip_loop_filter >= AVDISCARD_NONREF && h->nal_ref_idc == 0)) h->deblocking_filter= 0; if(h->deblocking_filter == 1 && h0->max_contexts > 1) { if(s->avctx->flags2 & CODEC_FLAG2_FAST) { h->deblocking_filter = 2; } else { h0->max_contexts = 1; if(!h0->single_decode_warning) { av_log(s->avctx, AV_LOG_INFO, "Cannot parallelize deblocking type 1, decoding such frames in sequential order\n"); h0->single_decode_warning = 1; } if (h != h0) { av_log(h->s.avctx, AV_LOG_ERROR, "Deblocking switched inside frame.\n"); return 1; } } } h->qp_thresh = 15 + 52 - FFMIN(h->slice_alpha_c0_offset, h->slice_beta_offset) - FFMAX3(0, h->pps.chroma_qp_index_offset[0], h->pps.chroma_qp_index_offset[1]) + 6 * (h->sps.bit_depth_luma - 8); #if 0 if( h->pps.num_slice_groups > 1 && h->pps.mb_slice_group_map_type >= 3 && h->pps.mb_slice_group_map_type <= 5) slice_group_change_cycle= get_bits(&s->gb, ?); #endif h0->last_slice_type = slice_type; h->slice_num = ++h0->current_slice; if(h->slice_num) h0->slice_row[(h->slice_num-1)&(MAX_SLICES-1)]= s->resync_mb_y; if ( h0->slice_row[h->slice_num&(MAX_SLICES-1)] + 3 >= s->resync_mb_y && h0->slice_row[h->slice_num&(MAX_SLICES-1)] <= s->resync_mb_y && h->slice_num >= MAX_SLICES) { av_log(s->avctx, AV_LOG_WARNING, "Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\n", h->slice_num, MAX_SLICES); } for(j=0; j<2; j++){ int id_list[16]; int *ref2frm= h->ref2frm[h->slice_num&(MAX_SLICES-1)][j]; for(i=0; i<16; i++){ id_list[i]= 60; if (h->ref_list[j][i].f.data[0]) { int k; uint8_t *base = h->ref_list[j][i].f.base[0]; for(k=0; k<h->short_ref_count; k++) if (h->short_ref[k]->f.base[0] == base) { id_list[i]= k; break; } for(k=0; k<h->long_ref_count; k++) if (h->long_ref[k] && h->long_ref[k]->f.base[0] == base) { id_list[i]= h->short_ref_count + k; break; } } } ref2frm[0]= ref2frm[1]= -1; for(i=0; i<16; i++) ref2frm[i+2]= 4*id_list[i] + (h->ref_list[j][i].f.reference & 3); ref2frm[18+0]= ref2frm[18+1]= -1; for(i=16; i<48; i++) ref2frm[i+4]= 4*id_list[(i-16)>>1] + (h->ref_list[j][i].f.reference & 3); } h->emu_edge_width= (s->flags&CODEC_FLAG_EMU_EDGE || (!h->sps.frame_mbs_only_flag && s->avctx->active_thread_type)) ? 0 : 16; h->emu_edge_height= (FRAME_MBAFF || FIELD_PICTURE) ? 0 : h->emu_edge_width; if(s->avctx->debug&FF_DEBUG_PICT_INFO){ av_log(h->s.avctx, AV_LOG_DEBUG, "slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n", h->slice_num, (s->picture_structure==PICT_FRAME ? "F" : s->picture_structure==PICT_TOP_FIELD ? "T" : "B"), first_mb_in_slice, av_get_picture_type_char(h->slice_type), h->slice_type_fixed ? " fix" : "", h->nal_unit_type == NAL_IDR_SLICE ? " IDR" : "", pps_id, h->frame_num, s->current_picture_ptr->field_poc[0], s->current_picture_ptr->field_poc[1], h->ref_count[0], h->ref_count[1], s->qscale, h->deblocking_filter, h->slice_alpha_c0_offset/2-26, h->slice_beta_offset/2-26, h->use_weight, h->use_weight==1 && h->use_weight_chroma ? "c" : "", h->slice_type == AV_PICTURE_TYPE_B ? (h->direct_spatial_mv_pred ? "SPAT" : "TEMP") : "" ); } return 0; }<SPLIT>[15.829144422795602, 10.954063741547252, 0.0, 15.557713146280612, 10.509535922478314, 0.0, 12.440520847750903, 12.659665995320244, 11.851502741245765, 10.275171305326538, 11.976219274201435, 16.106743729572077, 11.25902255568061, 0.0, 0.0, 0.30852482215402843, 11.549473539604373, 15.82215656391402, 10.842056143724736, 7.493353399954214, 5.839632883406059, 0.0, 0.13403667075800713, 0.9973611507722091, 9.213209935408898, 9.01160751766878, 6.891782720718273, 2.47944955092491, 9.503106047553523, 12.437003647995772, 12.656735380498468, 11.84827117060347, 10.27248794793478, 2.6191065950439585, 0.0, 12.418282299777653, 12.637956661697451, 11.829584750361333, 10.253519014145146]
0<SPLIT>static void enable_tracks(AVFormatContext *s) { MOVMuxContext *mov = s->priv_data; int i; int enabled[AVMEDIA_TYPE_NB]; int first[AVMEDIA_TYPE_NB]; for (i = 0; i < AVMEDIA_TYPE_NB; i++) { enabled[i] = 0; first[i] = -1; } for (i = 0; i < s->nb_streams; i++) { AVStream *st = s->streams[i]; if (st->codec->codec_type <= AVMEDIA_TYPE_UNKNOWN || st->codec->codec_type >= AVMEDIA_TYPE_NB) continue; if (first[st->codec->codec_type] < 0) first[st->codec->codec_type] = i; if (st->disposition & AV_DISPOSITION_DEFAULT) { mov->tracks[i].flags |= MOV_TRACK_ENABLED; enabled[st->codec->codec_type]++; } } for (i = 0; i < AVMEDIA_TYPE_NB; i++) { switch (i) { case AVMEDIA_TYPE_VIDEO: case AVMEDIA_TYPE_AUDIO: case AVMEDIA_TYPE_SUBTITLE: if (enabled[i] > 1) mov->per_stream_grouping = 1; if (!enabled[i] && first[i] >= 0) mov->tracks[first[i]].flags |= MOV_TRACK_ENABLED; break; } } }<SPLIT>[-0.25365086435942685, 0.11205980419667652, 0.0, -0.2665172434374763, 0.04037983893342262, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.06880498590772346, -0.25297036047912586, 0.13609701908992267, 0.0, 0.0, 0.30852482215402843, 0.0027959847161670454, -0.26569807294376846, 0.06381159668134254, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int av_cold opengl_load_procedures(OpenGLContext *opengl) { FFOpenGLFunctions *procs = &opengl->glprocs; #if HAVE_SDL if (!opengl->no_window) return opengl_sdl_load_procedures(opengl); #endif procs->glActiveTexture = glActiveTexture; procs->glGenBuffers = glGenBuffers; procs->glDeleteBuffers = glDeleteBuffers; procs->glBufferData = glBufferData; procs->glBindBuffer = glBindBuffer; procs->glGetAttribLocation = glGetAttribLocation; procs->glGetUniformLocation = glGetUniformLocation; procs->glUniform1f = glUniform1f; procs->glUniform1i = glUniform1i; procs->glUniformMatrix4fv = glUniformMatrix4fv; procs->glCreateProgram = glCreateProgram; procs->glDeleteProgram = glDeleteProgram; procs->glUseProgram = glUseProgram; procs->glLinkProgram = glLinkProgram; procs->glGetProgramiv = glGetProgramiv; procs->glGetProgramInfoLog = glGetProgramInfoLog; procs->glAttachShader = glAttachShader; procs->glCreateShader = glCreateShader; procs->glDeleteShader = glDeleteShader; procs->glCompileShader = glCompileShader; procs->glShaderSource = glShaderSource; procs->glGetShaderiv = glGetShaderiv; procs->glGetShaderInfoLog = glGetShaderInfoLog; procs->glEnableVertexAttribArray = glEnableVertexAttribArray; procs->glVertexAttribPointer = (FF_PFNGLVERTEXATTRIBPOINTERPROC) glVertexAttribPointer; return 0; } #else static int av_cold opengl_load_procedures(OpenGLContext *opengl) { FFOpenGLFunctions *procs = &opengl->glprocs; #if HAVE_GLXGETPROCADDRESS #define SelectedGetProcAddress glXGetProcAddress #elif HAVE_WGLGETPROCADDRESS #define SelectedGetProcAddress wglGetProcAddress #endif #define LOAD_OPENGL_FUN(name, type) \ procs->name = (type)SelectedGetProcAddress(#name); \ if (!procs->name) { \ av_log(opengl, AV_LOG_ERROR, "Cannot load OpenGL function: '%s'\n", #name); \ return AVERROR(ENOSYS); \ } #if HAVE_SDL if (!opengl->no_window) return opengl_sdl_load_procedures(opengl); #endif LOAD_OPENGL_FUN(glActiveTexture, FF_PFNGLACTIVETEXTUREPROC) LOAD_OPENGL_FUN(glGenBuffers, FF_PFNGLGENBUFFERSPROC) LOAD_OPENGL_FUN(glDeleteBuffers, FF_PFNGLDELETEBUFFERSPROC) LOAD_OPENGL_FUN(glBufferData, FF_PFNGLBUFFERDATAPROC) LOAD_OPENGL_FUN(glBindBuffer, FF_PFNGLBINDBUFFERPROC) LOAD_OPENGL_FUN(glGetAttribLocation, FF_PFNGLGETATTRIBLOCATIONPROC) LOAD_OPENGL_FUN(glGetUniformLocation, FF_PFNGLGETUNIFORMLOCATIONPROC) LOAD_OPENGL_FUN(glUniform1f, FF_PFNGLUNIFORM1FPROC) LOAD_OPENGL_FUN(glUniform1i, FF_PFNGLUNIFORM1IPROC) LOAD_OPENGL_FUN(glUniformMatrix4fv, FF_PFNGLUNIFORMMATRIX4FVPROC) LOAD_OPENGL_FUN(glCreateProgram, FF_PFNGLCREATEPROGRAMPROC) LOAD_OPENGL_FUN(glDeleteProgram, FF_PFNGLDELETEPROGRAMPROC) LOAD_OPENGL_FUN(glUseProgram, FF_PFNGLUSEPROGRAMPROC) LOAD_OPENGL_FUN(glLinkProgram, FF_PFNGLLINKPROGRAMPROC) LOAD_OPENGL_FUN(glGetProgramiv, FF_PFNGLGETPROGRAMIVPROC) LOAD_OPENGL_FUN(glGetProgramInfoLog, FF_PFNGLGETPROGRAMINFOLOGPROC) LOAD_OPENGL_FUN(glAttachShader, FF_PFNGLATTACHSHADERPROC) LOAD_OPENGL_FUN(glCreateShader, FF_PFNGLCREATESHADERPROC) LOAD_OPENGL_FUN(glDeleteShader, FF_PFNGLDELETESHADERPROC) LOAD_OPENGL_FUN(glCompileShader, FF_PFNGLCOMPILESHADERPROC) LOAD_OPENGL_FUN(glShaderSource, FF_PFNGLSHADERSOURCEPROC) LOAD_OPENGL_FUN(glGetShaderiv, FF_PFNGLGETSHADERIVPROC) LOAD_OPENGL_FUN(glGetShaderInfoLog, FF_PFNGLGETSHADERINFOLOGPROC) LOAD_OPENGL_FUN(glEnableVertexAttribArray, FF_PFNGLENABLEVERTEXATTRIBARRAYPROC) LOAD_OPENGL_FUN(glVertexAttribPointer, FF_PFNGLVERTEXATTRIBPOINTERPROC) return 0; #undef SelectedGetProcAddress #undef LOAD_OPENGL_FUN }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, 1.0404821477273452, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.9133561274674181, -0.26569807294376846, 0.6822354641346521, -0.7880534307994381, -0.518115519420462, 0.0, 0.6852718019606829, 8.53464374073119, 0.5004366117594818, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void color_printf(int color, const char *fmt, ...) { static int use_color = -1; va_list arg; #if HAVE_SETCONSOLETEXTATTRIBUTE static HANDLE con; static WORD org_attributes; if (use_color < 0) { CONSOLE_SCREEN_BUFFER_INFO con_info; con = GetStdHandle(STD_ERROR_HANDLE); if (con && con != INVALID_HANDLE_VALUE && GetConsoleScreenBufferInfo(con, &con_info)) { org_attributes = con_info.wAttributes; use_color = 1; } else use_color = 0; } if (use_color) SetConsoleTextAttribute(con, (org_attributes & 0xfff0) | (color & 0x0f)); #else if (use_color < 0) { const char *term = getenv("TERM"); use_color = term && strcmp(term, "dumb") && isatty(2); } if (use_color) fprintf(stderr, "\x1b[%d;3%dm", (color & 0x08) >> 3, color & 0x07); #endif va_start(arg, fmt); vfprintf(stderr, fmt, arg); va_end(arg); if (use_color) { #if HAVE_SETCONSOLETEXTATTRIBUTE SetConsoleTextAttribute(con, org_attributes); #else fprintf(stderr, "\x1b[0m"); #endif } }<SPLIT>[-0.25365086435942685, 0.15613299093387398, 0.0, -0.2665172434374763, 0.08293738398848315, 0.0, -0.07259221415890627, -0.06585336703851451, 0.24256368267104944, -0.27925050329511203, 0.10876275197582316, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, 0.04154322483324156, -0.26569807294376846, -0.33374660382435645, 0.11772544131424245, 0.029966239443893296, 0.0, 1.457000985644429, 3.3165250246057414, -0.06167779621789984, -0.03454968660237938, 0.23107402248845843, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, 0.24218765769350709, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static void nv21ToUV_c(uint8_t *dstU, uint8_t *dstV, const uint8_t *unused0, const uint8_t *src1, const uint8_t *src2, int width, uint32_t *unused) { nvXXtoUV_c(dstV, dstU, src1, width); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int mov_write_chpl_tag(AVIOContext *pb, AVFormatContext *s) { int64_t pos = avio_tell(pb); int i, nb_chapters = FFMIN(s->nb_chapters, 255); avio_wb32(pb, 0); ffio_wfourcc(pb, "chpl"); avio_wb32(pb, 0x01000000); avio_wb32(pb, 0); avio_w8(pb, nb_chapters); for (i = 0; i < nb_chapters; i++) { AVChapter *c = s->chapters[i]; AVDictionaryEntry *t; avio_wb64(pb, av_rescale_q(c->start, c->time_base, (AVRational){1,10000000})); if ((t = av_dict_get(c->metadata, "title", NULL, 0))) { int len = FFMIN(strlen(t->value), 255); avio_w8(pb, len); avio_write(pb, t->value, len); } else avio_w8(pb, 0); } return update_size(pb, pos); }<SPLIT>[-0.25365086435942685, -0.17441590959510697, 0.0, -0.2665172434374763, -0.23624420392447085, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.1909204935349246, -0.25297036047912586, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.26569807294376846, -0.22331377035055117, 0.37651940477529405, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, 0.29241985090139744, 0.6826474935548865, 0.6817979554923368, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int hvcc_parse_sps(GetBitContext *gb, HEVCDecoderConfigurationRecord *hvcc) { unsigned int i, sps_max_sub_layers_minus1, log2_max_pic_order_cnt_lsb_minus4; unsigned int num_short_term_ref_pic_sets, num_delta_pocs[MAX_SHORT_TERM_RPS_COUNT]; skip_bits(gb, 4); sps_max_sub_layers_minus1 = get_bits (gb, 3); hvcc->numTemporalLayers = FFMAX(hvcc->numTemporalLayers, sps_max_sub_layers_minus1 + 1); hvcc->temporalIdNested = get_bits1(gb); hvcc_parse_ptl(gb, hvcc, sps_max_sub_layers_minus1); get_ue_golomb_long(gb); hvcc->chromaFormat = get_ue_golomb_long(gb); if (hvcc->chromaFormat == 3) skip_bits1(gb); get_ue_golomb_long(gb); get_ue_golomb_long(gb); if (get_bits1(gb)) { get_ue_golomb_long(gb); get_ue_golomb_long(gb); get_ue_golomb_long(gb); get_ue_golomb_long(gb); } hvcc->bitDepthLumaMinus8 = get_ue_golomb_long(gb); hvcc->bitDepthChromaMinus8 = get_ue_golomb_long(gb); log2_max_pic_order_cnt_lsb_minus4 = get_ue_golomb_long(gb); i = get_bits1(gb) ? 0 : sps_max_sub_layers_minus1; for (; i <= sps_max_sub_layers_minus1; i++) skip_sub_layer_ordering_info(gb); get_ue_golomb_long(gb); get_ue_golomb_long(gb); get_ue_golomb_long(gb); get_ue_golomb_long(gb); get_ue_golomb_long(gb); get_ue_golomb_long(gb); if (get_bits1(gb) && get_bits1(gb)) skip_scaling_list_data(gb); skip_bits1(gb); skip_bits1(gb); if (get_bits1(gb)) { skip_bits (gb, 4); skip_bits (gb, 4); get_ue_golomb_long(gb); get_ue_golomb_long(gb); skip_bits1 (gb); } num_short_term_ref_pic_sets = get_ue_golomb_long(gb); if (num_short_term_ref_pic_sets > MAX_SHORT_TERM_RPS_COUNT) return AVERROR_INVALIDDATA; for (i = 0; i < num_short_term_ref_pic_sets; i++) { int ret = parse_rps(gb, i, num_short_term_ref_pic_sets, num_delta_pocs); if (ret < 0) return ret; } if (get_bits1(gb)) { unsigned num_long_term_ref_pics_sps = get_ue_golomb_long(gb); if (num_long_term_ref_pics_sps > 31U) return AVERROR_INVALIDDATA; for (i = 0; i < num_long_term_ref_pics_sps; i++) { int len = FFMIN(log2_max_pic_order_cnt_lsb_minus4 + 4, 16); skip_bits (gb, len); skip_bits1(gb); } } skip_bits1(gb); skip_bits1(gb); if (get_bits1(gb)) hvcc_parse_vui(gb, hvcc, sps_max_sub_layers_minus1); return 0; }<SPLIT>[1.2927717594054797, 0.9053771654662308, 0.0, 1.2550433709584938, 0.8064156499245122, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 0.380400859743741, 0.9878336054740167, 1.3200790712565666, 0.9566407062154653, 0.0, 0.0, 0.30852482215402843, 0.8939825074088809, 1.281211026754096, 0.8589279976927405, 1.2822982768889746, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, 1.203079621731209, 1.0008538488262473, 1.3600077001545285, -0.21702784222394986, 0.6138826961206794, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 0.3801362775450152, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 0.3766295797615486]
0<SPLIT>static void flush(AVFrame *out, AVFilterLink *outlink, int *nb_samples_written, int *ret) { if (*nb_samples_written) { out->nb_samples = *nb_samples_written / outlink->channels; *ret = ff_filter_frame(outlink, out); *nb_samples_written = 0; } else { av_frame_free(&out); } }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.39986248560786075, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void uyvytoyuv422_c(uint8_t *ydst, uint8_t *udst, uint8_t *vdst, const uint8_t *src, int width, int height, int lumStride, int chromStride, int srcStride) { int y; const int chromWidth = FF_CEIL_RSHIFT(width, 1); for (y = 0; y < height; y++) { extract_even_c(src + 1, ydst, width); extract_even2_c(src, udst, vdst, chromWidth); src += srcStride; ydst += lumStride; udst += chromStride; vdst += chromStride; } }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.06601402370422871, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 3.3489446507317613, -0.09407211557651925, -0.26569807294376846, -0.04662123679246273, 0.6353133682363457, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, 0.0744401592322129, 0.11818065472185141, -0.21702784222394986, 0.05245806339860493, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.04739993194876201]
0<SPLIT>unsigned long WINAPI libAVMemInputPin_Release(libAVMemInputPin *this) { libAVPin *pin = (libAVPin *) ((uint8_t *) this - imemoffset); dshowdebug("libAVMemInputPin_Release(%p)\n", this); return libAVPin_Release(pin); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment) { int i, length; segment->nb_index_entries = avio_rb32(pb); length = avio_rb32(pb); if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) || !(segment->flag_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) || !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries)))) { av_freep(&segment->temporal_offset_entries); av_freep(&segment->flag_entries); return AVERROR(ENOMEM); } for (i = 0; i < segment->nb_index_entries; i++) { segment->temporal_offset_entries[i] = avio_r8(pb); avio_r8(pb); segment->flag_entries[i] = avio_r8(pb); segment->stream_offset_entries[i] = avio_rb64(pb); avio_skip(pb, length - 11); } return 0; }<SPLIT>[-0.25365086435942685, -0.1964525029637057, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.21089937656897445, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, 0.24712242304476825, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.08904460951967552, 0.23107402248845843, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static inline int *DEC_SPAIR(int *dst, unsigned idx) { dst[0] = (idx & 15) - 4; dst[1] = (idx >> 4 & 15) - 4; return dst + 2; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.7880534307994381, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5250039928580447, -0.7849662874110047, -0.21702784222394986, -0.22825425296243224, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int ff_audio_data_realloc(AudioData *a, int nb_samples) { int ret, new_buf_size, plane_size, p; if (a->allocated_samples >= nb_samples) return 0; if (a->read_only || !a->allow_realloc) return AVERROR(EINVAL); new_buf_size = av_samples_get_buffer_size(&plane_size, a->allocated_channels, nb_samples, a->sample_fmt, 0); if (new_buf_size < 0) return new_buf_size; if (a->nb_samples > 0 && a->is_planar) { uint8_t *new_data[AVRESAMPLE_MAX_CHANNELS] = { NULL }; ret = av_samples_alloc(new_data, &plane_size, a->allocated_channels, nb_samples, a->sample_fmt, 0); if (ret < 0) return ret; for (p = 0; p < a->planes; p++) memcpy(new_data[p], a->data[p], a->nb_samples * a->stride); av_freep(&a->buffer); memcpy(a->data, new_data, sizeof(new_data)); a->buffer = a->data[0]; } else { av_freep(&a->buffer); a->buffer = av_malloc(new_buf_size); if (!a->buffer) return AVERROR(ENOMEM); ret = av_samples_fill_arrays(a->data, &plane_size, a->buffer, a->allocated_channels, nb_samples, a->sample_fmt, 0); if (ret < 0) return ret; } a->buffer_size = new_buf_size; a->allocated_samples = nb_samples; calc_ptr_alignment(a); a->samples_align = plane_size / a->stride; return 0; }<SPLIT>[0.5195604475230265, 0.2222427710396702, 0.0, 0.4942630637605089, 0.14677370157107394, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, 1.3698779043020206, 0.268593816248222, 0.5335543553887203, 0.2500614200795814, 0.0, 0.0, 0.30852482215402843, 0.19653218530153962, 0.5077564769051636, 0.17424443015514782, 0.37651940477529405, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, 0.14911510677361828, 0.5103995425705821, 0.5697541257882794, -0.21702784222394986, 0.42674115187998785, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, 1.3693714445839917, 0.9056307075691036, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 1.3643185231999084]
0<SPLIT>int main(void) { int i, j, k; AVSHA512 ctx; unsigned char digest[64]; static const int lengths[4] = { 224, 256, 384, 512 }; for (j = 0; j < 4; j++) { if (j < 2) printf("Testing SHA-512/%d\n", lengths[j]); else printf("Testing SHA-%d\n", lengths[j]); for (k = 0; k < 3; k++) { av_sha512_init(&ctx, lengths[j]); if (k == 0) av_sha512_update(&ctx, "abc", 3); else if (k == 1) av_sha512_update(&ctx, "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn" "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu", 112); else for (i = 0; i < 1000*1000; i++) av_sha512_update(&ctx, "a", 1); av_sha512_final(&ctx, digest); for (i = 0; i < lengths[j] >> 3; i++) printf("%02X", digest[i]); putchar('\n'); } switch (j) { case 0: printf("4634270f 707b6a54 daae7530 460842e2 0e37ed26 5ceee9a4 3e8924aa\n" "23fec5bb 94d60b23 30819264 0b0c4533 35d66473 4fe40e72 68674af9\n" "37ab331d 76f0d36d e422bd0e deb22a28 accd487b 7a8453ae 965dd287\n"); break; case 1: printf("53048e26 81941ef9 9b2e29b7 6b4c7dab e4c2d0c6 34fc6d46 e0e2f131 07e7af23\n" "3928e184 fb8690f8 40da3988 121d31be 65cb9d3e f83ee614 6feac861 e19b563a\n" "9a59a052 930187a9 7038cae6 92f30708 aa649192 3ef51943 94dc68d5 6c74fb21\n"); break; case 2: printf("cb00753f 45a35e8b b5a03d69 9ac65007 272c32ab 0eded163 " "1a8b605a 43ff5bed 8086072b a1e7cc23 58baeca1 34c825a7\n" "09330c33 f71147e8 3d192fc7 82cd1b47 53111b17 3b3b05d2 " "2fa08086 e3b0f712 fcc7c71a 557e2db9 66c3e9fa 91746039\n" "9d0e1809 716474cb 086e834e 310a4a1c ed149e9c 00f24852 " "7972cec5 704c2a5b 07b8b3dc 38ecc4eb ae97ddd8 7f3d8985\n"); break; case 3: printf("ddaf35a1 93617aba cc417349 ae204131 12e6fa4e 89a97ea2 0a9eeee6 4b55d39a " "2192992a 274fc1a8 36ba3c23 a3feebbd 454d4423 643ce80e 2a9ac94f a54ca49f\n" "8e959b75 dae313da 8cf4f728 14fc143f 8f7779c6 eb9f7fa1 7299aead b6889018 " "501d289e 4900f7e4 331b99de c4b5433a c7d329ee b6dd2654 5e96e55b 874be909\n" "e718483d 0ce76964 4e2e42c7 bc15b463 8e1f98b1 3b204428 5632a803 afa973eb " "de0ff244 877ea60a 4cb0432c e577c31b eb009c5c 2c49aa2e 4eadb217 ad8cc09b\n"); break; } } return 0; }<SPLIT>[-0.25365086435942685, 0.5527916715686512, 0.0, -0.2665172434374763, 0.4659552894840279, 0.0, 0.9701672076669112, 0.46437660639310047, 0.9059316288753189, -0.27925050329511203, 0.4683826465887205, -0.25297036047912586, 0.5919546230485575, 0.0, 0.0, 0.30852482215402843, 0.3902683858869122, -0.26569807294376846, 0.5055429305765636, 0.24712242304476825, 3.537689496175767, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3599080097651364, 1.3823183092473201, 0.34396739025506545, -0.21702784222394986, 2.111015050046211, 0.969587250454179, 0.46397383393136066, 0.9053924298597907, -0.27935383381430245, 1.7623686513065309, 0.0, 0.9653245912203542, 0.4603363055310632, 0.9011791483816026, -0.28182971586402455]
0<SPLIT>static int64_t get_delay(ASyncContext *s) { return avresample_available(s->avr) + avresample_get_delay(s->avr); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void process_c(EQParameters *param, uint8_t *dst, int dst_stride, const uint8_t *src, int src_stride, int w, int h) { int x, y, pel; int contrast = (int) (param->contrast * 256 * 16); int brightness = ((int) (100.0 * param->brightness + 100.0) * 511) / 200 - 128 - contrast / 32; for (y = 0; y < h; y++) { for (x = 0; x < w; x++) { pel = ((src[y * src_stride + x] * contrast) >> 12) + brightness; if (pel & ~255) pel = (-pel) >> 31; dst[y * dst_stride + x] = pel; } } }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.270465503877335, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, 0.01994523631491676, -0.22049944857796966, -0.21702784222394986, 0.23959960763929639, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 1.7623686513065309, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void av_always_inline idct16_1d(float *dst, const float *src, int dst_stridea, int dst_strideb, int src_stridea, int src_strideb, int add) { int i; for (i = 0; i < 16; i++) { const float x00 = 1.4142135623731f *src[ 0*src_stridea]; const float x01 = 1.40740373752638f *src[ 1*src_stridea] + 0.138617169199091f*src[15*src_stridea]; const float x02 = 1.38703984532215f *src[ 2*src_stridea] + 0.275899379282943f*src[14*src_stridea]; const float x03 = 1.35331800117435f *src[ 3*src_stridea] + 0.410524527522357f*src[13*src_stridea]; const float x04 = 1.30656296487638f *src[ 4*src_stridea] + 0.541196100146197f*src[12*src_stridea]; const float x05 = 1.24722501298667f *src[ 5*src_stridea] + 0.666655658477747f*src[11*src_stridea]; const float x06 = 1.17587560241936f *src[ 6*src_stridea] + 0.785694958387102f*src[10*src_stridea]; const float x07 = 1.09320186700176f *src[ 7*src_stridea] + 0.897167586342636f*src[ 9*src_stridea]; const float x08 = 1.4142135623731f *src[ 8*src_stridea]; const float x09 = -0.897167586342636f*src[ 7*src_stridea] + 1.09320186700176f*src[ 9*src_stridea]; const float x0a = 0.785694958387102f*src[ 6*src_stridea] - 1.17587560241936f*src[10*src_stridea]; const float x0b = -0.666655658477747f*src[ 5*src_stridea] + 1.24722501298667f*src[11*src_stridea]; const float x0c = 0.541196100146197f*src[ 4*src_stridea] - 1.30656296487638f*src[12*src_stridea]; const float x0d = -0.410524527522357f*src[ 3*src_stridea] + 1.35331800117435f*src[13*src_stridea]; const float x0e = 0.275899379282943f*src[ 2*src_stridea] - 1.38703984532215f*src[14*src_stridea]; const float x0f = -0.138617169199091f*src[ 1*src_stridea] + 1.40740373752638f*src[15*src_stridea]; const float x12 = x00 + x08; const float x13 = x01 + x07; const float x14 = x02 + x06; const float x15 = x03 + x05; const float x16 = 1.4142135623731f*x04; const float x17 = x00 - x08; const float x18 = x01 - x07; const float x19 = x02 - x06; const float x1a = x03 - x05; const float x1d = x12 + x16; const float x1e = x13 + x15; const float x1f = 1.4142135623731f*x14; const float x20 = x12 - x16; const float x21 = x13 - x15; const float x22 = 0.25f * (x1d - x1f); const float x23 = 0.25f * (x20 + x21); const float x24 = 0.25f * (x20 - x21); const float x25 = 1.4142135623731f*x17; const float x26 = 1.30656296487638f*x18 + 0.541196100146197f*x1a; const float x27 = 1.4142135623731f*x19; const float x28 = -0.541196100146197f*x18 + 1.30656296487638f*x1a; const float x29 = 0.176776695296637f * (x25 + x27) + 0.25f*x26; const float x2a = 0.25f * (x25 - x27); const float x2b = 0.176776695296637f * (x25 + x27) - 0.25f*x26; const float x2c = 0.353553390593274f*x28; const float x1b = 0.707106781186547f * (x2a - x2c); const float x1c = 0.707106781186547f * (x2a + x2c); const float x2d = 1.4142135623731f*x0c; const float x2e = x0b + x0d; const float x2f = x0a + x0e; const float x30 = x09 + x0f; const float x31 = x09 - x0f; const float x32 = x0a - x0e; const float x33 = x0b - x0d; const float x37 = 1.4142135623731f*x2d; const float x38 = 1.30656296487638f*x2e + 0.541196100146197f*x30; const float x39 = 1.4142135623731f*x2f; const float x3a = -0.541196100146197f*x2e + 1.30656296487638f*x30; const float x3b = 0.176776695296637f * (x37 + x39) + 0.25f*x38; const float x3c = 0.25f * (x37 - x39); const float x3d = 0.176776695296637f * (x37 + x39) - 0.25f*x38; const float x3e = 0.353553390593274f*x3a; const float x34 = 0.707106781186547f * (x3c - x3e); const float x35 = 0.707106781186547f * (x3c + x3e); const float x3f = 1.4142135623731f*x32; const float x40 = x31 + x33; const float x41 = x31 - x33; const float x42 = 0.25f * (x3f + x40); const float x43 = 0.25f * (x3f - x40); const float x44 = 0.353553390593274f*x41; dst[ 0*dst_stridea] = (add ? dst[ 0*dst_stridea] : 0) + 0.176776695296637f * (x1d + x1f) + 0.25f*x1e; dst[ 1*dst_stridea] = (add ? dst[ 1*dst_stridea] : 0) + 0.707106781186547f * (x29 + x3d); dst[ 2*dst_stridea] = (add ? dst[ 2*dst_stridea] : 0) + 0.707106781186547f * (x29 - x3d); dst[ 3*dst_stridea] = (add ? dst[ 3*dst_stridea] : 0) + 0.707106781186547f * (x23 - x43); dst[ 4*dst_stridea] = (add ? dst[ 4*dst_stridea] : 0) + 0.707106781186547f * (x23 + x43); dst[ 5*dst_stridea] = (add ? dst[ 5*dst_stridea] : 0) + 0.707106781186547f * (x1b - x35); dst[ 6*dst_stridea] = (add ? dst[ 6*dst_stridea] : 0) + 0.707106781186547f * (x1b + x35); dst[ 7*dst_stridea] = (add ? dst[ 7*dst_stridea] : 0) + 0.707106781186547f * (x22 + x44); dst[ 8*dst_stridea] = (add ? dst[ 8*dst_stridea] : 0) + 0.707106781186547f * (x22 - x44); dst[ 9*dst_stridea] = (add ? dst[ 9*dst_stridea] : 0) + 0.707106781186547f * (x1c + x34); dst[10*dst_stridea] = (add ? dst[10*dst_stridea] : 0) + 0.707106781186547f * (x1c - x34); dst[11*dst_stridea] = (add ? dst[11*dst_stridea] : 0) + 0.707106781186547f * (x24 + x42); dst[12*dst_stridea] = (add ? dst[12*dst_stridea] : 0) + 0.707106781186547f * (x24 - x42); dst[13*dst_stridea] = (add ? dst[13*dst_stridea] : 0) + 0.707106781186547f * (x2b - x3b); dst[14*dst_stridea] = (add ? dst[14*dst_stridea] : 0) + 0.707106781186547f * (x2b + x3b); dst[15*dst_stridea] = (add ? dst[15*dst_stridea] : 0) + 0.176776695296637f * (x1d + x1f) - 0.25f*x1e; dst += dst_strideb; src += src_strideb; } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, 1.274548645530178, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 1.126465948111328, -0.26569807294376846, 1.3448324649774837, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 2.3624405881845587, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int audio_write_trailer(AVFormatContext *s1) { OSSAudioData *s = s1->priv_data; ff_oss_audio_close(s); return 0; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align) { int ret, i; ret = av_image_check_size(width, height, 0, NULL); if (ret < 0) return ret; ret = av_image_fill_linesizes(dst_linesize, pix_fmt, width); if (ret < 0) return ret; for (i = 0; i < 4; i++) dst_linesize[i] = FFALIGN(dst_linesize[i], align); return av_image_fill_pointers(dst_data, pix_fmt, height, (uint8_t *)src, dst_linesize); }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.380400859743741, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, 0.11772544131424245, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, 0.18343000506680518, 0.005287286955244392, -0.21702784222394986, 0.33317037975964214, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.3801362775450152, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.3766295797615486]
0<SPLIT>static void free_slice(SwsSlice *s) { int i; if (s) { if (s->should_free_lines) free_lines(s); for (i = 0; i < 4; ++i) { av_freep(&s->plane[i].line); s->plane[i].tmp = NULL; } } }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3070243011888601, -0.4462861841111837, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static inline void fill_rectangle(int x, int y, int w, int h) { SDL_Rect rect; rect.x = x; rect.y = y; rect.w = w; rect.h = h; if (w && h) SDL_RenderFillRect(renderer, &rect); }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int get_intra_count(MpegEncContext *s, uint8_t *src, uint8_t *ref, int stride) { int x, y, w, h; int acc = 0; w = s->width & ~15; h = s->height & ~15; for (y = 0; y < h; y += 16) { for (x = 0; x < w; x += 16) { int offset = x + y * stride; int sad = s->mecc.sad[0](NULL, src + offset, ref + offset, stride, 16); int mean = (s->mpvencdsp.pix_sum(src + offset, stride) + 128) >> 8; int sae = get_sae(src + offset, mean, stride); acc += sae + 500 < sad; } } return acc; }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, 0.11772544131424245, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, 0.29241985090139744, 0.34396739025506545, -0.21702784222394986, 0.23959960763929639, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static inline void cvtyuvtoRGB(SwsContext *c, vector signed short Y, vector signed short U, vector signed short V, vector signed short *R, vector signed short *G, vector signed short *B) { vector signed short vx, ux, uvx; Y = vec_mradds(Y, c->CY, c->OY); U = vec_sub(U, (vector signed short) vec_splat((vector signed short) { 128 }, 0)); V = vec_sub(V, (vector signed short) vec_splat((vector signed short) { 128 }, 0)); ux = vec_sl(U, c->CSHIFT); *B = vec_mradds(ux, c->CBU, Y); vx = vec_sl(V, c->CSHIFT); *R = vec_mradds(vx, c->CRV, Y); uvx = vec_mradds(U, c->CGU, Y); *G = vec_mradds(V, c->CGV, uvx); }<SPLIT>[0.21027592277004517, -0.2625622830695019, 0.0, 0.18995094088131478, -0.3213592940345919, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.21089937656897445, 0.21894446904158188, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, 0.19837465696559078, -0.3116600371295954, -0.011671540416283347, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void bprint_bytes(AVBPrint *bp, const uint8_t *ubuf, size_t ubuf_size) { int i; av_bprintf(bp, "0X"); for (i = 0; i < ubuf_size; i++) av_bprintf(bp, "%02X", ubuf[i]); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size) { int i; for (i=0; i < in->n; i++) { int x = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1); if (in->pitch_lag > 0) do { out[x] = 0.0; x += in->pitch_lag; } while (x < size && repeats); } }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int av_buffersrc_add_frame_internal(AVFilterContext *ctx, AVFrame *frame, int flags) { BufferSourceContext *s = ctx->priv; AVFrame *copy; int refcounted, ret; s->nb_failed_requests = 0; if (!frame) { s->eof = 1; return 0; } else if (s->eof) return AVERROR(EINVAL); refcounted = !!frame->buf[0]; if (!(flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT)) { switch (ctx->outputs[0]->type) { case AVMEDIA_TYPE_VIDEO: CHECK_VIDEO_PARAM_CHANGE(ctx, s, frame->width, frame->height, frame->format); break; case AVMEDIA_TYPE_AUDIO: if (!frame->channel_layout) frame->channel_layout = s->channel_layout; CHECK_AUDIO_PARAM_CHANGE(ctx, s, frame->sample_rate, frame->channel_layout, av_frame_get_channels(frame), frame->format); break; default: return AVERROR(EINVAL); } } if (!av_fifo_space(s->fifo) && (ret = av_fifo_realloc2(s->fifo, av_fifo_size(s->fifo) + sizeof(copy))) < 0) return ret; if (!(copy = av_frame_alloc())) return AVERROR(ENOMEM); if (refcounted) { av_frame_move_ref(copy, frame); } else { ret = av_frame_ref(copy, frame); if (ret < 0) { av_frame_free(&copy); return ret; } } if ((ret = av_fifo_generic_write(s->fifo, &copy, sizeof(copy), NULL)) < 0) { if (refcounted) av_frame_move_ref(frame, copy); av_frame_free(&copy); return ret; } if ((flags & AV_BUFFERSRC_FLAG_PUSH)) if ((ret = ctx->output_pads[0].request_frame(ctx->outputs[0])) < 0) return ret; return 0; }<SPLIT>[-0.09900860198293619, 0.5527916715686512, 0.0, -0.11436118199787926, 0.4659552894840279, 0.0, 0.9701672076669112, 0.9946065798247155, 0.9059316288753189, 2.0295292673408736, 0.48836152962277035, -0.09566541730555662, 0.5919546230485575, 0.0, 0.0, 0.30852482215402843, 0.40964200594544947, -0.11100716297398205, 0.5055429305765636, 0.8941073316973973, 0.6876643500811196, 0.0, -0.08645738172306322, -0.16222078614455715, 0.18424725727220465, 0.8918640029916549, 0.7955408613214935, 0.6817979554923368, 0.8010242403613708, 0.969587250454179, 0.9940939011734088, 0.9053924298597907, 2.0288615559433096, 0.9056307075691036, 0.0, 0.9653245912203542, 0.9897980601469931, 0.9011791483816026, 2.0227778188254817]
0<SPLIT>void av_log_set_callback(void (*callback)(void*, int, const char*, va_list)) { av_log_callback = callback; }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void remap34(int8_t (**p_par_mapped)[PS_MAX_NR_IIDICC], int8_t (*par)[PS_MAX_NR_IIDICC], int num_par, int num_env, int full) { int8_t (*par_mapped)[PS_MAX_NR_IIDICC] = *p_par_mapped; int e; if (num_par == 20 || num_par == 11) { for (e = 0; e < num_env; e++) { map_idx_20_to_34(par_mapped[e], par[e], full); } } else if (num_par == 10 || num_par == 5) { for (e = 0; e < num_env; e++) { map_idx_10_to_34(par_mapped[e], par[e], full); } } else { *p_par_mapped = par; } }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.08729279623175898, 0.0, 0.10120102281206332, 0.11088995743869048, 0.4084056692221168, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 3.3489446507317613, -0.1134457356350565, -0.26569807294376846, -0.06870780348722379, 0.37651940477529405, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, 0.23792492798410134, -0.22049944857796966, -0.21702784222394986, 0.6138826961206794, 0.27459231726984007, 0.28726714485067795, 0.5737900437766489, -0.27935383381430245, 0.9056307075691036, 0.0, 0.791794928969486, 0.8133108086083498, 1.2323429545022004, 0.04739993194876201]
0<SPLIT>static int mov_write_trkn_tag(AVIOContext *pb, MOVMuxContext *mov, AVFormatContext *s, int disc) { AVDictionaryEntry *t = av_dict_get(s->metadata, disc ? "disc" : "track", NULL, 0); int size = 0, track = t ? atoi(t->value) : 0; if (track) { int tracks = 0; char *slash = strchr(t->value, '/'); if (slash) tracks = atoi(slash + 1); avio_wb32(pb, 32); ffio_wfourcc(pb, disc ? "disk" : "trkn"); avio_wb32(pb, 24); ffio_wfourcc(pb, "data"); avio_wb32(pb, 0); avio_wb32(pb, 0); avio_wb16(pb, 0); avio_wb16(pb, track); avio_wb16(pb, tracks); avio_wb16(pb, 0); size = 32; } return size; }<SPLIT>[-0.25365086435942685, -0.08626953612071205, 0.0, -0.2665172434374763, -0.15112911381434976, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.1110049613987252, -0.25297036047912586, -0.06903890269146298, 0.0, 0.0, 0.30852482215402843, -0.17156659581066827, -0.26569807294376846, -0.13496750357150694, 0.24712242304476825, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, 0.12893508214950905, 0.34396739025506545, -0.21702784222394986, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>void *avpriv_atomic_ptr_cas(void * volatile *ptr, void *oldval, void *newval) { void *ret; pthread_mutex_lock(&atomic_lock); ret = *ptr; if (ret == oldval) *ptr = newval; pthread_mutex_unlock(&atomic_lock); return ret; }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 3.3489446507317613, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, -0.270465503877335, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.03454968660237938, -0.3333928163445767, -0.21702784222394986, 0.23959960763929639, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>long WINAPI libAVFilter_SetSyncSource(libAVFilter *this, IReferenceClock *clock) { dshowdebug("libAVFilter_SetSyncSource(%p)\n", this); if (this->clock != clock) { if (this->clock) IReferenceClock_Release(this->clock); this->clock = clock; if (clock) IReferenceClock_AddRef(clock); } return S_OK; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static av_always_inline int process_frame(WriterContext *w, InputFile *ifile, AVFrame *frame, AVPacket *pkt) { AVFormatContext *fmt_ctx = ifile->fmt_ctx; AVCodecContext *dec_ctx = ifile->streams[pkt->stream_index].dec_ctx; AVCodecParameters *par = ifile->streams[pkt->stream_index].st->codecpar; AVSubtitle sub; int ret = 0, got_frame = 0; clear_log(1); if (dec_ctx && dec_ctx->codec) { switch (par->codec_type) { case AVMEDIA_TYPE_VIDEO: ret = avcodec_decode_video2(dec_ctx, frame, &got_frame, pkt); break; case AVMEDIA_TYPE_AUDIO: ret = avcodec_decode_audio4(dec_ctx, frame, &got_frame, pkt); break; case AVMEDIA_TYPE_SUBTITLE: ret = avcodec_decode_subtitle2(dec_ctx, &sub, &got_frame, pkt); break; } } if (ret < 0) return ret; ret = FFMIN(ret, pkt->size); pkt->data += ret; pkt->size -= ret; if (got_frame) { int is_sub = (par->codec_type == AVMEDIA_TYPE_SUBTITLE); nb_streams_frames[pkt->stream_index]++; if (do_show_frames) if (is_sub) show_subtitle(w, &sub, ifile->streams[pkt->stream_index].st, fmt_ctx); else show_frame(w, frame, ifile->streams[pkt->stream_index].st, fmt_ctx); if (is_sub) avsubtitle_free(&sub); } return got_frame; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, 0.16805247409860422, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.11903770506739059, -0.26569807294376846, 0.19633099684990887, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.07885080577644558, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int scale_slice(AVFilterLink *link, AVFrame *out_buf, AVFrame *cur_pic, struct SwsContext *sws, int y, int h, int mul, int field) { ScaleContext *scale = link->dst->priv; const uint8_t *in[4]; uint8_t *out[4]; int in_stride[4],out_stride[4]; int i; for(i=0; i<4; i++){ int vsub= ((i+1)&2) ? scale->vsub : 0; in_stride[i] = cur_pic->linesize[i] * mul; out_stride[i] = out_buf->linesize[i] * mul; in[i] = cur_pic->data[i] + ((y>>vsub)+field) * cur_pic->linesize[i]; out[i] = out_buf->data[i] + field * out_buf->linesize[i]; } if(scale->input_is_pal) in[1] = cur_pic->data[1]; if(scale->output_is_pal) out[1] = out_buf->data[1]; return sws_scale(sws, in, in_stride, y/mul, h, out,out_stride); }<SPLIT>[-0.25365086435942685, -0.1964525029637057, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.21089937656897445, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, -0.14353953243697165, 0.005287286955244392, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int parse_synth_channel_mix(struct sbg_parser *p, struct sbg_script_synth *synth) { int vol; if (!lex_fixed(p, "mix", 3)) return 0; FORWARD_ERROR(parse_volume(p, &vol)); synth->type = SBG_TYPE_MIX; synth->vol = vol; return 1; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.270465503877335, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.14353953243697165, -0.10760608081136262, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_cold void opengl_fill_color_map(OpenGLContext *opengl) { const AVPixFmtDescriptor *desc; int shift; enum AVPixelFormat pix_fmt = opengl->pix_fmt; if (pix_fmt == AV_PIX_FMT_RGB565 || pix_fmt == AV_PIX_FMT_BGR555 || pix_fmt == AV_PIX_FMT_BGR8 || pix_fmt == AV_PIX_FMT_RGB8) pix_fmt = AV_PIX_FMT_RGB24; else if (pix_fmt == AV_PIX_FMT_BGR565 || pix_fmt == AV_PIX_FMT_RGB555) pix_fmt = AV_PIX_FMT_BGR24; desc = av_pix_fmt_desc_get(pix_fmt); if (!(desc->flags & AV_PIX_FMT_FLAG_RGB)) return; #define FILL_COMPONENT(i) { \ shift = desc->comp[i].depth_minus1 >> 3; \ opengl->color_map[(i << 2) + ((desc->comp[i].offset_plus1 - 1) >> shift)] = 1.0; \ } memset(opengl->color_map, 0, sizeof(opengl->color_map)); FILL_COMPONENT(0); FILL_COMPONENT(1); FILL_COMPONENT(2); if (desc->flags & AV_PIX_FMT_FLAG_ALPHA) FILL_COMPONENT(3); #undef FILL_COMPONENT }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.11436118199787926, -0.17240788634188003, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.17156659581066827, -0.11100716297398205, -0.2012272036557901, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, 0.9973611507722091, -0.20220639821224526, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>long WINAPI libAVFilter_Run(libAVFilter *this, REFERENCE_TIME start) { dshowdebug("libAVFilter_Run(%p) %"PRId64"\n", this, start); this->state = State_Running; this->start_time = start; return S_OK; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *in) { AVFilterContext *ctx = inlink->dst; AVFilterLink *outlink = ctx->outputs[0]; NContext *s = ctx->priv; AVFrame *out; int plane, y; out = ff_get_video_buffer(outlink, outlink->w, outlink->h); if (!out) { av_frame_free(&in); return AVERROR(ENOMEM); } av_frame_copy_props(out, in); for (plane = 0; plane < s->nb_planes; plane++) { const int threshold = s->threshold[plane]; if (threshold) { const uint8_t *src = in->data[plane]; uint8_t *dst = out->data[plane]; int stride = in->linesize[plane]; int height = s->planeheight[plane]; int width = s->planewidth[plane]; uint8_t *p0 = s->buffer + 16; uint8_t *p1 = p0 + s->planewidth[0]; uint8_t *p2 = p1 + s->planewidth[0]; uint8_t *orig = p0, *end = p2; line_copy8(p0, src + stride, width, 1); line_copy8(p1, src, width, 1); for (y = 0; y < height; y++) { const uint8_t *coordinates[] = { p0 - 1, p0, p0 + 1, p1 - 1, p1 + 1, p2 - 1, p2, p2 + 1}; src += stride * (y < height - 1 ? 1 : -1); line_copy8(p2, src, width, 1); s->filter(dst, p1, width, threshold, coordinates, s->coordinates); p0 = p1; p1 = p2; p2 = (p2 == end) ? orig: p2 + s->planewidth[0]; dst += out->linesize[plane]; } } else { av_image_copy_plane(out->data[plane], out->linesize[plane], in->data[plane], in->linesize[plane], s->planewidth[plane], s->planeheight[plane]); } } av_frame_free(&in); return ff_filter_frame(outlink, out); }<SPLIT>[-0.25365086435942685, 0.39853551798846004, 0.0, -0.2665172434374763, 0.31700388179131606, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.3285304653503715, -0.25297036047912586, 0.4324044616630353, 0.0, 0.0, 0.30852482215402843, 0.2546530454771514, -0.26569807294376846, 0.35093696371323624, 0.8941073316973973, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5707009127566546, 0.18343000506680518, 0.9084342290881006, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_cold int audio_read_header(AVFormatContext *s1) { SndioData *s = s1->priv_data; AVStream *st; int ret; st = avformat_new_stream(s1, NULL); if (!st) return AVERROR(ENOMEM); ret = ff_sndio_open(s1, 0, s1->filename); if (ret < 0) return ret; st->codec->codec_type = AVMEDIA_TYPE_AUDIO; st->codec->codec_id = s->codec_id; st->codec->sample_rate = s->sample_rate; st->codec->channels = s->channels; avpriv_set_pts_info(st, 64, 1, 1000000); return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.11436118199787926, -0.3213592940345919, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.30718193622042905, -0.11100716297398205, -0.3116600371295954, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int get_samples_per_packet(MOVTrack *track) { int i, first_duration; if (!track->audio_vbr) return 1; if (!track->entry) return 0; first_duration = get_cluster_duration(track, 0); for (i = 1; i < track->entry; i++) { if (get_cluster_duration(track, i) != first_duration) return 0; } return first_duration; }<SPLIT>[0.21027592277004517, -0.3507086565438968, 0.0, 0.18995094088131478, -0.406474384144713, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.29081490870517385, 0.21894446904158188, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, 0.19837465696559078, -0.4000063039086396, -0.5292594673383866, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.25252937827156396, -0.4462861841111837, -0.21702784222394986, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int cmp(void *a, const void *b) { return (uint8_t *) a - (const uint8_t *) b; }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void ripemd256_transform(uint32_t *state, const uint8_t buffer[64]) { uint32_t a, b, c, d, e, f, g, h, av_unused t; uint32_t block[16]; int n; a = state[0]; b = state[1]; c = state[2]; d = state[3]; e = state[4]; f = state[5]; g = state[6]; h = state[7]; for (n = 0; n < 16; n++) block[n] = AV_RL32(buffer + 4 * n); n = 0; #if CONFIG_SMALL for (; n < 16;) { ROUND128_0_TO_15(a,b,c,d,e,f,g,h); t = d; d = c; c = b; b = a; a = t; t = h; h = g; g = f; f = e; e = t; } FFSWAP(uint32_t, a, e); for (; n < 32;) { ROUND128_16_TO_31(a,b,c,d,e,f,g,h); t = d; d = c; c = b; b = a; a = t; t = h; h = g; g = f; f = e; e = t; } FFSWAP(uint32_t, b, f); for (; n < 48;) { ROUND128_32_TO_47(a,b,c,d,e,f,g,h); t = d; d = c; c = b; b = a; a = t; t = h; h = g; g = f; f = e; e = t; } FFSWAP(uint32_t, c, g); for (; n < 64;) { ROUND128_48_TO_63(a,b,c,d,e,f,g,h); t = d; d = c; c = b; b = a; a = t; t = h; h = g; g = f; f = e; e = t; } FFSWAP(uint32_t, d, h); #else R128_0; R128_0; R128_0; R128_0; FFSWAP(uint32_t, a, e); R128_16; R128_16; R128_16; R128_16; FFSWAP(uint32_t, b, f); R128_32; R128_32; R128_32; R128_32; FFSWAP(uint32_t, c, g); R128_48; R128_48; R128_48; R128_48; FFSWAP(uint32_t, d, h); #endif state[0] += a; state[1] += b; state[2] += c; state[3] += d; state[4] += e; state[5] += f; state[6] += g; state[7] += h; }<SPLIT>[-0.25365086435942685, 0.39853551798846004, 0.0, -0.2665172434374763, 0.31700388179131606, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.3285304653503715, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, 0.2546530454771514, -0.26569807294376846, -0.24540033704531222, -0.39986248560786075, -0.4084991676475909, 0.0, 2.5594712480497805, 1.5771521192305922, 2.784026394167595, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>static int gsm_parse(AVCodecParserContext *s1, AVCodecContext *avctx, const uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size) { GSMParseContext *s = s1->priv_data; ParseContext *pc = &s->pc; int next; if (!s->block_size) { switch (avctx->codec_id) { case AV_CODEC_ID_GSM: s->block_size = GSM_BLOCK_SIZE; s->duration = GSM_FRAME_SIZE; break; case AV_CODEC_ID_GSM_MS: s->block_size = avctx->block_align ? avctx->block_align : GSM_MS_BLOCK_SIZE; s->duration = GSM_FRAME_SIZE * 2; break; default: av_assert0(0); } } if (!s->remaining) s->remaining = s->block_size; if (s->remaining <= buf_size) { next = s->remaining; s->remaining = 0; } else { next = END_NOT_FOUND; s->remaining -= buf_size; } if (ff_combine_frame(pc, next, &buf, &buf_size) < 0 || !buf_size) { *poutbuf = NULL; *poutbuf_size = 0; return buf_size; } s1->duration = s->duration; *poutbuf = buf; *poutbuf_size = buf_size; return next; }<SPLIT>[0.5195604475230265, 0.24427936440826892, 0.0, 0.4942630637605089, 0.16805247409860422, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.2885726992822718, 0.5335543553887203, 0.2728543002775131, 0.0, 0.0, 0.30852482215402843, 0.21590580536007686, 0.5077564769051636, 0.19633099684990887, -0.14106852214680915, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, 0.07885080577644558, -0.14353953243697165, -0.4462861841111837, -0.21702784222394986, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>const AVFilter *avfilter_next(const AVFilter *prev) { return prev ? prev->next : first_filter; }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>double strtod(const char *, char **); double avpriv_strtod(const char *nptr, char **endptr) { char *end; double res; while (av_isspace(*nptr)) nptr++; if (!av_strncasecmp(nptr, "infinity", 8)) { end = nptr + 8; res = INFINITY; } else if (!av_strncasecmp(nptr, "inf", 3)) { end = nptr + 3; res = INFINITY; } else if (!av_strncasecmp(nptr, "+infinity", 9)) { end = nptr + 9; res = INFINITY; } else if (!av_strncasecmp(nptr, "+inf", 4)) { end = nptr + 4; res = INFINITY; } else if (!av_strncasecmp(nptr, "-infinity", 9)) { end = nptr + 9; res = -INFINITY; } else if (!av_strncasecmp(nptr, "-inf", 4)) { end = nptr + 4; res = -INFINITY; } else if (!av_strncasecmp(nptr, "nan", 3)) { end = check_nan_suffix(nptr + 3); res = NAN; } else if (!av_strncasecmp(nptr, "+nan", 4) || !av_strncasecmp(nptr, "-nan", 4)) { end = check_nan_suffix(nptr + 4); res = NAN; } else if (!av_strncasecmp(nptr, "0x", 2) || !av_strncasecmp(nptr, "-0x", 3) || !av_strncasecmp(nptr, "+0x", 3)) { res = strtoll(nptr, &end, 16); } else { res = strtod(nptr, &end); } if (endptr) *endptr = end; return res; }<SPLIT>[0.21027592277004517, 0.2663159577768676, 0.0, 0.18995094088131478, 0.21061001915366473, 0.0, 1.49154691857982, 1.5248365532563304, 1.9009835481817232, -0.27925050329511203, 0.268593816248222, 0.21894446904158188, 0.29564718047544486, 0.0, 0.0, 0.30852482215402843, 0.21590580536007686, 0.19837465696559078, 0.24050413023943099, 0.11772544131424245, 2.5511423302199274, 0.0, -0.08645738172306322, -0.16222078614455715, 0.14911510677361828, 1.0553487717435432, 0.11818065472185141, -0.21702784222394986, 1.736731961564828, 1.4908334503424332, 1.524213968415457, 1.9001995881092162, -0.27935383381430245, 0.04889276383167627, 0.0, 1.4859135779729586, 1.519259814762923, 1.8946705667433963, -0.28182971586402455]
0<SPLIT>static int config_input(AVFilterLink *inlink) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format); VectorscopeContext *s = inlink->dst->priv; s->is_yuv = !(desc->flags & AV_PIX_FMT_FLAG_RGB); if (s->mode == GRAY && s->is_yuv) s->pd = 0; else { if ((s->x == 1 && s->y == 2) || (s->x == 2 && s->y == 1)) s->pd = 0; else if ((s->x == 0 && s->y == 2) || (s->x == 2 && s->y == 0)) s->pd = 1; else if ((s->x == 0 && s->y == 1) || (s->x == 1 && s->y == 0)) s->pd = 2; } switch (inlink->format) { case AV_PIX_FMT_GBRAP: case AV_PIX_FMT_GBRP: s->bg_color = black_gbrp_color; break; default: s->bg_color = black_yuva_color; } s->hsub = desc->log2_chroma_w; s->vsub = desc->log2_chroma_h; s->planeheight[1] = s->planeheight[2] = FF_CEIL_RSHIFT(inlink->h, desc->log2_chroma_h); s->planeheight[0] = s->planeheight[3] = inlink->h; s->planewidth[1] = s->planewidth[2] = FF_CEIL_RSHIFT(inlink->w, desc->log2_chroma_w); s->planewidth[0] = s->planewidth[3] = inlink->w; return 0; }<SPLIT>[-0.25365086435942685, 0.023913430722281605, 0.0, -0.2665172434374763, -0.044735251176698444, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.011110546228475942, -0.25297036047912586, 0.04492549829819571, 0.0, 0.0, 0.30852482215402843, -0.07469849551798198, -0.26569807294376846, -0.024534670097701678, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.3615192241061562, -0.4462861841111837, 0.6817979554923368, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int rtmp_receive_hs_packet(RTMPContext* rt, uint32_t *first_int, uint32_t *second_int, char *arraydata, int size) { int inoutsize; inoutsize = ffurl_read_complete(rt->stream, arraydata, RTMP_HANDSHAKE_PACKET_SIZE); if (inoutsize <= 0) return AVERROR(EIO); if (inoutsize != RTMP_HANDSHAKE_PACKET_SIZE) { av_log(rt, AV_LOG_ERROR, "Erroneous Message size %d" " not following standard\n", (int)inoutsize); return AVERROR(EINVAL); } *first_int = AV_RB32(arraydata); *second_int = AV_RB32(arraydata + 4); return 0; }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, 0.11772544131424245, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.3070243011888601, -0.22049944857796966, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_cold int config_output(AVFilterLink *outlink) { AVFilterContext *avctx = outlink->src; ColorkeyContext *ctx = avctx->priv; const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(outlink->format); int i; outlink->w = avctx->inputs[0]->w; outlink->h = avctx->inputs[0]->h; outlink->time_base = avctx->inputs[0]->time_base; for (i = 0; i < 4; ++i) ctx->co[i] = desc->comp[i].offset_plus1 - 1; return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static av_cold int sbg_read_probe(AVProbeData *p) { int r, score; struct sbg_script script = { 0 }; r = parse_script(NULL, p->buf, p->buf_size, &script); score = r < 0 || !script.nb_def || !script.nb_tseq ? 0 : AVPROBE_SCORE_MAX / 3; free_script(&script); return score; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int mov_write_trailer(AVFormatContext *s) { MOVMuxContext *mov = s->priv_data; AVIOContext *pb = s->pb; int res = 0; int i; int64_t moov_pos; for (i = 0; i < mov->nb_streams; i++) { MOVTrack *trk = &mov->tracks[i]; if (trk->enc->codec_id == AV_CODEC_ID_MOV_TEXT && !trk->last_sample_is_subtitle_end) { mov_write_subtitle_end_packet(s, i, trk->track_duration); trk->last_sample_is_subtitle_end = 1; } } if (!mov->chapter_track && !(mov->flags & FF_MOV_FLAG_FRAGMENT)) { if (mov->mode & (MODE_MP4|MODE_MOV|MODE_IPOD) && s->nb_chapters) { mov->chapter_track = mov->nb_streams++; if ((res = mov_create_chapter_track(s, mov->chapter_track)) < 0) goto error; } } if (!(mov->flags & FF_MOV_FLAG_FRAGMENT)) { moov_pos = avio_tell(pb); if (mov->mdat_size + 8 <= UINT32_MAX) { avio_seek(pb, mov->mdat_pos, SEEK_SET); avio_wb32(pb, mov->mdat_size + 8); } else { avio_seek(pb, mov->mdat_pos - 8, SEEK_SET); avio_wb32(pb, 1); ffio_wfourcc(pb, "mdat"); avio_wb64(pb, mov->mdat_size + 16); } avio_seek(pb, mov->reserved_moov_size > 0 ? mov->reserved_header_pos : moov_pos, SEEK_SET); if (mov->flags & FF_MOV_FLAG_FASTSTART) { av_log(s, AV_LOG_INFO, "Starting second pass: moving the moov atom to the beginning of the file\n"); res = shift_data(s); if (res == 0) { avio_seek(pb, mov->reserved_header_pos, SEEK_SET); if ((res = mov_write_moov_tag(pb, mov, s)) < 0) goto error; } } else if (mov->reserved_moov_size > 0) { int64_t size; if ((res = mov_write_moov_tag(pb, mov, s)) < 0) goto error; size = mov->reserved_moov_size - (avio_tell(pb) - mov->reserved_header_pos); if (size < 8){ av_log(s, AV_LOG_ERROR, "reserved_moov_size is too small, needed %"PRId64" additional\n", 8-size); res = AVERROR(EINVAL); goto error; } avio_wb32(pb, size); ffio_wfourcc(pb, "free"); ffio_fill(pb, 0, size - 8); avio_seek(pb, moov_pos, SEEK_SET); } else { if ((res = mov_write_moov_tag(pb, mov, s)) < 0) goto error; } res = 0; } else { mov_auto_flush_fragment(s); for (i = 0; i < mov->nb_streams; i++) mov->tracks[i].data_offset = 0; if (mov->flags & FF_MOV_FLAG_GLOBAL_SIDX) { av_log(s, AV_LOG_INFO, "Starting second pass: inserting sidx atoms\n"); res = shift_data(s); if (res == 0) { int64_t end = avio_tell(pb); avio_seek(pb, mov->reserved_header_pos, SEEK_SET); mov_write_sidx_tags(pb, mov, -1, 0); avio_seek(pb, end, SEEK_SET); mov_write_mfra_tag(pb, mov); } } else { mov_write_mfra_tag(pb, mov); } } error: mov_free(s); return res; }<SPLIT>[1.4474140217819704, 1.1698162858894157, 0.0, 1.4071994323980908, 1.0617609202548755, 0.0, 2.012926629492729, 2.0550665266879453, 1.9009835481817232, 3.34883199341858, 1.2475590849166647, 1.477384014430136, 1.2301552685906463, 0.0, 0.0, 0.30852482215402843, 1.1458395681698652, 1.4359019367238823, 1.123966798029873, 1.5410922403500262, 1.2357461089454749, 0.0, -0.08645738172306322, -0.16222078614455715, 1.0625510197368635, 1.5458030779992087, 1.3600077001545285, 0.6817979554923368, 1.4560196452037908, 2.0120796502306875, 2.054334035657505, 1.9001995881092162, 3.347841778661945, 2.6191065950439585, 0.0, 2.006502564725563, 2.048721569378853, 1.8946705667433963, 3.339696410076628]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { MBContext *mb = ctx->priv; av_freep(&mb->point_cache); av_freep(&mb-> next_cache); av_freep(&mb->zyklus); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int filter_frame(AVFilterLink *link, AVFrame *frame) { AVFilterContext *ctx = link->dst; CropContext *s = ctx->priv; const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(link->format); int i; frame->width = s->w; frame->height = s->h; s->var_values[VAR_N] = link->frame_count; s->var_values[VAR_T] = frame->pts == AV_NOPTS_VALUE ? NAN : frame->pts * av_q2d(link->time_base); s->var_values[VAR_POS] = av_frame_get_pkt_pos(frame) == -1 ? NAN : av_frame_get_pkt_pos(frame); s->var_values[VAR_X] = av_expr_eval(s->x_pexpr, s->var_values, NULL); s->var_values[VAR_Y] = av_expr_eval(s->y_pexpr, s->var_values, NULL); s->var_values[VAR_X] = av_expr_eval(s->x_pexpr, s->var_values, NULL); normalize_double(&s->x, s->var_values[VAR_X]); normalize_double(&s->y, s->var_values[VAR_Y]); if (s->x < 0) s->x = 0; if (s->y < 0) s->y = 0; if ((unsigned)s->x + (unsigned)s->w > link->w) s->x = link->w - s->w; if ((unsigned)s->y + (unsigned)s->h > link->h) s->y = link->h - s->h; s->x &= ~((1 << s->hsub) - 1); s->y &= ~((1 << s->vsub) - 1); av_log(ctx, AV_LOG_TRACE, "n:%d t:%f pos:%f x:%d y:%d x+w:%d y+h:%d\n", (int)s->var_values[VAR_N], s->var_values[VAR_T], s->var_values[VAR_POS], s->x, s->y, s->x+s->w, s->y+s->h); frame->data[0] += s->y * frame->linesize[0]; frame->data[0] += s->x * s->max_step[0]; if (!(desc->flags & AV_PIX_FMT_FLAG_PAL || desc->flags & AV_PIX_FMT_FLAG_PSEUDOPAL)) { for (i = 1; i < 3; i ++) { if (frame->data[i]) { frame->data[i] += (s->y >> s->vsub) * frame->linesize[i]; frame->data[i] += (s->x * s->max_step[i]) >> s->hsub; } } } if (frame->data[3]) { frame->data[3] += s->y * frame->linesize[3]; frame->data[3] += s->x * s->max_step[3]; } return ff_filter_frame(link->dst->outputs[0], frame); }<SPLIT>[-0.09900860198293619, 0.3764989246198613, 0.0, -0.11436118199787926, 0.2957251092637858, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 0.3285304653503715, -0.09566541730555662, 0.40961158146510357, 0.0, 0.0, 0.30852482215402843, 0.2546530454771514, -0.11100716297398205, 0.3288503970184752, 0.24712242304476825, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3599080097651364, 0.12893508214950905, 0.23107402248845843, -0.21702784222394986, 0.05245806339860493, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 1.7623686513065309, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static int find_tracked_method(URLContext *s, RTMPPacket *pkt, int offset, char **tracked_method) { RTMPContext *rt = s->priv_data; GetByteContext gbc; double pkt_id; int ret; int i; bytestream2_init(&gbc, pkt->data + offset, pkt->size - offset); if ((ret = ff_amf_read_number(&gbc, &pkt_id)) < 0) return ret; for (i = 0; i < rt->nb_tracked_methods; i++) { if (rt->tracked_methods[i].id != pkt_id) continue; *tracked_method = rt->tracked_methods[i].name; del_tracked_method(rt, i); break; } return 0; }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, 0.11772544131424245, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.1980344553542678, -0.10760608081136262, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { AudioDelayContext *s = ctx->priv; int i; for (i = 0; i < s->nb_delays; i++) av_freep(&s->chandelay[i].samples); av_freep(&s->chandelay); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void vector_pow43(int *coefs, int len) { int i, coef; for (i=0; i<len; i++) { coef = coefs[i]; if (coef < 0) coef = -(int)cbrt_tab[-coef]; else coef = (int)cbrt_tab[coef]; coefs[i] = coef; } }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.6586564490689124, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.3070243011888601, -0.5591795518777907, -0.21702784222394986, -0.04111270872174079, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int decode_scalefactors(AACContext *ac, INTFLOAT sf[120], GetBitContext *gb, unsigned int global_gain, IndividualChannelStream *ics, enum BandType band_type[120], int band_type_run_end[120]) { int g, i, idx = 0; int offset[3] = { global_gain, global_gain - NOISE_OFFSET, 0 }; int clipped_offset; int noise_flag = 1; for (g = 0; g < ics->num_window_groups; g++) { for (i = 0; i < ics->max_sfb;) { int run_end = band_type_run_end[idx]; if (band_type[idx] == ZERO_BT) { for (; i < run_end; i++, idx++) sf[idx] = FIXR(0.); } else if ((band_type[idx] == INTENSITY_BT) || (band_type[idx] == INTENSITY_BT2)) { for (; i < run_end; i++, idx++) { offset[2] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - SCALE_DIFF_ZERO; clipped_offset = av_clip(offset[2], -155, 100); if (offset[2] != clipped_offset) { avpriv_request_sample(ac->avctx, "If you heard an audible artifact, there may be a bug in the decoder. " "Clipped intensity stereo position (%d -> %d)", offset[2], clipped_offset); } #if USE_FIXED sf[idx] = 100 - clipped_offset; #else sf[idx] = ff_aac_pow2sf_tab[-clipped_offset + POW_SF2_ZERO]; #endif } } else if (band_type[idx] == NOISE_BT) { for (; i < run_end; i++, idx++) { if (noise_flag-- > 0) offset[1] += get_bits(gb, NOISE_PRE_BITS) - NOISE_PRE; else offset[1] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - SCALE_DIFF_ZERO; clipped_offset = av_clip(offset[1], -100, 155); if (offset[1] != clipped_offset) { avpriv_request_sample(ac->avctx, "If you heard an audible artifact, there may be a bug in the decoder. " "Clipped noise gain (%d -> %d)", offset[1], clipped_offset); } #if USE_FIXED sf[idx] = -(100 + clipped_offset); #else sf[idx] = -ff_aac_pow2sf_tab[clipped_offset + POW_SF2_ZERO]; #endif } } else { for (; i < run_end; i++, idx++) { offset[0] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - SCALE_DIFF_ZERO; if (offset[0] > 255U) { av_log(ac->avctx, AV_LOG_ERROR, "Scalefactor (%d) out of range.\n", offset[0]); return AVERROR_INVALIDDATA; } #if USE_FIXED sf[idx] = -offset[0]; #else sf[idx] = -ff_aac_pow2sf_tab[offset[0] - 100 + POW_SF2_ZERO]; #endif } } } } return 0; }<SPLIT>[-0.25365086435942685, 0.9053771654662308, 0.0, -0.2665172434374763, 0.8064156499245122, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.7880447751335181, -0.25297036047912586, 0.6831261438402845, 0.0, 0.0, 0.30852482215402843, 0.7002463068235083, -0.26569807294376846, 0.5938891973556079, 1.1529012951584487, 0.13958259121676436, 0.0, 0.24428369699854227, 5.055897929980891, 0.5355687622580682, 0.12893508214950905, 0.7955408613214935, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>long WINAPI libAVPin_QueryDirection(libAVPin *this, PIN_DIRECTION *dir) { dshowdebug("libAVPin_QueryDirection(%p)\n", this); if (!dir) return E_POINTER; *dir = PINDIR_INPUT; return S_OK; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>int av_strstart(const char *str, const char *pfx, const char **ptr) { while (*pfx && *pfx == *str) { pfx++; str++; } if (!*pfx && ptr) *ptr = str; return !*pfx; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.07259221415890627, -0.06585336703851451, 0.24256368267104944, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.7880534307994381, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.3615192241061562, -0.7849662874110047, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, 0.24218765769350709, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { static const enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV411P, AV_PIX_FMT_YUV410P, AV_PIX_FMT_NONE }; AVFilterFormats *fmts_list = ff_make_format_list(pix_fmts); if (!fmts_list) return AVERROR(ENOMEM); return ff_set_common_formats(ctx, fmts_list); }<SPLIT>[-0.09900860198293619, -0.3947818432810943, 0.0, -0.11436118199787926, -0.44903192919977347, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.09566541730555662, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.11100716297398205, -0.44417943729816173, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static inline int asym_quant(int c, int e, int qbits) { int m; c = (((c << e) >> (24 - qbits)) + 1) >> 1; m = (1 << (qbits-1)); if (c >= m) c = m - 1; av_assert2(c >= -m); return c; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.25252937827156396, -0.5591795518777907, -0.21702784222394986, 0.05245806339860493, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void close_connection(HTTPContext *c) { HTTPContext **cp, *c1; int i, nb_streams; AVFormatContext *ctx; AVStream *st; cp = &first_http_ctx; while (*cp) { c1 = *cp; if (c1 == c) *cp = c->next; else cp = &c1->next; } for(c1 = first_http_ctx; c1; c1 = c1->next) { if (c1->rtsp_c == c) c1->rtsp_c = NULL; } if (c->fd >= 0) closesocket(c->fd); if (c->fmt_in) { for(i=0;i<c->fmt_in->nb_streams;i++) { st = c->fmt_in->streams[i]; if (st->codec->codec) avcodec_close(st->codec); } avformat_close_input(&c->fmt_in); } nb_streams = 0; if (c->stream) nb_streams = c->stream->nb_streams; for(i=0;i<nb_streams;i++) { ctx = c->rtp_ctx[i]; if (ctx) { av_write_trailer(ctx); av_dict_free(&ctx->metadata); av_freep(&ctx->streams[0]); av_freep(&ctx); } ffurl_close(c->rtp_handles[i]); } ctx = c->pfmt_ctx; if (ctx) { if (!c->last_packet_sent && c->state == HTTPSTATE_SEND_DATA_TRAILER) { if (ctx->oformat && avio_open_dyn_buf(&ctx->pb) >= 0) { av_write_trailer(ctx); av_freep(&c->pb_buffer); avio_close_dyn_buf(ctx->pb, &c->pb_buffer); } } for(i=0; i<ctx->nb_streams; i++) av_freep(&ctx->streams[i]); av_freep(&ctx->streams); av_freep(&ctx->priv_data); } if (c->stream && !c->post && c->stream->stream_type == STREAM_TYPE_LIVE) current_bandwidth -= c->stream->bandwidth; if (c->state == HTTPSTATE_RECEIVE_DATA && c->stream) { c->stream->feed_opened = 0; close(c->feed_fd); } av_freep(&c->pb_buffer); av_freep(&c->packet_buffer); av_freep(&c->buffer); av_free(c); nb_connections--; }<SPLIT>[0.8288449722760078, 0.8172307919918359, 0.0, 0.798575186639703, 0.7213005598143911, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, -0.27925050329511203, 0.8479814242356677, 0.8481642417358589, 0.8654691854237383, 0.0, 0.0, 0.30852482215402843, 0.7583671669991201, 0.8171382968447365, 0.7705817309136963, 0.7647103499668715, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.8517581167453454, 0.5648944654878781, 0.6826474935548865, -0.21702784222394986, 0.42674115187998785, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, -0.27935383381430245, 1.7623686513065309, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, -0.28182971586402455]
0<SPLIT>void ff_avfilter_graph_update_heap(AVFilterGraph *graph, AVFilterLink *link) { heap_bubble_up (graph, link, link->age_index); heap_bubble_down(graph, link, link->age_index); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int mxf_interleave_get_packet(AVFormatContext *s, AVPacket *out, AVPacket *pkt, int flush) { int i, stream_count = 0; for (i = 0; i < s->nb_streams; i++) stream_count += !!s->streams[i]->last_in_packet_buffer; if (stream_count && (s->nb_streams == stream_count || flush)) { AVPacketList *pktl = s->internal->packet_buffer; if (s->nb_streams != stream_count) { AVPacketList *last = NULL; while (pktl) { if (!stream_count || pktl->pkt.stream_index == 0) break; last = pktl; pktl = pktl->next; stream_count--; } while (pktl) { AVPacketList *next = pktl->next; if(s->streams[pktl->pkt.stream_index]->last_in_packet_buffer == pktl) s->streams[pktl->pkt.stream_index]->last_in_packet_buffer= NULL; av_free_packet(&pktl->pkt); av_freep(&pktl); pktl = next; } if (last) last->next = NULL; else { s->internal->packet_buffer = NULL; s->internal->packet_buffer_end= NULL; goto out; } pktl = s->internal->packet_buffer; } *out = pktl->pkt; av_log(s, AV_LOG_TRACE, "out st:%d dts:%"PRId64"\n", (*out).stream_index, (*out).dts); s->internal->packet_buffer = pktl->next; if(s->streams[pktl->pkt.stream_index]->last_in_packet_buffer == pktl) s->streams[pktl->pkt.stream_index]->last_in_packet_buffer= NULL; if(!s->internal->packet_buffer) s->internal->packet_buffer_end= NULL; av_freep(&pktl); return 1; } else { out: av_init_packet(out); return 0; } }<SPLIT>[0.05563366039355449, 0.39853551798846004, 0.0, 0.037794879441717756, 0.31700388179131606, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, 0.3684882314184712, 0.061639525868012635, 0.4324044616630353, 0.0, 0.0, 0.30852482215402843, 0.29340028559422593, 0.04368374699580437, 0.35093696371323624, -0.14106852214680915, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, 0.32477585926655006, 0.12893508214950905, 0.005287286955244392, 1.5806237532086234, 0.05245806339860493, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 1.7623686513065309, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static void generate_round_keys(AVCAMELLIA *cs, uint64_t Kl[2], uint64_t Kr[2], uint64_t Ka[2], uint64_t Kb[2]) { int i; uint64_t *Kd[4], d[2]; Kd[0] = Kl; Kd[1] = Kr; Kd[2] = Ka; Kd[3] = Kb; cs->Kw[0] = Kl[0]; cs->Kw[1] = Kl[1]; if (cs->key_bits == 128) { for (i = 0; i < 9; i++) { LR128(d, Kd[vars[0][i]], shifts[0][i]); cs->K[2*i] = d[0]; cs->K[2*i+1] = d[1]; } LR128(d, Kd[0], 60); cs->K[9] = d[1]; LR128(d, Kd[2], 30); cs->Ke[0] = d[0]; cs->Ke[1] = d[1]; LR128(d, Kd[0], 77); cs->Ke[2] = d[0]; cs->Ke[3] = d[1]; LR128(d, Kd[2], 111); cs->Kw[2] = d[0]; cs->Kw[3] = d[1]; } else { for (i = 0; i < 12; i++) { LR128(d, Kd[vars[1][i]], shifts[1][i]); cs->K[2*i] = d[0]; cs->K[2*i+1] = d[1]; } LR128(d, Kd[1], 30); cs->Ke[0] = d[0]; cs->Ke[1] = d[1]; LR128(d, Kd[0], 60); cs->Ke[2] = d[0]; cs->Ke[3] = d[1]; LR128(d, Kd[2], 77); cs->Ke[4] = d[0]; cs->Ke[5] = d[1]; LR128(d, Kd[3], 111); cs->Kw[2] = d[0]; cs->Kw[3] = d[1]; } }<SPLIT>[-0.25365086435942685, 0.3764989246198613, 0.0, -0.2665172434374763, 0.2957251092637858, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.3085515823163217, -0.25297036047912586, 0.40961158146510357, 0.0, 0.0, 0.30852482215402843, 0.23527942541861413, -0.26569807294376846, 0.3288503970184752, -0.5292594673383866, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 0.7463616652495864, -0.1980344553542678, -0.5591795518777907, -0.21702784222394986, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static int init_encoder(AVCodec *enc, AVCodecContext **enc_ctx, int64_t ch_layout, int sample_rate) { AVCodecContext *ctx; int result; char name_buff[NAME_BUFF_SIZE]; av_get_channel_layout_string(name_buff, NAME_BUFF_SIZE, 0, ch_layout); av_log(NULL, AV_LOG_INFO, "channel layout: %s, sample rate: %i\n", name_buff, sample_rate); ctx = avcodec_alloc_context3(enc); if (!ctx) { av_log(NULL, AV_LOG_ERROR, "Can't allocate encoder context\n"); return AVERROR(ENOMEM); } ctx->sample_fmt = AV_SAMPLE_FMT_S16; ctx->sample_rate = sample_rate; ctx->channel_layout = ch_layout; result = avcodec_open2(ctx, enc, NULL); if (result < 0) { av_log(ctx, AV_LOG_ERROR, "Can't open encoder\n"); return result; } *enc_ctx = ctx; return 0; }<SPLIT>[-0.25365086435942685, -0.13034272285790952, 0.0, -0.2665172434374763, -0.1936866588694103, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.1509627274668249, -0.25297036047912586, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.21031383592774278, -0.26569807294376846, -0.17914063696102905, 0.24712242304476825, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, -0.08904460951967552, 0.005287286955244392, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int open_in(HLSContext *c, AVIOContext **in, const char *url) { AVDictionary *tmp = NULL; int ret; av_dict_copy(&tmp, c->avio_opts, 0); ret = avio_open2(in, url, AVIO_FLAG_READ, c->interrupt_callback, &tmp); av_dict_free(&tmp); return ret; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void vector_fmul_reverse_c(float *dst, const float *src0, const float *src1, int len) { int i; src1 += len-1; for (i = 0; i < len; i++) dst[i] = src0[i] * src1[-i]; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.3615192241061562, -0.6720729196443977, -0.21702784222394986, -0.04111270872174079, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void ff_gradfun_filter_line_c(uint8_t *dst, const uint8_t *src, const uint16_t *dc, int width, int thresh, const uint16_t *dithers) { int x; for (x = 0; x < width; dc += x & 1, x++) { int pix = src[x] << 7; int delta = dc[0] - pix; int m = abs(delta) * thresh >> 16; m = FFMAX(0, 127 - m); m = m * m * delta >> 14; pix += m + dithers[x & 7]; dst[x] = av_clip_uint8(pix >> 7); } }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.011671540416283347, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.03454968660237938, 0.005287286955244392, 0.6817979554923368, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int push_samples(AVFilterLink *outlink) { ASNSContext *asns = outlink->src->priv; AVFrame *outsamples = NULL; int ret, nb_out_samples, nb_pad_samples; if (asns->pad) { nb_out_samples = av_audio_fifo_size(asns->fifo) ? asns->nb_out_samples : 0; nb_pad_samples = nb_out_samples - FFMIN(nb_out_samples, av_audio_fifo_size(asns->fifo)); } else { nb_out_samples = FFMIN(asns->nb_out_samples, av_audio_fifo_size(asns->fifo)); nb_pad_samples = 0; } if (!nb_out_samples) return 0; outsamples = ff_get_audio_buffer(outlink, nb_out_samples); if (!outsamples) return AVERROR(ENOMEM); av_audio_fifo_read(asns->fifo, (void **)outsamples->extended_data, nb_out_samples); if (nb_pad_samples) av_samples_set_silence(outsamples->extended_data, nb_out_samples - nb_pad_samples, nb_pad_samples, outlink->channels, outlink->format); outsamples->nb_samples = nb_out_samples; outsamples->channel_layout = outlink->channel_layout; outsamples->sample_rate = outlink->sample_rate; outsamples->pts = asns->next_out_pts; if (asns->next_out_pts != AV_NOPTS_VALUE) asns->next_out_pts += av_rescale_q(nb_out_samples, (AVRational){1, outlink->sample_rate}, outlink->time_base); ret = ff_filter_frame(outlink, outsamples); if (ret < 0) return ret; return nb_out_samples; }<SPLIT>[-0.25365086435942685, 0.0900232108280778, 0.0, -0.2665172434374763, 0.01910106640589235, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.380400859743741, 0.04882610287367361, -0.25297036047912586, 0.11330413889199094, 0.0, 0.0, 0.30852482215402843, -0.016577635342370212, -0.26569807294376846, 0.04172502998658149, 0.37651940477529405, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, 0.29241985090139744, 0.4568607580216725, -0.21702784222394986, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.3801362775450152, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.3766295797615486]
0<SPLIT>int main(int argc, char **argv) { int i, j; AVAES b; uint8_t rkey[2][16] = { { 0 }, { 0x10, 0xa5, 0x88, 0x69, 0xd7, 0x4b, 0xe5, 0xa3, 0x74, 0xcf, 0x86, 0x7c, 0xfb, 0x47, 0x38, 0x59 } }; uint8_t pt[16], rpt[2][16]= { { 0x6a, 0x84, 0x86, 0x7c, 0xd7, 0x7e, 0x12, 0xad, 0x07, 0xea, 0x1b, 0xe8, 0x95, 0xc5, 0x3f, 0xa3 }, { 0 } }; uint8_t rct[2][16]= { { 0x73, 0x22, 0x81, 0xc0, 0xa0, 0xaa, 0xb8, 0xf7, 0xa5, 0x4a, 0x0c, 0x67, 0xa0, 0xc4, 0x5e, 0xcf }, { 0x6d, 0x25, 0x1e, 0x69, 0x44, 0xb0, 0x51, 0xe0, 0x4e, 0xaa, 0x6f, 0xb4, 0xdb, 0xf7, 0x84, 0x65 } }; uint8_t temp[16]; int err = 0; av_log_set_level(AV_LOG_DEBUG); for (i = 0; i < 2; i++) { av_aes_init(&b, rkey[i], 128, 1); av_aes_crypt(&b, temp, rct[i], 1, NULL, 1); for (j = 0; j < 16; j++) { if (rpt[i][j] != temp[j]) { av_log(NULL, AV_LOG_ERROR, "%d %02X %02X\n", j, rpt[i][j], temp[j]); err = 1; } } } if (argc > 1 && !strcmp(argv[1], "-t")) { AVAES ae, ad; AVLFG prng; av_aes_init(&ae, (const uint8_t*)"PI=3.141592654..", 128, 0); av_aes_init(&ad, (const uint8_t*)"PI=3.141592654..", 128, 1); av_lfg_init(&prng, 1); for (i = 0; i < 10000; i++) { for (j = 0; j < 16; j++) { pt[j] = av_lfg_get(&prng); } { START_TIMER; av_aes_crypt(&ae, temp, pt, 1, NULL, 0); if (!(i & (i - 1))) av_log(NULL, AV_LOG_ERROR, "%02X %02X %02X %02X\n", temp[0], temp[5], temp[10], temp[15]); av_aes_crypt(&ad, temp, temp, 1, NULL, 1); STOP_TIMER("aes"); } for (j = 0; j < 16; j++) { if (pt[j] != temp[j]) { av_log(NULL, AV_LOG_ERROR, "%d %d %02X %02X\n", i, j, pt[j], temp[j]); } } } } return err; }<SPLIT>[-0.25365086435942685, 0.729084418517441, 0.0, -0.2665172434374763, 0.63618546970427, 0.0, 0.9701672076669112, 0.9946065798247155, 1.0717736154263862, -0.27925050329511203, 0.6282137108611193, -0.25297036047912586, 0.7742976646320114, 0.0, 0.0, 0.30852482215402843, 0.5452573463552103, -0.26569807294376846, 0.6822354641346521, 0.5059163865058198, 0.6876643500811196, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5355687622580682, 1.0553487717435432, 0.4568607580216725, -0.21702784222394986, 1.4560196452037908, 0.969587250454179, 0.9940939011734088, 1.0711936229013617, -0.27935383381430245, 2.6191065950439585, 0.0, 0.9653245912203542, 0.9897980601469931, 1.0667610514419015, -0.28182971586402455]
0<SPLIT>static int init_MP4DescrParseContext(MP4DescrParseContext *d, AVFormatContext *s, const uint8_t *buf, unsigned size, Mp4Descr *descr, int max_descr_count) { int ret; if (size > (1 << 30)) return AVERROR_INVALIDDATA; if ((ret = ffio_init_context(&d->pb, (unsigned char *)buf, size, 0, NULL, NULL, NULL, NULL)) < 0) return ret; d->s = s; d->level = 0; d->descr_count = 0; d->descr = descr; d->active_descr = NULL; d->max_descr_count = max_descr_count; return 0; }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *buf) { AVFilterContext *ctx = inlink->dst; AVFilterLink *outlink = ctx->outputs[0]; InterlaceContext *s = ctx->priv; AVFrame *out; int tff, ret; av_frame_free(&s->cur); s->cur = s->next; s->next = buf; if (!s->cur || !s->next) return 0; if (s->cur->interlaced_frame) { av_log(ctx, AV_LOG_WARNING, "video is already interlaced, adjusting framerate only\n"); out = av_frame_clone(s->cur); if (!out) return AVERROR(ENOMEM); out->pts /= 2; ret = ff_filter_frame(outlink, out); return ret; } tff = (s->scan == MODE_TFF); out = ff_get_video_buffer(outlink, outlink->w, outlink->h); if (!out) return AVERROR(ENOMEM); av_frame_copy_props(out, s->cur); out->interlaced_frame = 1; out->top_field_first = tff; out->pts /= 2; copy_picture_field(s, s->cur, out, inlink, tff ? FIELD_UPPER : FIELD_LOWER, s->lowpass); av_frame_free(&s->cur); copy_picture_field(s, s->next, out, inlink, tff ? FIELD_LOWER : FIELD_UPPER, s->lowpass); av_frame_free(&s->next); ret = ff_filter_frame(outlink, out); return ret; }<SPLIT>[0.21027592277004517, 0.15613299093387398, 0.0, 0.18995094088131478, 0.08293738398848315, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, 0.1686994010779727, 0.21894446904158188, 0.18168277948578615, 0.0, 0.0, 0.30852482215402843, 0.09966408500885333, 0.19837465696559078, 0.10798473007086465, 0.37651940477529405, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2896437087679637, 0.12893508214950905, 0.34396739025506545, -0.21702784222394986, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>int ff_formats_ref(AVFilterFormats *f, AVFilterFormats **ref) { FORMATS_REF(f, ref); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static inline void compose2D(float *dst, const float *src_l, const float *src_h, int xlinesize, int ylinesize, int step, int w, int h) { int y, x; for (y = 0; y < h; y++) for (x = 0; x < step; x++) compose(dst + ylinesize*y + xlinesize*x, src_l + ylinesize*y + xlinesize*x, src_h + ylinesize*y + xlinesize*x, step * xlinesize, (w - x + step - 1) / step); }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.270465503877335, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.14353953243697165, -0.4462861841111837, -0.21702784222394986, 0.14602883551895066, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void parse_fmtp(AVFormatContext *s, RTSPState *rt, int payload_type, const char *line) { int i; for (i = 0; i < rt->nb_rtsp_streams; i++) { RTSPStream *rtsp_st = rt->rtsp_streams[i]; if (rtsp_st->sdp_payload_type == payload_type && rtsp_st->dynamic_handler && rtsp_st->dynamic_handler->parse_sdp_a_line) { rtsp_st->dynamic_handler->parse_sdp_a_line(s, i, rtsp_st->dynamic_protocol_context, line); } } }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void av_audio_fifo_free(AVAudioFifo *af) { if (af) { if (af->buf) { int i; for (i = 0; i < af->nb_buffers; i++) { if (af->buf[i]) av_fifo_free(af->buf[i]); } av_freep(&af->buf); } av_free(af); } }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3615192241061562, -0.3333928163445767, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int config_output(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; FrameRateContext *s = ctx->priv; int exact; ff_dlog(ctx, "config_output()\n"); ff_dlog(ctx, "config_output() input time base:%u/%u (%f)\n", ctx->inputs[0]->time_base.num,ctx->inputs[0]->time_base.den, av_q2d(ctx->inputs[0]->time_base)); exact = av_reduce(&s->dest_time_base.num, &s->dest_time_base.den, av_gcd((int64_t)s->srce_time_base.num * s->dest_frame_rate.num, (int64_t)s->srce_time_base.den * s->dest_frame_rate.den ), (int64_t)s->srce_time_base.den * s->dest_frame_rate.num, INT_MAX); av_log(ctx, AV_LOG_INFO, "time base:%u/%u -> %u/%u exact:%d\n", s->srce_time_base.num, s->srce_time_base.den, s->dest_time_base.num, s->dest_time_base.den, exact); if (!exact) { av_log(ctx, AV_LOG_WARNING, "Timebase conversion is not exact\n"); } outlink->frame_rate = s->dest_frame_rate; outlink->time_base = s->dest_time_base; outlink->flags |= FF_LINK_FLAG_REQUEST_LOOP; ff_dlog(ctx, "config_output() output time base:%u/%u (%f) w:%d h:%d\n", outlink->time_base.num, outlink->time_base.den, av_q2d(outlink->time_base), outlink->w, outlink->h); av_log(ctx, AV_LOG_INFO, "fps -> fps:%u/%u scene score:%f interpolate start:%d end:%d\n", s->dest_frame_rate.num, s->dest_frame_rate.den, s->scene_score, s->interp_start, s->interp_end); return 0; }<SPLIT>[-0.09900860198293619, 0.0900232108280778, 0.0, -0.11436118199787926, 0.01910106640589235, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.06880498590772346, -0.09566541730555662, 0.11330413889199094, 0.0, 0.0, 0.30852482215402843, 0.0027959847161670454, -0.11100716297398205, 0.04172502998658149, -0.011671540416283347, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.25252937827156396, -0.10760608081136262, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int dc1394_v1_close(AVFormatContext * context) { struct dc1394_data *dc1394 = context->priv_data; dc1394_stop_iso_transmission(dc1394->handle, dc1394->camera.node); dc1394_dma_unlisten(dc1394->handle, &dc1394->camera); dc1394_dma_release_camera(dc1394->handle, &dc1394->camera); dc1394_destroy_handle(dc1394->handle); return 0; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3070243011888601, -0.10760608081136262, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int default_query_formats_common(AVFilterContext *ctx, AVFilterChannelLayouts *(layouts)(void)) { int ret; enum AVMediaType type = ctx->inputs && ctx->inputs [0] ? ctx->inputs [0]->type : ctx->outputs && ctx->outputs[0] ? ctx->outputs[0]->type : AVMEDIA_TYPE_VIDEO; ret = ff_set_common_formats(ctx, ff_all_formats(type)); if (ret < 0) return ret; if (type == AVMEDIA_TYPE_AUDIO) { ret = ff_set_common_channel_layouts(ctx, layouts()); if (ret < 0) return ret; ret = ff_set_common_samplerates(ctx, ff_all_samplerates()); if (ret < 0) return ret; } return 0; }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 1.040052222782594, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.011671540416283347, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, 0.18343000506680518, 0.11818065472185141, -0.21702784222394986, 0.23959960763929639, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 1.039626388904333, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 1.0350888753871217]
0<SPLIT>static int parse_read_interval(const char *interval_spec, ReadInterval *interval) { int ret = 0; char *next, *p, *spec = av_strdup(interval_spec); if (!spec) return AVERROR(ENOMEM); if (!*spec) { av_log(NULL, AV_LOG_ERROR, "Invalid empty interval specification\n"); ret = AVERROR(EINVAL); goto end; } p = spec; next = strchr(spec, '%'); if (next) *next++ = 0; if (*p) { interval->has_start = 1; if (*p == '+') { interval->start_is_offset = 1; p++; } else { interval->start_is_offset = 0; } ret = av_parse_time(&interval->start, p, 1); if (ret < 0) { av_log(NULL, AV_LOG_ERROR, "Invalid interval start specification '%s'\n", p); goto end; } } else { interval->has_start = 0; } p = next; if (p && *p) { int64_t us; interval->has_end = 1; if (*p == '+') { interval->end_is_offset = 1; p++; } else { interval->end_is_offset = 0; } if (interval->end_is_offset && *p == '#') { long long int lli; char *tail; interval->duration_frames = 1; p++; lli = strtoll(p, &tail, 10); if (*tail || lli < 0) { av_log(NULL, AV_LOG_ERROR, "Invalid or negative value '%s' for duration number of frames\n", p); goto end; } interval->end = lli; } else { ret = av_parse_time(&us, p, 1); if (ret < 0) { av_log(NULL, AV_LOG_ERROR, "Invalid interval end/duration specification '%s'\n", p); goto end; } interval->end = us; } } else { interval->has_end = 0; } end: av_free(spec); return ret; }<SPLIT>[0.05563366039355449, 0.8613039787290333, 0.0, 0.037794879441717756, 0.7638581048694516, 0.0, 1.3177536816088504, 1.3480932287791254, 1.5692995750795884, 2.0295292673408736, 0.7880447751335181, 0.061639525868012635, 0.9110549458196018, 0.0, 0.0, 0.30852482215402843, 0.7002463068235083, 0.04368374699580437, 0.8147548643032184, 0.6353133682363457, 2.8799913855385406, 0.0, -0.08645738172306322, -0.16222078614455715, 0.6409652137538272, 1.3823183092473201, 0.7955408613214935, -0.21702784222394986, 1.736731961564828, 1.3170847170463484, 1.3475072793347742, 1.5685972020260743, 2.0288615559433096, 1.7623686513065309, 0.0, 1.3123839157220905, 1.3427725632242797, 1.5635067606227984, 2.0227778188254817]
0<SPLIT>void ff_audio_convert_free(AudioConvert **ac) { if (!*ac) return; ff_dither_free(&(*ac)->dc); av_freep(ac); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int compare_floats(const float *a, const float *b, int len, float max_diff) { int i; for (i = 0; i < len; i++) { if (fabsf(a[i] - b[i]) > max_diff) { av_log(NULL, AV_LOG_ERROR, "%d: %- .12f - %- .12f = % .12g\n", i, a[i], b[i], a[i] - b[i]); return -1; } } return 0; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.270465503877335, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.1980344553542678, -0.4462861841111837, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static void encode_pulses(AACEncContext *s, Pulse *pulse) { int i; put_bits(&s->pb, 1, !!pulse->num_pulse); if (!pulse->num_pulse) return; put_bits(&s->pb, 2, pulse->num_pulse - 1); put_bits(&s->pb, 6, pulse->start); for (i = 0; i < pulse->num_pulse; i++) { put_bits(&s->pb, 5, pulse->pos[i]); put_bits(&s->pb, 4, pulse->amp[i]); } }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void av_sha512_final(AVSHA512* ctx, uint8_t *digest) { uint64_t i = 0; uint64_t finalcount = av_be2ne64(ctx->count << 3); av_sha512_update(ctx, "\200", 1); while ((ctx->count & 127) != 112) av_sha512_update(ctx, "", 1); av_sha512_update(ctx, (uint8_t *)&i, 8); av_sha512_update(ctx, (uint8_t *)&finalcount, 8); for (i = 0; i < ctx->digest_len; i++) AV_WB64(digest + i*8, ctx->state[i]); if (ctx->digest_len & 1) AV_WB32(digest + i*8, ctx->state[i] >> 32); }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void flat_print_str(WriterContext *wctx, const char *key, const char *value) { FlatContext *flat = wctx->priv; AVBPrint buf; printf("%s", wctx->section_pbuf[wctx->level].str); av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED); printf("%s=", flat_escape_key_str(&buf, key, flat->sep)); av_bprint_clear(&buf); printf("\"%s\"\n", flat_escape_value_str(&buf, value)); av_bprint_finalize(&buf, NULL); }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.011671540416283347, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.3615192241061562, -0.10760608081136262, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *in) { AVFilterContext *ctx = inlink->dst; AVFilterLink *outlink = ctx->outputs[0]; ThreadData td; AVFrame *out; out = ff_get_video_buffer(outlink, outlink->w, outlink->h); if (!out) { av_frame_free(&in); return AVERROR(ENOMEM); } av_frame_copy_props(out, in); if (av_pix_fmt_desc_get(inlink->format)->flags & AV_PIX_FMT_FLAG_PAL) memcpy(out->data[1], in->data[1], AVPALETTE_SIZE); td.in = in, td.out = out; ctx->internal->execute(ctx, filter_slice, &td, NULL, FFMIN(outlink->h, ctx->graph->nb_threads)); av_frame_free(&in); return ff_filter_frame(outlink, out); }<SPLIT>[-0.09900860198293619, -0.24052568970090316, 0.0, -0.11436118199787926, -0.30008052150706166, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.2308782596030243, -0.09566541730555662, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.11100716297398205, -0.28957347043483433, 0.24712242304476825, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.1980344553542678, 0.11818065472185141, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int gen_delete_stream(URLContext *s, RTMPContext *rt) { RTMPPacket pkt; uint8_t *p; int ret; av_log(s, AV_LOG_DEBUG, "Deleting stream...\n"); if ((ret = ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE, 0, 34)) < 0) return ret; p = pkt.data; ff_amf_write_string(&p, "deleteStream"); ff_amf_write_number(&p, ++rt->nb_invokes); ff_amf_write_null(&p); ff_amf_write_number(&p, rt->stream_id); return rtmp_send_packet(rt, &pkt, 0); }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, 0.11772544131424245, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.1980344553542678, 0.005287286955244392, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int mov_write_trak_tag(AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track, AVStream *st) { int64_t pos = avio_tell(pb); int entry_backup = track->entry; int chunk_backup = track->chunkCount; int ret; if (mov->flags & FF_MOV_FLAG_EMPTY_MOOV) track->chunkCount = track->entry = 0; avio_wb32(pb, 0); ffio_wfourcc(pb, "trak"); mov_write_tkhd_tag(pb, mov, track, st); av_assert2(mov->use_editlist >= 0); if (track->start_dts != AV_NOPTS_VALUE) { if (mov->use_editlist) mov_write_edts_tag(pb, mov, track); else if ((track->entry && track->cluster[0].dts) || track->mode == MODE_PSP || is_clcp_track(track)) av_log(mov->fc, AV_LOG_WARNING, "Not writing any edit list even though one would have been required\n"); } if (track->tref_tag) mov_write_tref_tag(pb, track); if ((ret = mov_write_mdia_tag(pb, mov, track)) < 0) return ret; if (track->mode == MODE_PSP) mov_write_uuid_tag_psp(pb, track); if (track->tag == MKTAG('r','t','p',' ')) mov_write_udta_sdp(pb, track); if (track->mode == MODE_MOV) { if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO) { double sample_aspect_ratio = av_q2d(st->sample_aspect_ratio); if (st->sample_aspect_ratio.num && 1.0 != sample_aspect_ratio) { mov_write_tapt_tag(pb, track); } } if (is_clcp_track(track) && st->sample_aspect_ratio.num) { mov_write_tapt_tag(pb, track); } } mov_write_track_udta_tag(pb, mov, st); track->entry = entry_backup; track->chunkCount = chunk_backup; return update_size(pb, pos); }<SPLIT>[0.05563366039355449, 0.3103891445140651, 0.0, 0.037794879441717756, 0.231888791681195, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, -0.27925050329511203, 0.2885726992822718, 0.061639525868012635, 0.34123294087130834, 0.0, 0.0, 0.30852482215402843, 0.21590580536007686, 0.04368374699580437, 0.262590696934192, 1.799886203811078, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.07885080577644558, 0.7828741571570628, 1.4729010679211356, -0.21702784222394986, 0.14602883551895066, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, -0.27935383381430245, 1.7623686513065309, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, -0.28182971586402455]
0<SPLIT>static void encode_ms_info(PutBitContext *pb, ChannelElement *cpe) { int i, w; put_bits(pb, 2, cpe->ms_mode); if (cpe->ms_mode == 1) for (w = 0; w < cpe->ch[0].ics.num_windows; w += cpe->ch[0].ics.group_len[w]) for (i = 0; i < cpe->ch[0].ics.max_sfb; i++) put_bits(pb, 1, cpe->ms_mask[w*16 + i]); }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void ff_float_dsp_init_mips(AVFloatDSPContext *fdsp) { #if HAVE_INLINE_ASM && HAVE_MIPSFPU fdsp->vector_fmul = vector_fmul_mips; fdsp->vector_fmul_scalar = vector_fmul_scalar_mips; fdsp->vector_fmul_window = vector_fmul_window_mips; fdsp->butterflies_float = butterflies_float_mips; fdsp->vector_fmul_reverse = vector_fmul_reverse_mips; #endif }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.6160680274418248, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.6650451042457722, -0.7880534307994381, -0.518115519420462, 0.0, 0.4647777494796126, 0.9973611507722091, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void run_lavu_twofish(uint8_t *output, const uint8_t *input, unsigned size) { static struct AVTWOFISH *twofish; if (!twofish && !(twofish = av_twofish_alloc())) fatal_error("out of memory"); av_twofish_init(twofish, hardcoded_key, 128); av_twofish_crypt(twofish, output, input, size >> 4, NULL, 0); }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.24638545112987587, -0.2425966915157195, -0.08912029043108533, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.011671540416283347, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.25252937827156396, -0.10760608081136262, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void dump_attachment(AVStream *st, const char *filename) { int ret; AVIOContext *out = NULL; AVDictionaryEntry *e; if (!st->codecpar->extradata_size) { av_log(NULL, AV_LOG_WARNING, "No extradata to dump in stream #%d:%d.\n", nb_input_files - 1, st->index); return; } if (!*filename && (e = av_dict_get(st->metadata, "filename", NULL, 0))) filename = e->value; if (!*filename) { av_log(NULL, AV_LOG_FATAL, "No filename specified and no 'filename' tag" "in stream #%d:%d.\n", nb_input_files - 1, st->index); exit_program(1); } assert_file_overwrite(filename); if ((ret = avio_open2(&out, filename, AVIO_FLAG_WRITE, &int_cb, NULL)) < 0) { av_log(NULL, AV_LOG_FATAL, "Could not open file %s for writing.\n", filename); exit_program(1); } avio_write(out, st->codecpar->extradata, st->codecpar->extradata_size); avio_flush(out); avio_close(out); }<SPLIT>[-0.25365086435942685, -0.06423294275211332, 0.0, -0.2665172434374763, -0.12985034128681952, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.09102607836467534, -0.25297036047912586, -0.04624602249353125, 0.0, 0.0, 0.30852482215402843, -0.152192975752131, -0.26569807294376846, -0.1128809368767459, 0.37651940477529405, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, 0.18343000506680518, 0.23107402248845843, -0.21702784222394986, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static av_always_inline void color_correlation(uint8_t *dst, int dst_linesize, float **src, int src_linesize, int w, int h, int r, int g, int b) { int x, y; const float *src_r = src[0]; const float *src_g = src[1]; const float *src_b = src[2]; for (y = 0; y < h; y++) { uint8_t *dstp = dst; for (x = 0; x < w; x++) { dstp[r] = av_clip_uint8(src_r[x] * DCT3X3_0_0 + src_g[x] * DCT3X3_1_0 + src_b[x] * DCT3X3_2_0); dstp[g] = av_clip_uint8(src_r[x] * DCT3X3_0_1 + src_b[x] * DCT3X3_2_1); dstp[b] = av_clip_uint8(src_r[x] * DCT3X3_0_2 + src_g[x] * DCT3X3_1_2 + src_b[x] * DCT3X3_2_2); dstp += 3; } dst += dst_linesize; src_r += src_linesize; src_g += src_linesize; src_b += src_linesize; } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int config_output(AVFilterLink *outlink) { int ret; AVFilterContext *ctx = outlink->src; AVFilterLink *inlink = ctx->inputs[0]; AResampleContext *aresample = ctx->priv; int64_t out_rate, out_layout; enum AVSampleFormat out_format; char inchl_buf[128], outchl_buf[128]; aresample->swr = swr_alloc_set_opts(aresample->swr, outlink->channel_layout, outlink->format, outlink->sample_rate, inlink->channel_layout, inlink->format, inlink->sample_rate, 0, ctx); if (!aresample->swr) return AVERROR(ENOMEM); if (!inlink->channel_layout) av_opt_set_int(aresample->swr, "ich", inlink->channels, 0); if (!outlink->channel_layout) av_opt_set_int(aresample->swr, "och", outlink->channels, 0); ret = swr_init(aresample->swr); if (ret < 0) return ret; av_opt_get_int(aresample->swr, "osr", 0, &out_rate); av_opt_get_int(aresample->swr, "ocl", 0, &out_layout); av_opt_get_sample_fmt(aresample->swr, "osf", 0, &out_format); outlink->time_base = (AVRational) {1, out_rate}; av_assert0(outlink->sample_rate == out_rate); av_assert0(outlink->channel_layout == out_layout || !outlink->channel_layout); av_assert0(outlink->format == out_format); aresample->ratio = (double)outlink->sample_rate / inlink->sample_rate; av_get_channel_layout_string(inchl_buf, sizeof(inchl_buf), inlink ->channels, inlink ->channel_layout); av_get_channel_layout_string(outchl_buf, sizeof(outchl_buf), outlink->channels, outlink->channel_layout); av_log(ctx, AV_LOG_VERBOSE, "ch:%d chl:%s fmt:%s r:%dHz -> ch:%d chl:%s fmt:%s r:%dHz\n", inlink ->channels, inchl_buf, av_get_sample_fmt_name(inlink->format), inlink->sample_rate, outlink->channels, outchl_buf, av_get_sample_fmt_name(outlink->format), outlink->sample_rate); return 0; }<SPLIT>[-0.25365086435942685, 0.15613299093387398, 0.0, -0.2665172434374763, 0.08293738398848315, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.10876275197582316, -0.25297036047912586, 0.18168277948578615, 0.0, 0.0, 0.30852482215402843, 0.04154322483324156, -0.26569807294376846, 0.10798473007086465, 0.8941073316973973, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 0.18424725727220465, 0.29241985090139744, 0.9084342290881006, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int glyph_cmp(void *key, const void *b) { const Glyph *a = key, *bb = b; int64_t diff = (int64_t)a->code - (int64_t)bb->code; return diff > 0 ? 1 : diff < 0 ? -1 : 0; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int read_mfra(struct Tracks *tracks, int start_index, const char *file, int split, int ismf, const char *basename, const char* output_prefix) { int err = 0; const char* err_str = ""; AVIOContext *f = NULL; int32_t mfra_size; if ((err = avio_open2(&f, file, AVIO_FLAG_READ, NULL, NULL)) < 0) goto fail; avio_seek(f, avio_size(f) - 4, SEEK_SET); mfra_size = avio_rb32(f); avio_seek(f, -mfra_size, SEEK_CUR); if (avio_rb32(f) != mfra_size) { err = AVERROR_INVALIDDATA; err_str = "mfra size mismatch"; goto fail; } if (avio_rb32(f) != MKBETAG('m', 'f', 'r', 'a')) { err = AVERROR_INVALIDDATA; err_str = "mfra tag mismatch"; goto fail; } while (!read_tfra(tracks, start_index, f)) { } if (split || ismf) err = write_fragments(tracks, start_index, f, basename, split, ismf, output_prefix); err_str = "error in write_fragments"; fail: if (f) avio_close(f); if (err) fprintf(stderr, "Unable to read the MFRA atom in %s (%s)\n", file, err_str); return err; }<SPLIT>[-0.09900860198293619, 0.13409639756527525, 0.0, -0.11436118199787926, 0.06165861146095288, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, 0.10876275197582316, -0.09566541730555662, 0.1588898992878544, 0.0, 0.0, 0.30852482215402843, 0.04154322483324156, -0.11100716297398205, 0.08589816337610359, 0.7647103499668715, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, 0.6193893884051743, 0.6826474935548865, 0.6817979554923368, 0.42674115187998785, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>int av_hmac_final(AVHMAC *c, uint8_t *out, unsigned int outlen) { uint8_t block[MAX_BLOCKLEN]; int i; if (outlen < c->hashlen) return AVERROR(EINVAL); c->final(c->hash, out); c->init(c->hash); for (i = 0; i < c->keylen; i++) block[i] = c->key[i] ^ 0x5C; for (i = c->keylen; i < c->blocklen; i++) block[i] = 0x5C; c->update(c->hash, block, c->blocklen); c->update(c->hash, out, c->hashlen); c->final(c->hash, out); return c->hashlen; }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int read_sbr_single_channel_element(AACContext *ac, SpectralBandReplication *sbr, GetBitContext *gb) { if (get_bits1(gb)) skip_bits(gb, 4); if (read_sbr_grid(ac, sbr, gb, &sbr->data[0])) return -1; read_sbr_dtdf(sbr, gb, &sbr->data[0]); read_sbr_invf(sbr, gb, &sbr->data[0]); read_sbr_envelope(sbr, gb, &sbr->data[0], 0); read_sbr_noise(sbr, gb, &sbr->data[0], 0); if ((sbr->data[0].bs_add_harmonic_flag = get_bits1(gb))) get_bits1_vector(gb, sbr->data[0].bs_add_harmonic, sbr->n[1]); return 0; }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, 0.5059163865058198, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.08904460951967552, 0.11818065472185141, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void dump_bih(void *s, BITMAPINFOHEADER *bih) { dshowdebug(" BITMAPINFOHEADER\n"); dstruct(s, bih, biSize, "lu"); dstruct(s, bih, biWidth, "ld"); dstruct(s, bih, biHeight, "ld"); dstruct(s, bih, biPlanes, "d"); dstruct(s, bih, biBitCount, "d"); dstruct(s, bih, biCompression, "lu"); dshowdebug(" biCompression:\t\"%.4s\"\n", (char*) &bih->biCompression); dstruct(s, bih, biSizeImage, "lu"); dstruct(s, bih, biXPelsPerMeter, "lu"); dstruct(s, bih, biYPelsPerMeter, "lu"); dstruct(s, bih, biClrUsed, "lu"); dstruct(s, bih, biClrImportant, "lu"); }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int libAVEnumMediaTypes_Setup(libAVEnumMediaTypes *this, const AM_MEDIA_TYPE *type) { IEnumMediaTypesVtbl *vtbl = this->vtbl; SETVTBL(vtbl, libAVEnumMediaTypes, QueryInterface); SETVTBL(vtbl, libAVEnumMediaTypes, AddRef); SETVTBL(vtbl, libAVEnumMediaTypes, Release); SETVTBL(vtbl, libAVEnumMediaTypes, Next); SETVTBL(vtbl, libAVEnumMediaTypes, Skip); SETVTBL(vtbl, libAVEnumMediaTypes, Reset); SETVTBL(vtbl, libAVEnumMediaTypes, Clone); if (!type) { this->type.majortype = GUID_NULL; } else { ff_copy_dshow_media_type(&this->type, type); } return 1; }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void camellia_encrypt(AVCAMELLIA *cs, uint8_t *dst, const uint8_t *src) { uint64_t D1, D2; D1 = AV_RB64(src); D2 = AV_RB64(src + 8); D1 ^= cs->Kw[0]; D2 ^= cs->Kw[1]; D2 ^= F(D1, cs->K[0]); D1 ^= F(D2, cs->K[1]); D2 ^= F(D1, cs->K[2]); D1 ^= F(D2, cs->K[3]); D2 ^= F(D1, cs->K[4]); D1 ^= F(D2, cs->K[5]); D1 = FL(D1, cs->Ke[0]); D2 = FLINV(D2, cs->Ke[1]); D2 ^= F(D1, cs->K[6]); D1 ^= F(D2, cs->K[7]); D2 ^= F(D1, cs->K[8]); D1 ^= F(D2, cs->K[9]); D2 ^= F(D1, cs->K[10]); D1 ^= F(D2, cs->K[11]); D1 = FL(D1, cs->Ke[2]); D2 = FLINV(D2, cs->Ke[3]); D2 ^= F(D1, cs->K[12]); D1 ^= F(D2, cs->K[13]); D2 ^= F(D1, cs->K[14]); D1 ^= F(D2, cs->K[15]); D2 ^= F(D1, cs->K[16]); D1 ^= F(D2, cs->K[17]); if (cs->key_bits != 128) { D1 = FL(D1, cs->Ke[4]); D2 = FLINV(D2, cs->Ke[5]); D2 ^= F(D1, cs->K[18]); D1 ^= F(D2, cs->K[19]); D2 ^= F(D1, cs->K[20]); D1 ^= F(D2, cs->K[21]); D2 ^= F(D1, cs->K[22]); D1 ^= F(D2, cs->K[23]); } D2 ^= cs->Kw[2]; D1 ^= cs->Kw[3]; AV_WB64(dst, D2); AV_WB64(dst + 8, D1); }<SPLIT>[-0.25365086435942685, 0.3103891445140651, 0.0, -0.2665172434374763, 0.231888791681195, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.24861493321417213, -0.25297036047912586, 0.34123294087130834, 0.0, 0.0, 0.30852482215402843, 0.17715856524300236, -0.26569807294376846, 0.262590696934192, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 0.6760973642524136, -0.3615192241061562, -0.22049944857796966, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void param_write_hex(AVIOContext *pb, const char *name, const uint8_t *value, int len) { char buf[150]; len = FFMIN(sizeof(buf) / 2 - 1, len); ff_data_to_hex(buf, value, len, 0); buf[2 * len] = '\0'; avio_printf(pb, "<param name=\"%s\" value=\"%s\" valuetype=\"data\"/>\n", name, buf); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.3615192241061562, -0.3333928163445767, -0.21702784222394986, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd){ int64_t r=0; assert(c > 0); assert(b >=0); assert(rnd >=0 && rnd<=5 && rnd!=4); if(a<0 && a != INT64_MIN) return -av_rescale_rnd(-a, b, c, rnd ^ ((rnd>>1)&1)); if(rnd==AV_ROUND_NEAR_INF) r= c/2; else if(rnd&1) r= c-1; if(b<=INT_MAX && c<=INT_MAX){ if(a<=INT_MAX) return (a * b + r)/c; else return a/c*b + (a%c*b + r)/c; }else{ uint64_t a0= a&0xFFFFFFFF; uint64_t a1= a>>32; uint64_t b0= b&0xFFFFFFFF; uint64_t b1= b>>32; uint64_t t1= a0*b1 + a1*b0; uint64_t t1a= t1<<32; int i; a0 = a0*b0 + t1a; a1 = a1*b1 + (t1>>32) + (a0<t1a); a0 += r; a1 += a0<r; for(i=63; i>=0; i--){ a1+= a1 + ((a0>>i)&1); t1+=t1; if(c <= a1){ a1 -= c; t1++; } } return t1; } AVInteger ai; ai= av_mul_i(av_int2i(a), av_int2i(b)); ai= av_add_i(ai, av_int2i(r)); return av_i2int(av_div_i(ai, av_int2i(c))); } }<SPLIT>[1.1381294970289892, 0.2222427710396702, 0.0, 1.2550433709584938, 0.16805247409860422, 0.0, 0.10120102281206332, 0.11088995743869048, 0.4084056692221168, -0.27925050329511203, 0.3485093483844214, 1.1627741280829973, 0.2500614200795814, 0.0, 0.0, 0.30852482215402843, 0.31277390565276314, 1.281211026754096, 0.19633099684990887, -0.011671540416283347, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3950401602637228, 0.0744401592322129, 0.11818065472185141, -0.21702784222394986, 0.05245806339860493, 0.10084358397375535, 0.11056045576999526, 0.40798885073507796, -0.27935383381430245, 1.7623686513065309, 0.0, 0.09767627996601334, 0.10736180245377658, 0.4044334392007059, -0.28182971586402455]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { BiquadsContext *s = ctx->priv; av_freep(&s->cache); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>void ff_vector_fmul_altivec(float *dst, const float *src0, const float *src1, int len) { int i; vec_f d0, d1, s, zero = (vec_f)vec_splat_u32(0); for (i = 0; i < len - 7; i += 8) { d0 = vec_ld( 0, src0 + i); s = vec_ld( 0, src1 + i); d1 = vec_ld(16, src0 + i); d0 = vec_madd(d0, s, zero); d1 = vec_madd(d1, vec_ld(16, src1 + i), zero); vec_st(d0, 0, dst + i); vec_st(d1, 16, dst + i); } }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.3070243011888601, -0.3333928163445767, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *in) { AVFilterContext *ctx = inlink->dst; RandomContext *s = ctx->priv; AVFilterLink *outlink = ctx->outputs[0]; AVFrame *out; int idx; if (s->nb_frames_filled < s->nb_frames) { s->frames[s->nb_frames_filled] = in; s->pts[s->nb_frames_filled++] = in->pts; return 0; } idx = av_lfg_get(&s->lfg) % s->nb_frames; out = s->frames[idx]; out->pts = s->pts[0]; memmove(&s->pts[0], &s->pts[1], (s->nb_frames - 1) * sizeof(s->pts[0])); s->frames[idx] = in; s->pts[s->nb_frames - 1] = in->pts; return ff_filter_frame(outlink, out); }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, -0.3615192241061562, -0.3333928163445767, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int get_sidx_size(AVFormatContext *s) { int ret; AVIOContext *buf; MOVMuxContext *mov = s->priv_data; if ((ret = ffio_open_null_buf(&buf)) < 0) return ret; mov_write_sidx_tags(buf, mov, -1, 0); return ffio_close_null_buf(buf); }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3615192241061562, -0.3333928163445767, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int get_nb_points(const struct keypoint *d) { int n = 0; while (d) { n++; d = d->next; } return n; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.6586564490689124, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { AVFilterFormats *formats; AVFilterChannelLayouts *layouts; static const enum AVSampleFormat sample_fmts[] = { AV_SAMPLE_FMT_DBL, AV_SAMPLE_FMT_DBLP, AV_SAMPLE_FMT_FLT, AV_SAMPLE_FMT_FLTP, AV_SAMPLE_FMT_S32, AV_SAMPLE_FMT_S32P, AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_S16P, AV_SAMPLE_FMT_NONE }; int ret; layouts = ff_all_channel_layouts(); if (!layouts) return AVERROR(ENOMEM); ret = ff_set_common_channel_layouts(ctx, layouts); if (ret < 0) return ret; formats = ff_make_format_list(sample_fmts); if (!formats) return AVERROR(ENOMEM); ret = ff_set_common_formats(ctx, formats); if (ret < 0) return ret; formats = ff_all_samplerates(); if (!formats) return AVERROR(ENOMEM); return ff_set_common_samplerates(ctx, formats); }<SPLIT>[-0.25365086435942685, -0.020159756014915854, 0.0, -0.2665172434374763, -0.08729279623175898, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.051068312296575644, -0.25297036047912586, -0.0006602620976677653, 0.0, 0.0, 0.30852482215402843, -0.1134457356350565, -0.26569807294376846, -0.06870780348722379, 0.37651940477529405, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, 0.0744401592322129, 0.34396739025506545, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int mpeg_decode_slice(MpegEncContext *s, int mb_y, const uint8_t **buf, int buf_size) { AVCodecContext *avctx = s->avctx; const int lowres = s->avctx->lowres; const int field_pic = s->picture_structure != PICT_FRAME; int ret; s->resync_mb_x = s->resync_mb_y = -1; av_assert0(mb_y < s->mb_height); init_get_bits(&s->gb, *buf, buf_size * 8); if (s->codec_id != AV_CODEC_ID_MPEG1VIDEO && s->mb_height > 2800/16) skip_bits(&s->gb, 3); ff_mpeg1_clean_buffers(s); s->interlaced_dct = 0; s->qscale = get_qscale(s); if (s->qscale == 0) { av_log(s->avctx, AV_LOG_ERROR, "qscale == 0\n"); return AVERROR_INVALIDDATA; } if (skip_1stop_8data_bits(&s->gb) < 0) return AVERROR_INVALIDDATA; s->mb_x = 0; if (mb_y == 0 && s->codec_tag == AV_RL32("SLIF")) { skip_bits1(&s->gb); } else { while (get_bits_left(&s->gb) > 0) { int code = get_vlc2(&s->gb, ff_mbincr_vlc.table, MBINCR_VLC_BITS, 2); if (code < 0) { av_log(s->avctx, AV_LOG_ERROR, "first mb_incr damaged\n"); return AVERROR_INVALIDDATA; } if (code >= 33) { if (code == 33) s->mb_x += 33; } else { s->mb_x += code; break; } } } if (s->mb_x >= (unsigned) s->mb_width) { av_log(s->avctx, AV_LOG_ERROR, "initial skip overflow\n"); return AVERROR_INVALIDDATA; } if (avctx->hwaccel && avctx->hwaccel->decode_slice) { const uint8_t *buf_end, *buf_start = *buf - 4; int start_code = -1; buf_end = avpriv_find_start_code(buf_start + 2, *buf + buf_size, &start_code); if (buf_end < *buf + buf_size) buf_end -= 4; s->mb_y = mb_y; if (avctx->hwaccel->decode_slice(avctx, buf_start, buf_end - buf_start) < 0) return DECODE_SLICE_ERROR; *buf = buf_end; return DECODE_SLICE_OK; } s->resync_mb_x = s->mb_x; s->resync_mb_y = s->mb_y = mb_y; s->mb_skip_run = 0; ff_init_block_index(s); if (s->mb_y == 0 && s->mb_x == 0 && (s->first_field || s->picture_structure == PICT_FRAME)) { if (s->avctx->debug & FF_DEBUG_PICT_INFO) { av_log(s->avctx, AV_LOG_DEBUG, "qp:%d fc:%2d%2d%2d%2d %s %s %s %s %s dc:%d pstruct:%d fdct:%d cmv:%d qtype:%d ivlc:%d rff:%d %s\n", s->qscale, s->mpeg_f_code[0][0], s->mpeg_f_code[0][1], s->mpeg_f_code[1][0], s->mpeg_f_code[1][1], s->pict_type == AV_PICTURE_TYPE_I ? "I" : (s->pict_type == AV_PICTURE_TYPE_P ? "P" : (s->pict_type == AV_PICTURE_TYPE_B ? "B" : "S")), s->progressive_sequence ? "ps" : "", s->progressive_frame ? "pf" : "", s->alternate_scan ? "alt" : "", s->top_field_first ? "top" : "", s->intra_dc_precision, s->picture_structure, s->frame_pred_frame_dct, s->concealment_motion_vectors, s->q_scale_type, s->intra_vlc_format, s->repeat_first_field, s->chroma_420_type ? "420" : ""); } } for (;;) { if ((CONFIG_MPEG1_XVMC_HWACCEL || CONFIG_MPEG2_XVMC_HWACCEL) && s->pack_pblocks) ff_xvmc_init_block(s); if ((ret = mpeg_decode_mb(s, s->block)) < 0) return ret; if (s->current_picture.motion_val[0] && !s->encoding) { const int wrap = s->b8_stride; int xy = s->mb_x * 2 + s->mb_y * 2 * wrap; int b8_xy = 4 * (s->mb_x + s->mb_y * s->mb_stride); int motion_x, motion_y, dir, i; for (i = 0; i < 2; i++) { for (dir = 0; dir < 2; dir++) { if (s->mb_intra || (dir == 1 && s->pict_type != AV_PICTURE_TYPE_B)) { motion_x = motion_y = 0; } else if (s->mv_type == MV_TYPE_16X16 || (s->mv_type == MV_TYPE_FIELD && field_pic)) { motion_x = s->mv[dir][0][0]; motion_y = s->mv[dir][0][1]; } else { motion_x = s->mv[dir][i][0]; motion_y = s->mv[dir][i][1]; } s->current_picture.motion_val[dir][xy][0] = motion_x; s->current_picture.motion_val[dir][xy][1] = motion_y; s->current_picture.motion_val[dir][xy + 1][0] = motion_x; s->current_picture.motion_val[dir][xy + 1][1] = motion_y; s->current_picture.ref_index [dir][b8_xy] = s->current_picture.ref_index [dir][b8_xy + 1] = s->field_select[dir][i]; av_assert2(s->field_select[dir][i] == 0 || s->field_select[dir][i] == 1); } xy += wrap; b8_xy += 2; } } s->dest[0] += 16 >> lowres; s->dest[1] +=(16 >> lowres) >> s->chroma_x_shift; s->dest[2] +=(16 >> lowres) >> s->chroma_x_shift; ff_mpv_decode_mb(s, s->block); if (++s->mb_x >= s->mb_width) { const int mb_size = 16 >> s->avctx->lowres; ff_mpeg_draw_horiz_band(s, mb_size * (s->mb_y >> field_pic), mb_size); ff_mpv_report_decode_progress(s); s->mb_x = 0; s->mb_y += 1 << field_pic; if (s->mb_y >= s->mb_height) { int left = get_bits_left(&s->gb); int is_d10 = s->chroma_format == 2 && s->pict_type == AV_PICTURE_TYPE_I && avctx->profile == 0 && avctx->level == 5 && s->intra_dc_precision == 2 && s->q_scale_type == 1 && s->alternate_scan == 0 && s->progressive_frame == 0 ; if (left >= 32 && !is_d10) { GetBitContext gb = s->gb; align_get_bits(&gb); if (show_bits(&gb, 24) == 0x060E2B) { av_log(avctx, AV_LOG_DEBUG, "Invalid MXF data found in video stream\n"); is_d10 = 1; } } if (left < 0 || (left && show_bits(&s->gb, FFMIN(left, 23)) && !is_d10) || ((avctx->err_recognition & (AV_EF_BITSTREAM | AV_EF_AGGRESSIVE)) && left > 8)) { av_log(avctx, AV_LOG_ERROR, "end mismatch left=%d %0X\n", left, show_bits(&s->gb, FFMIN(left, 23))); return AVERROR_INVALIDDATA; } else goto eos; } if (s->mb_y >= ((s->height + 15) >> 4) && !s->progressive_sequence && get_bits_left(&s->gb) <= 8 && get_bits_left(&s->gb) >= 0 && s->mb_skip_run == -1 && show_bits(&s->gb, 8) == 0) goto eos; ff_init_block_index(s); } if (s->mb_skip_run == -1) { s->mb_skip_run = 0; for (;;) { int code = get_vlc2(&s->gb, ff_mbincr_vlc.table, MBINCR_VLC_BITS, 2); if (code < 0) { av_log(s->avctx, AV_LOG_ERROR, "mb incr damaged\n"); return AVERROR_INVALIDDATA; } if (code >= 33) { if (code == 33) { s->mb_skip_run += 33; } else if (code == 35) { if (s->mb_skip_run != 0 || show_bits(&s->gb, 15) != 0) { av_log(s->avctx, AV_LOG_ERROR, "slice mismatch\n"); return AVERROR_INVALIDDATA; } goto eos; } } else { s->mb_skip_run += code; break; } } if (s->mb_skip_run) { int i; if (s->pict_type == AV_PICTURE_TYPE_I) { av_log(s->avctx, AV_LOG_ERROR, "skipped MB in I frame at %d %d\n", s->mb_x, s->mb_y); return AVERROR_INVALIDDATA; } s->mb_intra = 0; for (i = 0; i < 12; i++) s->block_last_index[i] = -1; if (s->picture_structure == PICT_FRAME) s->mv_type = MV_TYPE_16X16; else s->mv_type = MV_TYPE_FIELD; if (s->pict_type == AV_PICTURE_TYPE_P) { s->mv_dir = MV_DIR_FORWARD; s->mv[0][0][0] = s->mv[0][0][1] = 0; s->last_mv[0][0][0] = s->last_mv[0][0][1] = 0; s->last_mv[0][1][0] = s->last_mv[0][1][1] = 0; s->field_select[0][0] = (s->picture_structure - 1) & 1; } else { s->mv[0][0][0] = s->last_mv[0][0][0]; s->mv[0][0][1] = s->last_mv[0][0][1]; s->mv[1][0][0] = s->last_mv[1][0][0]; s->mv[1][0][1] = s->last_mv[1][0][1]; } } } } eos: if (get_bits_left(&s->gb) < 0) { av_log(s, AV_LOG_ERROR, "overread %d\n", -get_bits_left(&s->gb)); return AVERROR_INVALIDDATA; } *buf += (get_bits_count(&s->gb) - 1) / 8; ff_dlog(s, "Slice start:%d %d end:%d %d\n", s->resync_mb_x, s->resync_mb_y, s->mb_x, s->mb_y); return 0; }<SPLIT>[1.9113408089114425, 4.276975950861837, 0.0, 1.863667616716882, 4.062067846636642, 0.0, 4.793618421028242, 4.882959718323225, 4.720297319549869, 3.34883199341858, 4.144497124853893, 1.9492988439508436, 4.4439513764990215, 0.0, 0.0, 0.30852482215402843, 3.9550144766577677, 1.8999746666332415, 4.238172701991182, 4.258428856691069, 2.4415259784470567, 0.0, -0.08645738172306322, -0.16222078614455715, 3.416405103142149, 4.270549223864015, 4.069448526553097, 5.17592694407377, 3.421005859731051, 4.792059382968043, 4.881641060948428, 4.718819869815921, 3.347841778661945, 4.332582482518814, 0.0, 4.782977160739454, 4.872517593997146, 4.709562918768478, 3.339696410076628]
0<SPLIT>static void calc_stereo_peak(const float *samples, int nb_samples, float *peak_p) { float peak = 0.0; while (nb_samples--) { if (samples[0] > peak) peak = samples[0]; else if (-samples[0] > peak) peak = -samples[0]; if (samples[1] > peak) peak = samples[1]; else if (-samples[1] > peak) peak = -samples[1]; samples += 2; } *peak_p = FFMAX(peak, *peak_p); }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.39986248560786075, 0.7972807018539907, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, 0.01994523631491676, -0.5591795518777907, -0.21702784222394986, 0.5203119240003335, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, -0.27935383381430245, 0.9056307075691036, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, -0.28182971586402455]
0<SPLIT>static int request_frame(AVFilterLink *outlink) { int ret; ANullContext *null = outlink->src->priv; AVFrame *samplesref; samplesref = ff_get_audio_buffer(outlink, null->nb_samples); if (!samplesref) return AVERROR(ENOMEM); samplesref->pts = null->pts; samplesref->channel_layout = null->channel_layout; samplesref->sample_rate = outlink->sample_rate; ret = ff_filter_frame(outlink, av_frame_clone(samplesref)); av_frame_free(&samplesref); if (ret < 0) return ret; null->pts += null->nb_samples; return ret; }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.14106852214680915, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.1980344553542678, -0.10760608081136262, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void perform_dc_correction(DynamicAudioNormalizerContext *s, AVFrame *frame) { const double diff = 1.0 / frame->nb_samples; int is_first_frame = cqueue_empty(s->gain_history_original[0]); int c, i; for (c = 0; c < s->channels; c++) { double *dst_ptr = (double *)frame->extended_data[c]; double current_average_value = 0.0; double prev_value; for (i = 0; i < frame->nb_samples; i++) current_average_value += dst_ptr[i] * diff; prev_value = is_first_frame ? current_average_value : s->dc_correction_value[c]; s->dc_correction_value[c] = is_first_frame ? current_average_value : update_value(current_average_value, s->dc_correction_value[c], 0.1); for (i = 0; i < frame->nb_samples; i++) { dst_ptr[i] -= fade(prev_value, s->dc_correction_value[c], i, s->fade_factors); } } }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, 0.24712242304476825, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, -0.14353953243697165, 0.34396739025506545, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *frame) { AVFilterContext *ctx = inlink->dst; int i, ret = AVERROR_EOF; for (i = 0; i < ctx->nb_outputs; i++) { AVFrame *buf_out; if (ctx->outputs[i]->closed) continue; buf_out = av_frame_clone(frame); if (!buf_out) { ret = AVERROR(ENOMEM); break; } ret = ff_filter_frame(ctx->outputs[i], buf_out); if (ret < 0) break; } av_frame_free(&frame); return ret; }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.14106852214680915, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.3615192241061562, -0.10760608081136262, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void draw_line(uint8_t *buf, int sx, int sy, int ex, int ey, int w, int h, int stride, int color) { int x, y, fr, f; if (clip_line(&sx, &sy, &ex, &ey, w - 1)) return; if (clip_line(&sy, &sx, &ey, &ex, h - 1)) return; sx = av_clip(sx, 0, w - 1); sy = av_clip(sy, 0, h - 1); ex = av_clip(ex, 0, w - 1); ey = av_clip(ey, 0, h - 1); buf[sy * stride + sx] += color; if (FFABS(ex - sx) > FFABS(ey - sy)) { if (sx > ex) { FFSWAP(int, sx, ex); FFSWAP(int, sy, ey); } buf += sx + sy * stride; ex -= sx; f = ((ey - sy) << 16) / ex; for (x = 0; x <= ex; x++) { y = (x * f) >> 16; fr = (x * f) & 0xFFFF; buf[ y * stride + x] += (color * (0x10000 - fr)) >> 16; if(fr) buf[(y + 1) * stride + x] += (color * fr ) >> 16; } } else { if (sy > ey) { FFSWAP(int, sx, ex); FFSWAP(int, sy, ey); } buf += sx + sy * stride; ey -= sy; if (ey) f = ((ex - sx) << 16) / ey; else f = 0; for(y= 0; y <= ey; y++){ x = (y*f) >> 16; fr = (y*f) & 0xFFFF; buf[y * stride + x ] += (color * (0x10000 - fr)) >> 16; if(fr) buf[y * stride + x + 1] += (color * fr ) >> 16; } } }<SPLIT>[-0.25365086435942685, 0.35446233125126253, 0.0, -0.2665172434374763, 0.2744463367362555, 0.0, 0.9701672076669112, 0.9946065798247155, 0.9059316288753189, 0.380400859743741, 0.2885726992822718, -0.25297036047912586, 0.3868187012671718, 0.0, 0.0, 0.30852482215402843, 0.21590580536007686, -0.26569807294376846, 0.3067638303237141, -0.011671540416283347, 2.2222932749013142, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3950401602637228, 1.2188335404954318, 0.11818065472185141, -0.21702784222394986, 2.0174442779258652, 0.969587250454179, 0.9940939011734088, 0.9053924298597907, 0.3801362775450152, 0.9056307075691036, 0.0, 0.9653245912203542, 0.9897980601469931, 0.9011791483816026, 0.3766295797615486]
0<SPLIT>static int show_sinks_sources_parse_arg(const char *arg, char **dev, AVDictionary **opts) { int ret; if (arg) { char *opts_str = NULL; av_assert0(dev && opts); *dev = av_strdup(arg); if (!*dev) return AVERROR(ENOMEM); if ((opts_str = strchr(*dev, ','))) { *(opts_str++) = '\0'; if (opts_str[0] && ((ret = av_dict_parse_string(opts, opts_str, "=", ":", 0)) < 0)) { av_freep(dev); return ret; } } } else printf("\nDevice name is not provided.\n" "You can pass devicename[,opt1=val1[,opt2=val2...]] as an argument.\n\n"); return 0; }<SPLIT>[-0.25365086435942685, -0.1964525029637057, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, -0.21089937656897445, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, 0.37651940477529405, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, 0.23792492798410134, 0.23107402248845843, -0.21702784222394986, 0.23959960763929639, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 1.7623686513065309, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static void ring1_test(uint8_t *dst, int dst_linesize, int off) { int x, y, color = 0; for (y = off; y < 16*16; y += 16) { for (x = off; x < 16*16; x += 16) { draw_dc(dst + x + y*dst_linesize, dst_linesize, ((x+y)&16) ? color : -color, 16, 16); color++; } } }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.08904460951967552, -0.3333928163445767, -0.21702784222394986, 0.14602883551895066, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static av_always_inline void xbr_filter(const ThreadData *td, int jobnr, int nb_jobs, int n) { int x, y; const AVFrame *input = td->in; AVFrame *output = td->out; const uint32_t *r2y = td->rgbtoyuv; const int slice_start = (input->height * jobnr ) / nb_jobs; const int slice_end = (input->height * (jobnr+1)) / nb_jobs; const int nl = output->linesize[0] >> 2; const int nl1 = nl + nl; const int nl2 = nl1 + nl; for (y = slice_start; y < slice_end; y++) { uint32_t *E = (uint32_t *)(output->data[0] + y * output->linesize[0] * n); const uint32_t *sa2 = (uint32_t *)(input->data[0] + y * input->linesize[0] - 8); const uint32_t *sa1 = sa2 - (input->linesize[0]>>2); const uint32_t *sa0 = sa1 - (input->linesize[0]>>2); const uint32_t *sa3 = sa2 + (input->linesize[0]>>2); const uint32_t *sa4 = sa3 + (input->linesize[0]>>2); if (y <= 1) { sa0 = sa1; if (y == 0) { sa0 = sa1 = sa2; } } if (y >= input->height - 2) { sa4 = sa3; if (y == input->height - 1) { sa4 = sa3 = sa2; } } for (x = 0; x < input->width; x++) { const uint32_t B1 = sa0[2]; const uint32_t PB = sa1[2]; const uint32_t PE = sa2[2]; const uint32_t PH = sa3[2]; const uint32_t H5 = sa4[2]; const int pprev = 2 - (x > 0); const uint32_t A1 = sa0[pprev]; const uint32_t PA = sa1[pprev]; const uint32_t PD = sa2[pprev]; const uint32_t PG = sa3[pprev]; const uint32_t G5 = sa4[pprev]; const int pprev2 = pprev - (x > 1); const uint32_t A0 = sa1[pprev2]; const uint32_t D0 = sa2[pprev2]; const uint32_t G0 = sa3[pprev2]; const int pnext = 3 - (x == input->width - 1); const uint32_t C1 = sa0[pnext]; const uint32_t PC = sa1[pnext]; const uint32_t PF = sa2[pnext]; const uint32_t PI = sa3[pnext]; const uint32_t I5 = sa4[pnext]; const int pnext2 = pnext + 1 - (x >= input->width - 2); const uint32_t C4 = sa1[pnext2]; const uint32_t F4 = sa2[pnext2]; const uint32_t I4 = sa3[pnext2]; if (n == 2) { E[0] = E[1] = E[nl] = E[nl + 1] = PE; FILT2(PE, PI, PH, PF, PG, PC, PD, PB, PA, G5, C4, G0, D0, C1, B1, F4, I4, H5, I5, A0, A1, 0, 1, nl, nl+1); FILT2(PE, PC, PF, PB, PI, PA, PH, PD, PG, I4, A1, I5, H5, A0, D0, B1, C1, F4, C4, G5, G0, nl, 0, nl+1, 1); FILT2(PE, PA, PB, PD, PC, PG, PF, PH, PI, C1, G0, C4, F4, G5, H5, D0, A0, B1, A1, I4, I5, nl+1, nl, 1, 0); FILT2(PE, PG, PD, PH, PA, PI, PB, PF, PC, A0, I5, A1, B1, I4, F4, H5, G5, D0, G0, C1, C4, 1, nl+1, 0, nl); } else if (n == 3) { E[0] = E[1] = E[2] = E[nl] = E[nl+1] = E[nl+2] = E[nl1] = E[nl1+1] = E[nl1+2] = PE; FILT3(PE, PI, PH, PF, PG, PC, PD, PB, PA, G5, C4, G0, D0, C1, B1, F4, I4, H5, I5, A0, A1, 0, 1, 2, nl, nl+1, nl+2, nl1, nl1+1, nl1+2); FILT3(PE, PC, PF, PB, PI, PA, PH, PD, PG, I4, A1, I5, H5, A0, D0, B1, C1, F4, C4, G5, G0, nl1, nl, 0, nl1+1, nl+1, 1, nl1+2, nl+2, 2); FILT3(PE, PA, PB, PD, PC, PG, PF, PH, PI, C1, G0, C4, F4, G5, H5, D0, A0, B1, A1, I4, I5, nl1+2, nl1+1, nl1, nl+2, nl+1, nl, 2, 1, 0); FILT3(PE, PG, PD, PH, PA, PI, PB, PF, PC, A0, I5, A1, B1, I4, F4, H5, G5, D0, G0, C1, C4, 2, nl+2, nl1+2, 1, nl+1, nl1+1, 0, nl, nl1); } else if (n == 4) { E[0] = E[1] = E[2] = E[3] = E[nl] = E[nl+1] = E[nl+2] = E[nl+3] = E[nl1] = E[nl1+1] = E[nl1+2] = E[nl1+3] = E[nl2] = E[nl2+1] = E[nl2+2] = E[nl2+3] = PE; FILT4(PE, PI, PH, PF, PG, PC, PD, PB, PA, G5, C4, G0, D0, C1, B1, F4, I4, H5, I5, A0, A1, nl2+3, nl2+2, nl1+3, 3, nl+3, nl1+2, nl2+1, nl2, nl1+1, nl+2, 2, 1, nl+1, nl1, nl, 0); FILT4(PE, PC, PF, PB, PI, PA, PH, PD, PG, I4, A1, I5, H5, A0, D0, B1, C1, F4, C4, G5, G0, 3, nl+3, 2, 0, 1, nl+2, nl1+3, nl2+3, nl1+2, nl+1, nl, nl1, nl1+1, nl2+2, nl2+1, nl2); FILT4(PE, PA, PB, PD, PC, PG, PF, PH, PI, C1, G0, C4, F4, G5, H5, D0, A0, B1, A1, I4, I5, 0, 1, nl, nl2, nl1, nl+1, 2, 3, nl+2, nl1+1, nl2+1, nl2+2, nl1+2, nl+3, nl1+3, nl2+3); FILT4(PE, PG, PD, PH, PA, PI, PB, PF, PC, A0, I5, A1, B1, I4, F4, H5, G5, D0, G0, C1, C4, nl2, nl1, nl2+1, nl2+3, nl2+2, nl1+1, nl, 0, nl+1, nl1+2, nl1+3, nl+3, nl+2, 1, 2, 3); } sa0 += 1; sa1 += 1; sa2 += 1; sa3 += 1; sa4 += 1; E += n; } } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, 1.2107123279475873, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 1.0683450879357161, -0.26569807294376846, 1.2785727648932006, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 1.7300618792100042, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void set_srce_frame_dest_pts(AVFilterContext *ctx) { FrameRateContext *s = ctx->priv; ff_dlog(ctx, "set_srce_frame_output_pts()\n"); if (s->srce[s->prev]) s->srce_pts_dest[s->prev] = av_rescale_q(s->srce[s->prev]->pts, s->srce_time_base, s->dest_time_base); if (s->srce[s->crnt]) s->srce_pts_dest[s->crnt] = av_rescale_q(s->srce[s->crnt]->pts, s->srce_time_base, s->dest_time_base); if (s->srce[s->next]) s->srce_pts_dest[s->next] = av_rescale_q(s->srce[s->next]->pts, s->srce_time_base, s->dest_time_base); }<SPLIT>[-0.09900860198293619, -0.416818436649693, 0.0, -0.11436118199787926, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3907093238754231, -0.09566541730555662, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.11100716297398205, -0.4662660039929228, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int do_llnw_auth(RTMPContext *rt, const char *user, const char *nonce) { uint8_t hash[16]; char hashstr1[33], hashstr2[33]; const char *realm = "live"; const char *method = "publish"; const char *qop = "auth"; const char *nc = "00000001"; char cnonce[10]; struct AVMD5 *md5 = av_md5_alloc(); if (!md5) return AVERROR(ENOMEM); snprintf(cnonce, sizeof(cnonce), "%08x", av_get_random_seed()); av_md5_init(md5); av_md5_update(md5, user, strlen(user)); av_md5_update(md5, ":", 1); av_md5_update(md5, realm, strlen(realm)); av_md5_update(md5, ":", 1); av_md5_update(md5, rt->password, strlen(rt->password)); av_md5_final(md5, hash); ff_data_to_hex(hashstr1, hash, 16, 1); hashstr1[32] = '\0'; av_md5_init(md5); av_md5_update(md5, method, strlen(method)); av_md5_update(md5, ":/", 2); av_md5_update(md5, rt->app, strlen(rt->app)); if (!strchr(rt->app, '/')) av_md5_update(md5, "/_definst_", strlen("/_definst_")); av_md5_final(md5, hash); ff_data_to_hex(hashstr2, hash, 16, 1); hashstr2[32] = '\0'; av_md5_init(md5); av_md5_update(md5, hashstr1, strlen(hashstr1)); av_md5_update(md5, ":", 1); if (nonce) av_md5_update(md5, nonce, strlen(nonce)); av_md5_update(md5, ":", 1); av_md5_update(md5, nc, strlen(nc)); av_md5_update(md5, ":", 1); av_md5_update(md5, cnonce, strlen(cnonce)); av_md5_update(md5, ":", 1); av_md5_update(md5, qop, strlen(qop)); av_md5_update(md5, ":", 1); av_md5_update(md5, hashstr2, strlen(hashstr2)); av_md5_final(md5, hash); ff_data_to_hex(hashstr1, hash, 16, 1); snprintf(rt->auth_params, sizeof(rt->auth_params), "?authmod=%s&user=%s&nonce=%s&cnonce=%s&nc=%s&response=%s", "llnw", user, nonce, cnonce, nc, hashstr1); av_free(md5); return 0; }<SPLIT>[-0.25365086435942685, 0.48668189146285495, 0.0, -0.2665172434374763, 0.40211897190143714, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.40844599748657096, -0.25297036047912586, 0.5235759824547622, 0.0, 0.0, 0.30852482215402843, 0.3321475257113004, -0.26569807294376846, 0.43928323049228046, 1.1529012951584487, 3.318456792630025, 0.0, -0.08645738172306322, -0.16222078614455715, 0.8517581167453454, 1.9272675384202815, 1.4729010679211356, -0.21702784222394986, 2.111015050046211, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void clip_interval(int wmax, int *x, int *w, int *dx) { if (dx) *dx = 0; if (*x < 0) { if (dx) *dx = -*x; *w += *x; *x = 0; } if (*x + *w > wmax) *w = wmax - *x; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.7880534307994381, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.1980344553542678, -0.7849662874110047, -0.21702784222394986, 0.33317037975964214, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static int handle_invoke(URLContext *s, RTMPPacket *pkt) { RTMPContext *rt = s->priv_data; int ret = 0; if (ff_amf_match_string(pkt->data, pkt->size, "_error")) { if ((ret = handle_invoke_error(s, pkt)) < 0) return ret; } else if (ff_amf_match_string(pkt->data, pkt->size, "_result")) { if ((ret = handle_invoke_result(s, pkt)) < 0) return ret; } else if (ff_amf_match_string(pkt->data, pkt->size, "onStatus")) { if ((ret = handle_invoke_status(s, pkt)) < 0) return ret; } else if (ff_amf_match_string(pkt->data, pkt->size, "onBWDone")) { if ((ret = gen_check_bw(s, rt)) < 0) return ret; } else if (ff_amf_match_string(pkt->data, pkt->size, "releaseStream") || ff_amf_match_string(pkt->data, pkt->size, "FCPublish") || ff_amf_match_string(pkt->data, pkt->size, "publish") || ff_amf_match_string(pkt->data, pkt->size, "play") || ff_amf_match_string(pkt->data, pkt->size, "_checkbw") || ff_amf_match_string(pkt->data, pkt->size, "createStream")) { if ((ret = send_invoke_response(s, pkt)) < 0) return ret; } return ret; }<SPLIT>[-0.09900860198293619, -0.06423294275211332, 0.0, -0.11436118199787926, -0.12985034128681952, 0.0, 1.3177536816088504, 1.3480932287791254, 1.2376156019774536, 3.0190063118991532, -0.07104719533062549, -0.09566541730555662, -0.04624602249353125, 0.0, 0.0, 0.30852482215402843, -0.13281935569359377, -0.11100716297398205, -0.1128809368767459, 0.11772544131424245, 0.7972807018539907, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, 0.5648944654878781, 0.005287286955244392, -0.21702784222394986, 0.9881657846020622, 1.3170847170463484, 1.3475072793347742, 1.2369948159429325, 3.018096722982286, 0.9056307075691036, 0.0, 1.3123839157220905, 1.3427725632242797, 1.2323429545022004, 3.0104667622638415]
0<SPLIT>static av_cold int query_formats(AVFilterContext *avctx) { static const enum AVPixelFormat pixel_fmts[] = { AV_PIX_FMT_ARGB, AV_PIX_FMT_RGBA, AV_PIX_FMT_ABGR, AV_PIX_FMT_BGRA, AV_PIX_FMT_NONE }; AVFilterFormats *formats = NULL; formats = ff_make_format_list(pixel_fmts); if (!formats) return AVERROR(ENOMEM); return ff_set_common_formats(avctx, formats); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { AVFilterFormats *formats; enum AVPixelFormat pix_fmt; int ret; if (ctx->inputs[0]) { const AVPixFmtDescriptor *desc = NULL; formats = NULL; while ((desc = av_pix_fmt_desc_next(desc))) { pix_fmt = av_pix_fmt_desc_get_id(desc); if (!(desc->flags & AV_PIX_FMT_FLAG_HWACCEL || desc->flags & AV_PIX_FMT_FLAG_PAL || desc->flags & AV_PIX_FMT_FLAG_BITSTREAM) && desc->nb_components && !desc->log2_chroma_h && (ret = ff_add_format(&formats, pix_fmt)) < 0) { ff_formats_unref(&formats); return ret; } } ff_formats_ref(formats, &ctx->inputs[0]->out_formats); ff_formats_ref(formats, &ctx->outputs[0]->in_formats); } return 0; }<SPLIT>[0.05563366039355449, -0.13034272285790952, 0.0, 0.037794879441717756, -0.1936866588694103, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1110049613987252, 0.061639525868012635, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.17156659581066827, 0.04368374699580437, -0.17914063696102905, 0.24712242304476825, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.08904460951967552, 0.23107402248845843, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void ff_aac_apply_tns(AACEncContext *s, SingleChannelElement *sce) { TemporalNoiseShaping *tns = &sce->tns; IndividualChannelStream *ics = &sce->ics; int w, filt, m, i, top, order, bottom, start, end, size, inc; const int mmm = FFMIN(ics->tns_max_bands, ics->max_sfb); float lpc[TNS_MAX_ORDER]; for (w = 0; w < ics->num_windows; w++) { bottom = ics->num_swb; for (filt = 0; filt < tns->n_filt[w]; filt++) { top = bottom; bottom = FFMAX(0, top - tns->length[w][filt]); order = tns->order[w][filt]; if (order == 0) continue; compute_lpc_coefs(tns->coef[w][filt], order, lpc, 0, 0, 0); start = ics->swb_offset[FFMIN(bottom, mmm)]; end = ics->swb_offset[FFMIN( top, mmm)]; if ((size = end - start) <= 0) continue; if (tns->direction[w][filt]) { inc = -1; start = end - 1; } else { inc = 1; } start += w * 128; for (m = 0; m < size; m++, start += inc) for (i = 1; i <= FFMIN(m, order); i++) sce->coeffs[start] += lpc[i-1]*sce->pcoeffs[start - i*inc]; } } }<SPLIT>[0.05563366039355449, 0.06798661745947907, 0.0, 0.037794879441717756, -0.0021777061216379156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.06880498590772346, 0.061639525868012635, 0.0905112586940592, 0.0, 0.0, 0.30852482215402843, 0.0027959847161670454, 0.04368374699580437, 0.01963846329182043, -0.14106852214680915, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2545115582693773, 0.18343000506680518, 1.0213275968547075, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int usage(const char *argv0, int ret) { fprintf(stderr, "%s -out foo.mpd file1\n", argv0); return ret; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static uint32_t get_generic_seed(void) { uint8_t tmp[120]; struct AVSHA *sha = (void*)tmp; clock_t last_t = 0; static uint64_t i = 0; static uint32_t buffer[512] = { 0 }; unsigned char digest[20]; uint64_t last_i = i; av_assert0(sizeof(tmp) >= av_sha_size); if(TEST){ memset(buffer, 0, sizeof(buffer)); last_i = i = 0; }else{ #ifdef AV_READ_TIME buffer[13] ^= AV_READ_TIME(); buffer[41] ^= AV_READ_TIME()>>32; #endif } for (;;) { clock_t t = clock(); if (last_t == t) { buffer[i & 511]++; } else { buffer[++i & 511] += (t - last_t) % 3294638521U; if (last_i && i - last_i > 4 || i - last_i > 64 || TEST && i - last_i > 8) break; } last_t = t; } if(TEST) buffer[0] = buffer[1] = 0; av_sha_init(sha, 160); av_sha_update(sha, (const uint8_t *)buffer, sizeof(buffer)); av_sha_final(sha, digest); return AV_RB32(digest) + AV_RB32(digest + 16); }<SPLIT>[-0.25365086435942685, 0.15613299093387398, 0.0, -0.2665172434374763, 0.08293738398848315, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 0.7102265412631674, 0.10876275197582316, -0.25297036047912586, 0.0905112586940592, 0.0, 0.0, 0.30852482215402843, 0.04154322483324156, -0.26569807294376846, 0.01963846329182043, 0.37651940477529405, 0.4684316465353775, 0.0, 0.13403667075800713, 0.9973611507722091, 0.14911510677361828, 0.4559046196532859, 0.4568607580216725, 2.47944955092491, 0.14602883551895066, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 0.7098813332246741, 1.7623686513065309, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 0.7058592275743352]
0<SPLIT>static void pulse_context_state(pa_context *ctx, void *userdata) { PulseData *s = userdata; if (s->ctx != ctx) return; switch (pa_context_get_state(ctx)) { case PA_CONTEXT_READY: case PA_CONTEXT_FAILED: case PA_CONTEXT_TERMINATED: pa_threaded_mainloop_signal(s->mainloop, 0); default: break; } }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int mrefs, int parity, int mode); av_cold void ff_yadif_init_x86(YADIFContext *yadif) { int cpu_flags = av_get_cpu_flags(); int bit_depth = (!yadif->csp) ? 8 : yadif->csp->comp[0].depth_minus1 + 1; if (bit_depth >= 15) { #if ARCH_X86_32 if (EXTERNAL_MMXEXT(cpu_flags)) yadif->filter_line = ff_yadif_filter_line_16bit_mmxext; #endif if (EXTERNAL_SSE2(cpu_flags)) yadif->filter_line = ff_yadif_filter_line_16bit_sse2; if (EXTERNAL_SSSE3(cpu_flags)) yadif->filter_line = ff_yadif_filter_line_16bit_ssse3; if (EXTERNAL_SSE4(cpu_flags)) yadif->filter_line = ff_yadif_filter_line_16bit_sse4; } else if ( bit_depth >= 9 && bit_depth <= 14) { #if ARCH_X86_32 if (EXTERNAL_MMXEXT(cpu_flags)) yadif->filter_line = ff_yadif_filter_line_10bit_mmxext; #endif if (EXTERNAL_SSE2(cpu_flags)) yadif->filter_line = ff_yadif_filter_line_10bit_sse2; if (EXTERNAL_SSSE3(cpu_flags)) yadif->filter_line = ff_yadif_filter_line_10bit_ssse3; } else { #if ARCH_X86_32 if (EXTERNAL_MMXEXT(cpu_flags)) yadif->filter_line = ff_yadif_filter_line_mmxext; #endif if (EXTERNAL_SSE2(cpu_flags)) yadif->filter_line = ff_yadif_filter_line_sse2; if (EXTERNAL_SSSE3(cpu_flags)) yadif->filter_line = ff_yadif_filter_line_ssse3; } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, 0.08293738398848315, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.04154322483324156, -0.26569807294376846, -0.157054070266268, -0.7880534307994381, -0.518115519420462, 0.0, 0.5750247757201478, 3.3165250246057414, -0.2373385487108316, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static inline void rgb24tobgr32_c(const uint8_t *src, uint8_t *dst, int src_size) { uint8_t *dest = dst; const uint8_t *s = src; const uint8_t *end = s + src_size; while (s < end) { #if HAVE_BIGENDIAN *dest++ = 255; *dest++ = s[2]; *dest++ = s[1]; *dest++ = s[0]; s += 3; #else *dest++ = *s++; *dest++ = *s++; *dest++ = *s++; *dest++ = 255; #endif } }<SPLIT>[-0.09900860198293619, -0.1964525029637057, 0.0, -0.11436118199787926, -0.2575229764520011, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.1909204935349246, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.26569807294376846, -0.42209287060340067, -0.39986248560786075, -0.518115519420462, 0.0, 0.5750247757201478, 1.5771521192305922, -0.27247069920941797, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void mix_2_to_1_s16p_flt_c(int16_t **samples, float **matrix, int len, int out_ch, int in_ch) { int16_t *src0 = samples[0]; int16_t *src1 = samples[1]; int16_t *dst = src0; float m0 = matrix[0][0]; float m1 = matrix[0][1]; while (len > 4) { *dst++ = av_clip_int16(lrintf(*src0++ * m0 + *src1++ * m1)); *dst++ = av_clip_int16(lrintf(*src0++ * m0 + *src1++ * m1)); *dst++ = av_clip_int16(lrintf(*src0++ * m0 + *src1++ * m1)); *dst++ = av_clip_int16(lrintf(*src0++ * m0 + *src1++ * m1)); len -= 4; } while (len > 0) { *dst++ = av_clip_int16(lrintf(*src0++ * m0 + *src1++ * m1)); len--; } }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.270465503877335, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.25252937827156396, -0.3333928163445767, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
1<SPLIT>static int get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c) { uint8_t byte; if (bytestream2_get_bytes_left(&s->g) < 5) return AVERROR_INVALIDDATA; c->nreslevels = bytestream2_get_byteu(&s->g) + 1; if (c->nreslevels >= JPEG2000_MAX_RESLEVELS) { av_log(s->avctx, AV_LOG_ERROR, "nreslevels %d is invalid\n", c->nreslevels); return AVERROR_INVALIDDATA; } if (c->nreslevels < s->reduction_factor) c->nreslevels2decode = 1; else c->nreslevels2decode = c->nreslevels - s->reduction_factor; c->log2_cblk_width = (bytestream2_get_byteu(&s->g) & 15) + 2; c->log2_cblk_height = (bytestream2_get_byteu(&s->g) & 15) + 2; if (c->log2_cblk_width > 10 || c->log2_cblk_height > 10 || c->log2_cblk_width + c->log2_cblk_height > 12) { av_log(s->avctx, AV_LOG_ERROR, "cblk size invalid\n"); return AVERROR_INVALIDDATA; } c->cblk_style = bytestream2_get_byteu(&s->g); if (c->cblk_style != 0) { av_log(s->avctx, AV_LOG_WARNING, "extra cblk styles %X\n", c->cblk_style); } c->transform = bytestream2_get_byteu(&s->g); if ((s->avctx->flags & CODEC_FLAG_BITEXACT) && (c->transform == FF_DWT97)) c->transform = FF_DWT97_INT; if (c->csty & JPEG2000_CSTY_PREC) { int i; for (i = 0; i < c->nreslevels; i++) { byte = bytestream2_get_byte(&s->g); c->log2_prec_widths[i] = byte & 0x0F; c->log2_prec_heights[i] = (byte >> 4) & 0x0F; } } else { memset(c->log2_prec_widths , 15, sizeof(c->log2_prec_widths )); memset(c->log2_prec_heights, 15, sizeof(c->log2_prec_heights)); } return 0; }<SPLIT>[1.4474140217819704, 0.24427936440826892, 0.0, 1.4071994323980908, 0.16805247409860422, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 0.40844599748657096, 1.477384014430136, 0.2728543002775131, 0.0, 0.0, 0.30852482215402843, 0.3321475257113004, 1.4359019367238823, 0.19633099684990887, -0.011671540416283347, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.14911510677361828, -0.08904460951967552, -0.10760608081136262, -0.21702784222394986, -0.04111270872174079, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static int mxf_write_tagged_value(AVFormatContext *s, const char* name, const char* value) { MXFContext *mxf = s->priv_data; AVIOContext *pb = s->pb; int name_size = mxf_utf16_local_tag_length(name); int indirect_value_size = 13 + mxf_utf16_local_tag_length(value); if (!name_size || indirect_value_size == 13) return 1; mxf_write_metadata_key(pb, 0x013f00); klv_encode_ber_length(pb, 24 + name_size + indirect_value_size); mxf_write_local_tag(pb, 16, 0x3C0A); mxf_write_uuid(pb, TaggedValue, mxf->tagged_value_count); mxf_write_local_tag_utf16(pb, 0x5001, name); mxf_write_local_tag(pb, indirect_value_size, 0x5003); avio_write(pb, mxf_indirect_value_utf16le, 17); avio_put_str16le(pb, value); mxf->tagged_value_count++; return 0; }<SPLIT>[0.21027592277004517, -0.24052568970090316, 0.0, 0.18995094088131478, -0.30008052150706166, 0.0, -0.24638545112987587, -0.2425966915157195, -0.08912029043108533, -0.27925050329511203, -0.1909204935349246, 0.21894446904158188, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, 0.19837465696559078, -0.28957347043483433, 0.37651940477529405, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, 0.01994523631491676, 0.34396739025506545, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int asf_read_picture(AVFormatContext *s, int len) { ASFContext *asf = s->priv_data; AVPacket pkt = { 0 }; const CodecMime *mime = ff_id3v2_mime_tags; enum AVCodecID id = AV_CODEC_ID_NONE; char mimetype[64]; uint8_t *desc = NULL; AVStream *st = NULL; int ret, type, picsize, desc_len; ASFStream *asf_st; if (len < 1 + 4 + 2 + 2) { av_log(s, AV_LOG_ERROR, "Invalid attached picture size: %d.\n", len); return AVERROR_INVALIDDATA; } type = avio_r8(s->pb); len--; if (type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types) || type < 0) { av_log(s, AV_LOG_WARNING, "Unknown attached picture type: %d.\n", type); type = 0; } picsize = avio_rl32(s->pb); len -= 4; len -= avio_get_str16le(s->pb, len, mimetype, sizeof(mimetype)); while (mime->id != AV_CODEC_ID_NONE) { if (!strncmp(mime->str, mimetype, sizeof(mimetype))) { id = mime->id; break; } mime++; } if (id == AV_CODEC_ID_NONE) { av_log(s, AV_LOG_ERROR, "Unknown attached picture mimetype: %s.\n", mimetype); return 0; } if (picsize >= len) { av_log(s, AV_LOG_ERROR, "Invalid attached picture data size: %d >= %d.\n", picsize, len); return AVERROR_INVALIDDATA; } desc_len = (len - picsize) * 2 + 1; desc = av_malloc(desc_len); if (!desc) return AVERROR(ENOMEM); len -= avio_get_str16le(s->pb, len - picsize, desc, desc_len); ret = av_get_packet(s->pb, &pkt, picsize); if (ret < 0) goto fail; st = avformat_new_stream(s, NULL); if (!st) { ret = AVERROR(ENOMEM); goto fail; } asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st)); asf_st = asf->asf_st[asf->nb_streams]; if (!asf_st) { ret = AVERROR(ENOMEM); goto fail; } st->disposition |= AV_DISPOSITION_ATTACHED_PIC; st->codec->codec_type = asf_st->type = AVMEDIA_TYPE_VIDEO; st->codec->codec_id = id; st->attached_pic = pkt; st->attached_pic.stream_index = asf_st->index = st->index; st->attached_pic.flags |= AV_PKT_FLAG_KEY; asf->nb_streams++; if (*desc) { if (av_dict_set(&st->metadata, "title", desc, AV_DICT_DONT_STRDUP_VAL) < 0) av_log(s, AV_LOG_WARNING, "av_dict_set failed.\n"); } else av_freep(&desc); if (av_dict_set(&st->metadata, "comment", ff_id3v2_picture_types[type], 0) < 0) av_log(s, AV_LOG_WARNING, "av_dict_set failed.\n"); return 0; fail: av_freep(&desc); av_free_packet(&pkt); return ret; }<SPLIT>[0.5195604475230265, 1.1037065057836193, 0.0, 0.4942630637605089, 0.9979246026722846, 0.0, 0.9701672076669112, 0.9946065798247155, 0.9059316288753189, 1.040052222782594, 1.067749137610216, 0.5335543553887203, 1.1617766279968509, 0.0, 0.0, 0.30852482215402843, 0.9714769876430299, 0.5077564769051636, 1.05770709794559, 1.5410922403500262, 1.2357461089454749, 0.0, -0.08645738172306322, -0.16222078614455715, 1.1328153207340361, 1.6547929238338008, 1.8115811712209564, 1.5806237532086234, 1.1753073288427536, 0.969587250454179, 0.9940939011734088, 0.9053924298597907, 1.039626388904333, 0.04889276383167627, 0.0, 0.9653245912203542, 0.9897980601469931, 0.9011791483816026, 1.0350888753871217]
0<SPLIT>int av_opt_get_key_value(const char **ropts, const char *key_val_sep, const char *pairs_sep, unsigned flags, char **rkey, char **rval) { int ret; char *key = NULL, *val; const char *opts = *ropts; if ((ret = get_key(&opts, key_val_sep, &key)) < 0 && !(flags & AV_OPT_FLAG_IMPLICIT_KEY)) return AVERROR(EINVAL); if (!(val = av_get_token(&opts, pairs_sep))) { av_free(key); return AVERROR(ENOMEM); } *ropts = opts; *rkey = key; *rval = val; return 0; }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, 0.5059163865058198, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.03454968660237938, 0.11818065472185141, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
1<SPLIT>void ff_er_frame_end(MpegEncContext *s){ int i, mb_x, mb_y, error, error_type, dc_error, mv_error, ac_error; int distance; int threshold_part[4]= {100,100,100}; int threshold= 50; int is_intra_likely; int size = s->b8_stride * 2 * s->mb_height; Picture *pic= s->current_picture_ptr; if(!s->error_recognition || s->error_count==0 || s->avctx->lowres || s->avctx->hwaccel || s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU || s->picture_structure != PICT_FRAME || s->error_count==3*s->mb_width*(s->avctx->skip_top + s->avctx->skip_bottom)) return; if (s->current_picture.f.motion_val[0] == NULL) { av_log(s->avctx, AV_LOG_ERROR, "Warning MVs not available\n"); for(i=0; i<2; i++){ pic->f.ref_index[i] = av_mallocz(s->mb_stride * s->mb_height * 4 * sizeof(uint8_t)); pic->motion_val_base[i]= av_mallocz((size+4) * 2 * sizeof(uint16_t)); pic->f.motion_val[i] = pic->motion_val_base[i] + 4; } pic->f.motion_subsample_log2 = 3; s->current_picture= *s->current_picture_ptr; } if(s->avctx->debug&FF_DEBUG_ER){ for(mb_y=0; mb_y<s->mb_height; mb_y++){ for(mb_x=0; mb_x<s->mb_width; mb_x++){ int status= s->error_status_table[mb_x + mb_y*s->mb_stride]; av_log(s->avctx, AV_LOG_DEBUG, "%2X ", status); } av_log(s->avctx, AV_LOG_DEBUG, "\n"); } } for(error_type=1; error_type<=3; error_type++){ int end_ok=0; for(i=s->mb_num-1; i>=0; i--){ const int mb_xy= s->mb_index2xy[i]; int error= s->error_status_table[mb_xy]; if(error&(1<<error_type)) end_ok=1; if(error&(8<<error_type)) end_ok=1; if(!end_ok) s->error_status_table[mb_xy]|= 1<<error_type; if(error&VP_START) end_ok=0; } } if(s->partitioned_frame){ int end_ok=0; for(i=s->mb_num-1; i>=0; i--){ const int mb_xy= s->mb_index2xy[i]; int error= s->error_status_table[mb_xy]; if(error&AC_END) end_ok=0; if((error&MV_END) || (error&DC_END) || (error&AC_ERROR)) end_ok=1; if(!end_ok) s->error_status_table[mb_xy]|= AC_ERROR; if(error&VP_START) end_ok=0; } } if(s->error_recognition>=4){ int end_ok=1; for(i=s->mb_num-2; i>=s->mb_width+100; i--){ const int mb_xy= s->mb_index2xy[i]; int error1= s->error_status_table[mb_xy ]; int error2= s->error_status_table[s->mb_index2xy[i+1]]; if(error1&VP_START) end_ok=1; if( error2==(VP_START|DC_ERROR|AC_ERROR|MV_ERROR|AC_END|DC_END|MV_END) && error1!=(VP_START|DC_ERROR|AC_ERROR|MV_ERROR|AC_END|DC_END|MV_END) && ((error1&AC_END) || (error1&DC_END) || (error1&MV_END))){ end_ok=0; } if(!end_ok) s->error_status_table[mb_xy]|= DC_ERROR|AC_ERROR|MV_ERROR; } } distance=9999999; for(error_type=1; error_type<=3; error_type++){ for(i=s->mb_num-1; i>=0; i--){ const int mb_xy= s->mb_index2xy[i]; int error= s->error_status_table[mb_xy]; if(!s->mbskip_table[mb_xy]) distance++; if(error&(1<<error_type)) distance= 0; if(s->partitioned_frame){ if(distance < threshold_part[error_type-1]) s->error_status_table[mb_xy]|= 1<<error_type; }else{ if(distance < threshold) s->error_status_table[mb_xy]|= 1<<error_type; } if(error&VP_START) distance= 9999999; } } error=0; for(i=0; i<s->mb_num; i++){ const int mb_xy= s->mb_index2xy[i]; int old_error= s->error_status_table[mb_xy]; if(old_error&VP_START) error= old_error& (DC_ERROR|AC_ERROR|MV_ERROR); else{ error|= old_error& (DC_ERROR|AC_ERROR|MV_ERROR); s->error_status_table[mb_xy]|= error; } } if(!s->partitioned_frame){ for(i=0; i<s->mb_num; i++){ const int mb_xy= s->mb_index2xy[i]; error= s->error_status_table[mb_xy]; if(error&(AC_ERROR|DC_ERROR|MV_ERROR)) error|= AC_ERROR|DC_ERROR|MV_ERROR; s->error_status_table[mb_xy]= error; } } dc_error= ac_error= mv_error=0; for(i=0; i<s->mb_num; i++){ const int mb_xy= s->mb_index2xy[i]; error= s->error_status_table[mb_xy]; if(error&DC_ERROR) dc_error ++; if(error&AC_ERROR) ac_error ++; if(error&MV_ERROR) mv_error ++; } av_log(s->avctx, AV_LOG_INFO, "concealing %d DC, %d AC, %d MV errors\n", dc_error, ac_error, mv_error); is_intra_likely= is_intra_more_likely(s); for(i=0; i<s->mb_num; i++){ const int mb_xy= s->mb_index2xy[i]; error= s->error_status_table[mb_xy]; if(!((error&DC_ERROR) && (error&MV_ERROR))) continue; if(is_intra_likely) s->current_picture.f.mb_type[mb_xy] = MB_TYPE_INTRA4x4; else s->current_picture.f.mb_type[mb_xy] = MB_TYPE_16x16 | MB_TYPE_L0; } if (!s->last_picture.f.data[0] && !s->next_picture.f.data[0]) for(i=0; i<s->mb_num; i++){ const int mb_xy= s->mb_index2xy[i]; if (!IS_INTRA(s->current_picture.f.mb_type[mb_xy])) s->current_picture.f.mb_type[mb_xy] = MB_TYPE_INTRA4x4; } for(mb_y=0; mb_y<s->mb_height; mb_y++){ for(mb_x=0; mb_x<s->mb_width; mb_x++){ const int mb_xy= mb_x + mb_y * s->mb_stride; const int mb_type= s->current_picture.f.mb_type[mb_xy]; int dir = !s->last_picture.f.data[0]; error= s->error_status_table[mb_xy]; if(IS_INTRA(mb_type)) continue; if(error&MV_ERROR) continue; if(!(error&AC_ERROR)) continue; s->mv_dir = dir ? MV_DIR_BACKWARD : MV_DIR_FORWARD; s->mb_intra=0; s->mb_skipped=0; if(IS_8X8(mb_type)){ int mb_index= mb_x*2 + mb_y*2*s->b8_stride; int j; s->mv_type = MV_TYPE_8X8; for(j=0; j<4; j++){ s->mv[0][j][0] = s->current_picture.f.motion_val[dir][mb_index + (j & 1) + (j >> 1) * s->b8_stride][0]; s->mv[0][j][1] = s->current_picture.f.motion_val[dir][mb_index + (j & 1) + (j >> 1) * s->b8_stride][1]; } }else{ s->mv_type = MV_TYPE_16X16; s->mv[0][0][0] = s->current_picture.f.motion_val[dir][ mb_x*2 + mb_y*2*s->b8_stride ][0]; s->mv[0][0][1] = s->current_picture.f.motion_val[dir][ mb_x*2 + mb_y*2*s->b8_stride ][1]; } s->dsp.clear_blocks(s->block[0]); s->mb_x= mb_x; s->mb_y= mb_y; decode_mb(s, 0); } } if(s->pict_type==AV_PICTURE_TYPE_B){ for(mb_y=0; mb_y<s->mb_height; mb_y++){ for(mb_x=0; mb_x<s->mb_width; mb_x++){ int xy= mb_x*2 + mb_y*2*s->b8_stride; const int mb_xy= mb_x + mb_y * s->mb_stride; const int mb_type= s->current_picture.f.mb_type[mb_xy]; error= s->error_status_table[mb_xy]; if(IS_INTRA(mb_type)) continue; if(!(error&MV_ERROR)) continue; if(!(error&AC_ERROR)) continue; s->mv_dir = MV_DIR_FORWARD|MV_DIR_BACKWARD; if(!s->last_picture.f.data[0]) s->mv_dir &= ~MV_DIR_FORWARD; if(!s->next_picture.f.data[0]) s->mv_dir &= ~MV_DIR_BACKWARD; s->mb_intra=0; s->mv_type = MV_TYPE_16X16; s->mb_skipped=0; if(s->pp_time){ int time_pp= s->pp_time; int time_pb= s->pb_time; if (s->avctx->codec_id == CODEC_ID_H264) { } else { ff_thread_await_progress((AVFrame *) s->next_picture_ptr, mb_y, 0); } s->mv[0][0][0] = s->next_picture.f.motion_val[0][xy][0] * time_pb / time_pp; s->mv[0][0][1] = s->next_picture.f.motion_val[0][xy][1] * time_pb / time_pp; s->mv[1][0][0] = s->next_picture.f.motion_val[0][xy][0] * (time_pb - time_pp) / time_pp; s->mv[1][0][1] = s->next_picture.f.motion_val[0][xy][1] * (time_pb - time_pp) / time_pp; }else{ s->mv[0][0][0]= 0; s->mv[0][0][1]= 0; s->mv[1][0][0]= 0; s->mv[1][0][1]= 0; } s->dsp.clear_blocks(s->block[0]); s->mb_x= mb_x; s->mb_y= mb_y; decode_mb(s, 0); } } }else guess_mv(s); if(CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) goto ec_clean; for(mb_y=0; mb_y<s->mb_height; mb_y++){ for(mb_x=0; mb_x<s->mb_width; mb_x++){ int dc, dcu, dcv, y, n; int16_t *dc_ptr; uint8_t *dest_y, *dest_cb, *dest_cr; const int mb_xy= mb_x + mb_y * s->mb_stride; const int mb_type = s->current_picture.f.mb_type[mb_xy]; error= s->error_status_table[mb_xy]; if(IS_INTRA(mb_type) && s->partitioned_frame) continue; dest_y = s->current_picture.f.data[0] + mb_x * 16 + mb_y * 16 * s->linesize; dest_cb = s->current_picture.f.data[1] + mb_x * 8 + mb_y * 8 * s->uvlinesize; dest_cr = s->current_picture.f.data[2] + mb_x * 8 + mb_y * 8 * s->uvlinesize; dc_ptr= &s->dc_val[0][mb_x*2 + mb_y*2*s->b8_stride]; for(n=0; n<4; n++){ dc=0; for(y=0; y<8; y++){ int x; for(x=0; x<8; x++){ dc+= dest_y[x + (n&1)*8 + (y + (n>>1)*8)*s->linesize]; } } dc_ptr[(n&1) + (n>>1)*s->b8_stride]= (dc+4)>>3; } dcu=dcv=0; for(y=0; y<8; y++){ int x; for(x=0; x<8; x++){ dcu+=dest_cb[x + y*(s->uvlinesize)]; dcv+=dest_cr[x + y*(s->uvlinesize)]; } } s->dc_val[1][mb_x + mb_y*s->mb_stride]= (dcu+4)>>3; s->dc_val[2][mb_x + mb_y*s->mb_stride]= (dcv+4)>>3; } } guess_dc(s, s->dc_val[0], s->mb_width*2, s->mb_height*2, s->b8_stride, 1); guess_dc(s, s->dc_val[1], s->mb_width , s->mb_height , s->mb_stride, 0); guess_dc(s, s->dc_val[2], s->mb_width , s->mb_height , s->mb_stride, 0); filter181(s->dc_val[0], s->mb_width*2, s->mb_height*2, s->b8_stride); for(mb_y=0; mb_y<s->mb_height; mb_y++){ for(mb_x=0; mb_x<s->mb_width; mb_x++){ uint8_t *dest_y, *dest_cb, *dest_cr; const int mb_xy= mb_x + mb_y * s->mb_stride; const int mb_type = s->current_picture.f.mb_type[mb_xy]; error= s->error_status_table[mb_xy]; if(IS_INTER(mb_type)) continue; if(!(error&AC_ERROR)) continue; dest_y = s->current_picture.f.data[0] + mb_x * 16 + mb_y * 16 * s->linesize; dest_cb = s->current_picture.f.data[1] + mb_x * 8 + mb_y * 8 * s->uvlinesize; dest_cr = s->current_picture.f.data[2] + mb_x * 8 + mb_y * 8 * s->uvlinesize; put_dc(s, dest_y, dest_cb, dest_cr, mb_x, mb_y); } } if(s->avctx->error_concealment&FF_EC_DEBLOCK){ h_block_filter(s, s->current_picture.f.data[0], s->mb_width*2, s->mb_height*2, s->linesize , 1); h_block_filter(s, s->current_picture.f.data[1], s->mb_width , s->mb_height , s->uvlinesize, 0); h_block_filter(s, s->current_picture.f.data[2], s->mb_width , s->mb_height , s->uvlinesize, 0); v_block_filter(s, s->current_picture.f.data[0], s->mb_width*2, s->mb_height*2, s->linesize , 1); v_block_filter(s, s->current_picture.f.data[1], s->mb_width , s->mb_height , s->uvlinesize, 0); v_block_filter(s, s->current_picture.f.data[2], s->mb_width , s->mb_height , s->uvlinesize, 0); } ec_clean: for(i=0; i<s->mb_num; i++){ const int mb_xy= s->mb_index2xy[i]; int error= s->error_status_table[mb_xy]; if(s->pict_type!=AV_PICTURE_TYPE_B && (error&(DC_ERROR|MV_ERROR|AC_ERROR))){ s->mbskip_table[mb_xy]=0; } s->mbintra_table[mb_xy]=1; } }<SPLIT>[12.427014650512808, 5.753427706557951, 0.0, 12.210279794609479, 5.4877456059811704, 0.0, 3.924652236173394, 3.9992430959372007, 3.7252454002434643, -0.27925050329511203, 6.821667451416573, 12.646034979753555, 5.971074349760448, 0.0, 0.0, 0.30852482215402843, 6.5510795645017605, 12.418956544578718, 5.717972670540172, 6.716971509571059, 2.8799913855385406, 0.0, -0.08645738172306322, -0.16222078614455715, 7.245809507488062, 6.014386757217492, 7.117569456251487, 4.277101146357483, 3.9824304924531253, 3.9233157164876196, 3.998107615545014, 3.724012711566496, -0.27935383381430245, 1.7623686513065309, 0.0, 3.9153288494851126, 3.990081336303929, 3.7160715004066844, -0.28182971586402455]
1<SPLIT>static av_always_inline int vorbis_residue_decode_internal(vorbis_context *vc, vorbis_residue *vr, uint_fast8_t ch, uint_fast8_t *do_not_decode, float *vec, uint_fast16_t vlen, int vr_type) { GetBitContext *gb = &vc->gb; uint_fast8_t c_p_c = vc->codebooks[vr->classbook].dimensions; uint_fast16_t n_to_read = vr->end-vr->begin; uint_fast16_t ptns_to_read = n_to_read/vr->partition_size; uint_fast8_t classifs[ptns_to_read*vc->audio_channels]; uint_fast8_t pass; uint_fast8_t ch_used; uint_fast8_t i,j,l; uint_fast16_t k; if (vr_type == 2) { for (j = 1; j < ch; ++j) do_not_decode[0] &= do_not_decode[j]; if (do_not_decode[0]) return 0; ch_used = 1; } else { ch_used = ch; } AV_DEBUG(" residue type 0/1/2 decode begin, ch: %d cpc %d \n", ch, c_p_c); for (pass = 0; pass <= vr->maxpass; ++pass) { uint_fast16_t voffset; uint_fast16_t partition_count; uint_fast16_t j_times_ptns_to_read; voffset = vr->begin; for (partition_count = 0; partition_count < ptns_to_read;) { if (!pass) { uint_fast32_t inverse_class = ff_inverse[vr->classifications]; for (j_times_ptns_to_read = 0, j = 0; j < ch_used; ++j) { if (!do_not_decode[j]) { uint_fast32_t temp = get_vlc2(gb, vc->codebooks[vr->classbook].vlc.table, vc->codebooks[vr->classbook].nb_bits, 3); AV_DEBUG("Classword: %d \n", temp); assert(vr->classifications > 1 && temp <= 65536); for (i = 0; i < c_p_c; ++i) { uint_fast32_t temp2; temp2 = (((uint_fast64_t)temp) * inverse_class) >> 32; if (partition_count + c_p_c - 1 - i < ptns_to_read) classifs[j_times_ptns_to_read + partition_count + c_p_c - 1 - i] = temp - temp2 * vr->classifications; temp = temp2; } } j_times_ptns_to_read += ptns_to_read; } } for (i = 0; (i < c_p_c) && (partition_count < ptns_to_read); ++i) { for (j_times_ptns_to_read = 0, j = 0; j < ch_used; ++j) { uint_fast16_t voffs; if (!do_not_decode[j]) { uint_fast8_t vqclass = classifs[j_times_ptns_to_read+partition_count]; int_fast16_t vqbook = vr->books[vqclass][pass]; if (vqbook >= 0 && vc->codebooks[vqbook].codevectors) { uint_fast16_t coffs; unsigned dim = vc->codebooks[vqbook].dimensions; uint_fast16_t step = dim == 1 ? vr->partition_size : FASTDIV(vr->partition_size, dim); vorbis_codebook codebook = vc->codebooks[vqbook]; if (vr_type == 0) { voffs = voffset+j*vlen; for (k = 0; k < step; ++k) { coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim; for (l = 0; l < dim; ++l) vec[voffs + k + l * step] += codebook.codevectors[coffs + l]; } } else if (vr_type == 1) { voffs = voffset + j * vlen; for (k = 0; k < step; ++k) { coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim; for (l = 0; l < dim; ++l, ++voffs) { vec[voffs]+=codebook.codevectors[coffs+l]; AV_DEBUG(" pass %d offs: %d curr: %f change: %f cv offs.: %d \n", pass, voffs, vec[voffs], codebook.codevectors[coffs+l], coffs); } } } else if (vr_type == 2 && ch == 2 && (voffset & 1) == 0 && (dim & 1) == 0) { voffs = voffset >> 1; if (dim == 2) { for (k = 0; k < step; ++k) { coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * 2; vec[voffs + k ] += codebook.codevectors[coffs ]; vec[voffs + k + vlen] += codebook.codevectors[coffs + 1]; } } else if (dim == 4) { for (k = 0; k < step; ++k, voffs += 2) { coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * 4; vec[voffs ] += codebook.codevectors[coffs ]; vec[voffs + 1 ] += codebook.codevectors[coffs + 2]; vec[voffs + vlen ] += codebook.codevectors[coffs + 1]; vec[voffs + vlen + 1] += codebook.codevectors[coffs + 3]; } } else for (k = 0; k < step; ++k) { coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim; for (l = 0; l < dim; l += 2, voffs++) { vec[voffs ] += codebook.codevectors[coffs + l ]; vec[voffs + vlen] += codebook.codevectors[coffs + l + 1]; AV_DEBUG(" pass %d offs: %d curr: %f change: %f cv offs.: %d+%d \n", pass, voffset / ch + (voffs % ch) * vlen, vec[voffset / ch + (voffs % ch) * vlen], codebook.codevectors[coffs + l], coffs, l); } } } else if (vr_type == 2) { voffs = voffset; for (k = 0; k < step; ++k) { coffs = get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim; for (l = 0; l < dim; ++l, ++voffs) { vec[voffs / ch + (voffs % ch) * vlen] += codebook.codevectors[coffs + l]; AV_DEBUG(" pass %d offs: %d curr: %f change: %f cv offs.: %d+%d \n", pass, voffset / ch + (voffs % ch) * vlen, vec[voffset / ch + (voffs % ch) * vlen], codebook.codevectors[coffs + l], coffs, l); } } } } } j_times_ptns_to_read += ptns_to_read; } ++partition_count; voffset += vr->partition_size; } } } return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 2.320135801035673, 1.9767481389386767, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 2.095146951038191, 2.3640473965426008, 2.0736891659045984, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 2.6786299426718356, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int verify_expr(AVExpr *e) { if (!e) return 0; switch (e->type) { case e_value: case e_const: return 1; case e_func0: case e_func1: case e_squish: case e_ld: case e_gauss: case e_isnan: case e_isinf: case e_floor: case e_ceil: case e_trunc: case e_sqrt: case e_not: case e_random: return verify_expr(e->param[0]) && !e->param[1]; case e_print: return verify_expr(e->param[0]) && (!e->param[1] || verify_expr(e->param[1])); case e_if: case e_ifnot: case e_taylor: return verify_expr(e->param[0]) && verify_expr(e->param[1]) && (!e->param[2] || verify_expr(e->param[2])); case e_between: case e_clip: return verify_expr(e->param[0]) && verify_expr(e->param[1]) && verify_expr(e->param[2]); default: return verify_expr(e->param[0]) && verify_expr(e->param[1]) && !e->param[2]; } }<SPLIT>[-0.25365086435942685, 0.13409639756527525, 0.0, -0.2665172434374763, 0.06165861146095288, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.08878386894177331, -0.25297036047912586, 0.1588898992878544, 0.0, 0.0, 0.30852482215402843, 0.022169604774704303, -0.26569807294376846, 0.08589816337610359, -0.7880534307994381, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.5794989157753407, -0.7849662874110047, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void update_gain_history(DynamicAudioNormalizerContext *s, int channel, double current_gain_factor) { if (cqueue_empty(s->gain_history_original[channel]) || cqueue_empty(s->gain_history_minimum[channel])) { const int pre_fill_size = s->filter_size / 2; s->prev_amplification_factor[channel] = s->alt_boundary_mode ? current_gain_factor : 1.0; while (cqueue_size(s->gain_history_original[channel]) < pre_fill_size) { cqueue_enqueue(s->gain_history_original[channel], s->alt_boundary_mode ? current_gain_factor : 1.0); } while (cqueue_size(s->gain_history_minimum[channel]) < pre_fill_size) { cqueue_enqueue(s->gain_history_minimum[channel], s->alt_boundary_mode ? current_gain_factor : 1.0); } } cqueue_enqueue(s->gain_history_original[channel], current_gain_factor); while (cqueue_size(s->gain_history_original[channel]) >= s->filter_size) { double minimum; av_assert0(cqueue_size(s->gain_history_original[channel]) == s->filter_size); minimum = minimum_filter(s->gain_history_original[channel]); cqueue_enqueue(s->gain_history_minimum[channel], minimum); cqueue_pop(s->gain_history_original[channel]); } while (cqueue_size(s->gain_history_minimum[channel]) >= s->filter_size) { double smoothed; av_assert0(cqueue_size(s->gain_history_minimum[channel]) == s->filter_size); smoothed = gaussian_filter(s, s->gain_history_minimum[channel]); cqueue_enqueue(s->gain_history_smoothed[channel], smoothed); cqueue_pop(s->gain_history_minimum[channel]); } }<SPLIT>[-0.25365086435942685, 0.0018768373536828752, 0.0, -0.2665172434374763, -0.06601402370422871, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.031089429262525795, -0.25297036047912586, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, -0.09407211557651925, -0.26569807294376846, -0.04662123679246273, 0.6353133682363457, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, -0.08904460951967552, 0.34396739025506545, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>enum AVSampleFormat av_get_sample_fmt(const char *name) { int i; for (i = 0; i < AV_SAMPLE_FMT_NB; i++) if (!strcmp(sample_fmt_info[i].name, name)) return i; return AV_SAMPLE_FMT_NONE; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold int opengl_read_limits(OpenGLContext *opengl) { static const struct{ const char *extension; int major; int minor; } required_extensions[] = { { "GL_ARB_multitexture", 1, 3 }, { "GL_ARB_vertex_buffer_object", 1, 5 }, { "GL_ARB_vertex_shader", 2, 0 }, { "GL_ARB_fragment_shader", 2, 0 }, { "GL_ARB_shader_objects", 2, 0 }, { NULL, 0, 0 } }; int i, major, minor; const char *extensions, *version; version = glGetString(GL_VERSION); extensions = glGetString(GL_EXTENSIONS); av_log(opengl, AV_LOG_DEBUG, "OpenGL version: %s\n", version); sscanf(version, "%d.%d", &major, &minor); for (i = 0; required_extensions[i].extension; i++) { if (major < required_extensions[i].major && (major == required_extensions[i].major && minor < required_extensions[i].minor) && !strstr(extensions, required_extensions[i].extension)) { av_log(opengl, AV_LOG_ERROR, "Required extension %s is not supported.\n", required_extensions[i].extension); av_log(opengl, AV_LOG_DEBUG, "Supported extensions are: %s\n", extensions); return AVERROR(ENOSYS); } } glGetIntegerv(GL_MAX_TEXTURE_SIZE, &opengl->max_texture_size); glGetIntegerv(GL_MAX_VIEWPORT_DIMS, &opengl->max_viewport_width); opengl->non_pow_2_textures = major >= 2 || strstr(extensions, "GL_ARB_texture_non_power_of_two"); #if defined(GL_ES_VERSION_2_0) opengl->unpack_subimage = !!strstr(extensions, "GL_EXT_unpack_subimage"); #else opengl->unpack_subimage = 1; #endif av_log(opengl, AV_LOG_DEBUG, "Non Power of 2 textures support: %s\n", opengl->non_pow_2_textures ? "Yes" : "No"); av_log(opengl, AV_LOG_DEBUG, "Unpack Subimage extension support: %s\n", opengl->unpack_subimage ? "Yes" : "No"); av_log(opengl, AV_LOG_DEBUG, "Max texture size: %dx%d\n", opengl->max_texture_size, opengl->max_texture_size); av_log(opengl, AV_LOG_DEBUG, "Max viewport size: %dx%d\n", opengl->max_viewport_width, opengl->max_viewport_height); OPENGL_ERROR_CHECK(opengl); return 0; fail: return AVERROR_EXTERNAL; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, 0.31700388179131606, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.2546530454771514, -0.26569807294376846, 0.262590696934192, -0.917450412529964, -0.518115519420462, 0.0, 0.02378964451747194, 1.5771521192305922, 0.2545115582693773, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static inline int isHorizMinMaxOk_C(const uint8_t src[], int stride, int QP) { int i; for(i=0; i<2; i++){ if((unsigned)(src[0] - src[5] + 2*QP) > 4*QP) return 0; src += stride; if((unsigned)(src[2] - src[7] + 2*QP) > 4*QP) return 0; src += stride; if((unsigned)(src[4] - src[1] + 2*QP) > 4*QP) return 0; src += stride; if((unsigned)(src[6] - src[3] + 2*QP) > 4*QP) return 0; src += stride; } return 1; }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, 1.3698779043020206, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.6586564490689124, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, 0.01994523631491676, -0.6720729196443977, -0.21702784222394986, 0.6138826961206794, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, 1.3693714445839917, 0.9056307075691036, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 1.3643185231999084]
0<SPLIT>static int parse_primary(AVExpr **e, Parser *p) { AVExpr *d = av_mallocz(sizeof(AVExpr)); char *next = p->s, *s0 = p->s; int ret, i; if (!d) return AVERROR(ENOMEM); d->value = av_strtod(p->s, &next); if (next != p->s) { d->type = e_value; p->s= next; *e = d; return 0; } d->value = 1; for (i=0; p->const_names && p->const_names[i]; i++) { if (strmatch(p->s, p->const_names[i])) { p->s+= strlen(p->const_names[i]); d->type = e_const; d->a.const_index = i; *e = d; return 0; } } for (i = 0; i < FF_ARRAY_ELEMS(constants); i++) { if (strmatch(p->s, constants[i].name)) { p->s += strlen(constants[i].name); d->type = e_value; d->value = constants[i].value; *e = d; return 0; } } p->s= strchr(p->s, '('); if (!p->s) { av_log(p, AV_LOG_ERROR, "Undefined constant or missing '(' in '%s'\n", s0); p->s= next; av_expr_free(d); return AVERROR(EINVAL); } p->s++; if (*next == '(') { av_freep(&d); if ((ret = parse_expr(&d, p)) < 0) return ret; if (p->s[0] != ')') { av_log(p, AV_LOG_ERROR, "Missing ')' in '%s'\n", s0); av_expr_free(d); return AVERROR(EINVAL); } p->s++; *e = d; return 0; } if ((ret = parse_expr(&(d->param[0]), p)) < 0) { av_expr_free(d); return ret; } if (p->s[0]== ',') { p->s++; parse_expr(&d->param[1], p); } if (p->s[0]== ',') { p->s++; parse_expr(&d->param[2], p); } if (p->s[0] != ')') { av_log(p, AV_LOG_ERROR, "Missing ')' or too many args in '%s'\n", s0); av_expr_free(d); return AVERROR(EINVAL); } p->s++; d->type = e_func0; if (strmatch(next, "sinh" )) d->a.func0 = sinh; else if (strmatch(next, "cosh" )) d->a.func0 = cosh; else if (strmatch(next, "tanh" )) d->a.func0 = tanh; else if (strmatch(next, "sin" )) d->a.func0 = sin; else if (strmatch(next, "cos" )) d->a.func0 = cos; else if (strmatch(next, "tan" )) d->a.func0 = tan; else if (strmatch(next, "atan" )) d->a.func0 = atan; else if (strmatch(next, "asin" )) d->a.func0 = asin; else if (strmatch(next, "acos" )) d->a.func0 = acos; else if (strmatch(next, "exp" )) d->a.func0 = exp; else if (strmatch(next, "log" )) d->a.func0 = log; else if (strmatch(next, "abs" )) d->a.func0 = fabs; else if (strmatch(next, "time" )) d->a.func0 = etime; else if (strmatch(next, "squish")) d->type = e_squish; else if (strmatch(next, "gauss" )) d->type = e_gauss; else if (strmatch(next, "mod" )) d->type = e_mod; else if (strmatch(next, "max" )) d->type = e_max; else if (strmatch(next, "min" )) d->type = e_min; else if (strmatch(next, "eq" )) d->type = e_eq; else if (strmatch(next, "gte" )) d->type = e_gte; else if (strmatch(next, "gt" )) d->type = e_gt; else if (strmatch(next, "lte" )) d->type = e_lte; else if (strmatch(next, "lt" )) d->type = e_lt; else if (strmatch(next, "ld" )) d->type = e_ld; else if (strmatch(next, "isnan" )) d->type = e_isnan; else if (strmatch(next, "isinf" )) d->type = e_isinf; else if (strmatch(next, "st" )) d->type = e_st; else if (strmatch(next, "while" )) d->type = e_while; else if (strmatch(next, "taylor")) d->type = e_taylor; else if (strmatch(next, "root" )) d->type = e_root; else if (strmatch(next, "floor" )) d->type = e_floor; else if (strmatch(next, "ceil" )) d->type = e_ceil; else if (strmatch(next, "trunc" )) d->type = e_trunc; else if (strmatch(next, "sqrt" )) d->type = e_sqrt; else if (strmatch(next, "not" )) d->type = e_not; else if (strmatch(next, "pow" )) d->type = e_pow; else if (strmatch(next, "print" )) d->type = e_print; else if (strmatch(next, "random")) d->type = e_random; else if (strmatch(next, "hypot" )) d->type = e_hypot; else if (strmatch(next, "gcd" )) d->type = e_gcd; else if (strmatch(next, "if" )) d->type = e_if; else if (strmatch(next, "ifnot" )) d->type = e_ifnot; else if (strmatch(next, "bitand")) d->type = e_bitand; else if (strmatch(next, "bitor" )) d->type = e_bitor; else if (strmatch(next, "between"))d->type = e_between; else if (strmatch(next, "clip" )) d->type = e_clip; else { for (i=0; p->func1_names && p->func1_names[i]; i++) { if (strmatch(next, p->func1_names[i])) { d->a.func1 = p->funcs1[i]; d->type = e_func1; *e = d; return 0; } } for (i=0; p->func2_names && p->func2_names[i]; i++) { if (strmatch(next, p->func2_names[i])) { d->a.func2 = p->funcs2[i]; d->type = e_func2; *e = d; return 0; } } av_log(p, AV_LOG_ERROR, "Unknown function in '%s'\n", s0); av_expr_free(d); return AVERROR(EINVAL); } *e = d; return 0; }<SPLIT>[0.05563366039355449, 2.4920118880053392, 0.0, 0.037794879441717756, 2.338487271906691, 0.0, 9.138449345302481, 9.30154283025335, 8.700504996775486, 1.040052222782594, 2.2664821196532072, 0.061639525868012635, 2.597728080466551, 0.0, 0.0, 0.30852482215402843, 2.1338941911552656, 0.04368374699580437, 2.4491607997155365, 2.4468711124637066, 5.4011674763145745, 0.0, -0.08645738172306322, -0.16222078614455715, 3.2407443506492175, 6.559335986390454, 2.2631546422873847, 41.12895885272523, 5.105279757897274, 9.13577771537016, 9.299308287965495, 8.698048502813624, 1.039626388904333, 0.9056307075691036, 0.0, 9.121218717011157, 9.284698882463228, 8.683528592215653, 1.0350888753871217]
0<SPLIT>static int pulse_stream_wait(PulseData *s) { pa_stream_state_t state; while ((state = pa_stream_get_state(s->stream)) != PA_STREAM_READY) { if (state == PA_STREAM_FAILED || state == PA_STREAM_TERMINATED) return AVERROR_EXTERNAL; pa_threaded_mainloop_wait(s->mainloop); } return 0; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int lex_time(struct sbg_parser *p, int64_t *rt) { int r = str_to_time(p->cursor, rt); p->cursor += r; return r > 0; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int config_output(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; FramepackContext *s = outlink->src->priv; int width = ctx->inputs[LEFT]->w; int height = ctx->inputs[LEFT]->h; AVRational time_base = ctx->inputs[LEFT]->time_base; AVRational frame_rate = ctx->inputs[LEFT]->frame_rate; if (width != ctx->inputs[RIGHT]->w || height != ctx->inputs[RIGHT]->h) { av_log(ctx, AV_LOG_ERROR, "Left and right sizes differ (%dx%d vs %dx%d).\n", width, height, ctx->inputs[RIGHT]->w, ctx->inputs[RIGHT]->h); return AVERROR_INVALIDDATA; } else if (av_cmp_q(time_base, ctx->inputs[RIGHT]->time_base) != 0) { av_log(ctx, AV_LOG_ERROR, "Left and right time bases differ (%d/%d vs %d/%d).\n", time_base.num, time_base.den, ctx->inputs[RIGHT]->time_base.num, ctx->inputs[RIGHT]->time_base.den); return AVERROR_INVALIDDATA; } else if (av_cmp_q(frame_rate, ctx->inputs[RIGHT]->frame_rate) != 0) { av_log(ctx, AV_LOG_ERROR, "Left and right framerates differ (%d/%d vs %d/%d).\n", frame_rate.num, frame_rate.den, ctx->inputs[RIGHT]->frame_rate.num, ctx->inputs[RIGHT]->frame_rate.den); return AVERROR_INVALIDDATA; } s->pix_desc = av_pix_fmt_desc_get(outlink->format); if (!s->pix_desc) return AVERROR_BUG; switch (s->format) { case AV_STEREO3D_FRAMESEQUENCE: time_base.den *= 2; frame_rate.num *= 2; s->double_pts = AV_NOPTS_VALUE; break; case AV_STEREO3D_COLUMNS: case AV_STEREO3D_SIDEBYSIDE: width *= 2; break; case AV_STEREO3D_LINES: case AV_STEREO3D_TOPBOTTOM: height *= 2; break; default: av_log(ctx, AV_LOG_ERROR, "Unknown packing mode."); return AVERROR_INVALIDDATA; } outlink->w = width; outlink->h = height; outlink->time_base = time_base; outlink->frame_rate= frame_rate; return 0; }<SPLIT>[0.05563366039355449, 0.5968648583058486, 0.0, 0.037794879441717756, 0.5085128345390885, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.5482981787249199, 0.061639525868012635, 0.637540383444421, 0.0, 0.0, 0.30852482215402843, 0.4677628661210612, 0.04368374699580437, 0.5497160639660857, -0.14106852214680915, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 0.32477585926655006, -0.1980344553542678, -0.22049944857796966, -0.21702784222394986, -0.13468348084208653, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
1<SPLIT>static int gif_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { GifState *s = avctx->priv_data; AVFrame *picture = data; int ret; bytestream2_init(&s->gb, avpkt->data, avpkt->size); s->picture.pts = avpkt->pts; s->picture.pkt_pts = avpkt->pts; s->picture.pkt_dts = avpkt->dts; s->picture.pkt_duration = avpkt->duration; if (avpkt->size >= 6) { s->keyframe = memcmp(avpkt->data, gif87a_sig, 6) == 0 || memcmp(avpkt->data, gif89a_sig, 6) == 0; } else { s->keyframe = 0; } if (s->keyframe) { if ((ret = gif_read_header1(s)) < 0) return ret; if ((ret = av_image_check_size(s->screen_width, s->screen_height, 0, avctx)) < 0) return ret; avcodec_set_dimensions(avctx, s->screen_width, s->screen_height); if (s->picture.data[0]) avctx->release_buffer(avctx, &s->picture); if ((ret = ff_get_buffer(avctx, &s->picture)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return ret; } s->picture.pict_type = AV_PICTURE_TYPE_I; s->picture.key_frame = 1; } else { if ((ret = avctx->reget_buffer(avctx, &s->picture)) < 0) { av_log(avctx, AV_LOG_ERROR, "reget_buffer() failed\n"); return ret; } s->picture.pict_type = AV_PICTURE_TYPE_P; s->picture.key_frame = 0; } ret = gif_parse_next_image(s, got_frame); if (ret < 0) return ret; else if (*got_frame) *picture = s->picture; return avpkt->size; }<SPLIT>[1.4474140217819704, 0.33242573788266383, 0.0, 1.4071994323980908, 0.25316756420872527, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, 1.699703585821447, 0.48836152962277035, 1.477384014430136, 0.3640258210692401, 0.0, 0.0, 0.30852482215402843, 0.40964200594544947, 1.4359019367238823, 0.28467726362895307, 0.37651940477529405, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, 0.21937940777079099, 0.5103995425705821, 0.23107402248845843, 0.6817979554923368, 0.6138826961206794, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, 1.6991165002636506, 0.9056307075691036, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 1.693548171012695]
0<SPLIT>static void show_help_muxer(const char *name) { const AVCodecDescriptor *desc; const AVOutputFormat *fmt = av_guess_format(name, NULL, NULL); if (!fmt) { av_log(NULL, AV_LOG_ERROR, "Unknown format '%s'.\n", name); return; } printf("Muxer %s [%s]:\n", fmt->name, fmt->long_name); if (fmt->extensions) printf(" Common extensions: %s.\n", fmt->extensions); if (fmt->mime_type) printf(" Mime type: %s.\n", fmt->mime_type); if (fmt->video_codec != AV_CODEC_ID_NONE && (desc = avcodec_descriptor_get(fmt->video_codec))) { printf(" Default video codec: %s.\n", desc->name); } if (fmt->audio_codec != AV_CODEC_ID_NONE && (desc = avcodec_descriptor_get(fmt->audio_codec))) { printf(" Default audio codec: %s.\n", desc->name); } if (fmt->subtitle_codec != AV_CODEC_ID_NONE && (desc = avcodec_descriptor_get(fmt->subtitle_codec))) { printf(" Default subtitle codec: %s.\n", desc->name); } if (fmt->priv_class) show_help_children(fmt->priv_class, AV_OPT_FLAG_ENCODING_PARAM); }<SPLIT>[-0.25365086435942685, -0.04219634938351458, 0.0, -0.2665172434374763, -0.10857156875928925, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, -0.07104719533062549, -0.25297036047912586, -0.023453142295599506, 0.0, 0.0, 0.30852482215402843, -0.13281935569359377, -0.26569807294376846, -0.09079437018198484, -0.011671540416283347, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.03454968660237938, 0.005287286955244392, -0.21702784222394986, -0.04111270872174079, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>); static void ac3_downmix_sse(float **samples, float (*matrix)[2], int out_ch, int in_ch, int len) { int (*matrix_cmp)[2] = (int(*)[2])matrix; intptr_t i, j, k, m; i = -len * sizeof(float); if (in_ch == 5 && out_ch == 2 && !(matrix_cmp[0][1] | matrix_cmp[2][0] | matrix_cmp[3][1] | matrix_cmp[4][0] | (matrix_cmp[1][0] ^ matrix_cmp[1][1]) | (matrix_cmp[0][0] ^ matrix_cmp[2][1]))) { MIX5(IF0, IF1); } else if (in_ch == 5 && out_ch == 1 && matrix_cmp[0][0] == matrix_cmp[2][0] && matrix_cmp[3][0] == matrix_cmp[4][0]) { MIX5(IF1, IF0); } else { LOCAL_ALIGNED(16, float, matrix_simd, [AC3_MAX_CHANNELS], [2][4]); float *samp[AC3_MAX_CHANNELS]; for (j = 0; j < in_ch; j++) samp[j] = samples[j] + len; j = 2 * in_ch * sizeof(float); __asm__ volatile ( "1: \n" "sub $8, %0 \n" "movss (%2, %0), %%xmm4 \n" "movss 4(%2, %0), %%xmm5 \n" "shufps $0, %%xmm4, %%xmm4 \n" "shufps $0, %%xmm5, %%xmm5 \n" "movaps %%xmm4, (%1, %0, 4) \n" "movaps %%xmm5, 16(%1, %0, 4) \n" "jg 1b \n" : "+&r"(j) : "r"(matrix_simd), "r"(matrix) : "memory" ); if (out_ch == 2) { MIX_MISC(IF1); } else { MIX_MISC(IF0); } } }<SPLIT>[-0.25365086435942685, 0.2883525511454664, 0.0, -0.2665172434374763, 0.231888791681195, 0.0, 0.10120102281206332, 0.11088995743869048, 0.9059316288753189, -0.27925050329511203, 0.22863605018012226, -0.25297036047912586, 0.3184400606733766, 0.0, 0.0, 0.30852482215402843, 0.17715856524300236, -0.26569807294376846, 0.262590696934192, -0.011671540416283347, 0.9068970536268617, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, -0.25252937827156396, -0.22049944857796966, -0.21702784222394986, -0.22825425296243224, 0.10084358397375535, 0.11056045576999526, 0.9053924298597907, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.9011791483816026, -0.28182971586402455]
0<SPLIT>static void show_format_opts(void) { AVInputFormat *iformat = NULL; AVOutputFormat *oformat = NULL; printf("@section Generic format AVOptions\n"); show_opts(avformat_get_class()); printf("@section Format-specific AVOptions\n"); while ((iformat = av_iformat_next(iformat))) { if (!iformat->priv_class) continue; printf("@subsection %s AVOptions\n", iformat->priv_class->class_name); show_opts(iformat->priv_class); } while ((oformat = av_oformat_next(oformat))) { if (!oformat->priv_class) continue; printf("@subsection %s AVOptions\n", oformat->priv_class->class_name); show_opts(oformat->priv_class); } }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.25252937827156396, -0.22049944857796966, -0.21702784222394986, -0.22825425296243224, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void rgbtest_put_pixel(uint8_t *dst, int dst_linesize, int x, int y, int r, int g, int b, enum AVPixelFormat fmt, uint8_t rgba_map[4]) { int32_t v; uint8_t *p; switch (fmt) { case AV_PIX_FMT_BGR444: ((uint16_t*)(dst + y*dst_linesize))[x] = ((r >> 4) << 8) | ((g >> 4) << 4) | (b >> 4); break; case AV_PIX_FMT_RGB444: ((uint16_t*)(dst + y*dst_linesize))[x] = ((b >> 4) << 8) | ((g >> 4) << 4) | (r >> 4); break; case AV_PIX_FMT_BGR555: ((uint16_t*)(dst + y*dst_linesize))[x] = ((r>>3)<<10) | ((g>>3)<<5) | (b>>3); break; case AV_PIX_FMT_RGB555: ((uint16_t*)(dst + y*dst_linesize))[x] = ((b>>3)<<10) | ((g>>3)<<5) | (r>>3); break; case AV_PIX_FMT_BGR565: ((uint16_t*)(dst + y*dst_linesize))[x] = ((r>>3)<<11) | ((g>>2)<<5) | (b>>3); break; case AV_PIX_FMT_RGB565: ((uint16_t*)(dst + y*dst_linesize))[x] = ((b>>3)<<11) | ((g>>2)<<5) | (r>>3); break; case AV_PIX_FMT_RGB24: case AV_PIX_FMT_BGR24: v = (r << (rgba_map[R]*8)) + (g << (rgba_map[G]*8)) + (b << (rgba_map[B]*8)); p = dst + 3*x + y*dst_linesize; AV_WL24(p, v); break; case AV_PIX_FMT_RGBA: case AV_PIX_FMT_BGRA: case AV_PIX_FMT_ARGB: case AV_PIX_FMT_ABGR: v = (r << (rgba_map[R]*8)) + (g << (rgba_map[G]*8)) + (b << (rgba_map[B]*8)) + (255 << (rgba_map[A]*8)); p = dst + 4*x + y*dst_linesize; AV_WL32(p, v); break; } }<SPLIT>[-0.25365086435942685, -0.020159756014915854, 0.0, -0.2665172434374763, -0.08729279623175898, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.051068312296575644, -0.25297036047912586, -0.0006602620976677653, 0.0, 0.0, 0.30852482215402843, -0.1134457356350565, -0.26569807294376846, -0.06870780348722379, -0.270465503877335, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, 0.07885080577644558, -0.03454968660237938, -0.4462861841111837, -0.21702784222394986, 0.33317037975964214, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, 0.04889276383167627, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void write_time(AVIOContext *out, int64_t time) { int seconds = time / AV_TIME_BASE; int fractions = time % AV_TIME_BASE; int minutes = seconds / 60; int hours = minutes / 60; seconds %= 60; minutes %= 60; avio_printf(out, "PT"); if (hours) avio_printf(out, "%dH", hours); if (hours || minutes) avio_printf(out, "%dM", minutes); avio_printf(out, "%d.%dS", seconds, fractions / (AV_TIME_BASE / 10)); }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.14106852214680915, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.3070243011888601, -0.22049944857796966, -0.21702784222394986, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int mov_write_mdhd_tag(AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track) { int version = track->track_duration < INT32_MAX ? 0 : 1; if (track->mode == MODE_ISM) version = 1; (version == 1) ? avio_wb32(pb, 44) : avio_wb32(pb, 32); ffio_wfourcc(pb, "mdhd"); avio_w8(pb, version); avio_wb24(pb, 0); if (version == 1) { avio_wb64(pb, track->time); avio_wb64(pb, track->time); } else { avio_wb32(pb, track->time); avio_wb32(pb, track->time); } avio_wb32(pb, track->timescale); if (!track->entry && mov->mode == MODE_ISM) (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff); else if (!track->entry) (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0); else (version == 1) ? avio_wb64(pb, track->track_duration) : avio_wb32(pb, track->track_duration); avio_wb16(pb, track->language); avio_wb16(pb, 0); if (version != 0 && track->mode == MODE_MOV) { av_log(NULL, AV_LOG_ERROR, "FATAL error, file duration too long for timebase, this file will not be\n" "playable with quicktime. Choose a different timebase or a different\n" "container format\n"); } return 32; }<SPLIT>[-0.25365086435942685, 0.0900232108280778, 0.0, -0.2665172434374763, 0.01910106640589235, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.04882610287367361, -0.25297036047912586, 0.11330413889199094, 0.0, 0.0, 0.30852482215402843, -0.016577635342370212, -0.26569807294376846, 0.04172502998658149, 0.5059163865058198, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.06167779621789984, 0.0744401592322129, 0.23107402248845843, -0.21702784222394986, -0.04111270872174079, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void print_cpu_name(void) { if (state.cpu_flag_name) { color_printf(COLOR_YELLOW, "%s:\n", state.cpu_flag_name); state.cpu_flag_name = NULL; } }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int ff_draw_round_to_sub(FFDrawContext *draw, int sub_dir, int round_dir, int value) { unsigned shift = sub_dir ? draw->vsub_max : draw->hsub_max; if (!shift) return value; if (round_dir >= 0) value += round_dir ? (1 << shift) - 1 : 1 << (shift - 1); return (value >> shift) << shift; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.3615192241061562, -0.6720729196443977, -0.21702784222394986, -0.04111270872174079, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { AShowInfoContext *s = ctx->priv; av_freep(&s->plane_checksums); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static inline void rgb15tobgr24_c(const uint8_t *src, uint8_t *dst, int src_size) { uint8_t *d = dst; const uint16_t *s = (const uint16_t *)src; const uint16_t *end = s + src_size / 2; while (s < end) { register uint16_t bgr = *s++; *d++ = ((bgr&0x001F)<<3) | ((bgr&0x001F)>> 2); *d++ = ((bgr&0x03E0)>>2) | ((bgr&0x03E0)>> 7); *d++ = ((bgr&0x7C00)>>7) | ((bgr&0x7C00)>>12); } }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int mov_write_header(AVFormatContext *s) { AVIOContext *pb = s->pb; MOVMuxContext *mov = s->priv_data; AVDictionaryEntry *t, *global_tcr = av_dict_get(s->metadata, "timecode", NULL, 0); int i, ret, hint_track = 0, tmcd_track = 0; mov->fc = s; mov->mode = MODE_MP4; if (s->oformat) { if (!strcmp("3gp", s->oformat->name)) mov->mode = MODE_3GP; else if (!strcmp("3g2", s->oformat->name)) mov->mode = MODE_3GP|MODE_3G2; else if (!strcmp("mov", s->oformat->name)) mov->mode = MODE_MOV; else if (!strcmp("psp", s->oformat->name)) mov->mode = MODE_PSP; else if (!strcmp("ipod",s->oformat->name)) mov->mode = MODE_IPOD; else if (!strcmp("ismv",s->oformat->name)) mov->mode = MODE_ISM; else if (!strcmp("f4v", s->oformat->name)) mov->mode = MODE_F4V; } if (mov->flags & FF_MOV_FLAG_DELAY_MOOV) mov->flags |= FF_MOV_FLAG_EMPTY_MOOV; if (mov->max_fragment_duration || mov->max_fragment_size || mov->flags & (FF_MOV_FLAG_EMPTY_MOOV | FF_MOV_FLAG_FRAG_KEYFRAME | FF_MOV_FLAG_FRAG_CUSTOM)) mov->flags |= FF_MOV_FLAG_FRAGMENT; if (mov->mode == MODE_ISM) mov->flags |= FF_MOV_FLAG_EMPTY_MOOV | FF_MOV_FLAG_SEPARATE_MOOF | FF_MOV_FLAG_FRAGMENT; if (mov->flags & FF_MOV_FLAG_DASH) mov->flags |= FF_MOV_FLAG_FRAGMENT | FF_MOV_FLAG_EMPTY_MOOV | FF_MOV_FLAG_DEFAULT_BASE_MOOF; if (mov->flags & FF_MOV_FLAG_FASTSTART) { mov->reserved_moov_size = -1; } if (mov->use_editlist < 0) { mov->use_editlist = 1; if (mov->flags & FF_MOV_FLAG_FRAGMENT && !(mov->flags & FF_MOV_FLAG_DELAY_MOOV)) { if (s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_AUTO || s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO) mov->use_editlist = 0; } } if (mov->flags & FF_MOV_FLAG_EMPTY_MOOV && !(mov->flags & FF_MOV_FLAG_DELAY_MOOV) && mov->use_editlist) av_log(s, AV_LOG_WARNING, "No meaningful edit list will be written when using empty_moov without delay_moov\n"); if (!mov->use_editlist && s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_AUTO) s->avoid_negative_ts = AVFMT_AVOID_NEG_TS_MAKE_ZERO; if (mov->flags & FF_MOV_FLAG_OMIT_TFHD_OFFSET && mov->flags & FF_MOV_FLAG_DEFAULT_BASE_MOOF) mov->flags &= ~FF_MOV_FLAG_OMIT_TFHD_OFFSET; if (mov->frag_interleave && mov->flags & (FF_MOV_FLAG_OMIT_TFHD_OFFSET | FF_MOV_FLAG_SEPARATE_MOOF)) { av_log(s, AV_LOG_ERROR, "Sample interleaving in fragments is mutually exclusive with " "omit_tfhd_offset and separate_moof\n"); return AVERROR(EINVAL); } if (!s->pb->seekable && (!(mov->flags & FF_MOV_FLAG_FRAGMENT) || mov->ism_lookahead)) { av_log(s, AV_LOG_ERROR, "muxer does not support non seekable output\n"); return AVERROR(EINVAL); } if (!(mov->flags & FF_MOV_FLAG_DELAY_MOOV)) { if ((ret = mov_write_identification(pb, s)) < 0) return ret; } mov->nb_streams = s->nb_streams; if (mov->mode & (MODE_MP4|MODE_MOV|MODE_IPOD) && s->nb_chapters) mov->chapter_track = mov->nb_streams++; if (mov->flags & FF_MOV_FLAG_RTP_HINT) { hint_track = mov->nb_streams; for (i = 0; i < s->nb_streams; i++) { AVStream *st = s->streams[i]; if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO || st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { mov->nb_streams++; } } } if (mov->mode == MODE_MOV) { tmcd_track = mov->nb_streams; for (i = 0; i < s->nb_streams; i++) { AVStream *st = s->streams[i]; if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO && (global_tcr || av_dict_get(st->metadata, "timecode", NULL, 0))) mov->nb_meta_tmcd++; } if (mov->nb_meta_tmcd) { for (i = 0; i < s->nb_streams; i++) { AVStream *st = s->streams[i]; if (st->codec->codec_tag == MKTAG('t','m','c','d')) { av_log(s, AV_LOG_WARNING, "You requested a copy of the original timecode track " "so timecode metadata are now ignored\n"); mov->nb_meta_tmcd = 0; } } } mov->nb_streams += mov->nb_meta_tmcd; } mov->tracks = av_mallocz_array((mov->nb_streams + 1), sizeof(*mov->tracks)); if (!mov->tracks) return AVERROR(ENOMEM); for (i = 0; i < s->nb_streams; i++) { AVStream *st= s->streams[i]; MOVTrack *track= &mov->tracks[i]; AVDictionaryEntry *lang = av_dict_get(st->metadata, "language", NULL,0); track->st = st; track->enc = st->codec; track->language = ff_mov_iso639_to_lang(lang?lang->value:"und", mov->mode!=MODE_MOV); if (track->language < 0) track->language = 0; track->mode = mov->mode; track->tag = mov_find_codec_tag(s, track); if (!track->tag) { av_log(s, AV_LOG_ERROR, "Could not find tag for codec %s in stream #%d, " "codec not currently supported in container\n", avcodec_get_name(st->codec->codec_id), i); ret = AVERROR(EINVAL); goto error; } track->hint_track = -1; track->start_dts = AV_NOPTS_VALUE; track->start_cts = AV_NOPTS_VALUE; track->end_pts = AV_NOPTS_VALUE; if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { if (track->tag == MKTAG('m','x','3','p') || track->tag == MKTAG('m','x','3','n') || track->tag == MKTAG('m','x','4','p') || track->tag == MKTAG('m','x','4','n') || track->tag == MKTAG('m','x','5','p') || track->tag == MKTAG('m','x','5','n')) { if (st->codec->width != 720 || (st->codec->height != 608 && st->codec->height != 512)) { av_log(s, AV_LOG_ERROR, "D-10/IMX must use 720x608 or 720x512 video resolution\n"); ret = AVERROR(EINVAL); goto error; } track->height = track->tag >> 24 == 'n' ? 486 : 576; } if (mov->video_track_timescale) { track->timescale = mov->video_track_timescale; } else { track->timescale = st->time_base.den; while(track->timescale < 10000) track->timescale *= 2; } if (st->codec->width > 65535 || st->codec->height > 65535) { av_log(s, AV_LOG_ERROR, "Resolution %dx%d too large for mov/mp4\n", st->codec->width, st->codec->height); ret = AVERROR(EINVAL); goto error; } if (track->mode == MODE_MOV && track->timescale > 100000) av_log(s, AV_LOG_WARNING, "WARNING codec timebase is very high. If duration is too long,\n" "file may not be playable by quicktime. Specify a shorter timebase\n" "or choose different container.\n"); } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { track->timescale = st->codec->sample_rate; if (!st->codec->frame_size && !av_get_bits_per_sample(st->codec->codec_id)) { av_log(s, AV_LOG_WARNING, "track %d: codec frame size is not set\n", i); track->audio_vbr = 1; }else if (st->codec->codec_id == AV_CODEC_ID_ADPCM_MS || st->codec->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV || st->codec->codec_id == AV_CODEC_ID_ILBC){ if (!st->codec->block_align) { av_log(s, AV_LOG_ERROR, "track %d: codec block align is not set for adpcm\n", i); ret = AVERROR(EINVAL); goto error; } track->sample_size = st->codec->block_align; }else if (st->codec->frame_size > 1){ track->audio_vbr = 1; }else{ track->sample_size = (av_get_bits_per_sample(st->codec->codec_id) >> 3) * st->codec->channels; } if (st->codec->codec_id == AV_CODEC_ID_ILBC || st->codec->codec_id == AV_CODEC_ID_ADPCM_IMA_QT) { track->audio_vbr = 1; } if (track->mode != MODE_MOV && track->enc->codec_id == AV_CODEC_ID_MP3 && track->timescale < 16000) { if (track->enc->strict_std_compliance >= FF_COMPLIANCE_NORMAL) { av_log(s, AV_LOG_ERROR, "track %d: muxing mp3 at %dhz is not standard, to mux anyway set strict to -1\n", i, track->enc->sample_rate); ret = AVERROR(EINVAL); goto error; } else { av_log(s, AV_LOG_WARNING, "track %d: muxing mp3 at %dhz is not standard in MP4\n", i, track->enc->sample_rate); } } } else if (st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) { track->timescale = st->time_base.den; } else if (st->codec->codec_type == AVMEDIA_TYPE_DATA) { track->timescale = st->time_base.den; } else { track->timescale = MOV_TIMESCALE; } if (!track->height) track->height = st->codec->height; if (mov->mode == MODE_ISM) track->timescale = 10000000; avpriv_set_pts_info(st, 64, 1, track->timescale); if (st->codec->extradata_size) { if (st->codec->codec_id == AV_CODEC_ID_DVD_SUBTITLE) mov_create_dvd_sub_decoder_specific_info(track, st); else if (!TAG_IS_AVCI(track->tag) && st->codec->codec_id != AV_CODEC_ID_DNXHD) { track->vos_len = st->codec->extradata_size; track->vos_data = av_malloc(track->vos_len); if (!track->vos_data) { ret = AVERROR(ENOMEM); goto error; } memcpy(track->vos_data, st->codec->extradata, track->vos_len); } } } for (i = 0; i < s->nb_streams; i++) { int j; AVStream *st= s->streams[i]; MOVTrack *track= &mov->tracks[i]; if (st->codec->codec_type != AVMEDIA_TYPE_AUDIO || track->enc->channel_layout != AV_CH_LAYOUT_MONO) continue; for (j = 0; j < s->nb_streams; j++) { AVStream *stj= s->streams[j]; MOVTrack *trackj= &mov->tracks[j]; if (j == i) continue; if (stj->codec->codec_type != AVMEDIA_TYPE_AUDIO || trackj->enc->channel_layout != AV_CH_LAYOUT_MONO || trackj->language != track->language || trackj->tag != track->tag ) continue; track->multichannel_as_mono++; } } enable_tracks(s); if (mov->reserved_moov_size){ mov->reserved_header_pos = avio_tell(pb); if (mov->reserved_moov_size > 0) avio_skip(pb, mov->reserved_moov_size); } if (mov->flags & FF_MOV_FLAG_FRAGMENT) { if (!(mov->flags & (FF_MOV_FLAG_FRAG_KEYFRAME | FF_MOV_FLAG_FRAG_CUSTOM)) && !mov->max_fragment_duration && !mov->max_fragment_size) mov->flags |= FF_MOV_FLAG_FRAG_KEYFRAME; } else { if (mov->flags & FF_MOV_FLAG_FASTSTART) mov->reserved_header_pos = avio_tell(pb); mov_write_mdat_tag(pb, mov); } if (t = av_dict_get(s->metadata, "creation_time", NULL, 0)) { mov->time = ff_iso8601_to_unix_time(t->value); if (mov->time < 0) { av_log(s, AV_LOG_WARNING, "Failed to parse creation_time %s\n", t->value); mov->time = 0; } } if (mov->time) mov->time += 0x7C25B080; if (mov->chapter_track) if ((ret = mov_create_chapter_track(s, mov->chapter_track)) < 0) goto error; if (mov->flags & FF_MOV_FLAG_RTP_HINT) { for (i = 0; i < s->nb_streams; i++) { AVStream *st = s->streams[i]; if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO || st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if ((ret = ff_mov_init_hinting(s, hint_track, i)) < 0) goto error; hint_track++; } } } if (mov->nb_meta_tmcd) { for (i = 0; i < s->nb_streams; i++) { AVStream *st = s->streams[i]; t = global_tcr; if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { if (!t) t = av_dict_get(st->metadata, "timecode", NULL, 0); if (!t) continue; if ((ret = mov_create_timecode_track(s, tmcd_track, i, t->value)) < 0) goto error; tmcd_track++; } } } avio_flush(pb); if (mov->flags & FF_MOV_FLAG_ISML) mov_write_isml_manifest(pb, mov); if (mov->flags & FF_MOV_FLAG_EMPTY_MOOV && !(mov->flags & FF_MOV_FLAG_DELAY_MOOV)) { if ((ret = mov_write_moov_tag(pb, mov, s)) < 0) return ret; mov->moov_written = 1; if (mov->flags & FF_MOV_FLAG_GLOBAL_SIDX) mov->reserved_header_pos = avio_tell(pb); } return 0; error: mov_free(s); return ret; }<SPLIT>[3.61240569505284, 6.039903420349734, 0.0, 3.5373842925524492, 5.764369648839064, 0.0, 3.229479288289516, 3.292269798028381, 3.0618774540391946, 1.699703585821447, 5.94259659791838, 3.6796532188601057, 6.26738179233356, 0.0, 0.0, 0.30852482215402843, 5.698640281926121, 3.601574676300892, 6.005098037572066, 3.093856021116336, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, 4.505501768598326, 2.6357015363451315, 3.053408216653634, 0.6817979554923368, 1.9238735058055194, 3.2283207833032805, 3.2912808592222835, 3.0608079394002123, 1.6991165002636506, 0.9056307075691036, 0.0, 3.22121020048164, 3.284132330149356, 3.053743888165489, 1.693548171012695]
0<SPLIT>static void mxf_write_identification(AVFormatContext *s) { MXFContext *mxf = s->priv_data; AVIOContext *pb = s->pb; const char *company = "FFmpeg"; const char *product = s->oformat != &ff_mxf_opatom_muxer ? "OP1a Muxer" : "OPAtom Muxer"; const char *version; int length; mxf_write_metadata_key(pb, 0x013000); PRINT_KEY(s, "identification key", pb->buf_ptr - 16); version = s->flags & AVFMT_FLAG_BITEXACT ? "0.0.0" : AV_STRINGIFY(LIBAVFORMAT_VERSION); length = 72 + mxf_utf16_local_tag_length(company) + mxf_utf16_local_tag_length(product) + mxf_utf16_local_tag_length(version); klv_encode_ber_length(pb, length); mxf_write_local_tag(pb, 16, 0x3C0A); mxf_write_uuid(pb, Identification, 0); PRINT_KEY(s, "identification uid", pb->buf_ptr - 16); mxf_write_local_tag(pb, 16, 0x3C09); mxf_write_uuid(pb, Identification, 1); mxf_write_local_tag_utf16(pb, 0x3C01, company); mxf_write_local_tag_utf16(pb, 0x3C02, product); mxf_write_local_tag_utf16(pb, 0x3C04, version); mxf_write_local_tag(pb, 16, 0x3C05); mxf_write_uuid(pb, Identification, 2); mxf_write_local_tag(pb, 8, 0x3C06); avio_wb64(pb, mxf->timestamp); }<SPLIT>[0.36491818514653585, -0.020159756014915854, 0.0, 0.34210700232091185, -0.08729279623175898, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.02884721983962376, 0.3762494122151511, -0.0006602620976677653, 0.0, 0.0, 0.30852482215402843, -0.03595125540090747, 0.35306556693537716, -0.06870780348722379, 0.8941073316973973, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 0.11398295627503194, 0.0744401592322129, 0.6826474935548865, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int request_frame(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; ATADenoiseContext *s = ctx->priv; int ret = 0; ret = ff_request_frame(ctx->inputs[0]); if (ret == AVERROR_EOF && !ctx->is_disabled && s->available) { AVFrame *buf = ff_get_video_buffer(outlink, outlink->w, outlink->h); if (!buf) return AVERROR(ENOMEM); ret = filter_frame(ctx->inputs[0], buf); s->available--; } return ret; }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.14106852214680915, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.3070243011888601, -0.22049944857796966, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static VideoState *stream_open(const char *filename, AVInputFormat *iformat) { VideoState *is; is = av_mallocz(sizeof(VideoState)); if (!is) return NULL; is->filename = av_strdup(filename); if (!is->filename) goto fail; is->iformat = iformat; is->ytop = 0; is->xleft = 0; if (frame_queue_init(&is->pictq, &is->videoq, VIDEO_PICTURE_QUEUE_SIZE, 1) < 0) goto fail; if (frame_queue_init(&is->subpq, &is->subtitleq, SUBPICTURE_QUEUE_SIZE, 0) < 0) goto fail; if (frame_queue_init(&is->sampq, &is->audioq, SAMPLE_QUEUE_SIZE, 1) < 0) goto fail; if (packet_queue_init(&is->videoq) < 0 || packet_queue_init(&is->audioq) < 0 || packet_queue_init(&is->subtitleq) < 0) goto fail; if (!(is->continue_read_thread = SDL_CreateCond())) { av_log(NULL, AV_LOG_FATAL, "SDL_CreateCond(): %s\n", SDL_GetError()); goto fail; } init_clock(&is->vidclk, &is->videoq.serial); init_clock(&is->audclk, &is->audioq.serial); init_clock(&is->extclk, &is->extclk.serial); is->audio_clock_serial = -1; if (startup_volume < 0) av_log(NULL, AV_LOG_WARNING, "-volume=%d < 0, setting to 0\n", startup_volume); if (startup_volume > 100) av_log(NULL, AV_LOG_WARNING, "-volume=%d > 100, setting to 100\n", startup_volume); startup_volume = av_clip(startup_volume, 0, 100); startup_volume = av_clip(SDL_MIX_MAXVOLUME * startup_volume / 100, 0, SDL_MIX_MAXVOLUME); is->audio_volume = startup_volume; is->muted = 0; is->av_sync_type = av_sync_type; is->read_tid = SDL_CreateThread(read_thread, "read_thread", is); if (!is->read_tid) { av_log(NULL, AV_LOG_FATAL, "SDL_CreateThread(): %s\n", SDL_GetError()); fail: stream_close(is); return NULL; } return is; }<SPLIT>[-0.09900860198293619, 0.39853551798846004, 0.0, -0.11436118199787926, 0.31700388179131606, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, 2.0295292673408736, 0.3485093483844214, -0.09566541730555662, 0.4324044616630353, 0.0, 0.0, 0.30852482215402843, 0.27402666553568866, -0.11100716297398205, 0.35093696371323624, 0.5059163865058198, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3599080097651364, 0.7283792342397666, 0.5697541257882794, 0.6817979554923368, 0.7074534682410251, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, 2.0288615559433096, 0.04889276383167627, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 2.0227778188254817]
0<SPLIT>static int mov_write_uuidusmt_tag(AVIOContext *pb, AVFormatContext *s) { AVDictionaryEntry *title = av_dict_get(s->metadata, "title", NULL, 0); int64_t pos, pos2; if (title) { pos = avio_tell(pb); avio_wb32(pb, 0); ffio_wfourcc(pb, "uuid"); ffio_wfourcc(pb, "USMT"); avio_wb32(pb, 0x21d24fce); avio_wb32(pb, 0xbb88695c); avio_wb32(pb, 0xfac9c740); pos2 = avio_tell(pb); avio_wb32(pb, 0); ffio_wfourcc(pb, "MTDT"); avio_wb16(pb, 4); avio_wb16(pb, 0x0C); avio_wb32(pb, 0x0B); avio_wb16(pb, language_code("und")); avio_wb16(pb, 0x0); avio_wb16(pb, 0x021C); if (!(s->flags & AVFMT_FLAG_BITEXACT)) mov_write_psp_udta_tag(pb, LIBAVCODEC_IDENT, "eng", 0x04); mov_write_psp_udta_tag(pb, title->value, "eng", 0x01); mov_write_psp_udta_tag(pb, "2006/04/01 11:11:11", "und", 0x03); update_size(pb, pos2); return update_size(pb, pos); } return 0; }<SPLIT>[-0.09900860198293619, 0.0018768373536828752, 0.0, -0.11436118199787926, -0.06601402370422871, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.011110546228475942, -0.09566541730555662, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, -0.07469849551798198, -0.11100716297398205, -0.04662123679246273, 0.24712242304476825, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.14911510677361828, -0.14353953243697165, 0.11818065472185141, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void json_print_section_footer(WriterContext *wctx) { JSONContext *json = wctx->priv; const struct section *section = wctx->section[wctx->level]; if (wctx->level == 0) { json->indent_level--; printf("\n}\n"); } else if (section->flags & SECTION_FLAG_IS_ARRAY) { printf("\n"); json->indent_level--; JSON_INDENT(); printf("]"); } else { printf("%s", json->item_start_end); json->indent_level--; if (!json->compact) JSON_INDENT(); printf("}"); } }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.39986248560786075, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, 0.01994523631491676, -0.3333928163445767, -0.21702784222394986, 0.33317037975964214, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void subshift(av_aes_block s0[2], int s, const uint8_t *box) { av_aes_block *s1 = (av_aes_block *) (s0[0].u8 - s); av_aes_block *s3 = (av_aes_block *) (s0[0].u8 + s); s0[0].u8[ 0] = box[s0[1].u8[ 0]]; s0[0].u8[ 4] = box[s0[1].u8[ 4]]; s0[0].u8[ 8] = box[s0[1].u8[ 8]]; s0[0].u8[12] = box[s0[1].u8[12]]; s1[0].u8[ 3] = box[s1[1].u8[ 7]]; s1[0].u8[ 7] = box[s1[1].u8[11]]; s1[0].u8[11] = box[s1[1].u8[15]]; s1[0].u8[15] = box[s1[1].u8[ 3]]; s0[0].u8[ 2] = box[s0[1].u8[10]]; s0[0].u8[10] = box[s0[1].u8[ 2]]; s0[0].u8[ 6] = box[s0[1].u8[14]]; s0[0].u8[14] = box[s0[1].u8[ 6]]; s3[0].u8[ 1] = box[s3[1].u8[13]]; s3[0].u8[13] = box[s3[1].u8[ 9]]; s3[0].u8[ 9] = box[s3[1].u8[ 5]]; s3[0].u8[ 5] = box[s3[1].u8[ 1]]; }<SPLIT>[-0.25365086435942685, -0.1964525029637057, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.21089937656897445, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.06167779621789984, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void av_vlog(void* avcl, int level, const char *fmt, va_list vl) { void (*log_callback)(void*, int, const char*, va_list) = av_log_callback; if (log_callback) log_callback(avcl, level, fmt, vl); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static PullupBuffer *pullup_lock_buffer(PullupBuffer *b, int parity) { if (!b) return NULL; if ((parity + 1) & 1) b->lock[0]++; if ((parity + 1) & 2) b->lock[1]++; return b; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>inline static AudioFragment *yae_prev_frag(ATempoContext *atempo) { return &atempo->frag[(atempo->nfrag + 1) % 2]; }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void draw_dot(AudioVectorScopeContext *s, unsigned x, unsigned y) { const int linesize = s->outpicref->linesize[0]; uint8_t *dst; if (s->zoom > 1) { if (y >= s->h || x >= s->w) return; } else { y = FFMIN(y, s->h - 1); x = FFMIN(x, s->w - 1); } dst = &s->outpicref->data[0][y * linesize + x * 4]; dst[0] = FFMIN(dst[0] + s->contrast[0], 255); dst[1] = FFMIN(dst[1] + s->contrast[1], 255); dst[2] = FFMIN(dst[2] + s->contrast[2], 255); dst[3] = FFMIN(dst[3] + s->contrast[3], 255); }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.39986248560786075, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.3615192241061562, -0.4462861841111837, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int print_link_prop(AVBPrint *buf, AVFilterLink *link) { char *format; char layout[64]; AVBPrint dummy_buffer = { 0 }; if (!buf) buf = &dummy_buffer; switch (link->type) { case AVMEDIA_TYPE_VIDEO: format = av_x_if_null(av_get_pix_fmt_name(link->format), "?"); av_bprintf(buf, "[%dx%d %d:%d %s]", link->w, link->h, link->sample_aspect_ratio.num, link->sample_aspect_ratio.den, format); break; case AVMEDIA_TYPE_AUDIO: av_get_channel_layout_string(layout, sizeof(layout), link->channels, link->channel_layout); format = av_x_if_null(av_get_sample_fmt_name(link->format), "?"); av_bprintf(buf, "[%dHz %s:%s]", (int)link->sample_rate, format, layout); break; default: av_bprintf(buf, "?"); break; } return buf->len; }<SPLIT>[-0.25365086435942685, -0.04219634938351458, 0.0, -0.2665172434374763, -0.10857156875928925, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.07104719533062549, -0.25297036047912586, -0.023453142295599506, 0.0, 0.0, 0.30852482215402843, -0.13281935569359377, -0.26569807294376846, -0.09079437018198484, -0.011671540416283347, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.3070243011888601, 0.005287286955244392, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>static int dv_extract_audio(uint8_t* frame, uint8_t* ppcm[4], const DVprofile *sys) { int size, chan, i, j, d, of, smpls, freq, quant, half_ch; uint16_t lc, rc; const uint8_t* as_pack; uint8_t *pcm, ipcm; as_pack = dv_extract_pack(frame, dv_audio_source); if (!as_pack) return 0; smpls = as_pack[1] & 0x3f; freq = (as_pack[4] >> 3) & 0x07; quant = as_pack[4] & 0x07; if (quant > 1) return -1; size = (sys->audio_min_samples[freq] + smpls) * 4; half_ch = sys->difseg_size / 2; ipcm = (sys->height == 720 && !(frame[1] & 0x0C)) ? 2 : 0; pcm = ppcm[ipcm++]; for (chan = 0; chan < sys->n_difchan; chan++) { for (i = 0; i < sys->difseg_size; i++) { frame += 6 * 80; if (quant == 1 && i == half_ch) { pcm = ppcm[ipcm++]; if (!pcm) break; } for (j = 0; j < 9; j++) { for (d = 8; d < 80; d += 2) { if (quant == 0) { of = sys->audio_shuffle[i][j] + (d - 8) / 2 * sys->audio_stride; if (of*2 >= size) continue; pcm[of*2] = frame[d+1]; pcm[of*2+1] = frame[d]; if (pcm[of*2+1] == 0x80 && pcm[of*2] == 0x00) pcm[of*2+1] = 0; } else { lc = ((uint16_t)frame[d] << 4) | ((uint16_t)frame[d+2] >> 4); rc = ((uint16_t)frame[d+1] << 4) | ((uint16_t)frame[d+2] & 0x0f); lc = (lc == 0x800 ? 0 : dv_audio_12to16(lc)); rc = (rc == 0x800 ? 0 : dv_audio_12to16(rc)); of = sys->audio_shuffle[i%half_ch][j] + (d - 8) / 3 * sys->audio_stride; if (of*2 >= size) continue; pcm[of*2] = lc & 0xff; pcm[of*2+1] = lc >> 8; of = sys->audio_shuffle[i%half_ch+half_ch][j] + (d - 8) / 3 * sys->audio_stride; pcm[of*2] = rc & 0xff; pcm[of*2+1] = rc >> 8; ++d; } } frame += 16 * 80; } } pcm = ppcm[ipcm++]; if (!pcm) break; } return size; }<SPLIT>[2.8391943831703865, 0.7731576052546384, 0.0, 2.7766039853544644, 0.6787430147593306, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, 1.067749137610216, 2.8931285029922593, 0.8198834250278749, 0.0, 0.0, 0.30852482215402843, 0.9714769876430299, 2.82812012645196, 0.7264085975241742, -0.14106852214680915, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, 0.9220224177425181, 0.29241985090139744, 0.6826474935548865, -0.21702784222394986, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int parse_script(void *log, char *script, int script_len, struct sbg_script *rscript) { struct sbg_parser sp = { .log = log, .script = script, .end = script + script_len, .cursor = script, .line_no = 1, .err_msg = "", .scs = { .start_ts = AV_NOPTS_VALUE, .sample_rate = 44100, .opt_fade_time = 60 * AV_TIME_BASE, }, }; int r; lex_space(&sp); while (sp.cursor < sp.end) { r = parse_options(&sp); if (r < 0) goto fail; if (!r && !lex_line_end(&sp)) break; } while (sp.cursor < sp.end) { r = parse_named_def(&sp); if (!r) r = parse_time_sequence(&sp, 0); if (!r) r = lex_line_end(&sp) ? 1 : AVERROR_INVALIDDATA; if (r < 0) goto fail; } *rscript = sp.scs; return 1; fail: free_script(&sp.scs); if (!*sp.err_msg) if (r == AVERROR_INVALIDDATA) snprintf(sp.err_msg, sizeof(sp.err_msg), "syntax error"); if (log && *sp.err_msg) { const char *ctx = sp.cursor; const char *ectx = av_x_if_null(memchr(ctx, '\n', sp.end - sp.cursor), sp.end); int lctx = ectx - ctx; const char *quote = "\""; if (lctx > 0 && ctx[lctx - 1] == '\r') lctx--; if (lctx == 0) { ctx = "the end of line"; lctx = strlen(ctx); quote = ""; } av_log(log, AV_LOG_ERROR, "Error line %d: %s near %s%.*s%s.\n", sp.line_no, sp.err_msg, quote, lctx, ctx, quote); } return r; }<SPLIT>[-0.09900860198293619, 0.6409380450430461, 0.0, -0.11436118199787926, 0.551070379594149, 0.0, 0.10120102281206332, 0.11088995743869048, 0.24256368267104944, -0.27925050329511203, 0.5682770617589697, -0.09566541730555662, 0.6831261438402845, 0.0, 0.0, 0.30852482215402843, 0.4871364861795985, -0.11100716297398205, 0.5938891973556079, 1.2822982768889746, 0.6876643500811196, 0.0, -0.08645738172306322, -0.16222078614455715, 0.14911510677361828, 0.9463589259089511, 1.4729010679211356, 0.6817979554923368, 0.33317037975964214, 0.10084358397375535, 0.11056045576999526, 0.24218765769350709, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static int request_frame(AVFilterLink *outlink) { int ret; AVFilterContext *ctx = outlink->src; DecimateContext *dm = ctx->priv; const uint32_t eof_mask = 1<<INPUT_MAIN | dm->ppsrc<<INPUT_CLEANSRC; if ((dm->eof & eof_mask) == eof_mask) return AVERROR_EOF; if ((ret = request_inlink(ctx, INPUT_MAIN)) < 0) return ret; if (dm->ppsrc && (ret = request_inlink(ctx, INPUT_CLEANSRC)) < 0) return ret; return 0; }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.39986248560786075, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.25252937827156396, -0.4462861841111837, -0.21702784222394986, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static void fill_yuv_image(uint8_t *data[4], int linesize[4], int width, int height, int frame_index) { int x, y; for (y = 0; y < height; y++) for (x = 0; x < width; x++) data[0][y * linesize[0] + x] = x + y + frame_index * 3; for (y = 0; y < height / 2; y++) { for (x = 0; x < width / 2; x++) { data[1][y * linesize[1] + x] = 128 + y + frame_index * 2; data[2][y * linesize[2] + x] = 64 + x + frame_index * 5; } } }<SPLIT>[0.05563366039355449, -0.3507086565438968, 0.0, 0.037794879441717756, -0.406474384144713, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.3107937917392237, 0.061639525868012635, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, 0.04368374699580437, -0.4000063039086396, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.25252937827156396, -0.5591795518777907, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int asf_read_value(AVFormatContext *s, const uint8_t *name, uint16_t name_len, uint16_t val_len, int type, AVDictionary **met) { int ret; uint8_t *value; uint16_t buflen = 2 * val_len + 1; AVIOContext *pb = s->pb; value = av_malloc(buflen); if (!value) return AVERROR(ENOMEM); if (type == ASF_UNICODE) { if ((ret = get_asf_string(pb, val_len, value, buflen)) < 0) goto failed; if (av_dict_set(met, name, value, 0) < 0) av_log(s, AV_LOG_WARNING, "av_dict_set failed.\n"); } else { char buf[256]; if (val_len > sizeof(buf)) { ret = AVERROR_INVALIDDATA; goto failed; } if ((ret = avio_read(pb, value, val_len)) < 0) goto failed; if (ret < 2 * val_len) value[ret] = '\0'; else value[2 * val_len - 1] = '\0'; snprintf(buf, sizeof(buf), "%s", value); if (av_dict_set(met, name, buf, 0) < 0) av_log(s, AV_LOG_WARNING, "av_dict_set failed.\n"); } av_freep(&value); return 0; failed: av_freep(&value); return ret; }<SPLIT>[-0.09900860198293619, 0.15613299093387398, 0.0, -0.11436118199787926, 0.08293738398848315, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 1.040052222782594, 0.128741635009873, -0.09566541730555662, 0.18168277948578615, 0.0, 0.0, 0.30852482215402843, 0.060916844891778815, -0.11100716297398205, 0.10798473007086465, 0.6353133682363457, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, 0.4559046196532859, 0.4568607580216725, 0.6817979554923368, 0.33317037975964214, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 1.039626388904333, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 1.0350888753871217]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { SmartblurContext *s = ctx->priv; sws_freeContext(s->luma.filter_context); sws_freeContext(s->chroma.filter_context); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int writer_register(const Writer *writer) { static int next_registered_writer_idx = 0; if (next_registered_writer_idx == MAX_REGISTERED_WRITERS_NB) return AVERROR(ENOMEM); registered_writers[next_registered_writer_idx++] = writer; return 0; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold int xcbgrab_read_header(AVFormatContext *s) { XCBGrabContext *c = s->priv_data; int screen_num, ret; const xcb_setup_t *setup; char *display_name = av_strdup(s->filename); if (!display_name) return AVERROR(ENOMEM); if (!sscanf(s->filename, "%[^+]+%d,%d", display_name, &c->x, &c->y)) { *display_name = 0; sscanf(s->filename, "+%d,%d", &c->x, &c->y); } c->conn = xcb_connect(display_name[0] ? display_name : NULL, &screen_num); av_freep(&display_name); if ((ret = xcb_connection_has_error(c->conn))) { av_log(s, AV_LOG_ERROR, "Cannot open display %s, error %d.\n", s->filename[0] ? s->filename : "default", ret); return AVERROR(EIO); } setup = xcb_get_setup(c->conn); c->screen = get_screen(setup, screen_num); if (!c->screen) { av_log(s, AV_LOG_ERROR, "The screen %d does not exist.\n", screen_num); xcbgrab_read_close(s); return AVERROR(EIO); } ret = create_stream(s); if (ret < 0) { xcbgrab_read_close(s); return ret; } #if CONFIG_LIBXCB_SHM if ((c->has_shm = check_shm(c->conn))) c->segment = xcb_generate_id(c->conn); #endif #if CONFIG_LIBXCB_XFIXES if (c->draw_mouse) { if (!(c->draw_mouse = check_xfixes(c->conn))) { av_log(s, AV_LOG_WARNING, "XFixes not available, cannot draw the mouse.\n"); } if (c->bpp < 24) { avpriv_report_missing_feature(s, "%d bits per pixel screen", c->bpp); c->draw_mouse = 0; } } #endif if (c->show_region) setup_window(s); return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, 0.4233977444289674, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.3515211457698377, -0.26569807294376846, 0.08589816337610359, -0.917450412529964, -0.518115519420462, 0.0, 1.346753959403894, 2.1569430876889752, 0.18424725727220465, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>AVFrame *ff_null_get_video_buffer(AVFilterLink *link, int w, int h) { return ff_get_video_buffer(link->dst->outputs[0], w, h); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void set_clock_speed(Clock *c, double speed) { set_clock(c, get_clock(c), c->serial); c->speed = speed; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold int alac_encode_close(AVCodecContext *avctx) { AlacEncodeContext *s = avctx->priv_data; ff_lpc_end(&s->lpc_ctx); av_freep(&avctx->extradata); avctx->extradata_size = 0; return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void load_colormap(PaletteUseContext *s) { int i, nb_used = 0; uint8_t color_used[AVPALETTE_COUNT] = {0}; uint32_t last_color = 0; struct color_rect box; qsort(s->palette, AVPALETTE_COUNT, sizeof(*s->palette), cmp_pal_entry); for (i = 0; i < AVPALETTE_COUNT; i++) { const uint32_t c = s->palette[i]; if (i != 0 && c == last_color) { color_used[i] = 1; continue; } last_color = c; if ((c & 0xff000000) != 0xff000000) { color_used[i] = 1; continue; } } box.min[0] = box.min[1] = box.min[2] = 0x00; box.max[0] = box.max[1] = box.max[2] = 0xff; colormap_insert(s->map, color_used, &nb_used, s->palette, &box); if (s->dot_filename) disp_tree(s->map, s->dot_filename); if (s->debug_accuracy) { if (!debug_accuracy(s->map, s->palette, s->color_search_method)) av_log(NULL, AV_LOG_INFO, "Accuracy check passed\n"); } }<SPLIT>[-0.09900860198293619, -0.020159756014915854, 0.0, -0.11436118199787926, -0.08729279623175898, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.031089429262525795, -0.09566541730555662, -0.0006602620976677653, 0.0, 0.0, 0.30852482215402843, -0.09407211557651925, -0.11100716297398205, -0.06870780348722379, 0.24712242304476825, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.06167779621789984, -0.08904460951967552, 0.34396739025506545, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { DeshakeContext *deshake = ctx->priv; if (CONFIG_OPENCL && deshake->opencl) { ff_opencl_deshake_uninit(ctx); } av_frame_free(&deshake->ref); av_freep(&deshake->angles); deshake->angles_size = 0; if (deshake->fp) fclose(deshake->fp); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>void pp_free_mode(pp_mode *mode){ av_free(mode); }<SPLIT>[-0.25365086435942685, -0.5931111835984828, 0.0, -0.2665172434374763, -0.6405408819475459, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5705192711818717, -0.25297036047912586, -0.593275147243893, 0.0, 0.0, 0.30852482215402843, -0.6171598571570251, -0.26569807294376846, -0.6429585375510112, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int config_output(AVFilterLink *outlink) { outlink->w = outlink->h = 16; outlink->sample_aspect_ratio = av_make_q(1, 1); outlink->flags |= FF_LINK_FLAG_REQUEST_LOOP; return 0; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { AVFilterChannelLayouts *layouts; AVFilterFormats *formats; static const enum AVSampleFormat sample_fmts[] = { AV_SAMPLE_FMT_S32P, AV_SAMPLE_FMT_NONE }; int ret; layouts = ff_all_channel_layouts(); if (!layouts) return AVERROR(ENOMEM); ret = ff_set_common_channel_layouts(ctx, layouts); if (ret < 0) return ret; formats = ff_make_format_list(sample_fmts); if (!formats) return AVERROR(ENOMEM); ret = ff_set_common_formats(ctx, formats); if (ret < 0) return ret; formats = ff_all_samplerates(); if (!formats) return AVERROR(ENOMEM); return ff_set_common_samplerates(ctx, formats); }<SPLIT>[-0.25365086435942685, -0.10830612948931077, 0.0, -0.2665172434374763, -0.17240788634188003, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.13098384443277505, -0.25297036047912586, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, -0.26569807294376846, -0.157054070266268, 0.37651940477529405, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, 0.0744401592322129, 0.34396739025506545, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static void ebml_free(EbmlSyntax *syntax, void *data) { int i, j; for (i = 0; syntax[i].id; i++) { void *data_off = (char *) data + syntax[i].data_offset; switch (syntax[i].type) { case EBML_STR: case EBML_UTF8: av_freep(data_off); break; case EBML_BIN: av_freep(&((EbmlBin *) data_off)->data); break; case EBML_LEVEL1: case EBML_NEST: if (syntax[i].list_elem_size) { EbmlList *list = data_off; char *ptr = list->elem; for (j = 0; j < list->nb_elem; j++, ptr += syntax[i].list_elem_size) ebml_free(syntax[i].def.n, ptr); av_freep(&list->elem); } else ebml_free(syntax[i].def.n, data_off); default: break; } } }<SPLIT>[-0.25365086435942685, -0.020159756014915854, 0.0, -0.2665172434374763, -0.08729279623175898, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.051068312296575644, -0.25297036047912586, -0.0006602620976677653, 0.0, 0.0, 0.30852482215402843, -0.1134457356350565, -0.26569807294376846, -0.06870780348722379, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int reduce_formats_on_filter(AVFilterContext *filter) { int i, j, k, ret = 0; REDUCE_FORMATS(int, AVFilterFormats, formats, formats, nb_formats, ff_add_format); REDUCE_FORMATS(int, AVFilterFormats, samplerates, formats, nb_formats, ff_add_format); for (i = 0; i < filter->nb_inputs; i++) { AVFilterLink *inlink = filter->inputs[i]; uint64_t fmt; if (!inlink->out_channel_layouts || inlink->out_channel_layouts->nb_channel_layouts != 1) continue; fmt = inlink->out_channel_layouts->channel_layouts[0]; for (j = 0; j < filter->nb_outputs; j++) { AVFilterLink *outlink = filter->outputs[j]; AVFilterChannelLayouts *fmts; fmts = outlink->in_channel_layouts; if (inlink->type != outlink->type || fmts->nb_channel_layouts == 1) continue; if (fmts->all_layouts && (!FF_LAYOUT2COUNT(fmt) || fmts->all_counts)) { fmts->all_layouts = fmts->all_counts = 0; ff_add_channel_layout(&outlink->in_channel_layouts, fmt); break; } for (k = 0; k < outlink->in_channel_layouts->nb_channel_layouts; k++) { if (fmts->channel_layouts[k] == fmt) { fmts->channel_layouts[0] = fmt; fmts->nb_channel_layouts = 1; ret = 1; break; } } } } return ret; }<SPLIT>[0.05563366039355449, 0.1781695843024727, 0.0, 0.037794879441717756, 0.10421615651601342, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.1686994010779727, 0.061639525868012635, 0.2044756596837179, 0.0, 0.0, 0.30852482215402843, 0.09966408500885333, 0.04368374699580437, 0.1300712967656257, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.18424725727220465, -0.25252937827156396, 0.005287286955244392, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int alloc_picture(MpegEncContext *s, Picture *pic, int shared) { return ff_alloc_picture(s->avctx, pic, &s->me, &s->sc, shared, 1, s->chroma_x_shift, s->chroma_y_shift, s->out_format, s->mb_stride, s->mb_width, s->mb_height, s->b8_stride, &s->linesize, &s->uvlinesize); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int open_codec_context(int *stream_idx, AVFormatContext *fmt_ctx, enum AVMediaType type) { int ret; AVStream *st; AVCodecContext *dec_ctx = NULL; AVCodec *dec = NULL; AVDictionary *opts = NULL; ret = av_find_best_stream(fmt_ctx, type, -1, -1, NULL, 0); if (ret < 0) { fprintf(stderr, "Could not find %s stream in input file '%s'\n", av_get_media_type_string(type), src_filename); return ret; } else { *stream_idx = ret; st = fmt_ctx->streams[*stream_idx]; dec_ctx = st->codec; dec = avcodec_find_decoder(dec_ctx->codec_id); if (!dec) { fprintf(stderr, "Failed to find %s codec\n", av_get_media_type_string(type)); return AVERROR(EINVAL); } av_dict_set(&opts, "flags2", "+export_mvs", 0); if ((ret = avcodec_open2(dec_ctx, dec, &opts)) < 0) { fprintf(stderr, "Failed to open %s codec\n", av_get_media_type_string(type)); return ret; } } return 0; }<SPLIT>[0.05563366039355449, 0.04595002409088034, 0.0, 0.037794879441717756, -0.02345647864916818, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.380400859743741, 0.04882610287367361, 0.061639525868012635, 0.06771837849612745, 0.0, 0.0, 0.30852482215402843, -0.016577635342370212, 0.04368374699580437, -0.0024481034029406237, 0.37651940477529405, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.06167779621789984, 0.18343000506680518, 0.23107402248845843, -0.21702784222394986, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.3801362775450152, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.3766295797615486]
0<SPLIT>static int rm_read_header_old(AVFormatContext *s) { RMDemuxContext *rm = s->priv_data; AVStream *st; rm->old_format = 1; st = avformat_new_stream(s, NULL); if (!st) return -1; st->priv_data = ff_rm_alloc_rmstream(); if (!st->priv_data) return AVERROR(ENOMEM); return rm_read_audio_stream_info(s, s->pb, st, st->priv_data, 1); }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.3615192241061562, -0.3333928163445767, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static double ssim_db(double ssim, double weight) { return 10 * (log(weight) / log(10) - log(weight - ssim) / log(10)); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>const char *avfilter_configuration(void) { return FFMPEG_CONFIGURATION; }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int mxf_write_user_comments(AVFormatContext *s, const AVDictionary *m) { MXFContext *mxf = s->priv_data; AVDictionaryEntry *t = NULL; int count = 0; while ((t = av_dict_get(m, "comment_", t, AV_DICT_IGNORE_SUFFIX))) { if (mxf->tagged_value_count >= UINT16_MAX) { av_log(s, AV_LOG_ERROR, "too many tagged values, ignoring remaining\n"); return count; } if (mxf_write_tagged_value(s, t->key + 8, t->value) == 0) count++; } return count; }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void lumRangeFromJpeg_c(int16_t *dst, int width) { int i; for (i = 0; i < width; i++) dst[i] = (dst[i] * 14071 + 33561947) >> 14; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void packet_queue_start(PacketQueue *q) { SDL_LockMutex(q->mutex); q->abort_request = 0; packet_queue_put_private(q, &flush_pkt); SDL_UnlockMutex(q->mutex); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static uint64_t sse_line_16bit(const uint8_t *_main_line, const uint8_t *_ref_line, int outw) { int j; uint64_t m2 = 0; const uint16_t *main_line = (const uint16_t *) _main_line; const uint16_t *ref_line = (const uint16_t *) _ref_line; for (j = 0; j < outw; j++) m2 += pow2(main_line[j] - ref_line[j]); return m2; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.4705090699407485, -0.3333928163445767, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void inverse3x3(double im[3][3], const double m[3][3]) { double det = ma * (me * mi - mf * mh) - mb * (md * mi - mf * mg) + mc * (md * mh - me * mg); det = 1.0 / det; ima = det * (me * mi - mf * mh); imb = det * (mc * mh - mb * mi); imc = det * (mb * mf - mc * me); imd = det * (mf * mg - md * mi); ime = det * (ma * mi - mc * mg); imf = det * (mc * md - ma * mf); img = det * (md * mh - me * mg); imh = det * (mb * mg - ma * mh); imi = det * (ma * me - mb * md); }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.6586564490689124, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int asf_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags) { ASFContext *asf = s->priv_data; int idx, ret; if (s->streams[stream_index]->nb_index_entries && asf->is_simple_index) { idx = av_index_search_timestamp(s->streams[stream_index], timestamp, flags); if (idx < 0 || idx >= s->streams[stream_index]->nb_index_entries) return AVERROR_INVALIDDATA; avio_seek(s->pb, s->streams[stream_index]->index_entries[idx].pos, SEEK_SET); } else { if ((ret = ff_seek_frame_binary(s, stream_index, timestamp, flags)) < 0) return ret; } reset_packet_state(s); return 0; }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.011671540416283347, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.14353953243697165, -0.10760608081136262, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static inline int get_len(LZOContext *c, int x, int mask) { int cnt = x & mask; if (!cnt) { while (!(x = get_byte(c))) { if (cnt >= INT_MAX - 1000) { c->error |= AV_LZO_ERROR; break; } cnt += 255; } cnt += mask + x; } return cnt; }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.5292594673383866, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
1<SPLIT>static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { IVI5DecContext *ctx = avctx->priv_data; const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; int result, p, b; init_get_bits(&ctx->gb, buf, buf_size * 8); ctx->frame_data = buf; ctx->frame_size = buf_size; result = decode_pic_hdr(ctx, avctx); if (result) { av_log(avctx, AV_LOG_ERROR, "Error while decoding picture header: %d\n", result); return -1; } if (ctx->gop_flags & IVI5_IS_PROTECTED) { av_log(avctx, AV_LOG_ERROR, "Password-protected clip!\n"); return -1; } switch_buffers(ctx); if (ctx->frame_type != FRAMETYPE_NULL) { for (p = 0; p < 3; p++) { for (b = 0; b < ctx->planes[p].num_bands; b++) { result = decode_band(ctx, p, &ctx->planes[p].bands[b], avctx); if (result) { av_log(avctx, AV_LOG_ERROR, "Error while decoding band: %d, plane: %d\n", b, p); return -1; } } } } if (ctx->frame.data[0]) avctx->release_buffer(avctx, &ctx->frame); ctx->frame.reference = 0; if (avctx->get_buffer(avctx, &ctx->frame) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return -1; } if (ctx->is_scalable) { ff_ivi_recompose53 (&ctx->planes[0], ctx->frame.data[0], ctx->frame.linesize[0], 4); } else { ff_ivi_output_plane(&ctx->planes[0], ctx->frame.data[0], ctx->frame.linesize[0]); } ff_ivi_output_plane(&ctx->planes[2], ctx->frame.data[1], ctx->frame.linesize[1]); ff_ivi_output_plane(&ctx->planes[1], ctx->frame.data[2], ctx->frame.linesize[2]); *data_size = sizeof(AVFrame); *(AVFrame*)data = ctx->frame; return buf_size; }<SPLIT>[2.065983071287933, 0.4646452980942562, 0.0, 2.015823678156479, 0.38084019937390684, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 0.7102265412631674, 0.6881503599632689, 2.106603787124413, 0.5007831022568305, 0.0, 0.0, 0.30852482215402843, 0.603378206530822, 2.054665576603028, 0.4171966637975194, 0.6353133682363457, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3950401602637228, 0.6193893884051743, 0.5697541257882794, -0.21702784222394986, 0.6138826961206794, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 0.7098813332246741, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 0.7058592275743352]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { ZPContext *s = ctx->priv; sws_freeContext(s->sws); s->sws = NULL; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void xml_print_section_footer(WriterContext *wctx) { XMLContext *xml = wctx->priv; const struct section *section = wctx->section[wctx->level]; if (wctx->level == 0) { printf("</%sffprobe>\n", xml->fully_qualified ? "ffprobe:" : ""); } else if (xml->within_tag) { xml->within_tag = 0; printf("/>\n"); xml->indent_level--; } else if (section->flags & SECTION_FLAG_HAS_VARIABLE_FIELDS) { xml->indent_level--; } else { XML_INDENT(); printf("</%s>\n", section->name); xml->indent_level--; } }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.39986248560786075, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.1980344553542678, -0.3333928163445767, -0.21702784222394986, -0.04111270872174079, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static int config_props_out(AVFilterLink *link) { AVFilterContext *ctx = link->src; return config_props(ctx, link, 1); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int config_props(AVFilterLink *inlink) { FFTFILTContext *fftfilt = inlink->dst->priv; const AVPixFmtDescriptor *desc; int rdft_hbits, rdft_vbits, i, j, plane; double values[VAR_VARS_NB]; desc = av_pix_fmt_desc_get(inlink->format); for (i = 0; i < desc->nb_components; i++) { int w = inlink->w; int h = inlink->h; for (rdft_hbits = 1; 1 << rdft_hbits < w*10/9; rdft_hbits++); fftfilt->rdft_hbits[i] = rdft_hbits; fftfilt->rdft_hlen[i] = 1 << rdft_hbits; if (!(fftfilt->rdft_hdata[i] = av_malloc_array(h, fftfilt->rdft_hlen[i] * sizeof(FFTSample)))) return AVERROR(ENOMEM); for (rdft_vbits = 1; 1 << rdft_vbits < h*10/9; rdft_vbits++); fftfilt->rdft_vbits[i] = rdft_vbits; fftfilt->rdft_vlen[i] = 1 << rdft_vbits; if (!(fftfilt->rdft_vdata[i] = av_malloc_array(fftfilt->rdft_hlen[i], fftfilt->rdft_vlen[i] * sizeof(FFTSample)))) return AVERROR(ENOMEM); } values[VAR_W] = inlink->w; values[VAR_H] = inlink->h; for (plane = 0; plane < 3; plane++) { if(!(fftfilt->weight[plane] = av_malloc_array(fftfilt->rdft_hlen[plane], fftfilt->rdft_vlen[plane] * sizeof(double)))) return AVERROR(ENOMEM); for (i = 0; i < fftfilt->rdft_hlen[plane]; i++) { values[VAR_X] = i; for (j = 0; j < fftfilt->rdft_vlen[plane]; j++) { values[VAR_Y] = j; fftfilt->weight[plane][i * fftfilt->rdft_vlen[plane] + j] = av_expr_eval(fftfilt->weight_expr[plane], values, fftfilt); } } } return 0; }<SPLIT>[0.21027592277004517, 0.2222427710396702, 0.0, 0.18995094088131478, 0.14677370157107394, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.22863605018012226, 0.21894446904158188, 0.2500614200795814, 0.0, 0.0, 0.30852482215402843, 0.1577849451844651, 0.19837465696559078, 0.17424443015514782, 0.37651940477529405, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5004366117594818, 0.23792492798410134, 0.6826474935548865, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { static const enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUV410P, AV_PIX_FMT_YUV411P, AV_PIX_FMT_YUV440P, AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUVJ440P, AV_PIX_FMT_NONE }; AVFilterFormats *fmts_list = ff_make_format_list(pix_fmts); if (!fmts_list) return AVERROR(ENOMEM); return ff_set_common_formats(ctx, fmts_list); }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static inline void RENAME(deInterlaceInterpolateCubic)(uint8_t src[], int stride) { #if TEMPLATE_PP_SSE2 || TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW src+= stride*3; __asm__ volatile( "lea (%0, %1), %%"REG_a" \n\t" "lea (%%"REG_a", %1, 4), %%"REG_d" \n\t" "lea (%%"REG_d", %1, 4), %%"REG_c" \n\t" "add %1, %%"REG_c" \n\t" #if TEMPLATE_PP_SSE2 "pxor %%xmm7, %%xmm7 \n\t" #define REAL_DEINT_CUBIC(a,b,c,d,e)\ "movq " #a ", %%xmm0 \n\t"\ "movq " #b ", %%xmm1 \n\t"\ "movq " #d ", %%xmm2 \n\t"\ "movq " #e ", %%xmm3 \n\t"\ "pavgb %%xmm2, %%xmm1 \n\t"\ "pavgb %%xmm3, %%xmm0 \n\t"\ "punpcklbw %%xmm7, %%xmm0 \n\t"\ "punpcklbw %%xmm7, %%xmm1 \n\t"\ "psubw %%xmm1, %%xmm0 \n\t"\ "psraw $3, %%xmm0 \n\t"\ "psubw %%xmm0, %%xmm1 \n\t"\ "packuswb %%xmm1, %%xmm1 \n\t"\ "movlps %%xmm1, " #c " \n\t" #else "pxor %%mm7, %%mm7 \n\t" #define REAL_DEINT_CUBIC(a,b,c,d,e)\ "movq " #a ", %%mm0 \n\t"\ "movq " #b ", %%mm1 \n\t"\ "movq " #d ", %%mm2 \n\t"\ "movq " #e ", %%mm3 \n\t"\ PAVGB(%%mm2, %%mm1) \ PAVGB(%%mm3, %%mm0) \ "movq %%mm0, %%mm2 \n\t"\ "punpcklbw %%mm7, %%mm0 \n\t"\ "punpckhbw %%mm7, %%mm2 \n\t"\ "movq %%mm1, %%mm3 \n\t"\ "punpcklbw %%mm7, %%mm1 \n\t"\ "punpckhbw %%mm7, %%mm3 \n\t"\ "psubw %%mm1, %%mm0 \n\t" \ "psubw %%mm3, %%mm2 \n\t" \ "psraw $3, %%mm0 \n\t" \ "psraw $3, %%mm2 \n\t" \ "psubw %%mm0, %%mm1 \n\t" \ "psubw %%mm2, %%mm3 \n\t" \ "packuswb %%mm3, %%mm1 \n\t"\ "movq %%mm1, " #c " \n\t" #endif #define DEINT_CUBIC(a,b,c,d,e) REAL_DEINT_CUBIC(a,b,c,d,e) DEINT_CUBIC((%0) , (%%REGa, %1), (%%REGa, %1, 2), (%0, %1, 4) , (%%REGd, %1)) DEINT_CUBIC((%%REGa, %1), (%0, %1, 4) , (%%REGd) , (%%REGd, %1), (%0, %1, 8)) DEINT_CUBIC((%0, %1, 4) , (%%REGd, %1), (%%REGd, %1, 2), (%0, %1, 8) , (%%REGc)) DEINT_CUBIC((%%REGd, %1), (%0, %1, 8) , (%%REGd, %1, 4), (%%REGc) , (%%REGc, %1, 2)) : : "r" (src), "r" ((x86_reg)stride) : #if TEMPLATE_PP_SSE2 XMM_CLOBBERS("%xmm0", "%xmm1", "%xmm2", "%xmm3", "%xmm7",) #endif "%"REG_a, "%"REG_d, "%"REG_c ); #undef REAL_DEINT_CUBIC #else int x; src+= stride*3; for(x=0; x<8; x++){ src[stride*3] = av_clip_uint8((-src[0] + 9*src[stride*2] + 9*src[stride*4] - src[stride*6])>>4); src[stride*5] = av_clip_uint8((-src[stride*2] + 9*src[stride*4] + 9*src[stride*6] - src[stride*8])>>4); src[stride*7] = av_clip_uint8((-src[stride*4] + 9*src[stride*6] + 9*src[stride*8] - src[stride*10])>>4); src[stride*9] = av_clip_uint8((-src[stride*6] + 9*src[stride*8] + 9*src[stride*10] - src[stride*12])>>4); src++; } #endif }<SPLIT>[0.05563366039355449, 0.971486945572027, 0.0, 0.037794879441717756, 0.870251967507103, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.8879391903037673, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, 0.7971144071161946, -0.26569807294376846, -0.44417943729816173, -0.5292594673383866, -0.4084991676475909, 0.0, 6.638611218949581, 12.593180519939871, -0.30760284970800433, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void ff_rtsp_parse_line(RTSPMessageHeader *reply, const char *buf, RTSPState *rt, const char *method) { const char *p; p = buf; if (av_stristart(p, "Session:", &p)) { int t; get_word_sep(reply->session_id, sizeof(reply->session_id), ";", &p); if (av_stristart(p, ";timeout=", &p) && (t = strtol(p, NULL, 10)) > 0) { reply->timeout = t; } } else if (av_stristart(p, "Content-Length:", &p)) { reply->content_length = strtol(p, NULL, 10); } else if (av_stristart(p, "Transport:", &p)) { rtsp_parse_transport(reply, p); } else if (av_stristart(p, "CSeq:", &p)) { reply->seq = strtol(p, NULL, 10); } else if (av_stristart(p, "Range:", &p)) { rtsp_parse_range_npt(p, &reply->range_start, &reply->range_end); } else if (av_stristart(p, "RealChallenge1:", &p)) { p += strspn(p, SPACE_CHARS); av_strlcpy(reply->real_challenge, p, sizeof(reply->real_challenge)); } else if (av_stristart(p, "Server:", &p)) { p += strspn(p, SPACE_CHARS); av_strlcpy(reply->server, p, sizeof(reply->server)); } else if (av_stristart(p, "Notice:", &p) || av_stristart(p, "X-Notice:", &p)) { reply->notice = strtol(p, NULL, 10); } else if (av_stristart(p, "Location:", &p)) { p += strspn(p, SPACE_CHARS); av_strlcpy(reply->location, p , sizeof(reply->location)); } else if (av_stristart(p, "WWW-Authenticate:", &p) && rt) { p += strspn(p, SPACE_CHARS); ff_http_auth_handle_header(&rt->auth_state, "WWW-Authenticate", p); } else if (av_stristart(p, "Authentication-Info:", &p) && rt) { p += strspn(p, SPACE_CHARS); ff_http_auth_handle_header(&rt->auth_state, "Authentication-Info", p); } else if (av_stristart(p, "Content-Base:", &p) && rt) { p += strspn(p, SPACE_CHARS); if (method && !strcmp(method, "DESCRIBE")) av_strlcpy(rt->control_uri, p , sizeof(rt->control_uri)); } else if (av_stristart(p, "RTP-Info:", &p) && rt) { p += strspn(p, SPACE_CHARS); if (method && !strcmp(method, "PLAY")) rtsp_parse_rtp_info(rt, p); } else if (av_stristart(p, "Public:", &p) && rt) { if (strstr(p, "GET_PARAMETER") && method && !strcmp(method, "OPTIONS")) rt->get_parameter_supported = 1; } else if (av_stristart(p, "x-Accept-Dynamic-Rate:", &p) && rt) { p += strspn(p, SPACE_CHARS); rt->accept_dynamic_rate = atoi(p); } else if (av_stristart(p, "Content-Type:", &p)) { p += strspn(p, SPACE_CHARS); av_strlcpy(reply->content_type, p, sizeof(reply->content_type)); } }<SPLIT>[-0.09900860198293619, 0.6189014516744473, 0.0, -0.11436118199787926, 0.5297916070666188, 0.0, 2.5343063404056374, 2.5852965001195605, 2.564351494385993, -0.27925050329511203, 0.5482981787249199, -0.09566541730555662, 0.6603332636423527, 0.0, 0.0, 0.30852482215402843, 0.4677628661210612, -0.11100716297398205, 0.5718026306608468, 1.1529012951584487, 1.564595164264088, 0.0, -0.08645738172306322, -0.16222078614455715, 0.32477585926655006, 1.0553487717435432, 0.7955408613214935, -0.21702784222394986, 1.1753073288427536, 2.5333258501189415, 2.584454102899553, 2.5634043602755, -0.27935383381430245, 0.9056307075691036, 0.0, 2.5270915514781676, 2.5781833239947827, 2.556998178984592, -0.28182971586402455]
0<SPLIT>static void reset_packet_state(AVFormatContext *s) { ASFContext *asf = s->priv_data; int i; asf->state = PARSE_PACKET_HEADER; asf->offset = 0; asf->return_subpayload = 0; asf->sub_left = 0; asf->sub_header_offset = 0; asf->packet_offset = asf->first_packet_offset; asf->pad_len = 0; asf->rep_data_len = 0; asf->dts_delta = 0; asf->mult_sub_len = 0; asf->nb_mult_left = 0; asf->nb_sub = 0; asf->prop_flags = 0; asf->sub_dts = 0; for (i = 0; i < asf->nb_streams; i++) { ASFPacket *pkt = &asf->asf_st[i]->pkt; pkt->size_left = 0; pkt->data_size = 0; pkt->duration = 0; pkt->flags = 0; pkt->dts = 0; pkt->duration = 0; av_free_packet(&pkt->avpkt); av_init_packet(&pkt->avpkt); } }<SPLIT>[-0.25365086435942685, 0.0018768373536828752, 0.0, -0.2665172434374763, -0.06601402370422871, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.031089429262525795, -0.25297036047912586, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, -0.09407211557651925, -0.26569807294376846, -0.04662123679246273, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2545115582693773, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int mov_write_rtp_tag(AVIOContext *pb, MOVTrack *track) { int64_t pos = avio_tell(pb); avio_wb32(pb, 0); ffio_wfourcc(pb, "rtp "); avio_wb32(pb, 0); avio_wb16(pb, 0); avio_wb16(pb, 1); avio_wb16(pb, 1); avio_wb16(pb, 1); avio_wb32(pb, track->max_packet_size); avio_wb32(pb, 12); ffio_wfourcc(pb, "tims"); avio_wb32(pb, track->timescale); return update_size(pb, pos); }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.4705090699407485, -0.3333928163445767, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void RENAME(yuv2yuyv422_1)(SwsContext *c, const int16_t *buf0, const int16_t *ubuf[2], const int16_t *vbuf[2], const int16_t *abuf0, uint8_t *dest, int dstW, int uvalpha, int y) { const int16_t *ubuf0 = ubuf[0]; const int16_t *buf1= buf0; if (uvalpha < 2048) { const int16_t *ubuf1 = ubuf[0]; __asm__ volatile( "mov %%"REG_b", "ESP_OFFSET"(%5) \n\t" "mov %4, %%"REG_b" \n\t" "push %%"REG_BP" \n\t" YSCALEYUV2PACKED1(%%REGBP, %5) WRITEYUY2(%%REGb, DSTW_OFFSET"(%5)", %%REGBP) "pop %%"REG_BP" \n\t" "mov "ESP_OFFSET"(%5), %%"REG_b" \n\t" :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest), "a" (&c->redDither) ); } else { const int16_t *ubuf1 = ubuf[1]; __asm__ volatile( "mov %%"REG_b", "ESP_OFFSET"(%5) \n\t" "mov %4, %%"REG_b" \n\t" "push %%"REG_BP" \n\t" YSCALEYUV2PACKED1b(%%REGBP, %5) WRITEYUY2(%%REGb, DSTW_OFFSET"(%5)", %%REGBP) "pop %%"REG_BP" \n\t" "mov "ESP_OFFSET"(%5), %%"REG_b" \n\t" :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest), "a" (&c->redDither) ); } }<SPLIT>[-0.25365086435942685, 0.11205980419667652, 0.0, -0.2665172434374763, 0.04037983893342262, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.06880498590772346, -0.25297036047912586, 0.13609701908992267, 0.0, 0.0, 0.30852482215402843, 0.0027959847161670454, -0.26569807294376846, 0.06381159668134254, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { AResampleContext *aresample = ctx->priv; swr_free(&aresample->swr); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int filter_slice(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs) { TransContext *trans = ctx->priv; ThreadData *td = arg; AVFrame *out = td->out; AVFrame *in = td->in; int plane; for (plane = 0; out->data[plane]; plane++) { int hsub = plane == 1 || plane == 2 ? trans->hsub : 0; int vsub = plane == 1 || plane == 2 ? trans->vsub : 0; int pixstep = trans->pixsteps[plane]; int inh = FF_CEIL_RSHIFT(in->height, vsub); int outw = FF_CEIL_RSHIFT(out->width, hsub); int outh = FF_CEIL_RSHIFT(out->height, vsub); int start = (outh * jobnr ) / nb_jobs; int end = (outh * (jobnr+1)) / nb_jobs; uint8_t *dst, *src; int dstlinesize, srclinesize; int x, y; dstlinesize = out->linesize[plane]; dst = out->data[plane] + start * dstlinesize; src = in->data[plane]; srclinesize = in->linesize[plane]; if (trans->dir & 1) { src += in->linesize[plane] * (inh - 1); srclinesize *= -1; } if (trans->dir & 2) { dst = out->data[plane] + dstlinesize * (outh - start - 1); dstlinesize *= -1; } switch (pixstep) { case 1: for (y = start; y < end; y++, dst += dstlinesize) for (x = 0; x < outw; x++) dst[x] = src[x * srclinesize + y]; break; case 2: for (y = start; y < end; y++, dst += dstlinesize) { for (x = 0; x < outw; x++) *((uint16_t *)(dst + 2 * x)) = *((uint16_t *)(src + x * srclinesize + y * 2)); } break; case 3: for (y = start; y < end; y++, dst += dstlinesize) { for (x = 0; x < outw; x++) { int32_t v = AV_RB24(src + x * srclinesize + y * 3); AV_WB24(dst + 3 * x, v); } } break; case 4: for (y = start; y < end; y++, dst += dstlinesize) { for (x = 0; x < outw; x++) *((uint32_t *)(dst + 4 * x)) = *((uint32_t *)(src + x * srclinesize + y * 4)); } break; case 6: for (y = start; y < end; y++, dst += dstlinesize) { for (x = 0; x < outw; x++) { int64_t v = AV_RB48(src + x * srclinesize + y*6); AV_WB48(dst + 6*x, v); } } break; case 8: for (y = start; y < end; y++, dst += dstlinesize) { for (x = 0; x < outw; x++) *((uint64_t *)(dst + 8*x)) = *((uint64_t *)(src + x * srclinesize + y*8)); } break; } } return 0; }<SPLIT>[-0.25365086435942685, 1.059633319046422, 0.0, -0.2665172434374763, 0.9553670576172241, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.9278969563718671, -0.25297036047912586, 1.1161908676009875, 0.0, 0.0, 0.30852482215402843, 0.8358616472332691, -0.26569807294376846, 1.013533964556068, 1.0235043134279231, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 1.5895332772156587, 0.23792492798410134, 1.0213275968547075, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int show_hwaccels(void *optctx, const char *opt, const char *arg) { int i; printf("Hardware acceleration methods:\n"); for (i = 0; hwaccels[i].name; i++) { printf("%s\n", hwaccels[i].name); } printf("\n"); return 0; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static uint32_t av_get_random_seed_deterministic(void) { return randomv = randomv * 1664525 + 1013904223; }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int ff_fbdev_get_device_list(AVDeviceInfoList *device_list) { struct fb_var_screeninfo varinfo; struct fb_fix_screeninfo fixinfo; char device_file[12]; AVDeviceInfo *device = NULL; int i, fd, ret = 0; const char *default_device = ff_fbdev_default_device(); if (!device_list) return AVERROR(EINVAL); for (i = 0; i <= 31; i++) { snprintf(device_file, sizeof(device_file), "/dev/fb%d", i); if ((fd = avpriv_open(device_file, O_RDWR)) < 0) { int err = AVERROR(errno); if (err != AVERROR(ENOENT)) av_log(NULL, AV_LOG_ERROR, "Could not open framebuffer device '%s': %s\n", device_file, av_err2str(err)); continue; } if (ioctl(fd, FBIOGET_VSCREENINFO, &varinfo) == -1) goto fail_device; if (ioctl(fd, FBIOGET_FSCREENINFO, &fixinfo) == -1) goto fail_device; device = av_mallocz(sizeof(AVDeviceInfo)); if (!device) { ret = AVERROR(ENOMEM); goto fail_device; } device->device_name = av_strdup(device_file); device->device_description = av_strdup(fixinfo.id); if (!device->device_name || !device->device_description) { ret = AVERROR(ENOMEM); goto fail_device; } if ((ret = av_dynarray_add_nofree(&device_list->devices, &device_list->nb_devices, device)) < 0) goto fail_device; if (default_device && !strcmp(device->device_name, default_device)) { device_list->default_device = device_list->nb_devices - 1; default_device = NULL; } close(fd); continue; fail_device: if (device) { av_freep(&device->device_name); av_freep(&device->device_description); av_freep(&device); } if (fd >= 0) close(fd); if (ret < 0) return ret; } return 0; }<SPLIT>[-0.25365086435942685, 0.5748282649372498, 0.0, -0.2665172434374763, 0.48723406201155817, 0.0, 1.49154691857982, 1.5248365532563304, 1.403457588528521, 2.3593549488603003, 0.48836152962277035, -0.25297036047912586, 0.6147475032464892, 0.0, 0.0, 0.30852482215402843, 0.40964200594544947, -0.26569807294376846, 0.5276294972713247, 1.5410922403500262, 1.564595164264088, 0.0, -0.08645738172306322, -0.16222078614455715, 0.4653044612608955, 1.9817624613375777, 1.9244745389875635, -0.21702784222394986, 1.8303027336851738, 1.4908334503424332, 1.524213968415457, 1.4027960089845035, 2.3586066116229683, 0.9056307075691036, 0.0, 1.4859135779729586, 1.519259814762923, 1.3979248575624994, 2.352007466638268]
0<SPLIT>static int handle_server_bw(URLContext *s, RTMPPacket *pkt) { RTMPContext *rt = s->priv_data; if (pkt->size < 4) { av_log(s, AV_LOG_ERROR, "Too short server bandwidth report packet (%d)\n", pkt->size); return AVERROR_INVALIDDATA; } rt->server_bw = AV_RB32(pkt->data); if (rt->server_bw <= 0) { av_log(s, AV_LOG_ERROR, "Incorrect server bandwidth %d\n", rt->server_bw); return AVERROR_INVALIDDATA; } av_log(s, AV_LOG_DEBUG, "Server bandwidth = %d\n", rt->server_bw); return 0; }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int decide_frame_length(PullupContext *s) { PullupField *f0 = s->first; PullupField *f1 = f0->next; PullupField *f2 = f1->next; PullupField *f; int i, l, n; if (queue_length(s->first, s->last) < 4) return 0; f = s->first; n = queue_length(f, s->last); for (i = 0; i < n - 1; i++) { if (i < n - 3) compute_breaks(s, f); compute_affinity(s, f); f = f->next; } if (f0->affinity == -1) return 1; l = find_first_break(f0, 3); if (l == 1 && s->strict_breaks < 0) l = 0; switch (l) { case 1: return 1 + (s->strict_breaks < 1 && f0->affinity == 1 && f1->affinity == -1); case 2: if (s->strict_pairs && (f0->prev->breaks & BREAK_RIGHT) && (f2->breaks & BREAK_LEFT) && (f0->affinity != 1 || f1->affinity != -1) ) return 1; return 1 + (f1->affinity != 1); case 3: return 2 + (f2->affinity != 1); default: if (f1->affinity == 1) return 1; else if (f1->affinity == -1) return 2; else if (f2->affinity == -1) { return (f0->affinity == 1) ? 3 : 1; } else { return 2; } } }<SPLIT>[0.05563366039355449, 0.33242573788266383, 0.0, 0.037794879441717756, 0.25316756420872527, 0.0, 1.49154691857982, 1.1713499043019204, 1.403457588528521, 2.689180630379727, 0.3085515823163217, 0.061639525868012635, 0.3640258210692401, 0.0, 0.0, 0.30852482215402843, 0.23527942541861413, 0.04368374699580437, 0.28467726362895307, -0.14106852214680915, 1.3453624607183459, 0.0, -0.08645738172306322, -0.16222078614455715, 0.14911510677361828, 1.0008538488262473, 0.005287286955244392, 1.5806237532086234, 1.5495904173241366, 1.4908334503424332, 1.1708005902540914, 1.4027960089845035, 2.6883516673026273, 0.9056307075691036, 0.0, 1.4859135779729586, 1.1662853116856364, 1.3979248575624994, 2.6812371144510547]
0<SPLIT>static void show_codec_opts(void) { printf("@section Codec AVOptions\n"); show_opts(avcodec_options, 1); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int filter_slice_alpha(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs) { FadeContext *s = ctx->priv; AVFrame *frame = arg; int plane = s->is_packed_rgb ? 0 : A; int slice_start = (frame->height * jobnr ) / nb_jobs; int slice_end = (frame->height * (jobnr+1)) / nb_jobs; int i, j; for (i = slice_start; i < slice_end; i++) { uint8_t *p = frame->data[plane] + i * frame->linesize[plane] + s->is_packed_rgb*s->rgba_map[A]; int step = s->is_packed_rgb ? 4 : 1; for (j = 0; j < frame->width; j++) { *p = ((*p - s->black_level) * s->factor + s->black_level_scaled) >> 16; p += step; } } return 0; }<SPLIT>[0.21027592277004517, -0.24052568970090316, 0.0, 0.18995094088131478, -0.30008052150706166, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1909204935349246, 0.21894446904158188, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, 0.19837465696559078, -0.28957347043483433, -0.011671540416283347, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, -0.14353953243697165, -0.10760608081136262, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void build_elision_headers(AVFormatContext *s) { NUTContext *nut = s->priv_data; int i; static const uint8_t headers[][5] = { { 3, 0x00, 0x00, 0x01 }, { 4, 0x00, 0x00, 0x01, 0xB6}, { 2, 0xFF, 0xFA }, { 2, 0xFF, 0xFB }, { 2, 0xFF, 0xFC }, { 2, 0xFF, 0xFD }, }; nut->header_count = 7; for (i = 1; i < nut->header_count; i++) { nut->header_len[i] = headers[i - 1][0]; nut->header[i] = &headers[i - 1][1]; } }<SPLIT>[0.05563366039355449, -0.2625622830695019, 0.0, 0.037794879441717756, -0.3213592940345919, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.2308782596030243, 0.061639525868012635, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, 0.04368374699580437, -0.3116600371295954, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void print_codecs_for_id(enum AVCodecID id, int encoder) { const AVCodec *codec = NULL; printf(" (%s: ", encoder ? "encoders" : "decoders"); while ((codec = next_codec_for_id(id, codec, encoder))) printf("%s ", codec->name); printf(")"); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.3615192241061562, -0.3333928163445767, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, -0.8078451799057511, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void map_idx_10_to_20(int8_t *par_mapped, const int8_t *par, int full) { int b; if (full) b = 9; else { b = 4; par_mapped[10] = 0; } for (; b >= 0; b--) { par_mapped[2*b+1] = par_mapped[2*b] = par[b]; } }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.6586564490689124, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.3070243011888601, -0.6720729196443977, 0.6817979554923368, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int pulse_set_pause(PulseData *s, int pause) { pa_operation *op; pa_threaded_mainloop_lock(s->mainloop); op = pa_stream_cork(s->stream, pause, pulse_stream_result, s); return pulse_finish_stream_operation(s, op, "pa_stream_cork"); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g) { ASFContext *asf = s->priv_data; AVIOContext *pb = s->pb; uint64_t size = avio_rl64(pb); int ret; if (asf->is_header) asf->unknown_size = size; asf->is_header = 0; if (!g->is_subobject) { if (!(ret = strcmp(g->name, "Header Extension"))) avio_skip(pb, 22); if ((ret = detect_unknown_subobject(s, asf->unknown_offset, asf->unknown_size)) < 0) return ret; } else avio_skip(pb, size - 24); return 0; }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, -0.270465503877335, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.1980344553542678, -0.3333928163445767, 0.6817979554923368, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int lockmgr(void **mtx, enum AVLockOp op) { switch(op) { case AV_LOCK_CREATE: *mtx = SDL_CreateMutex(); if(!*mtx) { av_log(NULL, AV_LOG_FATAL, "SDL_CreateMutex(): %s\n", SDL_GetError()); return 1; } return 0; case AV_LOCK_OBTAIN: return !!SDL_LockMutex(*mtx); case AV_LOCK_RELEASE: return !!SDL_UnlockMutex(*mtx); case AV_LOCK_DESTROY: SDL_DestroyMutex(*mtx); return 0; } return 1; }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, 0.380400859743741, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.14106852214680915, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, 0.23792492798410134, 0.005287286955244392, -0.21702784222394986, 0.42674115187998785, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, 0.3801362775450152, 0.9056307075691036, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, 0.3766295797615486]
0<SPLIT>const char *avutil_configuration(void) { return FFMPEG_CONFIGURATION; }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int create_subcc_streams(AVFormatContext *avctx) { LavfiContext *lavfi = avctx->priv_data; AVStream *st; int stream_idx, sink_idx; for (stream_idx = 0; stream_idx < lavfi->nb_sinks; stream_idx++) { sink_idx = lavfi->stream_sink_map[stream_idx]; if (lavfi->sink_stream_subcc_map[sink_idx]) { lavfi->sink_stream_subcc_map[sink_idx] = avctx->nb_streams; if (!(st = avformat_new_stream(avctx, NULL))) return AVERROR(ENOMEM); st->codec->codec_id = AV_CODEC_ID_EIA_608; st->codec->codec_type = AVMEDIA_TYPE_SUBTITLE; } else { lavfi->sink_stream_subcc_map[sink_idx] = -1; } } return 0; }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int encode_audio_frame(AVFrame *frame, AVFormatContext *output_format_context, AVCodecContext *output_codec_context, int *data_present) { AVPacket output_packet; int error; init_packet(&output_packet); if (frame) { frame->pts = pts; pts += frame->nb_samples; } if ((error = avcodec_encode_audio2(output_codec_context, &output_packet, frame, data_present)) < 0) { fprintf(stderr, "Could not encode frame (error '%s')\n", get_error_text(error)); av_free_packet(&output_packet); return error; } if (*data_present) { if ((error = av_write_frame(output_format_context, &output_packet)) < 0) { fprintf(stderr, "Could not write frame (error '%s')\n", get_error_text(error)); av_free_packet(&output_packet); return error; } av_free_packet(&output_packet); } return 0; }<SPLIT>[0.8288449722760078, 0.0018768373536828752, 0.0, 0.798575186639703, -0.06601402370422871, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 0.7102265412631674, 0.10876275197582316, 0.8481642417358589, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, 0.04154322483324156, 0.8171382968447365, -0.04662123679246273, 0.5059163865058198, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, 0.29241985090139744, 0.005287286955244392, -0.21702784222394986, 0.5203119240003335, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 0.7098813332246741, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 0.7058592275743352]
0<SPLIT>int av_opt_set_double(void *obj, const char *name, double val, int search_flags) { return set_number(obj, name, val, 1, 1, search_flags); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void inflate(uint8_t *dst, const uint8_t *p1, int width, int threshold, const uint8_t *coordinates[], int coord) { int x, i; for (x = 0; x < width; x++) { int sum = 0; int limit = FFMIN(p1[x] + threshold, 255); for (i = 0; i < 8; sum += *(coordinates[i++] + x)); dst[x] = FFMIN(FFMAX(sum / 8, p1[x]), limit); } }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.14106852214680915, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, 0.01994523631491676, -0.10760608081136262, 1.5806237532086234, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int compute_datarate(DataRateData *drd, int64_t count) { if (cur_time == drd->time1) return 0; return ((count - drd->count1) * 1000) / (cur_time - drd->time1); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.7880534307994381, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.7849662874110047, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static double drand(void *opaque, double min, double max) { return min + (max-min) / UINT_MAX * av_lfg_get(opaque); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *in) { AVFilterContext *ctx = inlink->dst; AVFilterLink *outlink = ctx->outputs[0]; ZPContext *s = ctx->priv; double var_values[VARS_NB], nb_frames, zoom, dx, dy; const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(in->format); AVFrame *out = NULL; int i, k, x, y, w, h, ret = 0; var_values[VAR_IN_W] = var_values[VAR_IW] = in->width; var_values[VAR_IN_H] = var_values[VAR_IH] = in->height; var_values[VAR_OUT_W] = var_values[VAR_OW] = s->w; var_values[VAR_OUT_H] = var_values[VAR_OH] = s->h; var_values[VAR_IN] = inlink->frame_count + 1; var_values[VAR_ON] = outlink->frame_count + 1; var_values[VAR_PX] = s->x; var_values[VAR_PY] = s->y; var_values[VAR_X] = 0; var_values[VAR_Y] = 0; var_values[VAR_PZOOM] = s->prev_zoom; var_values[VAR_ZOOM] = 1; var_values[VAR_PDURATION] = s->prev_nb_frames; var_values[VAR_A] = (double) in->width / in->height; var_values[VAR_SAR] = inlink->sample_aspect_ratio.num ? (double) inlink->sample_aspect_ratio.num / inlink->sample_aspect_ratio.den : 1; var_values[VAR_DAR] = var_values[VAR_A] * var_values[VAR_SAR]; var_values[VAR_HSUB] = 1 << desc->log2_chroma_w; var_values[VAR_VSUB] = 1 << desc->log2_chroma_h; if ((ret = av_expr_parse_and_eval(&nb_frames, s->duration_expr_str, var_names, var_values, NULL, NULL, NULL, NULL, NULL, 0, ctx)) < 0) goto fail; var_values[VAR_DURATION] = nb_frames; for (i = 0; i < nb_frames; i++) { int px[4]; int py[4]; uint8_t *input[4]; int64_t pts = av_rescale_q(in->pts, inlink->time_base, outlink->time_base) + s->frame_count; var_values[VAR_TIME] = pts * av_q2d(outlink->time_base); var_values[VAR_FRAME] = i; var_values[VAR_ON] = outlink->frame_count + 1; if ((ret = av_expr_parse_and_eval(&zoom, s->zoom_expr_str, var_names, var_values, NULL, NULL, NULL, NULL, NULL, 0, ctx)) < 0) goto fail; zoom = av_clipd(zoom, 1, 10); var_values[VAR_ZOOM] = zoom; w = in->width * (1.0 / zoom); h = in->height * (1.0 / zoom); if ((ret = av_expr_parse_and_eval(&dx, s->x_expr_str, var_names, var_values, NULL, NULL, NULL, NULL, NULL, 0, ctx)) < 0) goto fail; x = dx = av_clipd(dx, 0, FFMAX(in->width - w, 0)); var_values[VAR_X] = dx; x &= ~((1 << desc->log2_chroma_w) - 1); if ((ret = av_expr_parse_and_eval(&dy, s->y_expr_str, var_names, var_values, NULL, NULL, NULL, NULL, NULL, 0, ctx)) < 0) goto fail; y = dy = av_clipd(dy, 0, FFMAX(in->height - h, 0)); var_values[VAR_Y] = dy; y &= ~((1 << desc->log2_chroma_h) - 1); out = ff_get_video_buffer(outlink, outlink->w, outlink->h); if (!out) { ret = AVERROR(ENOMEM); goto fail; } px[1] = px[2] = FF_CEIL_RSHIFT(x, desc->log2_chroma_w); px[0] = px[3] = x; py[1] = py[2] = FF_CEIL_RSHIFT(y, desc->log2_chroma_h); py[0] = py[3] = y; s->sws = sws_alloc_context(); if (!s->sws) { ret = AVERROR(ENOMEM); goto fail; } for (k = 0; in->data[k]; k++) input[k] = in->data[k] + py[k] * in->linesize[k] + px[k]; av_opt_set_int(s->sws, "srcw", w, 0); av_opt_set_int(s->sws, "srch", h, 0); av_opt_set_int(s->sws, "src_format", in->format, 0); av_opt_set_int(s->sws, "dstw", outlink->w, 0); av_opt_set_int(s->sws, "dsth", outlink->h, 0); av_opt_set_int(s->sws, "dst_format", outlink->format, 0); av_opt_set_int(s->sws, "sws_flags", SWS_BICUBIC, 0); if ((ret = sws_init_context(s->sws, NULL, NULL)) < 0) goto fail; sws_scale(s->sws, (const uint8_t *const *)&input, in->linesize, 0, h, out->data, out->linesize); out->pts = pts; s->frame_count++; ret = ff_filter_frame(outlink, out); if (ret < 0) break; out = NULL; sws_freeContext(s->sws); s->sws = NULL; } s->x = dx; s->y = dy; s->prev_zoom = zoom; s->prev_nb_frames = nb_frames; fail: sws_freeContext(s->sws); s->sws = NULL; av_frame_free(&out); av_frame_free(&in); return ret; }<SPLIT>[-0.25365086435942685, 1.764804306841581, 0.0, -0.2665172434374763, 1.6362877784981926, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 1.5672212134614623, -0.25297036047912586, 1.8455630339348033, 0.0, 0.0, 0.30852482215402843, 1.4558174891064615, -0.26569807294376846, 1.7203040987884217, 1.670489222080552, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, 2.3624405881845587, 1.0008538488262473, 2.2631546422873847, 0.6817979554923368, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static double get_natural_factor(const VignetteContext *s, int x, int y) { const int xx = (x - s->x0) * s->xscale; const int yy = (y - s->y0) * s->yscale; const double dnorm = hypot(xx, yy) / s->dmax; if (dnorm > 1) { return 0; } else { const double c = cos(s->angle * dnorm); return (c*c)*(c*c); } }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.270465503877335, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.1980344553542678, -0.10760608081136262, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int ff_sample_fmt_is_planar(enum AVSampleFormat sample_fmt, int channels) { if (channels == 1) return 1; else return av_sample_fmt_is_planar(sample_fmt); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void aacsbr_func_ptr_init(AACSBRContext *c) { c->sbr_lf_gen = sbr_lf_gen; c->sbr_hf_assemble = sbr_hf_assemble; c->sbr_x_gen = sbr_x_gen; c->sbr_hf_inverse_filter = sbr_hf_inverse_filter; #if !USE_FIXED if(ARCH_MIPS) ff_aacsbr_func_ptr_init_mips(c); #endif }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.5104391373824448, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, 0.9973611507722091, -0.5183957526995224, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_always_inline int set_frame(PaletteUseContext *s, AVFrame *out, AVFrame *in, int x_start, int y_start, int w, int h, enum dithering_mode dither, const enum color_search_method search_method) { int x, y; const struct color_node *map = s->map; struct cache_node *cache = s->cache; const uint32_t *palette = s->palette; const int src_linesize = in ->linesize[0] >> 2; const int dst_linesize = out->linesize[0]; uint32_t *src = ((uint32_t *)in ->data[0]) + y_start*src_linesize; uint8_t *dst = out->data[0] + y_start*dst_linesize; w += x_start; h += y_start; for (y = y_start; y < h; y++) { for (x = x_start; x < w; x++) { int er, eg, eb; if (dither == DITHERING_BAYER) { const int d = s->ordered_dither[(y & 7)<<3 | (x & 7)]; const uint8_t r8 = src[x] >> 16 & 0xff; const uint8_t g8 = src[x] >> 8 & 0xff; const uint8_t b8 = src[x] & 0xff; const uint8_t r = av_clip_uint8(r8 + d); const uint8_t g = av_clip_uint8(g8 + d); const uint8_t b = av_clip_uint8(b8 + d); const uint32_t c = r<<16 | g<<8 | b; const int color = color_get(cache, c, r, g, b, map, palette, search_method); if (color < 0) return color; dst[x] = color; } else if (dither == DITHERING_HECKBERT) { const int right = x < w - 1, down = y < h - 1; const int color = get_dst_color_err(cache, src[x], map, palette, &er, &eg, &eb, search_method); if (color < 0) return color; dst[x] = color; if (right) src[ x + 1] = dither_color(src[ x + 1], er, eg, eb, 3, 3); if ( down) src[src_linesize + x ] = dither_color(src[src_linesize + x ], er, eg, eb, 3, 3); if (right && down) src[src_linesize + x + 1] = dither_color(src[src_linesize + x + 1], er, eg, eb, 2, 3); } else if (dither == DITHERING_FLOYD_STEINBERG) { const int right = x < w - 1, down = y < h - 1, left = x > x_start; const int color = get_dst_color_err(cache, src[x], map, palette, &er, &eg, &eb, search_method); if (color < 0) return color; dst[x] = color; if (right) src[ x + 1] = dither_color(src[ x + 1], er, eg, eb, 7, 4); if (left && down) src[src_linesize + x - 1] = dither_color(src[src_linesize + x - 1], er, eg, eb, 3, 4); if ( down) src[src_linesize + x ] = dither_color(src[src_linesize + x ], er, eg, eb, 5, 4); if (right && down) src[src_linesize + x + 1] = dither_color(src[src_linesize + x + 1], er, eg, eb, 1, 4); } else if (dither == DITHERING_SIERRA2) { const int right = x < w - 1, down = y < h - 1, left = x > x_start; const int right2 = x < w - 2, left2 = x > x_start + 1; const int color = get_dst_color_err(cache, src[x], map, palette, &er, &eg, &eb, search_method); if (color < 0) return color; dst[x] = color; if (right) src[ x + 1] = dither_color(src[ x + 1], er, eg, eb, 4, 4); if (right2) src[ x + 2] = dither_color(src[ x + 2], er, eg, eb, 3, 4); if (down) { if (left2) src[ src_linesize + x - 2] = dither_color(src[ src_linesize + x - 2], er, eg, eb, 1, 4); if (left) src[ src_linesize + x - 1] = dither_color(src[ src_linesize + x - 1], er, eg, eb, 2, 4); src[ src_linesize + x ] = dither_color(src[ src_linesize + x ], er, eg, eb, 3, 4); if (right) src[ src_linesize + x + 1] = dither_color(src[ src_linesize + x + 1], er, eg, eb, 2, 4); if (right2) src[ src_linesize + x + 2] = dither_color(src[ src_linesize + x + 2], er, eg, eb, 1, 4); } } else if (dither == DITHERING_SIERRA2_4A) { const int right = x < w - 1, down = y < h - 1, left = x > x_start; const int color = get_dst_color_err(cache, src[x], map, palette, &er, &eg, &eb, search_method); if (color < 0) return color; dst[x] = color; if (right) src[ x + 1] = dither_color(src[ x + 1], er, eg, eb, 2, 2); if (left && down) src[src_linesize + x - 1] = dither_color(src[src_linesize + x - 1], er, eg, eb, 1, 2); if ( down) src[src_linesize + x ] = dither_color(src[src_linesize + x ], er, eg, eb, 1, 2); } else { const uint8_t r = src[x] >> 16 & 0xff; const uint8_t g = src[x] >> 8 & 0xff; const uint8_t b = src[x] & 0xff; const int color = color_get(cache, src[x] & 0xffffff, r, g, b, map, palette, search_method); if (color < 0) return color; dst[x] = color; } } src += src_linesize; dst += dst_linesize; } return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, 1.2107123279475873, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 1.0683450879357161, -0.26569807294376846, 1.2785727648932006, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 1.7300618792100042, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static uint32_t MDS_mul(AVTWOFISH *cs, uint32_t X) { return cs->MDS1[(X) & 0xff] ^ cs->MDS2[((X) >> 8) & 0xff] ^ cs->MDS3[((X) >> 16) & 0xff] ^ cs->MDS4[(X) >> 24]; }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void envelope_instant(VectorscopeContext *s, AVFrame *out) { const int dlinesize = out->linesize[0]; uint8_t *dpd = s->mode == COLOR || !s->is_yuv ? out->data[s->pd] : out->data[0]; int i, j; for (i = 0; i < out->height; i++) { for (j = 0; j < out->width; j++) { const int pos = i * dlinesize + j; const int poa = (i - 1) * dlinesize + j; const int pob = (i + 1) * dlinesize + j; if (dpd[pos] && (((!j || !dpd[pos - 1]) || ((j == (out->width - 1)) || !dpd[pos + 1])) || ((!i || !dpd[poa]) || ((i == (out->height - 1)) || !dpd[pob])))) { dpd[pos] = 255; } } } }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.14106852214680915, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.3615192241061562, -0.10760608081136262, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int geq_query_formats(AVFilterContext *ctx) { GEQContext *geq = ctx->priv; static const enum AVPixelFormat yuv_pix_fmts[] = { AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV411P, AV_PIX_FMT_YUV410P, AV_PIX_FMT_YUV440P, AV_PIX_FMT_YUVA444P, AV_PIX_FMT_YUVA422P, AV_PIX_FMT_YUVA420P, AV_PIX_FMT_GRAY8, AV_PIX_FMT_NONE }; static const enum AVPixelFormat rgb_pix_fmts[] = { AV_PIX_FMT_GBRP, AV_PIX_FMT_GBRAP, AV_PIX_FMT_NONE }; AVFilterFormats *fmts_list; if (geq->is_rgb) { fmts_list = ff_make_format_list(rgb_pix_fmts); } else fmts_list = ff_make_format_list(yuv_pix_fmts); if (!fmts_list) return AVERROR(ENOMEM); return ff_set_common_formats(ctx, fmts_list); }<SPLIT>[-0.25365086435942685, -0.15237931622650824, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.17094161050087475, -0.25297036047912586, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, -0.14106852214680915, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.25252937827156396, -0.10760608081136262, 0.6817979554923368, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int avpriv_mpegts_parse_packet(MpegTSContext *ts, AVPacket *pkt, const uint8_t *buf, int len) { int len1; len1 = len; ts->pkt = pkt; for (;;) { ts->stop_parse = 0; if (len < TS_PACKET_SIZE) return AVERROR_INVALIDDATA; if (buf[0] != 0x47) { buf++; len--; } else { handle_packet(ts, buf); buf += TS_PACKET_SIZE; len -= TS_PACKET_SIZE; if (ts->stop_parse == 1) break; } } return len1 - len; }<SPLIT>[-0.25365086435942685, -0.15237931622650824, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, -0.17094161050087475, -0.25297036047912586, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, -0.39986248560786075, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.08904460951967552, -0.5591795518777907, 2.47944955092491, 0.05245806339860493, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 1.7623686513065309, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static int hls_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags) { HLSContext *c = s->priv_data; struct playlist *seek_pls = NULL; int i, seq_no; int64_t first_timestamp, seek_timestamp, duration; if ((flags & AVSEEK_FLAG_BYTE) || !(c->variants[0]->playlists[0]->finished || c->variants[0]->playlists[0]->type == PLS_TYPE_EVENT)) return AVERROR(ENOSYS); first_timestamp = c->first_timestamp == AV_NOPTS_VALUE ? 0 : c->first_timestamp; seek_timestamp = av_rescale_rnd(timestamp, AV_TIME_BASE, s->streams[stream_index]->time_base.den, flags & AVSEEK_FLAG_BACKWARD ? AV_ROUND_DOWN : AV_ROUND_UP); duration = s->duration == AV_NOPTS_VALUE ? 0 : s->duration; if (0 < duration && duration < seek_timestamp - first_timestamp) return AVERROR(EIO); for (i = 0; i < c->n_playlists; i++) { struct playlist *pls = c->playlists[i]; if (stream_index >= pls->stream_offset && stream_index - pls->stream_offset < pls->ctx->nb_streams) { seek_pls = pls; break; } } if (!seek_pls || !find_timestamp_in_playlist(c, seek_pls, seek_timestamp, &seq_no)) return AVERROR(EIO); seek_pls->cur_seq_no = seq_no; seek_pls->seek_stream_index = stream_index - seek_pls->stream_offset; for (i = 0; i < c->n_playlists; i++) { struct playlist *pls = c->playlists[i]; if (pls->input) { ffurl_close(pls->input); pls->input = NULL; } av_free_packet(&pls->pkt); reset_packet(&pls->pkt); pls->pb.eof_reached = 0; pls->pb.buf_end = pls->pb.buf_ptr = pls->pb.buffer; pls->pb.pos = 0; ff_read_frame_flush(pls->ctx); pls->seek_timestamp = seek_timestamp; pls->seek_flags = flags; if (pls != seek_pls) { find_timestamp_in_playlist(c, pls, seek_timestamp, &pls->cur_seq_no); pls->seek_stream_index = -1; pls->seek_flags |= AVSEEK_FLAG_ANY; } } c->cur_timestamp = seek_timestamp; return 0; }<SPLIT>[1.6020562841584611, 0.5527916715686512, 0.0, 1.559355493837688, 0.4659552894840279, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.7081292429973187, 1.6346889576037051, 0.5919546230485575, 0.0, 0.0, 0.30852482215402843, 0.6227518265893592, 1.5905928466936687, 0.5055429305765636, 0.7647103499668715, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5355687622580682, 0.0744401592322129, 0.6826474935548865, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { GradFunContext *s = ctx->priv; av_freep(&s->buf); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>int ff_graph_thread_init(AVFilterGraph *graph) { graph->thread_type = 0; graph->nb_threads = 1; return 0; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.7880534307994381, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int parse_key_value_pair(AVDictionary **pm, const char **buf, const char *key_val_sep, const char *pairs_sep, int flags) { char *key = av_get_token(buf, key_val_sep); char *val = NULL; int ret; if (key && *key && strspn(*buf, key_val_sep)) { (*buf)++; val = av_get_token(buf, pairs_sep); } if (key && *key && val && *val) ret = av_dict_set(pm, key, val, flags); else ret = AVERROR(EINVAL); av_freep(&key); av_freep(&val); return ret; }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, -0.24638545112987587, -0.2425966915157195, 0.07672169611998206, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, 0.37651940477529405, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.03454968660237938, 0.11818065472185141, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static int config_props_output(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; SeparateFieldsContext *s = ctx->priv; AVFilterLink *inlink = ctx->inputs[0]; s->nb_planes = av_pix_fmt_count_planes(inlink->format); if (inlink->h & 1) { av_log(ctx, AV_LOG_ERROR, "height must be even\n"); return AVERROR_INVALIDDATA; } outlink->time_base.num = inlink->time_base.num; outlink->time_base.den = inlink->time_base.den * 2; outlink->frame_rate.num = inlink->frame_rate.num * 2; outlink->frame_rate.den = inlink->frame_rate.den; outlink->w = inlink->w; outlink->h = inlink->h / 2; return 0; }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int gen_release_stream(URLContext *s, RTMPContext *rt) { RTMPPacket pkt; uint8_t *p; int ret; if ((ret = ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE, 0, 29 + strlen(rt->playpath))) < 0) return ret; av_log(s, AV_LOG_DEBUG, "Releasing stream...\n"); p = pkt.data; ff_amf_write_string(&p, "releaseStream"); ff_amf_write_number(&p, ++rt->nb_invokes); ff_amf_write_null(&p); ff_amf_write_string(&p, rt->playpath); return rtmp_send_packet(rt, &pkt, 1); }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, 0.24712242304476825, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.14353953243697165, 0.11818065472185141, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int ff_rm_retrieve_cache (AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *ast, AVPacket *pkt) { RMDemuxContext *rm = s->priv_data; av_assert0 (rm->audio_pkt_cnt > 0); if (ast->deint_id == DEINT_ID_VBRF || ast->deint_id == DEINT_ID_VBRS) { int ret = av_get_packet(pb, pkt, ast->sub_packet_lengths[ast->sub_packet_cnt - rm->audio_pkt_cnt]); if (ret < 0) return ret; } else { int ret = av_new_packet(pkt, st->codec->block_align); if (ret < 0) return ret; memcpy(pkt->data, ast->pkt.data + st->codec->block_align * (ast->sub_packet_h * ast->audio_framesize / st->codec->block_align - rm->audio_pkt_cnt), st->codec->block_align); } rm->audio_pkt_cnt--; if ((pkt->pts = ast->audiotimestamp) != AV_NOPTS_VALUE) { ast->audiotimestamp = AV_NOPTS_VALUE; pkt->flags = AV_PKT_FLAG_KEY; } else pkt->flags = 0; pkt->stream_index = st->index; return rm->audio_pkt_cnt; }<SPLIT>[-0.25365086435942685, -0.04219634938351458, 0.0, -0.2665172434374763, -0.10857156875928925, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 0.7102265412631674, -0.07104719533062549, -0.25297036047912586, -0.023453142295599506, 0.0, 0.0, 0.30852482215402843, -0.13281935569359377, -0.26569807294376846, -0.09079437018198484, -0.14106852214680915, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, 0.01994523631491676, -0.10760608081136262, 0.6817979554923368, 0.05245806339860493, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 0.7098813332246741, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 0.7058592275743352]
0<SPLIT>int show_sinks(void *optctx, const char *opt, const char *arg) { AVOutputFormat *fmt = NULL; char *dev = NULL; AVDictionary *opts = NULL; int ret = 0; int error_level = av_log_get_level(); av_log_set_level(AV_LOG_ERROR); if ((ret = show_sinks_sources_parse_arg(arg, &dev, &opts)) < 0) goto fail; do { fmt = av_output_audio_device_next(fmt); if (fmt) { if (dev && !av_match_name(dev, fmt->name)) continue; print_device_sinks(fmt, opts); } } while (fmt); do { fmt = av_output_video_device_next(fmt); if (fmt) { if (dev && !av_match_name(dev, fmt->name)) continue; print_device_sinks(fmt, opts); } } while (fmt); fail: av_dict_free(&opts); av_free(dev); av_log_set_level(error_level); return ret; }<SPLIT>[-0.25365086435942685, 0.04595002409088034, 0.0, -0.2665172434374763, -0.02345647864916818, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.008868336805573909, -0.25297036047912586, 0.06771837849612745, 0.0, 0.0, 0.30852482215402843, -0.05532487545944473, -0.26569807294376846, -0.0024481034029406237, 0.6353133682363457, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, 0.29241985090139744, 0.6826474935548865, -0.21702784222394986, -0.04111270872174079, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int config_input(AVFilterLink *inlink) { int i, j; OWDenoiseContext *s = inlink->dst->priv; const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format); const int h = FFALIGN(inlink->h, 16); s->hsub = desc->log2_chroma_w; s->vsub = desc->log2_chroma_h; s->linesize = FFALIGN(inlink->w, 16); for (j = 0; j < 4; j++) { for (i = 0; i <= s->depth; i++) { s->plane[i][j] = av_malloc_array(s->linesize, h * sizeof(s->plane[0][0][0])); if (!s->plane[i][j]) return AVERROR(ENOMEM); } } return 0; }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.14106852214680915, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.03454968660237938, 0.11818065472185141, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int64_t mkv_write_seekhead(AVIOContext *pb, MatroskaMuxContext *mkv) { mkv_seekhead *seekhead = mkv->main_seekhead; ebml_master metaseek, seekentry; int64_t currentpos; int i; currentpos = avio_tell(pb); if (seekhead->reserved_size > 0) { if (avio_seek(pb, seekhead->filepos, SEEK_SET) < 0) { currentpos = -1; goto fail; } } metaseek = start_ebml_master(pb, MATROSKA_ID_SEEKHEAD, seekhead->reserved_size); for (i = 0; i < seekhead->num_entries; i++) { mkv_seekhead_entry *entry = &seekhead->entries[i]; seekentry = start_ebml_master(pb, MATROSKA_ID_SEEKENTRY, MAX_SEEKENTRY_SIZE); put_ebml_id(pb, MATROSKA_ID_SEEKID); put_ebml_num(pb, ebml_id_size(entry->elementid), 0); put_ebml_id(pb, entry->elementid); put_ebml_uint(pb, MATROSKA_ID_SEEKPOSITION, entry->segmentpos); end_ebml_master(pb, seekentry); } end_ebml_master(pb, metaseek); if (seekhead->reserved_size > 0) { uint64_t remaining = seekhead->filepos + seekhead->reserved_size - avio_tell(pb); put_ebml_void(pb, remaining); avio_seek(pb, currentpos, SEEK_SET); currentpos = seekhead->filepos; } fail: av_freep(&mkv->main_seekhead->entries); av_freep(&mkv->main_seekhead); return currentpos; }<SPLIT>[-0.25365086435942685, 0.11205980419667652, 0.0, -0.2665172434374763, 0.04037983893342262, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.380400859743741, 0.06880498590772346, -0.25297036047912586, 0.13609701908992267, 0.0, 0.0, 0.30852482215402843, 0.0027959847161670454, -0.26569807294376846, 0.06381159668134254, 0.5059163865058198, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.18424725727220465, 0.23792492798410134, 0.5697541257882794, 0.6817979554923368, -0.13468348084208653, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.3801362775450152, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.3766295797615486]
0<SPLIT>static int matroska_parse_seekhead_entry(MatroskaDemuxContext *matroska, uint64_t pos) { uint32_t level_up = matroska->level_up; uint32_t saved_id = matroska->current_id; int64_t before_pos = avio_tell(matroska->ctx->pb); MatroskaLevel level; int64_t offset; int ret = 0; offset = pos + matroska->segment_start; if (avio_seek(matroska->ctx->pb, offset, SEEK_SET) == offset) { if (matroska->num_levels == EBML_MAX_DEPTH) { av_log(matroska->ctx, AV_LOG_INFO, "Max EBML element depth (%d) reached, " "cannot parse further.\n", EBML_MAX_DEPTH); ret = AVERROR_INVALIDDATA; } else { level.start = 0; level.length = (uint64_t) -1; matroska->levels[matroska->num_levels] = level; matroska->num_levels++; matroska->current_id = 0; ret = ebml_parse(matroska, matroska_segment, matroska); while (matroska->num_levels) { uint64_t length = matroska->levels[--matroska->num_levels].length; if (length == (uint64_t) -1) break; } } } avio_seek(matroska->ctx->pb, before_pos, SEEK_SET); matroska->level_up = level_up; matroska->current_id = saved_id; return ret; }<SPLIT>[0.5195604475230265, 0.11205980419667652, 0.0, 0.4942630637605089, 0.04037983893342262, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.1686994010779727, 0.5335543553887203, 0.13609701908992267, 0.0, 0.0, 0.30852482215402843, 0.09966408500885333, 0.5077564769051636, 0.06381159668134254, -0.14106852214680915, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 0.043718655277859224, -0.3070243011888601, -0.3333928163445767, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int rtmp_close(URLContext *h) { RTMPContext *rt = h->priv_data; int ret = 0, i, j; if (!rt->is_input) { rt->flv_data = NULL; if (rt->out_pkt.size) ff_rtmp_packet_destroy(&rt->out_pkt); if (rt->state > STATE_FCPUBLISH) ret = gen_fcunpublish_stream(h, rt); } if (rt->state > STATE_HANDSHAKED) ret = gen_delete_stream(h, rt); for (i = 0; i < 2; i++) { for (j = 0; j < rt->nb_prev_pkt[i]; j++) ff_rtmp_packet_destroy(&rt->prev_pkt[i][j]); av_freep(&rt->prev_pkt[i]); } free_tracked_methods(rt); av_freep(&rt->flv_data); ffurl_close(rt->stream); return ret; }<SPLIT>[-0.25365086435942685, -0.15237931622650824, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.17094161050087475, -0.25297036047912586, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, 0.11772544131424245, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, 0.0744401592322129, 0.23107402248845843, -0.21702784222394986, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void extract_exponents(AC3EncodeContext *s) { int ch = !s->cpl_on; int chan_size = AC3_MAX_COEFS * s->num_blocks * (s->channels - ch + 1); AC3Block *block = &s->blocks[0]; s->ac3dsp.extract_exponents(block->exp[ch], block->fixed_coef[ch], chan_size); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void free_device_list(AVOpenCLDeviceList *device_list) { int i, j; if (!device_list) return; for (i = 0; i < device_list->platform_num; i++) { if (!device_list->platform_node[i]) continue; for (j = 0; j < device_list->platform_node[i]->device_num; j++) { av_freep(&(device_list->platform_node[i]->device_node[j]->device_name)); av_freep(&(device_list->platform_node[i]->device_node[j])); } av_freep(&device_list->platform_node[i]->device_node); av_freep(&(device_list->platform_node[i]->platform_name)); av_freep(&device_list->platform_node[i]); } av_freep(&device_list->platform_node); device_list->platform_num = 0; }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.41601414702345235, -0.4462861841111837, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *buf) { AVFilterContext *ctx = inlink->dst; MixContext *s = ctx->priv; AVFilterLink *outlink = ctx->outputs[0]; int i, ret = 0; for (i = 0; i < ctx->nb_inputs; i++) if (ctx->inputs[i] == inlink) break; if (i >= ctx->nb_inputs) { av_log(ctx, AV_LOG_ERROR, "unknown input link\n"); ret = AVERROR(EINVAL); goto fail; } if (i == 0) { int64_t pts = av_rescale_q(buf->pts, inlink->time_base, outlink->time_base); ret = frame_list_add_frame(s->frame_list, buf->nb_samples, pts); if (ret < 0) goto fail; } ret = av_audio_fifo_write(s->fifos[i], (void **)buf->extended_data, buf->nb_samples); fail: av_frame_free(&buf); return ret; }<SPLIT>[-0.25365086435942685, -0.06423294275211332, 0.0, -0.2665172434374763, -0.12985034128681952, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, -0.09102607836467534, -0.25297036047912586, -0.04624602249353125, 0.0, 0.0, 0.30852482215402843, -0.152192975752131, -0.26569807294376846, -0.1128809368767459, -0.011671540416283347, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, 0.12893508214950905, 0.11818065472185141, 0.6817979554923368, 0.05245806339860493, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static int shuffleplanes_filter_frame(AVFilterLink *inlink, AVFrame *frame) { AVFilterContext *ctx = inlink->dst; ShufflePlanesContext *s = ctx->priv; uint8_t *shuffled_data[4] = { NULL }; int shuffled_linesize[4] = { 0 }; int i, ret; for (i = 0; i < s->planes; i++) { shuffled_data[i] = frame->data[s->map[i]]; shuffled_linesize[i] = frame->linesize[s->map[i]]; } memcpy(frame->data, shuffled_data, sizeof(shuffled_data)); memcpy(frame->linesize, shuffled_linesize, sizeof(shuffled_linesize)); if (s->copy) { AVFrame *copy = ff_get_video_buffer(ctx->outputs[0], frame->width, frame->height); if (!copy) { ret = AVERROR(ENOMEM); goto fail; } av_frame_copy(copy, frame); ret = av_frame_copy_props(copy, frame); if (ret < 0) { av_frame_free(&copy); goto fail; } av_frame_free(&frame); frame = copy; } return ff_filter_frame(ctx->outputs[0], frame); fail: av_frame_free(&frame); return ret; }<SPLIT>[-0.25365086435942685, 0.06798661745947907, 0.0, -0.2665172434374763, -0.0021777061216379156, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, 0.02884721983962376, -0.25297036047912586, 0.0905112586940592, 0.0, 0.0, 0.30852482215402843, -0.03595125540090747, -0.26569807294376846, 0.01963846329182043, 0.37651940477529405, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, 0.11398295627503194, 0.29241985090139744, 0.4568607580216725, 0.6817979554923368, 0.05245806339860493, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static int guess_channel_layout(MovieStream *st, int st_index, void *log_ctx) { AVCodecContext *dec_ctx = st->st->codec; char buf[256]; int64_t chl = av_get_default_channel_layout(dec_ctx->channels); if (!chl) { av_log(log_ctx, AV_LOG_ERROR, "Channel layout is not set in stream %d, and could not " "be guessed from the number of channels (%d)\n", st_index, dec_ctx->channels); return AVERROR(EINVAL); } av_get_channel_layout_string(buf, sizeof(buf), dec_ctx->channels, chl); av_log(log_ctx, AV_LOG_WARNING, "Channel layout is not set in output stream %d, " "guessed channel layout is '%s'\n", st_index, buf); dec_ctx->channel_layout = chl; return 0; }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.3615192241061562, -0.3333928163445767, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int alloc_out_frame(ShowWavesContext *showwaves, const int16_t *p, const AVFilterLink *inlink, AVFilterLink *outlink, const AVFrame *in) { if (!showwaves->outpicref) { int j; AVFrame *out = showwaves->outpicref = ff_get_video_buffer(outlink, outlink->w, outlink->h); if (!out) return AVERROR(ENOMEM); out->width = outlink->w; out->height = outlink->h; out->pts = in->pts + av_rescale_q((p - (int16_t *)in->data[0]) / inlink->channels, av_make_q(1, inlink->sample_rate), outlink->time_base); for (j = 0; j < outlink->h; j++) memset(out->data[0] + j*out->linesize[0], 0, outlink->w); } return 0; }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, 0.24712242304476825, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.25252937827156396, -0.10760608081136262, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void disp_node(AVBPrint *buf, const struct color_node *map, int parent_id, int node_id, int depth) { const struct color_node *node = &map[node_id]; const uint32_t fontcolor = node->val[0] > 0x50 && node->val[1] > 0x50 && node->val[2] > 0x50 ? 0 : 0xffffff; av_bprintf(buf, "%*cnode%d [" "label=\"%c%02X%c%02X%c%02X%c\" " "fillcolor=\"#%02x%02x%02x\" " "fontcolor=\"#%06X\"]\n", depth*INDENT, ' ', node->palette_id, "[ "[node->split], node->val[0], "][ "[node->split], node->val[1], " ]["[node->split], node->val[2], " ]"[node->split], node->val[0], node->val[1], node->val[2], fontcolor); if (parent_id != -1) av_bprintf(buf, "%*cnode%d -> node%d\n", depth*INDENT, ' ', map[parent_id].palette_id, node->palette_id); if (node->left_id != -1) disp_node(buf, map, node_id, node->left_id, depth + 1); if (node->right_id != -1) disp_node(buf, map, node_id, node->right_id, depth + 1); }<SPLIT>[-0.25365086435942685, -0.08626953612071205, 0.0, -0.2665172434374763, -0.15112911381434976, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.1110049613987252, -0.25297036047912586, -0.06903890269146298, 0.0, 0.0, 0.30852482215402843, -0.17156659581066827, -0.26569807294376846, -0.13496750357150694, -0.011671540416283347, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.4705090699407485, -0.3333928163445767, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int parse_read_intervals(const char *intervals_spec) { int ret, n, i; char *p, *spec = av_strdup(intervals_spec); if (!spec) return AVERROR(ENOMEM); for (n = 0, p = spec; *p; p++) if (*p == ',') n++; n++; read_intervals = av_malloc_array(n, sizeof(*read_intervals)); if (!read_intervals) { ret = AVERROR(ENOMEM); goto end; } read_intervals_nb = n; p = spec; for (i = 0; p; i++) { char *next; av_assert0(i < read_intervals_nb); next = strchr(p, ','); if (next) *next++ = 0; read_intervals[i].id = i; ret = parse_read_interval(p, &read_intervals[i]); if (ret < 0) { av_log(NULL, AV_LOG_ERROR, "Error parsing read interval #%d '%s'\n", i, p); goto end; } av_log(NULL, AV_LOG_VERBOSE, "Parsed log interval "); log_read_interval(&read_intervals[i], NULL, AV_LOG_VERBOSE); p = next; } av_assert0(i == read_intervals_nb); end: av_free(spec); return ret; }<SPLIT>[0.05563366039355449, 0.20020617767107143, 0.0, 0.037794879441717756, 0.12549492904354367, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 0.7102265412631674, 0.18867828411202256, 0.061639525868012635, 0.22726853988164963, 0.0, 0.0, 0.30852482215402843, 0.11903770506739059, 0.04368374699580437, 0.15215786346038676, 0.6353133682363457, 1.3453624607183459, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2896437087679637, 1.273328463412728, 1.0213275968547075, -0.21702784222394986, 1.3624488730834452, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 0.7098813332246741, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 0.7058592275743352]
0<SPLIT>static int sse(MpegEncContext *s, uint8_t *src1, uint8_t *src2, int w, int h, int stride){ uint32_t *sq = ff_square_tab + 256; int acc=0; int x,y; if(w==16 && h==16) return s->mecc.sse[0](NULL, src1, src2, stride, 16); else if(w==8 && h==8) return s->mecc.sse[1](NULL, src1, src2, stride, 8); for(y=0; y<h; y++){ for(x=0; x<w; x++){ acc+= sq[src1[x + y*stride] - src2[x + y*stride]]; } } av_assert2(acc>=0); return acc; }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.39986248560786075, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.03454968660237938, -0.3333928163445767, -0.21702784222394986, 0.23959960763929639, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void insert_inout(AVFilterInOut **inouts, AVFilterInOut *element) { element->next = *inouts; *inouts = element; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void hybrid_analysis(PSDSPContext *dsp, INTFLOAT out[91][32][2], INTFLOAT in[5][44][2], INTFLOAT L[2][38][64], int is34, int len) { int i, j; for (i = 0; i < 5; i++) { for (j = 0; j < 38; j++) { in[i][j+6][0] = L[0][j][i]; in[i][j+6][1] = L[1][j][i]; } } if (is34) { hybrid4_8_12_cx(dsp, in[0], out, f34_0_12, 12, len); hybrid4_8_12_cx(dsp, in[1], out+12, f34_1_8, 8, len); hybrid4_8_12_cx(dsp, in[2], out+20, f34_2_4, 4, len); hybrid4_8_12_cx(dsp, in[3], out+24, f34_2_4, 4, len); hybrid4_8_12_cx(dsp, in[4], out+28, f34_2_4, 4, len); dsp->hybrid_analysis_ileave(out + 27, L, 5, len); } else { hybrid6_cx(dsp, in[0], out, f20_0_8, len); hybrid2_re(in[1], out+6, g1_Q2, len, 1); hybrid2_re(in[2], out+8, g1_Q2, len, 0); dsp->hybrid_analysis_ileave(out + 7, L, 3, len); } for (i = 0; i < 5; i++) { memcpy(in[i], in[i]+32, 6 * sizeof(in[i][0])); } }<SPLIT>[-0.09900860198293619, -0.24052568970090316, 0.0, -0.11436118199787926, 0.12549492904354367, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.2308782596030243, -0.09566541730555662, -0.22858906407698518, 0.0, 0.0, 3.3489446507317613, 0.09966408500885333, -0.11100716297398205, 0.15215786346038676, 0.6353133682363457, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2545115582693773, 0.6738843113224704, 0.23107402248845843, -0.21702784222394986, 0.9881657846020622, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.9056307075691036, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 0.04739993194876201]
0<SPLIT>static AVFilterFormats *clone_filter_formats(AVFilterFormats *arg) { AVFilterFormats *a = av_memdup(arg, sizeof(*arg)); if (a) { a->refcount = 0; a->refs = NULL; a->formats = av_memdup(a->formats, sizeof(*a->formats) * a->nb_formats); if (!a->formats && arg->formats) av_freep(&a); } return a; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int write_frame(AlacEncodeContext *s, AVPacket *avpkt, uint8_t * const *samples) { PutBitContext *pb = &s->pbctx; const enum AlacRawDataBlockType *ch_elements = ff_alac_channel_elements[s->avctx->channels - 1]; const uint8_t *ch_map = ff_alac_channel_layout_offsets[s->avctx->channels - 1]; int ch, element, sce, cpe; init_put_bits(pb, avpkt->data, avpkt->size); ch = element = sce = cpe = 0; while (ch < s->avctx->channels) { if (ch_elements[element] == TYPE_CPE) { write_element(s, TYPE_CPE, cpe, samples[ch_map[ch]], samples[ch_map[ch + 1]]); cpe++; ch += 2; } else { write_element(s, TYPE_SCE, sce, samples[ch_map[ch]], NULL); sce++; ch++; } element++; } put_bits(pb, 3, TYPE_END); flush_put_bits(pb); return put_bits_count(pb) >> 3; }<SPLIT>[-0.25365086435942685, -0.08626953612071205, 0.0, -0.2665172434374763, -0.15112911381434976, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.1110049613987252, -0.25297036047912586, -0.06903890269146298, 0.0, 0.0, 0.30852482215402843, -0.17156659581066827, -0.26569807294376846, -0.13496750357150694, 0.37651940477529405, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, 0.01994523631491676, 0.5697541257882794, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void uyvytoyuv420_c(uint8_t *ydst, uint8_t *udst, uint8_t *vdst, const uint8_t *src, int width, int height, int lumStride, int chromStride, int srcStride) { int y; const int chromWidth = FF_CEIL_RSHIFT(width, 1); for (y = 0; y < height; y++) { extract_even_c(src + 1, ydst, width); if (y & 1) { extract_even2avg_c(src - srcStride, src, udst, vdst, chromWidth); udst += chromStride; vdst += chromStride; } src += srcStride; ydst += lumStride; } }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, 0.01910106640589235, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 3.3489446507317613, -0.016577635342370212, -0.26569807294376846, 0.04172502998658149, 0.6353133682363457, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, 0.18343000506680518, 0.11818065472185141, -0.21702784222394986, 0.23959960763929639, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 0.04739993194876201]
0<SPLIT>static void mxf_free_metadataset(MXFMetadataSet **ctx, int freectx) { MXFIndexTableSegment *seg; switch ((*ctx)->type) { case Descriptor: av_freep(&((MXFDescriptor *)*ctx)->extradata); break; case MultipleDescriptor: av_freep(&((MXFDescriptor *)*ctx)->sub_descriptors_refs); break; case Sequence: av_freep(&((MXFSequence *)*ctx)->structural_components_refs); break; case EssenceGroup: av_freep(&((MXFEssenceGroup *)*ctx)->structural_components_refs); break; case SourcePackage: case MaterialPackage: av_freep(&((MXFPackage *)*ctx)->tracks_refs); av_freep(&((MXFPackage *)*ctx)->name); av_freep(&((MXFPackage *)*ctx)->comment_refs); break; case TaggedValue: av_freep(&((MXFTaggedValue *)*ctx)->name); av_freep(&((MXFTaggedValue *)*ctx)->value); break; case IndexTableSegment: seg = (MXFIndexTableSegment *)*ctx; av_freep(&seg->temporal_offset_entries); av_freep(&seg->flag_entries); av_freep(&seg->stream_offset_entries); default: break; } if (freectx) av_freep(ctx); }<SPLIT>[-0.25365086435942685, 0.15613299093387398, 0.0, -0.2665172434374763, 0.08293738398848315, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.10876275197582316, -0.25297036047912586, 0.18168277948578615, 0.0, 0.0, 0.30852482215402843, 0.04154322483324156, -0.26569807294376846, 0.10798473007086465, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.07885080577644558, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void mxf_write_sequence(AVFormatContext *s, AVStream *st, enum MXFMetadataSetType type) { MXFContext *mxf = s->priv_data; AVIOContext *pb = s->pb; enum MXFMetadataSetType component; mxf_write_metadata_key(pb, 0x010f00); PRINT_KEY(s, "sequence key", pb->buf_ptr - 16); klv_encode_ber_length(pb, 80); mxf_write_local_tag(pb, 16, 0x3C0A); mxf_write_uuid(pb, type == MaterialPackage ? Sequence: Sequence + TypeBottom, st->index); PRINT_KEY(s, "sequence uid", pb->buf_ptr - 16); mxf_write_common_fields(s, st); mxf_write_local_tag(pb, 16 + 8, 0x1001); mxf_write_refs_count(pb, 1); if (st == mxf->timecode_track) component = TimecodeComponent; else component = SourceClip; if (type == SourcePackage) component += TypeBottom; mxf_write_uuid(pb, component, st->index); }<SPLIT>[-0.09900860198293619, -0.17441590959510697, 0.0, -0.11436118199787926, -0.23624420392447085, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.17094161050087475, -0.09566541730555662, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, -0.11100716297398205, -0.22331377035055117, 0.24712242304476825, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, -0.1980344553542678, 0.23107402248845843, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void update_datarate(DataRateData *drd, int64_t count) { if (!drd->time1 && !drd->count1) { drd->time1 = drd->time2 = cur_time; drd->count1 = drd->count2 = count; } else if (cur_time - drd->time2 > 5000) { drd->time1 = drd->time2; drd->count1 = drd->count2; drd->time2 = cur_time; drd->count2 = count; } }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.7880534307994381, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5794989157753407, -0.7849662874110047, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void RENAME(yuv2rgb32_2)(SwsContext *c, const int16_t *buf[2], const int16_t *ubuf[2], const int16_t *vbuf[2], const int16_t *abuf[2], uint8_t *dest, int dstW, int yalpha, int uvalpha, int y) { const int16_t *buf0 = buf[0], *buf1 = buf[1], *ubuf0 = ubuf[0], *ubuf1 = ubuf[1]; if (CONFIG_SWSCALE_ALPHA && c->alpPixBuf) { const int16_t *abuf0 = abuf[0], *abuf1 = abuf[1]; #if ARCH_X86_64 __asm__ volatile( YSCALEYUV2RGB(%%r8, %5) YSCALEYUV2RGB_YA(%%r8, %5, %6, %7) "psraw $3, %%mm1 \n\t" "psraw $3, %%mm7 \n\t" "packuswb %%mm7, %%mm1 \n\t" WRITEBGR32(%4, DSTW_OFFSET"(%5)", %%r8, %%mm2, %%mm4, %%mm5, %%mm1, %%mm0, %%mm7, %%mm3, %%mm6) :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "r" (dest), "a" (&c->redDither), "r" (abuf0), "r" (abuf1) : "%r8" ); #else c->u_temp=(intptr_t)abuf0; c->v_temp=(intptr_t)abuf1; __asm__ volatile( "mov %%"REG_b", "ESP_OFFSET"(%5) \n\t" "mov %4, %%"REG_b" \n\t" "push %%"REG_BP" \n\t" YSCALEYUV2RGB(%%REGBP, %5) "push %0 \n\t" "push %1 \n\t" "mov "U_TEMP"(%5), %0 \n\t" "mov "V_TEMP"(%5), %1 \n\t" YSCALEYUV2RGB_YA(%%REGBP, %5, %0, %1) "psraw $3, %%mm1 \n\t" "psraw $3, %%mm7 \n\t" "packuswb %%mm7, %%mm1 \n\t" "pop %1 \n\t" "pop %0 \n\t" WRITEBGR32(%%REGb, DSTW_OFFSET"(%5)", %%REGBP, %%mm2, %%mm4, %%mm5, %%mm1, %%mm0, %%mm7, %%mm3, %%mm6) "pop %%"REG_BP" \n\t" "mov "ESP_OFFSET"(%5), %%"REG_b" \n\t" :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest), "a" (&c->redDither) ); #endif } else { __asm__ volatile( "mov %%"REG_b", "ESP_OFFSET"(%5) \n\t" "mov %4, %%"REG_b" \n\t" "push %%"REG_BP" \n\t" YSCALEYUV2RGB(%%REGBP, %5) "pcmpeqd %%mm7, %%mm7 \n\t" WRITEBGR32(%%REGb, DSTW_OFFSET"(%5)", %%REGBP, %%mm2, %%mm4, %%mm5, %%mm7, %%mm0, %%mm1, %%mm3, %%mm6) "pop %%"REG_BP" \n\t" "mov "ESP_OFFSET"(%5), %%"REG_b" \n\t" :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest), "a" (&c->redDither) ); } }<SPLIT>[-0.25365086435942685, 0.7070478251488422, 0.0, -0.2665172434374763, 0.6149066971767397, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.6082348278270694, -0.25297036047912586, 0.40961158146510357, 0.0, 0.0, 0.30852482215402843, 0.525883726296673, -0.26569807294376846, 0.3288503970184752, -0.5292594673383866, -0.2988828158747199, 0.0, 1.2365069331633587, 1.5771521192305922, -0.44813145170234975, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void draw_rectangle(unsigned val, uint8_t *dst, int dst_linesize, int segment_width, int x, int y, int w, int h) { int i; int step = 3; dst += segment_width * (step * x + y * dst_linesize); w *= segment_width * step; h *= segment_width; for (i = 0; i < h; i++) { memset(dst, val, w); dst += dst_linesize; } }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.270465503877335, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.25252937827156396, -0.4462861841111837, -0.21702784222394986, -0.04111270872174079, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int av_audio_fifo_space(AVAudioFifo *af) { return af->allocated_samples - af->nb_samples; }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void rtsp_parse_transport(RTSPMessageHeader *reply, const char *p) { char transport_protocol[16]; char profile[16]; char lower_transport[16]; char parameter[16]; RTSPTransportField *th; char buf[256]; reply->nb_transports = 0; for (;;) { p += strspn(p, SPACE_CHARS); if (*p == '\0') break; th = &reply->transports[reply->nb_transports]; get_word_sep(transport_protocol, sizeof(transport_protocol), "/", &p); if (!av_strcasecmp (transport_protocol, "rtp")) { get_word_sep(profile, sizeof(profile), "/;,", &p); lower_transport[0] = '\0'; if (*p == '/') { get_word_sep(lower_transport, sizeof(lower_transport), ";,", &p); } th->transport = RTSP_TRANSPORT_RTP; } else if (!av_strcasecmp (transport_protocol, "x-pn-tng") || !av_strcasecmp (transport_protocol, "x-real-rdt")) { get_word_sep(lower_transport, sizeof(lower_transport), "/;,", &p); profile[0] = '\0'; th->transport = RTSP_TRANSPORT_RDT; } else if (!av_strcasecmp(transport_protocol, "raw")) { get_word_sep(profile, sizeof(profile), "/;,", &p); lower_transport[0] = '\0'; if (*p == '/') { get_word_sep(lower_transport, sizeof(lower_transport), ";,", &p); } th->transport = RTSP_TRANSPORT_RAW; } if (!av_strcasecmp(lower_transport, "TCP")) th->lower_transport = RTSP_LOWER_TRANSPORT_TCP; else th->lower_transport = RTSP_LOWER_TRANSPORT_UDP; if (*p == ';') p++; while (*p != '\0' && *p != ',') { get_word_sep(parameter, sizeof(parameter), "=;,", &p); if (!strcmp(parameter, "port")) { if (*p == '=') { p++; rtsp_parse_range(&th->port_min, &th->port_max, &p); } } else if (!strcmp(parameter, "client_port")) { if (*p == '=') { p++; rtsp_parse_range(&th->client_port_min, &th->client_port_max, &p); } } else if (!strcmp(parameter, "server_port")) { if (*p == '=') { p++; rtsp_parse_range(&th->server_port_min, &th->server_port_max, &p); } } else if (!strcmp(parameter, "interleaved")) { if (*p == '=') { p++; rtsp_parse_range(&th->interleaved_min, &th->interleaved_max, &p); } } else if (!strcmp(parameter, "multicast")) { if (th->lower_transport == RTSP_LOWER_TRANSPORT_UDP) th->lower_transport = RTSP_LOWER_TRANSPORT_UDP_MULTICAST; } else if (!strcmp(parameter, "ttl")) { if (*p == '=') { char *end; p++; th->ttl = strtol(p, &end, 10); p = end; } } else if (!strcmp(parameter, "destination")) { if (*p == '=') { p++; get_word_sep(buf, sizeof(buf), ";,", &p); get_sockaddr(buf, &th->destination); } } else if (!strcmp(parameter, "source")) { if (*p == '=') { p++; get_word_sep(buf, sizeof(buf), ";,", &p); av_strlcpy(th->source, buf, sizeof(th->source)); } } else if (!strcmp(parameter, "mode")) { if (*p == '=') { p++; get_word_sep(buf, sizeof(buf), ";, ", &p); if (!strcmp(buf, "record") || !strcmp(buf, "receive")) th->mode_record = 1; } } while (*p != ';' && *p != '\0' && *p != ',') p++; if (*p == ';') p++; } if (*p == ',') p++; reply->nb_transports++; if (reply->nb_transports >= RTSP_MAX_TRANSPORTS) break; } }<SPLIT>[0.36491818514653585, 1.8088774935787786, 0.0, 0.34210700232091185, 1.678845323553253, 0.0, 4.793618421028242, 4.882959718323225, 5.2178232792030705, 0.7102265412631674, 1.6870945116657614, 0.3762494122151511, 1.8911487943306668, 0.0, 0.0, 0.30852482215402843, 1.572059209457685, 0.35306556693537716, 1.7644772321779438, 1.0235043134279231, 6.8261800493618985, 0.0, -0.08645738172306322, -0.16222078614455715, 1.2382117722297952, 3.3441355342699812, 0.7955408613214935, 2.47944955092491, 4.824567441536237, 4.792059382968043, 4.881641060948428, 5.216223448940634, 0.7098813332246741, 2.6191065950439585, 0.0, 4.782977160739454, 4.872517593997146, 5.206308627949375, 0.7058592275743352]
0<SPLIT>static int mxf_parse_physical_source_package(MXFContext *mxf, MXFTrack *source_track, AVStream *st) { MXFPackage *physical_package = NULL; MXFTrack *physical_track = NULL; MXFStructuralComponent *sourceclip = NULL; MXFTimecodeComponent *mxf_tc = NULL; int i, j, k; AVTimecode tc; int flags; int64_t start_position; for (i = 0; i < source_track->sequence->structural_components_count; i++) { sourceclip = mxf_resolve_strong_ref(mxf, &source_track->sequence->structural_components_refs[i], SourceClip); if (!sourceclip) continue; if (!(physical_package = mxf_resolve_source_package(mxf, sourceclip->source_package_uid))) break; mxf_add_umid_metadata(&st->metadata, "reel_umid", physical_package); if (physical_package->name && physical_package->name[0]) av_dict_set(&st->metadata, "reel_name", physical_package->name, 0); for (j = 0; j < physical_package->tracks_count; j++) { if (!(physical_track = mxf_resolve_strong_ref(mxf, &physical_package->tracks_refs[j], Track))) { av_log(mxf->fc, AV_LOG_ERROR, "could not resolve source track strong ref\n"); continue; } if (!(physical_track->sequence = mxf_resolve_strong_ref(mxf, &physical_track->sequence_ref, Sequence))) { av_log(mxf->fc, AV_LOG_ERROR, "could not resolve source track sequence strong ref\n"); continue; } for (k = 0; k < physical_track->sequence->structural_components_count; k++) { if (!(mxf_tc = mxf_resolve_timecode_component(mxf, &physical_track->sequence->structural_components_refs[k]))) continue; flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0; start_position = av_rescale_q(sourceclip->start_position, physical_track->edit_rate, source_track->edit_rate); if (av_timecode_init(&tc, mxf_tc->rate, flags, start_position + mxf_tc->start_frame, mxf->fc) == 0) { mxf_add_timecode_metadata(&st->metadata, "timecode", &tc); return 0; } } } } return 0; }<SPLIT>[0.5195604475230265, 0.3103891445140651, 0.0, 0.4942630637605089, 0.231888791681195, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.3485093483844214, 0.5335543553887203, 0.34123294087130834, 0.0, 0.0, 0.30852482215402843, 0.27402666553568866, 0.5077564769051636, 0.262590696934192, 0.6353133682363457, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 0.32477585926655006, 0.0744401592322129, 0.6826474935548865, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void bgr24ToY_c(uint8_t *_dst, const uint8_t *src, const uint8_t *unused1, const uint8_t *unused2, int width, uint32_t *rgb2yuv) { int16_t *dst = (int16_t *)_dst; int32_t ry = rgb2yuv[RY_IDX], gy = rgb2yuv[GY_IDX], by = rgb2yuv[BY_IDX]; int i; for (i = 0; i < width; i++) { int b = src[i * 3 + 0]; int g = src[i * 3 + 1]; int r = src[i * 3 + 2]; dst[i] = ((ry*r + gy*g + by*b + (32<<(RGB2YUV_SHIFT-1)) + (1<<(RGB2YUV_SHIFT-7)))>>(RGB2YUV_SHIFT-6)); } }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.3070243011888601, -0.3333928163445767, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void init_sample_buffers(AlacEncodeContext *s, int channels, uint8_t const *samples[2]) { int ch, i; int shift = av_get_bytes_per_sample(s->avctx->sample_fmt) * 8 - s->avctx->bits_per_raw_sample; #define COPY_SAMPLES(type) do { \ for (ch = 0; ch < channels; ch++) { \ int32_t *bptr = s->sample_buf[ch]; \ const type *sptr = (const type *)samples[ch]; \ for (i = 0; i < s->frame_size; i++) \ bptr[i] = sptr[i] >> shift; \ } \ } while (0) if (s->avctx->sample_fmt == AV_SAMPLE_FMT_S32P) COPY_SAMPLES(int32_t); else COPY_SAMPLES(int16_t); }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.26569807294376846, -0.3116600371295954, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, 0.417570182313826, -0.30760284970800433, 0.12893508214950905, -0.10760608081136262, -0.21702784222394986, 0.33317037975964214, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, -0.27935383381430245, 1.7623686513065309, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, -0.28182971586402455]
0<SPLIT>static inline void encode_mb_hq(MpegEncContext *s, MpegEncContext *backup, MpegEncContext *best, int type, PutBitContext pb[2], PutBitContext pb2[2], PutBitContext tex_pb[2], int *dmin, int *next_block, int motion_x, int motion_y) { int score; uint8_t *dest_backup[3]; copy_context_before_encode(s, backup, type); s->block= s->blocks[*next_block]; s->pb= pb[*next_block]; if(s->data_partitioning){ s->pb2 = pb2 [*next_block]; s->tex_pb= tex_pb[*next_block]; } if(*next_block){ memcpy(dest_backup, s->dest, sizeof(s->dest)); s->dest[0] = s->sc.rd_scratchpad; s->dest[1] = s->sc.rd_scratchpad + 16*s->linesize; s->dest[2] = s->sc.rd_scratchpad + 16*s->linesize + 8; av_assert0(s->linesize >= 32); } encode_mb(s, motion_x, motion_y); score= put_bits_count(&s->pb); if(s->data_partitioning){ score+= put_bits_count(&s->pb2); score+= put_bits_count(&s->tex_pb); } if(s->avctx->mb_decision == FF_MB_DECISION_RD){ ff_mpv_decode_mb(s, s->block); score *= s->lambda2; score += sse_mb(s) << FF_LAMBDA_SHIFT; } if(*next_block){ memcpy(s->dest, dest_backup, sizeof(s->dest)); } if(score<*dmin){ *dmin= score; *next_block^=1; copy_context_after_encode(best, s, type); } }<SPLIT>[-0.25365086435942685, 0.2222427710396702, 0.0, -0.2665172434374763, 0.14677370157107394, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, -0.27925050329511203, 0.1686994010779727, -0.25297036047912586, 0.2500614200795814, 0.0, 0.0, 0.30852482215402843, 0.09966408500885333, -0.26569807294376846, 0.17424443015514782, 0.6353133682363457, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, 0.11398295627503194, 0.23792492798410134, 0.23107402248845843, -0.21702784222394986, 0.23959960763929639, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, -0.27935383381430245, 0.04889276383167627, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, -0.28182971586402455]
0<SPLIT>AVFilterContext *avfilter_graph_get_filter(AVFilterGraph *graph, const char *name) { int i; for (i = 0; i < graph->nb_filters; i++) if (graph->filters[i]->name && !strcmp(name, graph->filters[i]->name)) return graph->filters[i]; return NULL; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static inline void transpose_16x8_char_toPackedAlign_altivec(unsigned char* dst, unsigned char* src, int stride) { const vector unsigned char zero = vec_splat_u8(0); #define LOAD_DOUBLE_LINE(i, j) \ vector unsigned char perm1##i = vec_lvsl(i * stride, src); \ vector unsigned char perm2##i = vec_lvsl(j * stride, src); \ vector unsigned char srcA##i = vec_ld(i * stride, src); \ vector unsigned char srcB##i = vec_ld(i * stride + 16, src); \ vector unsigned char srcC##i = vec_ld(j * stride, src); \ vector unsigned char srcD##i = vec_ld(j * stride+ 16, src); \ vector unsigned char src##i = vec_perm(srcA##i, srcB##i, perm1##i); \ vector unsigned char src##j = vec_perm(srcC##i, srcD##i, perm2##i) LOAD_DOUBLE_LINE(0, 1); LOAD_DOUBLE_LINE(2, 3); LOAD_DOUBLE_LINE(4, 5); LOAD_DOUBLE_LINE(6, 7); #undef LOAD_DOUBLE_LINE vector unsigned char tempA = vec_mergeh(src0, zero); vector unsigned char tempB = vec_mergel(src0, zero); vector unsigned char tempC = vec_mergeh(src1, zero); vector unsigned char tempD = vec_mergel(src1, zero); vector unsigned char tempE = vec_mergeh(src2, zero); vector unsigned char tempF = vec_mergel(src2, zero); vector unsigned char tempG = vec_mergeh(src3, zero); vector unsigned char tempH = vec_mergel(src3, zero); vector unsigned char tempI = vec_mergeh(src4, zero); vector unsigned char tempJ = vec_mergel(src4, zero); vector unsigned char tempK = vec_mergeh(src5, zero); vector unsigned char tempL = vec_mergel(src5, zero); vector unsigned char tempM = vec_mergeh(src6, zero); vector unsigned char tempN = vec_mergel(src6, zero); vector unsigned char tempO = vec_mergeh(src7, zero); vector unsigned char tempP = vec_mergel(src7, zero); vector unsigned char temp0 = vec_mergeh(tempA, tempI); vector unsigned char temp1 = vec_mergel(tempA, tempI); vector unsigned char temp2 = vec_mergeh(tempB, tempJ); vector unsigned char temp3 = vec_mergel(tempB, tempJ); vector unsigned char temp4 = vec_mergeh(tempC, tempK); vector unsigned char temp5 = vec_mergel(tempC, tempK); vector unsigned char temp6 = vec_mergeh(tempD, tempL); vector unsigned char temp7 = vec_mergel(tempD, tempL); vector unsigned char temp8 = vec_mergeh(tempE, tempM); vector unsigned char temp9 = vec_mergel(tempE, tempM); vector unsigned char temp10 = vec_mergeh(tempF, tempN); vector unsigned char temp11 = vec_mergel(tempF, tempN); vector unsigned char temp12 = vec_mergeh(tempG, tempO); vector unsigned char temp13 = vec_mergel(tempG, tempO); vector unsigned char temp14 = vec_mergeh(tempH, tempP); vector unsigned char temp15 = vec_mergel(tempH, tempP); tempA = vec_mergeh(temp0, temp8); tempB = vec_mergel(temp0, temp8); tempC = vec_mergeh(temp1, temp9); tempD = vec_mergel(temp1, temp9); tempE = vec_mergeh(temp2, temp10); tempF = vec_mergel(temp2, temp10); tempG = vec_mergeh(temp3, temp11); tempH = vec_mergel(temp3, temp11); tempI = vec_mergeh(temp4, temp12); tempJ = vec_mergel(temp4, temp12); tempK = vec_mergeh(temp5, temp13); tempL = vec_mergel(temp5, temp13); tempM = vec_mergeh(temp6, temp14); tempN = vec_mergel(temp6, temp14); tempO = vec_mergeh(temp7, temp15); tempP = vec_mergel(temp7, temp15); temp0 = vec_mergeh(tempA, tempI); temp1 = vec_mergel(tempA, tempI); temp2 = vec_mergeh(tempB, tempJ); temp3 = vec_mergel(tempB, tempJ); temp4 = vec_mergeh(tempC, tempK); temp5 = vec_mergel(tempC, tempK); temp6 = vec_mergeh(tempD, tempL); temp7 = vec_mergel(tempD, tempL); temp8 = vec_mergeh(tempE, tempM); temp9 = vec_mergel(tempE, tempM); temp10 = vec_mergeh(tempF, tempN); temp11 = vec_mergel(tempF, tempN); temp12 = vec_mergeh(tempG, tempO); temp13 = vec_mergel(tempG, tempO); temp14 = vec_mergeh(tempH, tempP); temp15 = vec_mergel(tempH, tempP); vec_st(temp0, 0, dst); vec_st(temp1, 16, dst); vec_st(temp2, 32, dst); vec_st(temp3, 48, dst); vec_st(temp4, 64, dst); vec_st(temp5, 80, dst); vec_st(temp6, 96, dst); vec_st(temp7, 112, dst); vec_st(temp8, 128, dst); vec_st(temp9, 144, dst); vec_st(temp10, 160, dst); vec_st(temp11, 176, dst); vec_st(temp12, 192, dst); vec_st(temp13, 208, dst); vec_st(temp14, 224, dst); vec_st(temp15, 240, dst); }<SPLIT>[-0.25365086435942685, 1.4783285930497976, 0.0, -0.2665172434374763, 1.3596637356402992, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 1.3074957340188142, -0.25297036047912586, 1.5036698309658272, 0.0, 0.0, 0.30852482215402843, 1.203960428345477, -0.26569807294376846, 1.3890055983670058, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, 0.9973611507722091, 2.5381013406774904, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int configure_output_video_filter(FilterGraph *fg, OutputFilter *ofilter, AVFilterInOut *out) { char *pix_fmts; OutputStream *ost = ofilter->ost; OutputFile *of = output_files[ost->file_index]; AVFilterContext *last_filter = out->filter_ctx; int pad_idx = out->pad_idx; int ret; char name[255]; snprintf(name, sizeof(name), "out_%d_%d", ost->file_index, ost->index); ret = avfilter_graph_create_filter(&ofilter->filter, avfilter_get_by_name("buffersink"), name, NULL, NULL, fg->graph); if (ret < 0) return ret; if (ofilter->width || ofilter->height) { char args[255]; AVFilterContext *filter; AVDictionaryEntry *e = NULL; snprintf(args, sizeof(args), "%d:%d", ofilter->width, ofilter->height); while ((e = av_dict_get(ost->sws_dict, "", e, AV_DICT_IGNORE_SUFFIX))) { av_strlcatf(args, sizeof(args), ":%s=%s", e->key, e->value); } snprintf(name, sizeof(name), "scaler_out_%d_%d", ost->file_index, ost->index); if ((ret = avfilter_graph_create_filter(&filter, avfilter_get_by_name("scale"), name, args, NULL, fg->graph)) < 0) return ret; if ((ret = avfilter_link(last_filter, pad_idx, filter, 0)) < 0) return ret; last_filter = filter; pad_idx = 0; } if ((pix_fmts = choose_pix_fmts(ofilter))) { AVFilterContext *filter; snprintf(name, sizeof(name), "format_out_%d_%d", ost->file_index, ost->index); ret = avfilter_graph_create_filter(&filter, avfilter_get_by_name("format"), "format", pix_fmts, NULL, fg->graph); av_freep(&pix_fmts); if (ret < 0) return ret; if ((ret = avfilter_link(last_filter, pad_idx, filter, 0)) < 0) return ret; last_filter = filter; pad_idx = 0; } if (ost->frame_rate.num && 0) { AVFilterContext *fps; char args[255]; snprintf(args, sizeof(args), "fps=%d/%d", ost->frame_rate.num, ost->frame_rate.den); snprintf(name, sizeof(name), "fps_out_%d_%d", ost->file_index, ost->index); ret = avfilter_graph_create_filter(&fps, avfilter_get_by_name("fps"), name, args, NULL, fg->graph); if (ret < 0) return ret; ret = avfilter_link(last_filter, pad_idx, fps, 0); if (ret < 0) return ret; last_filter = fps; pad_idx = 0; } snprintf(name, sizeof(name), "trim_out_%d_%d", ost->file_index, ost->index); ret = insert_trim(of->start_time, of->recording_time, &last_filter, &pad_idx, name); if (ret < 0) return ret; if ((ret = avfilter_link(last_filter, pad_idx, ofilter->filter, 0)) < 0) return ret; return 0; }<SPLIT>[-0.25365086435942685, 1.0375967256778231, 0.0, -0.2665172434374763, 0.9340882850896938, 0.0, 1.6653401555507896, 1.7015798777335354, 1.5692995750795884, 3.6786576749380067, 0.9079180733378172, -0.25297036047912586, 1.0933979874030557, 0.0, 0.0, 0.30852482215402843, 0.8164880271747319, -0.26569807294376846, 0.9914473978613069, 1.1529012951584487, 2.0030605713555723, 0.0, -0.08645738172306322, -0.16222078614455715, 0.816625966246759, 1.5458030779992087, 0.9084342290881006, -0.21702784222394986, 1.9238735058055194, 1.664582183638518, 1.7009206574961395, 1.5685972020260743, 3.6775868343416036, 0.9056307075691036, 0.0, 1.6594432402238268, 1.6957470663015664, 1.5635067606227984, 3.6689260578894145]
0<SPLIT>int av_expr_parse(AVExpr **expr, const char *s, const char * const *const_names, const char * const *func1_names, double (* const *funcs1)(void *, double), const char * const *func2_names, double (* const *funcs2)(void *, double, double), int log_offset, void *log_ctx) { Parser p = { 0 }; AVExpr *e = NULL; char *w = av_malloc(strlen(s) + 1); char *wp = w; const char *s0 = s; int ret = 0; if (!w) return AVERROR(ENOMEM); while (*s) if (!av_isspace(*s++)) *wp++ = s[-1]; *wp++ = 0; p.class = &eval_class; p.stack_index=100; p.s= w; p.const_names = const_names; p.funcs1 = funcs1; p.func1_names = func1_names; p.funcs2 = funcs2; p.func2_names = func2_names; p.log_offset = log_offset; p.log_ctx = log_ctx; if ((ret = parse_expr(&e, &p)) < 0) goto end; if (*p.s) { av_log(&p, AV_LOG_ERROR, "Invalid chars '%s' at the end of expression '%s'\n", p.s, s0); ret = AVERROR(EINVAL); goto end; } if (!verify_expr(e)) { ret = AVERROR(EINVAL); goto end; } e->var= av_mallocz(sizeof(double) *VARS); if (!e->var) { ret = AVERROR(ENOMEM); goto end; } *expr = e; e = NULL; end: av_expr_free(e); av_free(w); return ret; }<SPLIT>[-0.25365086435942685, 0.4426087047256575, 0.0, -0.2665172434374763, 0.3595614268463766, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 1.040052222782594, 0.3684882314184712, -0.25297036047912586, 0.4779902220588988, 0.0, 0.0, 0.30852482215402843, 0.29340028559422593, -0.26569807294376846, 0.39511009710275835, 1.2822982768889746, 1.0165134053997327, 0.0, -0.08645738172306322, -0.16222078614455715, 0.4653044612608955, 0.9463589259089511, 0.9084342290881006, 0.6817979554923368, 0.8010242403613708, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 1.039626388904333, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 1.0350888753871217]
0<SPLIT>static void compute_real_filename(char *filename, int max_size) { char file1[1024]; char file2[1024]; char *p; FFServerStream *stream; av_strlcpy(file1, filename, sizeof(file1)); p = strrchr(file1, '.'); if (p) *p = '\0'; for(stream = config.first_stream; stream; stream = stream->next) { av_strlcpy(file2, stream->filename, sizeof(file2)); p = strrchr(file2, '.'); if (p) *p = '\0'; if (!strcmp(file1, file2)) { av_strlcpy(filename, stream->filename, max_size); break; } } }<SPLIT>[-0.25365086435942685, -0.1964525029637057, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.21089937656897445, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, -0.011671540416283347, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.14353953243697165, -0.10760608081136262, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void av_cast5_crypt2(AVCAST5* cs, uint8_t* dst, const uint8_t* src, int count, uint8_t *iv, int decrypt) { int i; while (count--) { if (decrypt) { decipher(cs, dst, src, iv); } else { if (iv) { for (i = 0; i < 8; i++) dst[i] = src[i] ^ iv[i]; encipher(cs, dst, dst); memcpy(iv, dst, 8); } else { encipher(cs, dst, src); } } src = src + 8; dst = dst + 8; } }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.270465503877335, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.3070243011888601, -0.3333928163445767, -0.21702784222394986, -0.22825425296243224, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 1.7623686513065309, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static int thread_init_internal(ThreadContext *c, int nb_threads) { int i, ret; if (!nb_threads) { int nb_cpus = av_cpu_count(); if (nb_cpus > 1) nb_threads = nb_cpus + 1; else nb_threads = 1; } if (nb_threads <= 1) return 1; c->nb_threads = nb_threads; c->workers = av_mallocz_array(sizeof(*c->workers), nb_threads); if (!c->workers) return AVERROR(ENOMEM); c->current_job = 0; c->nb_jobs = 0; c->done = 0; pthread_cond_init(&c->current_job_cond, NULL); pthread_cond_init(&c->last_job_cond, NULL); pthread_mutex_init(&c->current_job_lock, NULL); pthread_mutex_lock(&c->current_job_lock); for (i = 0; i < nb_threads; i++) { ret = pthread_create(&c->workers[i], NULL, worker, c); if (ret) { pthread_mutex_unlock(&c->current_job_lock); c->nb_threads = i; slice_thread_uninit(c); return AVERROR(ret); } } slice_thread_park_workers(c); return c->nb_threads; }<SPLIT>[-0.09900860198293619, 0.11205980419667652, 0.0, -0.11436118199787926, 0.04037983893342262, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, 0.7102265412631674, 0.08878386894177331, -0.09566541730555662, 0.13609701908992267, 0.0, 0.0, 0.30852482215402843, 0.022169604774704303, -0.11100716297398205, 0.06381159668134254, 0.6353133682363457, 0.6876643500811196, 0.0, -0.08645738172306322, -0.16222078614455715, 0.14911510677361828, 0.6193893884051743, 0.6826474935548865, -0.21702784222394986, 0.5203119240003335, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, 0.7098813332246741, 0.9056307075691036, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 0.7058592275743352]
0<SPLIT>static int get_input(AVFrame *frame, int frame_num) { int err, i, j; #define FRAME_SIZE 1024 frame->sample_rate = INPUT_SAMPLERATE; frame->format = INPUT_FORMAT; frame->channel_layout = INPUT_CHANNEL_LAYOUT; frame->nb_samples = FRAME_SIZE; frame->pts = frame_num * FRAME_SIZE; err = av_frame_get_buffer(frame, 0); if (err < 0) return err; for (i = 0; i < 5; i++) { float *data = (float*)frame->extended_data[i]; for (j = 0; j < frame->nb_samples; j++) data[j] = sin(2 * M_PI * (frame_num + j) * (i + 1) / FRAME_SIZE); } return 0; }<SPLIT>[0.05563366039355449, -0.24052568970090316, 0.0, 0.037794879441717756, -0.30008052150706166, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.21089937656897445, 0.061639525868012635, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, 0.04368374699580437, -0.3116600371295954, -0.270465503877335, -0.07965011232897776, 0.0, -0.08645738172306322, 0.417570182313826, -0.1670742477136589, -0.03454968660237938, -0.10760608081136262, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { VignetteContext *s = ctx->priv; av_freep(&s->fmap); av_expr_free(s->angle_pexpr); av_expr_free(s->x0_pexpr); av_expr_free(s->y0_pexpr); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int aac_encode_frame(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *got_packet_ptr) { AACEncContext *s = avctx->priv_data; float **samples = s->planar_samples, *samples2, *la, *overlap; ChannelElement *cpe; SingleChannelElement *sce; int i, ch, w, chans, tag, start_ch, ret; int ms_mode = 0, is_mode = 0, tns_mode = 0, pred_mode = 0; int chan_el_counter[4]; FFPsyWindowInfo windows[AAC_MAX_CHANNELS]; if (s->last_frame == 2) return 0; if (frame) { if ((ret = ff_af_queue_add(&s->afq, frame)) < 0) return ret; } copy_input_samples(s, frame); if (s->psypp) ff_psy_preprocess(s->psypp, s->planar_samples, s->channels); if (!avctx->frame_number) return 0; start_ch = 0; for (i = 0; i < s->chan_map[0]; i++) { FFPsyWindowInfo* wi = windows + start_ch; tag = s->chan_map[i+1]; chans = tag == TYPE_CPE ? 2 : 1; cpe = &s->cpe[i]; for (ch = 0; ch < chans; ch++) { IndividualChannelStream *ics = &cpe->ch[ch].ics; int cur_channel = start_ch + ch; float clip_avoidance_factor; overlap = &samples[cur_channel][0]; samples2 = overlap + 1024; la = samples2 + (448+64); if (!frame) la = NULL; if (tag == TYPE_LFE) { wi[ch].window_type[0] = ONLY_LONG_SEQUENCE; wi[ch].window_shape = 0; wi[ch].num_windows = 1; wi[ch].grouping[0] = 1; ics->num_swb = s->samplerate_index >= 8 ? 1 : 3; } else { wi[ch] = s->psy.model->window(&s->psy, samples2, la, cur_channel, ics->window_sequence[0]); } ics->window_sequence[1] = ics->window_sequence[0]; ics->window_sequence[0] = wi[ch].window_type[0]; ics->use_kb_window[1] = ics->use_kb_window[0]; ics->use_kb_window[0] = wi[ch].window_shape; ics->num_windows = wi[ch].num_windows; ics->swb_sizes = s->psy.bands [ics->num_windows == 8]; ics->num_swb = tag == TYPE_LFE ? ics->num_swb : s->psy.num_bands[ics->num_windows == 8]; ics->swb_offset = wi[ch].window_type[0] == EIGHT_SHORT_SEQUENCE ? ff_swb_offset_128 [s->samplerate_index]: ff_swb_offset_1024[s->samplerate_index]; ics->tns_max_bands = wi[ch].window_type[0] == EIGHT_SHORT_SEQUENCE ? ff_tns_max_bands_128 [s->samplerate_index]: ff_tns_max_bands_1024[s->samplerate_index]; clip_avoidance_factor = 0.0f; for (w = 0; w < ics->num_windows; w++) ics->group_len[w] = wi[ch].grouping[w]; for (w = 0; w < ics->num_windows; w++) { if (wi[ch].clipping[w] > CLIP_AVOIDANCE_FACTOR) { ics->window_clipping[w] = 1; clip_avoidance_factor = FFMAX(clip_avoidance_factor, wi[ch].clipping[w]); } else { ics->window_clipping[w] = 0; } } if (clip_avoidance_factor > CLIP_AVOIDANCE_FACTOR) { ics->clip_avoidance_factor = CLIP_AVOIDANCE_FACTOR / clip_avoidance_factor; } else { ics->clip_avoidance_factor = 1.0f; } apply_window_and_mdct(s, &cpe->ch[ch], overlap); if (isnan(cpe->ch->coeffs[0])) { av_log(avctx, AV_LOG_ERROR, "Input contains NaN\n"); return AVERROR(EINVAL); } avoid_clipping(s, &cpe->ch[ch]); } start_ch += chans; } if ((ret = ff_alloc_packet2(avctx, avpkt, 8192 * s->channels, 0)) < 0) return ret; do { int frame_bits; init_put_bits(&s->pb, avpkt->data, avpkt->size); if ((avctx->frame_number & 0xFF)==1 && !(avctx->flags & AV_CODEC_FLAG_BITEXACT)) put_bitstream_info(s, LIBAVCODEC_IDENT); start_ch = 0; memset(chan_el_counter, 0, sizeof(chan_el_counter)); for (i = 0; i < s->chan_map[0]; i++) { FFPsyWindowInfo* wi = windows + start_ch; const float *coeffs[2]; tag = s->chan_map[i+1]; chans = tag == TYPE_CPE ? 2 : 1; cpe = &s->cpe[i]; cpe->common_window = 0; memset(cpe->is_mask, 0, sizeof(cpe->is_mask)); memset(cpe->ms_mask, 0, sizeof(cpe->ms_mask)); put_bits(&s->pb, 3, tag); put_bits(&s->pb, 4, chan_el_counter[tag]++); for (ch = 0; ch < chans; ch++) { sce = &cpe->ch[ch]; coeffs[ch] = sce->coeffs; sce->ics.predictor_present = 0; memset(&sce->ics.prediction_used, 0, sizeof(sce->ics.prediction_used)); memset(&sce->tns, 0, sizeof(TemporalNoiseShaping)); for (w = 0; w < 128; w++) if (sce->band_type[w] > RESERVED_BT) sce->band_type[w] = 0; } s->psy.model->analyze(&s->psy, start_ch, coeffs, wi); for (ch = 0; ch < chans; ch++) { s->cur_channel = start_ch + ch; s->coder->search_for_quantizers(avctx, s, &cpe->ch[ch], s->lambda); } if (chans > 1 && wi[0].window_type[0] == wi[1].window_type[0] && wi[0].window_shape == wi[1].window_shape) { cpe->common_window = 1; for (w = 0; w < wi[0].num_windows; w++) { if (wi[0].grouping[w] != wi[1].grouping[w]) { cpe->common_window = 0; break; } } } for (ch = 0; ch < chans; ch++) { sce = &cpe->ch[ch]; s->cur_channel = start_ch + ch; if (s->options.pns && s->coder->search_for_pns) s->coder->search_for_pns(s, avctx, sce); if (s->options.tns && s->coder->search_for_tns) s->coder->search_for_tns(s, sce); if (s->options.tns && s->coder->apply_tns_filt) s->coder->apply_tns_filt(s, sce); if (sce->tns.present) tns_mode = 1; } s->cur_channel = start_ch; if (s->options.intensity_stereo) { if (s->coder->search_for_is) s->coder->search_for_is(s, avctx, cpe); if (cpe->is_mode) is_mode = 1; apply_intensity_stereo(cpe); } if (s->options.pred) { for (ch = 0; ch < chans; ch++) { sce = &cpe->ch[ch]; s->cur_channel = start_ch + ch; if (s->options.pred && s->coder->search_for_pred) s->coder->search_for_pred(s, sce); if (cpe->ch[ch].ics.predictor_present) pred_mode = 1; } if (s->coder->adjust_common_prediction) s->coder->adjust_common_prediction(s, cpe); for (ch = 0; ch < chans; ch++) { sce = &cpe->ch[ch]; s->cur_channel = start_ch + ch; if (s->options.pred && s->coder->apply_main_pred) s->coder->apply_main_pred(s, sce); } s->cur_channel = start_ch; } if (s->options.stereo_mode) { if (s->options.stereo_mode == -1 && s->coder->search_for_ms) s->coder->search_for_ms(s, cpe); else if (cpe->common_window) memset(cpe->ms_mask, 1, sizeof(cpe->ms_mask)); for (w = 0; w < 128; w++) cpe->ms_mask[w] = cpe->is_mask[w] ? 0 : cpe->ms_mask[w]; apply_mid_side_stereo(cpe); } adjust_frame_information(cpe, chans); if (chans == 2) { put_bits(&s->pb, 1, cpe->common_window); if (cpe->common_window) { put_ics_info(s, &cpe->ch[0].ics); if (s->coder->encode_main_pred) s->coder->encode_main_pred(s, &cpe->ch[0]); encode_ms_info(&s->pb, cpe); if (cpe->ms_mode) ms_mode = 1; } } for (ch = 0; ch < chans; ch++) { s->cur_channel = start_ch + ch; encode_individual_channel(avctx, s, &cpe->ch[ch], cpe->common_window); } start_ch += chans; } frame_bits = put_bits_count(&s->pb); if (frame_bits <= 6144 * s->channels - 3) { s->psy.bitres.bits = frame_bits / s->channels; break; } if (is_mode || ms_mode || tns_mode || pred_mode) { for (i = 0; i < s->chan_map[0]; i++) { chans = tag == TYPE_CPE ? 2 : 1; cpe = &s->cpe[i]; for (ch = 0; ch < chans; ch++) memcpy(cpe->ch[ch].coeffs, cpe->ch[ch].pcoeffs, sizeof(cpe->ch[ch].coeffs)); } } s->lambda *= avctx->bit_rate * 1024.0f / avctx->sample_rate / frame_bits; } while (1); put_bits(&s->pb, 3, TYPE_END); flush_put_bits(&s->pb); avctx->frame_bits = put_bits_count(&s->pb); if (!(avctx->flags & AV_CODEC_FLAG_QSCALE)) { float ratio = avctx->bit_rate * 1024.0f / avctx->sample_rate / avctx->frame_bits; s->lambda *= ratio; s->lambda = FFMIN(s->lambda, 65536.f); } if (!frame) s->last_frame++; ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts, &avpkt->duration); avpkt->size = put_bits_count(&s->pb) >> 3; *got_packet_ptr = 1; return 0; }<SPLIT>[0.8288449722760078, 4.299012544230435, 0.0, 0.798575186639703, 4.083346619164173, 0.0, 1.1439604446378808, 1.1713499043019204, 1.5692995750795884, 2.0295292673408736, 4.004644943615544, 0.8481642417358589, 4.466744256696954, 0.0, 0.0, 0.30852482215402843, 3.819399136248007, 0.8171382968447365, 4.260259268685943, 3.740840929768965, 1.3453624607183459, 0.0, -0.08645738172306322, -0.16222078614455715, 5.032484026077122, 2.853681228014316, 4.408128629852918, -0.21702784222394986, 1.2688781009630994, 1.143335983750264, 1.1708005902540914, 1.5685972020260743, 2.0288615559433096, 0.9056307075691036, 0.0, 1.1388542534712223, 1.1662853116856364, 1.5635067606227984, 2.0227778188254817]
0<SPLIT>static inline void decompose2D(float *dst_l, float *dst_h, const float *src, int xlinesize, int ylinesize, int step, int w, int h) { int y, x; for (y = 0; y < h; y++) for (x = 0; x < step; x++) decompose(dst_l + ylinesize*y + xlinesize*x, dst_h + ylinesize*y + xlinesize*x, src + ylinesize*y + xlinesize*x, step * xlinesize, (w - x + step - 1) / step); }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.270465503877335, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.14353953243697165, -0.4462861841111837, -0.21702784222394986, 0.14602883551895066, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int mov_pcm_le_gt16(enum AVCodecID codec_id) { return codec_id == AV_CODEC_ID_PCM_S24LE || codec_id == AV_CODEC_ID_PCM_S32LE || codec_id == AV_CODEC_ID_PCM_F32LE || codec_id == AV_CODEC_ID_PCM_F64LE; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void *alloc_array_elem(void **array, size_t elsize, int *size, int *max_size) { void *ret; if (*size == *max_size) { int m = FFMAX(32, FFMIN(*max_size, INT_MAX / 2) * 2); if (*size >= m) return NULL; *array = av_realloc_f(*array, m, elsize); if (!*array) return NULL; *max_size = m; } ret = (char *)*array + elsize * *size; memset(ret, 0, elsize); (*size)++; return ret; }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.14106852214680915, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, 0.01994523631491676, -0.10760608081136262, -0.21702784222394986, 0.14602883551895066, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *frame) { AVFilterContext *ctx = inlink->dst; FadeContext *s = ctx->priv; double frame_timestamp = frame->pts == AV_NOPTS_VALUE ? -1 : frame->pts * av_q2d(inlink->time_base); if (s->fade_state == VF_FADE_WAITING) { s->factor=0; if (frame_timestamp >= s->start_time/(double)AV_TIME_BASE && inlink->frame_count >= s->start_frame) { s->fade_state = VF_FADE_FADING; if (s->start_time == 0 && s->start_frame != 0) { s->start_time = frame_timestamp*(double)AV_TIME_BASE; } if (s->start_time != 0 && s->start_frame == 0) { s->start_frame = inlink->frame_count; } } } if (s->fade_state == VF_FADE_FADING) { if (s->duration == 0) { s->factor = (inlink->frame_count - s->start_frame) * s->fade_per_frame; if (inlink->frame_count > s->start_frame + s->nb_frames) { s->fade_state = VF_FADE_DONE; } } else { s->factor = (frame_timestamp - s->start_time/(double)AV_TIME_BASE) * (float) UINT16_MAX / (s->duration/(double)AV_TIME_BASE); if (frame_timestamp > s->start_time/(double)AV_TIME_BASE + s->duration/(double)AV_TIME_BASE) { s->fade_state = VF_FADE_DONE; } } } if (s->fade_state == VF_FADE_DONE) { s->factor=UINT16_MAX; } s->factor = av_clip_uint16(s->factor); if (s->type == FADE_OUT) { s->factor=UINT16_MAX-s->factor; } if (s->factor < UINT16_MAX) { if (s->alpha) { ctx->internal->execute(ctx, filter_slice_alpha, frame, NULL, FFMIN(frame->height, ctx->graph->nb_threads)); } else if (s->is_packed_rgb && !s->black_fade) { ctx->internal->execute(ctx, filter_slice_rgb, frame, NULL, FFMIN(frame->height, ctx->graph->nb_threads)); } else { ctx->internal->execute(ctx, filter_slice_luma, frame, NULL, FFMIN(frame->height, ctx->graph->nb_threads)); if (frame->data[1] && frame->data[2]) { ctx->internal->execute(ctx, filter_slice_chroma, frame, NULL, FFMIN(frame->height, ctx->graph->nb_threads)); } } } return ff_filter_frame(inlink->dst->outputs[0], frame); }<SPLIT>[1.1381294970289892, 0.6189014516744473, 0.0, 1.102887309518897, 0.5297916070666188, 0.0, 2.012926629492729, 2.0550665266879453, 1.9009835481817232, -0.27925050329511203, 0.7081292429973187, 1.1627741280829973, 0.6603332636423527, 0.0, 0.0, 0.30852482215402843, 0.6227518265893592, 1.1265201167843093, 0.5718026306608468, -0.270465503877335, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, 0.3469147738186936, -0.22049944857796966, -0.21702784222394986, 0.8010242403613708, 2.0120796502306875, 2.054334035657505, 1.9001995881092162, -0.27935383381430245, 1.7623686513065309, 0.0, 2.006502564725563, 2.048721569378853, 1.8946705667433963, -0.28182971586402455]
0<SPLIT>int ff_parse_channel_layout(int64_t *ret, int *nret, const char *arg, void *log_ctx) { char *tail; int64_t chlayout; chlayout = av_get_channel_layout(arg); if (chlayout == 0) { chlayout = strtol(arg, &tail, 10); if (!(*tail == '\0' || *tail == 'c' && *(tail + 1) == '\0') || chlayout <= 0 || chlayout > 63) { av_log(log_ctx, AV_LOG_ERROR, "Invalid channel layout '%s'\n", arg); return AVERROR(EINVAL); } if (nret) { *nret = chlayout; *ret = 0; return 0; } } *ret = chlayout; if (nret) *nret = av_get_channel_layout_nb_channels(chlayout); return 0; }<SPLIT>[-0.25365086435942685, -0.15237931622650824, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.380400859743741, -0.17094161050087475, -0.25297036047912586, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, 0.11772544131424245, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.08904460951967552, -0.10760608081136262, -0.21702784222394986, -0.04111270872174079, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.3801362775450152, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.3766295797615486]
0<SPLIT>static void compute_display_area(AVFormatContext *s) { XVContext *xv = s->priv_data; AVRational sar, dar; AVStream *st = s->streams[0]; AVCodecContext *encctx = st->codec; sar = st->sample_aspect_ratio.num ? st->sample_aspect_ratio : (AVRational){ 1, 1 }; dar = av_mul_q(sar, (AVRational){ encctx->width, encctx->height }); if (av_cmp_q(dar, (AVRational){ xv->dest_w, xv->dest_h }) > 0) { xv->dest_y = xv->dest_h; xv->dest_x = 0; xv->dest_h = av_rescale(xv->dest_w, dar.den, dar.num); xv->dest_y -= xv->dest_h; xv->dest_y /= 2; } else { xv->dest_x = xv->dest_w; xv->dest_y = 0; xv->dest_w = av_rescale(xv->dest_h, dar.num, dar.den); xv->dest_x -= xv->dest_w; xv->dest_x /= 2; }<SPLIT>[0.5195604475230265, -0.1964525029637057, 0.0, 0.4942630637605089, -0.2575229764520011, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1110049613987252, 0.5335543553887203, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.17156659581066827, 0.5077564769051636, -0.24540033704531222, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>long WINAPI libAVPin_Disconnect(libAVPin *this) { dshowdebug("libAVPin_Disconnect(%p)\n", this); if (this->filter->state != State_Stopped) return VFW_E_NOT_STOPPED; if (!this->connectedto) return S_FALSE; IPin_Release(this->connectedto); this->connectedto = NULL; return S_OK; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>void av_get_channel_layout_string(char *buf, int buf_size, int nb_channels, uint64_t channel_layout) { AVBPrint bp; av_bprint_init_for_buffer(&bp, buf, buf_size); av_bprint_channel_layout(&bp, nb_channels, channel_layout); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void count_frame_bits(AC3EncodeContext *s) { AC3EncOptions *opt = &s->options; int blk, ch; int frame_bits = 0; if (s->eac3) { if (opt->eac3_mixing_metadata) { if (s->channel_mode > AC3_CHMODE_STEREO) frame_bits += 2; if (s->has_center) frame_bits += 6; if (s->has_surround) frame_bits += 6; frame_bits += s->lfe_on; frame_bits += 1 + 1 + 2; if (s->channel_mode < AC3_CHMODE_STEREO) frame_bits++; frame_bits++; } if (opt->eac3_info_metadata) { frame_bits += 3 + 1 + 1; if (s->channel_mode == AC3_CHMODE_STEREO) frame_bits += 2 + 2; if (s->channel_mode >= AC3_CHMODE_2F2R) frame_bits += 2; frame_bits++; if (opt->audio_production_info) frame_bits += 5 + 2 + 1; frame_bits++; } if (s->channel_mode > AC3_CHMODE_MONO) { frame_bits++; for (blk = 1; blk < s->num_blocks; blk++) { AC3Block *block = &s->blocks[blk]; frame_bits++; if (block->new_cpl_strategy) frame_bits++; } } if (s->cpl_on) { if (s->use_frame_exp_strategy) { frame_bits += 5 * s->cpl_on; } else { for (blk = 0; blk < s->num_blocks; blk++) frame_bits += 2 * s->blocks[blk].cpl_in_use; } } } else { if (opt->audio_production_info) frame_bits += 7; if (s->bitstream_id == 6) { if (opt->extended_bsi_1) frame_bits += 14; if (opt->extended_bsi_2) frame_bits += 14; } } for (blk = 0; blk < s->num_blocks; blk++) { AC3Block *block = &s->blocks[blk]; if (!s->eac3) frame_bits++; if (block->new_cpl_strategy) { if (!s->eac3) frame_bits++; if (block->cpl_in_use) { if (s->eac3) frame_bits++; if (!s->eac3 || s->channel_mode != AC3_CHMODE_STEREO) frame_bits += s->fbw_channels; if (s->channel_mode == AC3_CHMODE_STEREO) frame_bits++; frame_bits += 4 + 4; if (s->eac3) frame_bits++; else frame_bits += s->num_cpl_subbands - 1; } } if (block->cpl_in_use) { for (ch = 1; ch <= s->fbw_channels; ch++) { if (block->channel_in_cpl[ch]) { if (!s->eac3 || block->new_cpl_coords[ch] != 2) frame_bits++; if (block->new_cpl_coords[ch]) { frame_bits += 2; frame_bits += (4 + 4) * s->num_cpl_bands; } } } } if (s->channel_mode == AC3_CHMODE_STEREO) { if (!s->eac3 || blk > 0) frame_bits++; if (s->blocks[blk].new_rematrixing_strategy) frame_bits += block->num_rematrixing_bands; } for (ch = 1; ch <= s->fbw_channels; ch++) { if (s->exp_strategy[ch][blk] != EXP_REUSE) { if (!block->channel_in_cpl[ch]) frame_bits += 6; frame_bits += 2; } } if (!s->eac3 && block->cpl_in_use) frame_bits += 2; if (!s->eac3) { frame_bits++; if (block->new_snr_offsets) frame_bits += 6 + (s->channels + block->cpl_in_use) * (4 + 3); } if (block->cpl_in_use) { if (!s->eac3 || block->new_cpl_leak != 2) frame_bits++; if (block->new_cpl_leak) frame_bits += 3 + 3; } } s->frame_bits = s->frame_bits_fixed + frame_bits; }<SPLIT>[1.4474140217819704, 1.9631336471589698, 0.0, 1.4071994323980908, 1.8277967312459649, 0.0, 2.5343063404056374, 2.5852965001195605, 2.3985095078349254, -0.27925050329511203, 1.9667988741424594, 1.477384014430136, 2.050698955716189, 0.0, 0.0, 0.30852482215402843, 1.8432898902772066, 1.4359019367238823, 1.9190831990412711, -0.5292594673383866, 1.674211516036959, 0.0, -0.08645738172306322, -0.16222078614455715, 1.308476073226968, 1.273328463412728, -0.4462861841111837, -0.21702784222394986, 2.5788689106479397, 2.5333258501189415, 2.584454102899553, 2.3976031672339286, -0.27935383381430245, 1.7623686513065309, 0.0, 2.5270915514781676, 2.5781833239947827, 2.391416275924293, -0.28182971586402455]
0<SPLIT>DEFINE_WRITER_CLASS(xml); static av_cold int xml_init(WriterContext *wctx) { XMLContext *xml = wctx->priv; if (xml->xsd_strict) { xml->fully_qualified = 1; #define CHECK_COMPLIANCE(opt, opt_name) \ if (opt) { \ av_log(wctx, AV_LOG_ERROR, \ "XSD-compliant output selected but option '%s' was selected, XML output may be non-compliant.\n" \ "You need to disable such option with '-no%s'\n", opt_name, opt_name); \ return AVERROR(EINVAL); \ } CHECK_COMPLIANCE(show_private_data, "private"); CHECK_COMPLIANCE(show_value_unit, "unit"); CHECK_COMPLIANCE(use_value_prefix, "prefix"); if (do_show_frames && do_show_packets) { av_log(wctx, AV_LOG_ERROR, "Interleaved frames and packets are not allowed in XSD. " "Select only one between the -show_frames and the -show_packets options.\n"); return AVERROR(EINVAL); } } return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.17240788634188003, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.19094021586920554, -0.26569807294376846, -0.17914063696102905, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, 0.417570182313826, -0.30760284970800433, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>void rgb15tobgr16(const uint8_t *src, uint8_t *dst, int src_size) { int i, num_pixels = src_size >> 1; for (i = 0; i < num_pixels; i++) { unsigned rgb = ((const uint16_t *)src)[i]; ((uint16_t *)dst)[i] = ((rgb & 0x7C00) >> 10) | ((rgb & 0x3E0) << 1) | (rgb << 11); } }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.3615192241061562, -0.4462861841111837, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int config_input(AVFilterLink *inlink) { AVFilterContext *ctx = inlink->dst; StabData *sd = ctx->priv; VSMotionDetect* md = &(sd->md); VSFrameInfo fi; const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format); vsFrameInfoInit(&fi, inlink->w, inlink->h, ff_av2vs_pixfmt(ctx, inlink->format)); if (fi.bytesPerPixel != av_get_bits_per_pixel(desc)/8) { av_log(ctx, AV_LOG_ERROR, "pixel-format error: wrong bits/per/pixel, please report a BUG"); return AVERROR(EINVAL); } if (fi.log2ChromaW != desc->log2_chroma_w) { av_log(ctx, AV_LOG_ERROR, "pixel-format error: log2_chroma_w, please report a BUG"); return AVERROR(EINVAL); } if (fi.log2ChromaH != desc->log2_chroma_h) { av_log(ctx, AV_LOG_ERROR, "pixel-format error: log2_chroma_h, please report a BUG"); return AVERROR(EINVAL); } sd->conf.algo = 1; sd->conf.modName = "vidstabdetect"; if (vsMotionDetectInit(md, &sd->conf, &fi) != VS_OK) { av_log(ctx, AV_LOG_ERROR, "initialization of Motion Detection failed, please report a BUG"); return AVERROR(EINVAL); } vsMotionDetectGetConfig(&sd->conf, md); av_log(ctx, AV_LOG_INFO, "Video stabilization settings (pass 1/2):\n"); av_log(ctx, AV_LOG_INFO, " shakiness = %d\n", sd->conf.shakiness); av_log(ctx, AV_LOG_INFO, " accuracy = %d\n", sd->conf.accuracy); av_log(ctx, AV_LOG_INFO, " stepsize = %d\n", sd->conf.stepSize); av_log(ctx, AV_LOG_INFO, " mincontrast = %f\n", sd->conf.contrastThreshold); av_log(ctx, AV_LOG_INFO, " tripod = %d\n", sd->conf.virtualTripod); av_log(ctx, AV_LOG_INFO, " show = %d\n", sd->conf.show); av_log(ctx, AV_LOG_INFO, " result = %s\n", sd->result); sd->f = fopen(sd->result, "w"); if (sd->f == NULL) { av_log(ctx, AV_LOG_ERROR, "cannot open transform file %s\n", sd->result); return AVERROR(EINVAL); } else { if (vsPrepareFile(md, sd->f) != VS_OK) { av_log(ctx, AV_LOG_ERROR, "cannot write to transform file %s\n", sd->result); return AVERROR(EINVAL); } } return 0; }<SPLIT>[-0.09900860198293619, 0.39853551798846004, 0.0, -0.11436118199787926, 0.31700388179131606, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, -0.27925050329511203, 0.3485093483844214, -0.09566541730555662, 0.4324044616630353, 0.0, 0.0, 0.30852482215402843, 0.27402666553568866, -0.11100716297398205, 0.35093696371323624, 0.5059163865058198, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3950401602637228, 0.29241985090139744, 0.4568607580216725, -0.21702784222394986, 0.14602883551895066, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, -0.27935383381430245, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, -0.28182971586402455]
0<SPLIT>static void flat_print_section_header(WriterContext *wctx) { FlatContext *flat = wctx->priv; AVBPrint *buf = &wctx->section_pbuf[wctx->level]; const struct section *section = wctx->section[wctx->level]; const struct section *parent_section = wctx->level ? wctx->section[wctx->level-1] : NULL; av_bprint_clear(buf); if (!parent_section) return; av_bprintf(buf, "%s", wctx->section_pbuf[wctx->level-1].str); if (flat->hierarchical || !(section->flags & (SECTION_FLAG_IS_ARRAY|SECTION_FLAG_IS_WRAPPER))) { av_bprintf(buf, "%s%s", wctx->section[wctx->level]->name, flat->sep_str); if (parent_section->flags & SECTION_FLAG_IS_ARRAY) { int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ? wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1]; av_bprintf(buf, "%d%s", n, flat->sep_str); } } }<SPLIT>[-0.09900860198293619, -0.1964525029637057, 0.0, -0.11436118199787926, -0.2575229764520011, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.1909204935349246, -0.09566541730555662, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.11100716297398205, -0.24540033704531222, -0.14106852214680915, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.14353953243697165, -0.10760608081136262, -0.21702784222394986, -0.13468348084208653, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static int ac3_max_msb_abs_int16_c(const int16_t *src, int len) { int i, v = 0; for (i = 0; i < len; i++) v |= abs(src[i]); return v; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int av_set_options_string(void *ctx, const char *opts, const char *key_val_sep, const char *pairs_sep) { int ret, count = 0; if (!opts) return 0; while (*opts) { if ((ret = parse_key_value_pair(ctx, &opts, key_val_sep, pairs_sep)) < 0) return ret; count++; if (*opts) opts++; } return count; }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 0.7102265412631674, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.39986248560786075, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.03454968660237938, -0.4462861841111837, -0.21702784222394986, 0.33317037975964214, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 0.7098813332246741, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 0.7058592275743352]
0<SPLIT>const char av_util_ffversion[] = "FFmpeg version " FFMPEG_VERSION; const char *av_version_info(void) { return FFMPEG_VERSION; }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int flv_read_packet(AVFormatContext *s, AVPacket *pkt) { FLVContext *flv = s->priv_data; int ret, i, size, flags; enum FlvTagType type; int stream_type=-1; int64_t next, pos, meta_pos; int64_t dts, pts = AV_NOPTS_VALUE; int av_uninit(channels); int av_uninit(sample_rate); AVStream *st = NULL; for (;; avio_skip(s->pb, 4)) { pos = avio_tell(s->pb); type = (avio_r8(s->pb) & 0x1F); size = avio_rb24(s->pb); dts = avio_rb24(s->pb); dts |= avio_r8(s->pb) << 24; av_log(s, AV_LOG_TRACE, "type:%d, size:%d, dts:%"PRId64" pos:%"PRId64"\n", type, size, dts, avio_tell(s->pb)); if (avio_feof(s->pb)) return AVERROR_EOF; avio_skip(s->pb, 3); flags = 0; if (flv->validate_next < flv->validate_count) { int64_t validate_pos = flv->validate_index[flv->validate_next].pos; if (pos == validate_pos) { if (FFABS(dts - flv->validate_index[flv->validate_next].dts) <= VALIDATE_INDEX_TS_THRESH) { flv->validate_next++; } else { clear_index_entries(s, validate_pos); flv->validate_count = 0; } } else if (pos > validate_pos) { clear_index_entries(s, validate_pos); flv->validate_count = 0; } } if (size == 0) continue; next = size + avio_tell(s->pb); if (type == FLV_TAG_TYPE_AUDIO) { stream_type = FLV_STREAM_TYPE_AUDIO; flags = avio_r8(s->pb); size--; } else if (type == FLV_TAG_TYPE_VIDEO) { stream_type = FLV_STREAM_TYPE_VIDEO; flags = avio_r8(s->pb); size--; if ((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_VIDEO_INFO_CMD) goto skip; } else if (type == FLV_TAG_TYPE_META) { stream_type=FLV_STREAM_TYPE_DATA; if (size > 13 + 1 + 4) { int type; meta_pos = avio_tell(s->pb); type = flv_read_metabody(s, next); if (type == 0 && dts == 0 || type < 0 || type == TYPE_UNKNOWN) { goto skip; } else if (type == TYPE_ONTEXTDATA) { avpriv_request_sample(s, "OnTextData packet"); return flv_data_packet(s, pkt, dts, next); } else if (type == TYPE_ONCAPTION) { return flv_data_packet(s, pkt, dts, next); } avio_seek(s->pb, meta_pos, SEEK_SET); } } else { av_log(s, AV_LOG_DEBUG, "Skipping flv packet: type %d, size %d, flags %d.\n", type, size, flags); skip: avio_seek(s->pb, next, SEEK_SET); continue; } if (!size) continue; for (i = 0; i < s->nb_streams; i++) { st = s->streams[i]; if (stream_type == FLV_STREAM_TYPE_AUDIO) { if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO && (s->audio_codec_id || flv_same_audio_codec(st->codec, flags))) break; } else if (stream_type == FLV_STREAM_TYPE_VIDEO) { if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO && (s->video_codec_id || flv_same_video_codec(st->codec, flags))) break; } else if (stream_type == FLV_STREAM_TYPE_DATA) { if (st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) break; } } if (i == s->nb_streams) { static const enum AVMediaType stream_types[] = {AVMEDIA_TYPE_VIDEO, AVMEDIA_TYPE_AUDIO, AVMEDIA_TYPE_SUBTITLE}; av_log(s, AV_LOG_WARNING, "Stream discovered after head already parsed\n"); st = create_stream(s, stream_types[stream_type]); if (!st) return AVERROR(ENOMEM); } av_log(s, AV_LOG_TRACE, "%d %X %d \n", stream_type, flags, st->discard); if (s->pb->seekable && ((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_KEY || stream_type == FLV_STREAM_TYPE_AUDIO)) av_add_index_entry(st, pos, dts, size, 0, AVINDEX_KEYFRAME); if ( (st->discard >= AVDISCARD_NONKEY && !((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_KEY || (stream_type == FLV_STREAM_TYPE_AUDIO))) ||(st->discard >= AVDISCARD_BIDIR && ((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_DISP_INTER && (stream_type == FLV_STREAM_TYPE_VIDEO))) || st->discard >= AVDISCARD_ALL ) { avio_seek(s->pb, next, SEEK_SET); continue; } break; } if (s->pb->seekable && (!s->duration || s->duration == AV_NOPTS_VALUE) && !flv->searched_for_end) { int size; const int64_t pos = avio_tell(s->pb); int64_t fsize = avio_size(s->pb); retry_duration: avio_seek(s->pb, fsize - 4, SEEK_SET); size = avio_rb32(s->pb); avio_seek(s->pb, fsize - 3 - size, SEEK_SET); if (size == avio_rb24(s->pb) + 11) { uint32_t ts = avio_rb24(s->pb); ts |= avio_r8(s->pb) << 24; if (ts) s->duration = ts * (int64_t)AV_TIME_BASE / 1000; else if (fsize >= 8 && fsize - 8 >= size) { fsize -= size+4; goto retry_duration; } } avio_seek(s->pb, pos, SEEK_SET); flv->searched_for_end = 1; } if (stream_type == FLV_STREAM_TYPE_AUDIO) { int bits_per_coded_sample; channels = (flags & FLV_AUDIO_CHANNEL_MASK) == FLV_STEREO ? 2 : 1; sample_rate = 44100 << ((flags & FLV_AUDIO_SAMPLERATE_MASK) >> FLV_AUDIO_SAMPLERATE_OFFSET) >> 3; bits_per_coded_sample = (flags & FLV_AUDIO_SAMPLESIZE_MASK) ? 16 : 8; if (!st->codec->channels || !st->codec->sample_rate || !st->codec->bits_per_coded_sample) { st->codec->channels = channels; st->codec->channel_layout = channels == 1 ? AV_CH_LAYOUT_MONO : AV_CH_LAYOUT_STEREO; st->codec->sample_rate = sample_rate; st->codec->bits_per_coded_sample = bits_per_coded_sample; } if (!st->codec->codec_id) { flv_set_audio_codec(s, st, st->codec, flags & FLV_AUDIO_CODECID_MASK); flv->last_sample_rate = sample_rate = st->codec->sample_rate; flv->last_channels = channels = st->codec->channels; } else { AVCodecContext ctx = {0}; ctx.sample_rate = sample_rate; ctx.bits_per_coded_sample = bits_per_coded_sample; flv_set_audio_codec(s, st, &ctx, flags & FLV_AUDIO_CODECID_MASK); sample_rate = ctx.sample_rate; } } else if (stream_type == FLV_STREAM_TYPE_VIDEO) { size -= flv_set_video_codec(s, st, flags & FLV_VIDEO_CODECID_MASK, 1); } else if (stream_type == FLV_STREAM_TYPE_DATA) { st->codec->codec_id = AV_CODEC_ID_TEXT; } if (st->codec->codec_id == AV_CODEC_ID_AAC || st->codec->codec_id == AV_CODEC_ID_H264 || st->codec->codec_id == AV_CODEC_ID_MPEG4) { int type = avio_r8(s->pb); size--; if (st->codec->codec_id == AV_CODEC_ID_H264 || st->codec->codec_id == AV_CODEC_ID_MPEG4) { int32_t cts = (avio_rb24(s->pb) + 0xff800000) ^ 0xff800000; pts = dts + cts; if (cts < 0) { if (!flv->wrong_dts) av_log(s, AV_LOG_WARNING, "Negative cts, previous timestamps might be wrong.\n"); flv->wrong_dts = 1; } else if (FFABS(dts - pts) > 1000*60*15) { av_log(s, AV_LOG_WARNING, "invalid timestamps %"PRId64" %"PRId64"\n", dts, pts); dts = pts = AV_NOPTS_VALUE; } } if (type == 0 && (!st->codec->extradata || st->codec->codec_id == AV_CODEC_ID_AAC || st->codec->codec_id == AV_CODEC_ID_H264)) { AVDictionaryEntry *t; if (st->codec->extradata) { if ((ret = flv_queue_extradata(flv, s->pb, stream_type, size)) < 0) return ret; ret = AVERROR(EAGAIN); goto leave; } if ((ret = flv_get_extradata(s, st, size)) < 0) return ret; t = av_dict_get(s->metadata, "Encoder", NULL, 0); if (st->codec->codec_id == AV_CODEC_ID_AAC && t && !strcmp(t->value, "Omnia A/XE")) st->codec->extradata_size = 2; if (st->codec->codec_id == AV_CODEC_ID_AAC && 0) { MPEG4AudioConfig cfg; if (avpriv_mpeg4audio_get_config(&cfg, st->codec->extradata, st->codec->extradata_size * 8, 1) >= 0) { st->codec->channels = cfg.channels; st->codec->channel_layout = 0; if (cfg.ext_sample_rate) st->codec->sample_rate = cfg.ext_sample_rate; else st->codec->sample_rate = cfg.sample_rate; av_log(s, AV_LOG_TRACE, "mp4a config channels %d sample rate %d\n", st->codec->channels, st->codec->sample_rate); } } ret = AVERROR(EAGAIN); goto leave; } } if (!size) { ret = AVERROR(EAGAIN); goto leave; } ret = av_get_packet(s->pb, pkt, size); if (ret < 0) return ret; pkt->dts = dts; pkt->pts = pts == AV_NOPTS_VALUE ? dts : pts; pkt->stream_index = st->index; if (flv->new_extradata[stream_type]) { uint8_t *side = av_packet_new_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, flv->new_extradata_size[stream_type]); if (side) { memcpy(side, flv->new_extradata[stream_type], flv->new_extradata_size[stream_type]); av_freep(&flv->new_extradata[stream_type]); flv->new_extradata_size[stream_type] = 0; } } if (stream_type == FLV_STREAM_TYPE_AUDIO && (sample_rate != flv->last_sample_rate || channels != flv->last_channels)) { flv->last_sample_rate = sample_rate; flv->last_channels = channels; ff_add_param_change(pkt, channels, 0, sample_rate, 0, 0); } if ( stream_type == FLV_STREAM_TYPE_AUDIO || ((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_KEY) || stream_type == FLV_STREAM_TYPE_DATA) pkt->flags |= AV_PKT_FLAG_KEY; leave: avio_skip(s->pb, 4); return ret; }<SPLIT>[1.6020562841584611, 4.9160371585512, 0.0, 1.559355493837688, 4.67915224993502, 0.0, 6.705344027708907, 6.827136287572481, 6.378717185060543, 6.647088808612845, 4.663948083739189, 1.6346889576037051, 5.104944902239042, 0.0, 0.0, 0.30852482215402843, 4.458728598179737, 1.5905928466936687, 4.878683136139252, 4.258428856691069, 3.756922199721509, 0.0, -0.08645738172306322, -0.16222078614455715, 4.013651661618117, 5.578427373879123, 4.746808733152739, 6.074752741790056, 5.011708985776928, 6.703295449224975, 6.8254146408359375, 6.37683180023163, 6.6452923354585325, 2.6191065950439585, 0.0, 6.691803445499003, 6.8138773609222225, 6.365381949371468, 6.631992888204494]
0<SPLIT>static void butterflies_float_c(float *av_restrict v1, float *av_restrict v2, int len) { int i; for (i = 0; i < len; i++) { float t = v1[i] - v2[i]; v1[i] += v2[i]; v2[i] = t; } }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int tblend_filter_frame(AVFilterLink *inlink, AVFrame *frame) { BlendContext *s = inlink->dst->priv; AVFilterLink *outlink = inlink->dst->outputs[0]; if (s->prev_frame) { AVFrame *out = blend_frame(inlink->dst, frame, s->prev_frame); av_frame_free(&s->prev_frame); s->prev_frame = frame; return ff_filter_frame(outlink, out); } s->prev_frame = frame; return 0; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.41601414702345235, -0.4462861841111837, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void amp_test(uint8_t *dst, int dst_linesize, int off) { int x, y, amp = off; for (y = 0; y < 16*16; y += 16) { for (x = 0; x < 16*16; x += 16) { draw_basis(dst + x + y*dst_linesize, dst_linesize, 4*amp, 1, 128*8); amp++; } } }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.08904460951967552, -0.3333928163445767, -0.21702784222394986, 0.14602883551895066, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { AVFilterFormats *formats = NULL; AVFilterChannelLayouts *layouts = NULL; AVFilterLink *inlink = ctx->inputs[0]; AVFilterLink *outlink = ctx->outputs[0]; static const enum AVSampleFormat sample_fmts[] = { AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE }; static const enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_GRAY8, AV_PIX_FMT_NONE }; formats = ff_make_format_list(sample_fmts); if (!formats) return AVERROR(ENOMEM); ff_formats_ref(formats, &inlink->out_formats); layouts = ff_all_channel_layouts(); if (!layouts) return AVERROR(ENOMEM); ff_channel_layouts_ref(layouts, &inlink->out_channel_layouts); formats = ff_all_samplerates(); if (!formats) return AVERROR(ENOMEM); ff_formats_ref(formats, &inlink->out_samplerates); formats = ff_make_format_list(pix_fmts); if (!formats) return AVERROR(ENOMEM); ff_formats_ref(formats, &outlink->in_formats); return 0; }<SPLIT>[0.05563366039355449, -0.08626953612071205, 0.0, 0.037794879441717756, -0.15112911381434976, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.07104719533062549, 0.061639525868012635, -0.06903890269146298, 0.0, 0.0, 0.30852482215402843, -0.13281935569359377, 0.04368374699580437, -0.13496750357150694, 0.24712242304476825, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, -0.08904460951967552, 0.34396739025506545, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static MpegTSFilter *mpegts_open_filter(MpegTSContext *ts, unsigned int pid, enum MpegTSFilterType type) { MpegTSFilter *filter; av_log(ts->stream, AV_LOG_TRACE, "Filter: pid=0x%x\n", pid); if (pid >= NB_PID_MAX || ts->pids[pid]) return NULL; filter = av_mallocz(sizeof(MpegTSFilter)); if (!filter) return NULL; ts->pids[pid] = filter; filter->type = type; filter->pid = pid; filter->es_id = -1; filter->last_cc = -1; filter->last_pcr= -1; return filter; }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int parse_sws_flags(const char **buf, AVFilterGraph *graph) { char *p = strchr(*buf, ';'); if (strncmp(*buf, "sws_flags=", 10)) return 0; if (!p) { av_log(graph, AV_LOG_ERROR, "sws_flags not terminated with ';'.\n"); return AVERROR(EINVAL); } *buf += 4; av_freep(&graph->scale_sws_opts); if (!(graph->scale_sws_opts = av_mallocz(p - *buf + 1))) return AVERROR(ENOMEM); av_strlcpy(graph->scale_sws_opts, *buf, p - *buf + 1); *buf = p + 1; return 0; }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, 0.11772544131424245, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, 0.0744401592322129, 0.11818065472185141, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void pa_state_cb(pa_context *c, void *userdata) { enum PulseAudioContextState *context_state = userdata; switch (pa_context_get_state(c)) { case PA_CONTEXT_FAILED: case PA_CONTEXT_TERMINATED: *context_state = PULSE_CONTEXT_FINISHED; break; case PA_CONTEXT_READY: *context_state = PULSE_CONTEXT_READY; break; default: break; } }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int device_init(AVFormatContext *ctx, int *width, int *height, uint32_t pixelformat) { struct video_data *s = ctx->priv_data; struct v4l2_format fmt = { .type = V4L2_BUF_TYPE_VIDEO_CAPTURE }; int res = 0; fmt.fmt.pix.width = *width; fmt.fmt.pix.height = *height; fmt.fmt.pix.pixelformat = pixelformat; fmt.fmt.pix.field = V4L2_FIELD_ANY; if (v4l2_ioctl(s->fd, VIDIOC_S_FMT, &fmt) < 0) res = AVERROR(errno); if ((*width != fmt.fmt.pix.width) || (*height != fmt.fmt.pix.height)) { av_log(ctx, AV_LOG_INFO, "The V4L2 driver changed the video from %dx%d to %dx%d\n", *width, *height, fmt.fmt.pix.width, fmt.fmt.pix.height); *width = fmt.fmt.pix.width; *height = fmt.fmt.pix.height; } if (pixelformat != fmt.fmt.pix.pixelformat) { av_log(ctx, AV_LOG_DEBUG, "The V4L2 driver changed the pixel format " "from 0x%08X to 0x%08X\n", pixelformat, fmt.fmt.pix.pixelformat); res = AVERROR(EINVAL); } if (fmt.fmt.pix.field == V4L2_FIELD_INTERLACED) { av_log(ctx, AV_LOG_DEBUG, "The V4L2 driver is using the interlaced mode\n"); s->interlaced = 1; } return res; }<SPLIT>[0.05563366039355449, 0.06798661745947907, 0.0, 0.037794879441717756, -0.0021777061216379156, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.06880498590772346, 0.061639525868012635, 0.0905112586940592, 0.0, 0.0, 0.30852482215402843, 0.0027959847161670454, 0.04368374699580437, 0.01963846329182043, 0.11772544131424245, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, -0.03454968660237938, 0.11818065472185141, -0.21702784222394986, -0.13468348084208653, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static int decode_interrupt_cb(void *ctx) { VideoState *is = ctx; return is->abort_request; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void rgb15to24(const uint8_t *src, uint8_t *dst, int src_size) { uint8_t *d = dst; const uint16_t *s = (const uint16_t *)src; const uint16_t *end = s + src_size / 2; while (s < end) { register uint16_t bgr = *s++; *d++ = ((bgr&0x7C00)>>7) | ((bgr&0x7C00)>>12); *d++ = ((bgr&0x03E0)>>2) | ((bgr&0x03E0)>> 7); *d++ = ((bgr&0x001F)<<3) | ((bgr&0x001F)>> 2); } }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int config_output(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; const ShowPaletteContext *s = ctx->priv; outlink->w = outlink->h = 16 * s->size; return 0; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int flush_packet(AVFormatContext *ctx, int stream_index, int64_t pts, int64_t dts, int64_t scr, int trailer_size) { MpegMuxContext *s = ctx->priv_data; StreamInfo *stream = ctx->streams[stream_index]->priv_data; uint8_t *buf_ptr; int size, payload_size, startcode, id, stuffing_size, i, header_len; int packet_size; uint8_t buffer[128]; int zero_trail_bytes = 0; int pad_packet_bytes = 0; int pes_flags; int general_pack = 0; int nb_frames; id = stream->id; av_log(ctx, AV_LOG_TRACE, "packet ID=%2x PTS=%0.3f\n", id, pts / 90000.0); buf_ptr = buffer; if ((s->packet_number % s->pack_header_freq) == 0 || s->last_scr != scr) { size = put_pack_header(ctx, buf_ptr, scr); buf_ptr += size; s->last_scr = scr; if (s->is_vcd) { if (stream->packet_number == 0) { size = put_system_header(ctx, buf_ptr, id); buf_ptr += size; } } else if (s->is_dvd) { if (stream->align_iframe || s->packet_number == 0) { int PES_bytes_to_fill = s->packet_size - size - 10; if (pts != AV_NOPTS_VALUE) { if (dts != pts) PES_bytes_to_fill -= 5 + 5; else PES_bytes_to_fill -= 5; } if (stream->bytes_to_iframe == 0 || s->packet_number == 0) { size = put_system_header(ctx, buf_ptr, 0); buf_ptr += size; size = buf_ptr - buffer; avio_write(ctx->pb, buffer, size); avio_wb32(ctx->pb, PRIVATE_STREAM_2); avio_wb16(ctx->pb, 0x03d4); avio_w8(ctx->pb, 0x00); for (i = 0; i < 979; i++) avio_w8(ctx->pb, 0x00); avio_wb32(ctx->pb, PRIVATE_STREAM_2); avio_wb16(ctx->pb, 0x03fa); avio_w8(ctx->pb, 0x01); for (i = 0; i < 1017; i++) avio_w8(ctx->pb, 0x00); memset(buffer, 0, 128); buf_ptr = buffer; s->packet_number++; stream->align_iframe = 0; scr += s->packet_size * 90000LL / (s->mux_rate * 50LL); size = put_pack_header(ctx, buf_ptr, scr); s->last_scr = scr; buf_ptr += size; } else if (stream->bytes_to_iframe < PES_bytes_to_fill) { pad_packet_bytes = PES_bytes_to_fill - stream->bytes_to_iframe; } } } else { if ((s->packet_number % s->system_header_freq) == 0) { size = put_system_header(ctx, buf_ptr, 0); buf_ptr += size; } } } size = buf_ptr - buffer; avio_write(ctx->pb, buffer, size); packet_size = s->packet_size - size; if (s->is_vcd && (id & 0xe0) == AUDIO_ID) zero_trail_bytes += 20; if ((s->is_vcd && stream->packet_number == 0) || (s->is_svcd && s->packet_number == 0)) { if (s->is_svcd) general_pack = 1; pad_packet_bytes = packet_size - zero_trail_bytes; } packet_size -= pad_packet_bytes + zero_trail_bytes; if (packet_size > 0) { packet_size -= 6; if (s->is_mpeg2) { header_len = 3; if (stream->packet_number == 0) header_len += 3; header_len += 1; } else { header_len = 0; } if (pts != AV_NOPTS_VALUE) { if (dts != pts) header_len += 5 + 5; else header_len += 5; } else { if (!s->is_mpeg2) header_len++; } payload_size = packet_size - header_len; if (id < 0xc0) { startcode = PRIVATE_STREAM_1; payload_size -= 1; if (id >= 0x40) { payload_size -= 3; if (id >= 0xa0) payload_size -= 3; } } else { startcode = 0x100 + id; } stuffing_size = payload_size - av_fifo_size(stream->fifo); if (payload_size <= trailer_size && pts != AV_NOPTS_VALUE) { int timestamp_len = 0; if (dts != pts) timestamp_len += 5; if (pts != AV_NOPTS_VALUE) timestamp_len += s->is_mpeg2 ? 5 : 4; pts = dts = AV_NOPTS_VALUE; header_len -= timestamp_len; if (s->is_dvd && stream->align_iframe) { pad_packet_bytes += timestamp_len; packet_size -= timestamp_len; } else { payload_size += timestamp_len; } stuffing_size += timestamp_len; if (payload_size > trailer_size) stuffing_size += payload_size - trailer_size; } if (pad_packet_bytes > 0 && pad_packet_bytes <= 7) { packet_size += pad_packet_bytes; payload_size += pad_packet_bytes; if (stuffing_size < 0) stuffing_size = pad_packet_bytes; else stuffing_size += pad_packet_bytes; pad_packet_bytes = 0; } if (stuffing_size < 0) stuffing_size = 0; if (startcode == PRIVATE_STREAM_1 && id >= 0xa0) { if (payload_size < av_fifo_size(stream->fifo)) stuffing_size += payload_size % stream->lpcm_align; } if (stuffing_size > 16) { pad_packet_bytes += stuffing_size; packet_size -= stuffing_size; payload_size -= stuffing_size; stuffing_size = 0; } nb_frames = get_nb_frames(ctx, stream, payload_size - stuffing_size); avio_wb32(ctx->pb, startcode); avio_wb16(ctx->pb, packet_size); if (!s->is_mpeg2) for (i = 0; i < stuffing_size; i++) avio_w8(ctx->pb, 0xff); if (s->is_mpeg2) { avio_w8(ctx->pb, 0x80); pes_flags = 0; if (pts != AV_NOPTS_VALUE) { pes_flags |= 0x80; if (dts != pts) pes_flags |= 0x40; } if (stream->packet_number == 0) pes_flags |= 0x01; avio_w8(ctx->pb, pes_flags); avio_w8(ctx->pb, header_len - 3 + stuffing_size); if (pes_flags & 0x80) put_timestamp(ctx->pb, (pes_flags & 0x40) ? 0x03 : 0x02, pts); if (pes_flags & 0x40) put_timestamp(ctx->pb, 0x01, dts); if (pes_flags & 0x01) { avio_w8(ctx->pb, 0x10); if ((id & 0xe0) == AUDIO_ID) avio_wb16(ctx->pb, 0x4000 | stream->max_buffer_size / 128); else avio_wb16(ctx->pb, 0x6000 | stream->max_buffer_size / 1024); } } else { if (pts != AV_NOPTS_VALUE) { if (dts != pts) { put_timestamp(ctx->pb, 0x03, pts); put_timestamp(ctx->pb, 0x01, dts); } else { put_timestamp(ctx->pb, 0x02, pts); } } else { avio_w8(ctx->pb, 0x0f); } } if (s->is_mpeg2) { avio_w8(ctx->pb, 0xff); for (i = 0; i < stuffing_size; i++) avio_w8(ctx->pb, 0xff); } if (startcode == PRIVATE_STREAM_1) { avio_w8(ctx->pb, id); if (id >= 0xa0) { avio_w8(ctx->pb, 7); avio_wb16(ctx->pb, 4); avio_w8(ctx->pb, stream->lpcm_header[0]); avio_w8(ctx->pb, stream->lpcm_header[1]); avio_w8(ctx->pb, stream->lpcm_header[2]); } else if (id >= 0x40) { avio_w8(ctx->pb, nb_frames); avio_wb16(ctx->pb, trailer_size + 1); } } av_assert0(payload_size - stuffing_size <= av_fifo_size(stream->fifo)); av_fifo_generic_read(stream->fifo, ctx->pb, payload_size - stuffing_size, (void (*)(void*, void*, int))avio_write); stream->bytes_to_iframe -= payload_size - stuffing_size; } else { payload_size = stuffing_size = 0; } if (pad_packet_bytes > 0) put_padding_packet(ctx, ctx->pb, pad_packet_bytes); for (i = 0; i < zero_trail_bytes; i++) avio_w8(ctx->pb, 0x00); avio_flush(ctx->pb); s->packet_number++; if (!general_pack) stream->packet_number++; return payload_size - stuffing_size; }<SPLIT>[4.849543794064766, 4.475305291179225, 0.0, 4.7546327840692255, 4.253576799384415, 0.0, 6.879137264679877, 7.003879612049685, 6.710401158162677, -0.27925050329511203, 4.683926966773239, 4.938092764248659, 4.649087298280407, 0.0, 0.0, 0.30852482215402843, 4.4781022182382735, 4.839101956059183, 4.436951802244032, 2.4468711124637066, 7.593494511771995, 0.0, -0.08645738172306322, -0.16222078614455715, 4.154180263612463, 5.523932450961827, 2.6018347455872055, -0.21702784222394986, 7.350978288785571, 6.87704418252106, 7.00212132991662, 6.708434186314772, -0.27935383381430245, 3.475844538781386, 0.0, 6.865333107749872, 6.990364612460866, 6.696545755492066, -0.28182971586402455]
0<SPLIT>long WINAPI libAVMemInputPin_GetAllocator(libAVMemInputPin *this, IMemAllocator **alloc) { dshowdebug("libAVMemInputPin_GetAllocator(%p)\n", this); return VFW_E_NO_ALLOCATOR; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void mpv_encode_defaults(MpegEncContext *s) { int i; ff_mpv_common_defaults(s); for (i = -16; i < 16; i++) { default_fcode_tab[i + MAX_MV] = 1; } s->me.mv_penalty = default_mv_penalty; s->fcode_tab = default_fcode_tab; s->input_picture_number = 0; s->picture_in_gop_number = 0; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void check_external_clock_speed(VideoState *is) { if (is->video_stream >= 0 && is->videoq.nb_packets <= EXTERNAL_CLOCK_MIN_FRAMES || is->audio_stream >= 0 && is->audioq.nb_packets <= EXTERNAL_CLOCK_MIN_FRAMES) { set_clock_speed(&is->extclk, FFMAX(EXTERNAL_CLOCK_SPEED_MIN, is->extclk.speed - EXTERNAL_CLOCK_SPEED_STEP)); } else if ((is->video_stream < 0 || is->videoq.nb_packets > EXTERNAL_CLOCK_MAX_FRAMES) && (is->audio_stream < 0 || is->audioq.nb_packets > EXTERNAL_CLOCK_MAX_FRAMES)) { set_clock_speed(&is->extclk, FFMIN(EXTERNAL_CLOCK_SPEED_MAX, is->extclk.speed + EXTERNAL_CLOCK_SPEED_STEP)); } else { double speed = is->extclk.speed; if (speed != 1.0) set_clock_speed(&is->extclk, speed + EXTERNAL_CLOCK_SPEED_STEP * (1.0 - speed) / fabs(1.0 - speed)); } }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.3070243011888601, -0.22049944857796966, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int skip_tag(AVIOContext *in, int32_t tag_name) { int64_t pos = avio_tell(in); int32_t size, tag; size = avio_rb32(in); tag = avio_rb32(in); if (expect_tag(tag, tag_name) != 0) return -1; avio_seek(in, pos + size, SEEK_SET); return 0; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.39986248560786075, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.3615192241061562, -0.4462861841111837, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *inpic) { SmartblurContext *s = inlink->dst->priv; AVFilterLink *outlink = inlink->dst->outputs[0]; AVFrame *outpic; int cw = FF_CEIL_RSHIFT(inlink->w, s->hsub); int ch = FF_CEIL_RSHIFT(inlink->h, s->vsub); outpic = ff_get_video_buffer(outlink, outlink->w, outlink->h); if (!outpic) { av_frame_free(&inpic); return AVERROR(ENOMEM); } av_frame_copy_props(outpic, inpic); blur(outpic->data[0], outpic->linesize[0], inpic->data[0], inpic->linesize[0], inlink->w, inlink->h, s->luma.threshold, s->luma.filter_context); if (inpic->data[2]) { blur(outpic->data[1], outpic->linesize[1], inpic->data[1], inpic->linesize[1], cw, ch, s->chroma.threshold, s->chroma.filter_context); blur(outpic->data[2], outpic->linesize[2], inpic->data[2], inpic->linesize[2], cw, ch, s->chroma.threshold, s->chroma.filter_context); } av_frame_free(&inpic); return ff_filter_frame(outlink, outpic); }<SPLIT>[-0.25365086435942685, 0.0018768373536828752, 0.0, -0.2665172434374763, -0.06601402370422871, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.031089429262525795, -0.25297036047912586, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, -0.09407211557651925, -0.26569807294376846, -0.04662123679246273, 0.24712242304476825, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.08904460951967552, 0.23107402248845843, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static MpegTSFilter *mpegts_open_section_filter(MpegTSContext *ts, unsigned int pid, SectionCallback *section_cb, void *opaque, int check_crc) { MpegTSFilter *filter; MpegTSSectionFilter *sec; if (!(filter = mpegts_open_filter(ts, pid, MPEGTS_SECTION))) return NULL; sec = &filter->u.section_filter; sec->section_cb = section_cb; sec->opaque = opaque; sec->section_buf = av_malloc(MAX_SECTION_SIZE); sec->check_crc = check_crc; sec->last_ver = -1; if (!sec->section_buf) { av_free(filter); return NULL; } return filter; }<SPLIT>[-0.25365086435942685, -0.17441590959510697, 0.0, -0.2665172434374763, -0.23624420392447085, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1909204935349246, -0.25297036047912586, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.26569807294376846, -0.22331377035055117, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void send_next(AVFilterContext *ctx) { AStreamSyncContext *as = ctx->priv; int i; while (1) { if (!as->queue[as->next_out].nb) break; send_out(ctx, as->next_out); if (!as->eof) as->next_out = av_expr_eval(as->expr, as->var_values, NULL) >= 0; } for (i = 0; i < 2; i++) if (as->queue[i].nb == QUEUE_SIZE) send_out(ctx, i); }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.39986248560786075, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.3615192241061562, -0.4462861841111837, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { static const enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUYV422, AV_PIX_FMT_ARGB, AV_PIX_FMT_0RGB, AV_PIX_FMT_ABGR, AV_PIX_FMT_0BGR, AV_PIX_FMT_RGBA, AV_PIX_FMT_RGB0, AV_PIX_FMT_BGRA, AV_PIX_FMT_BGR0, AV_PIX_FMT_NONE }; AVFilterFormats *fmts_list = ff_make_format_list(pix_fmts); if (!fmts_list) return AVERROR(ENOMEM); return ff_set_common_formats(ctx, fmts_list); }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { static const enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_YUV410P, AV_PIX_FMT_YUV411P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV440P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUVJ440P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ411P, AV_PIX_FMT_YUVA420P, AV_PIX_FMT_YUVA422P, AV_PIX_FMT_YUVA444P, AV_PIX_FMT_GBRP, AV_PIX_FMT_GBRAP, AV_PIX_FMT_GRAY8, AV_PIX_FMT_NONE }; AVFilterFormats *fmts_list = ff_make_format_list(pix_fmts); if (!fmts_list) return AVERROR(ENOMEM); return ff_set_common_formats(ctx, fmts_list); }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.14106852214680915, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.3615192241061562, -0.10760608081136262, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int altivec_uyvy_rgb32(SwsContext *c, const unsigned char **in, int *instrides, int srcSliceY, int srcSliceH, unsigned char **oplanes, int *outstrides) { int w = c->srcW; int h = srcSliceH; int i, j; vector unsigned char uyvy; vector signed short Y, U, V; vector signed short R0, G0, B0, R1, G1, B1; vector unsigned char R, G, B; vector unsigned char *out; const ubyte *img; img = in[0]; out = (vector unsigned char *) (oplanes[0] + srcSliceY * outstrides[0]); for (i = 0; i < h; i++) for (j = 0; j < w / 16; j++) { uyvy = vec_ld(0, img); U = (vector signed short) vec_perm(uyvy, (vector unsigned char) { 0 }, demux_u); V = (vector signed short) vec_perm(uyvy, (vector unsigned char) { 0 }, demux_v); Y = (vector signed short) vec_perm(uyvy, (vector unsigned char) { 0 }, demux_y); cvtyuvtoRGB(c, Y, U, V, &R0, &G0, &B0); uyvy = vec_ld(16, img); U = (vector signed short) vec_perm(uyvy, (vector unsigned char) { 0 }, demux_u); V = (vector signed short) vec_perm(uyvy, (vector unsigned char) { 0 }, demux_v); Y = (vector signed short) vec_perm(uyvy, (vector unsigned char) { 0 }, demux_y); cvtyuvtoRGB(c, Y, U, V, &R1, &G1, &B1); R = vec_packclp(R0, R1); G = vec_packclp(G0, G1); B = vec_packclp(B0, B1); out_rgba(R, G, B, out); img += 32; } return srcSliceH; }<SPLIT>[-0.09900860198293619, 0.24427936440826892, 0.0, -0.11436118199787926, 0.16805247409860422, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.2086571671460724, -0.09566541730555662, 0.2728543002775131, 0.0, 0.0, 0.30852482215402843, 0.13841132512592785, -0.11100716297398205, 0.19633099684990887, 0.5059163865058198, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3950401602637228, 0.18343000506680518, 0.23107402248845843, -0.21702784222394986, 0.14602883551895066, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>int av_log_get_flags(void) { return flags; }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>static int decodeTonalComponents (GetBitContext *gb, tonal_component *pComponent, int numBands) { int i,j,k,cnt; int components, coding_mode_selector, coding_mode, coded_values_per_component; int sfIndx, coded_values, max_coded_values, quant_step_index, coded_components; int band_flags[4], mantissa[8]; float *pCoef; float scalefactor; int component_count = 0; components = get_bits(gb,5); if (components == 0) return 0; coding_mode_selector = get_bits(gb,2); if (coding_mode_selector == 2) return -1; coding_mode = coding_mode_selector & 1; for (i = 0; i < components; i++) { for (cnt = 0; cnt <= numBands; cnt++) band_flags[cnt] = get_bits1(gb); coded_values_per_component = get_bits(gb,3); quant_step_index = get_bits(gb,3); if (quant_step_index <= 1) return -1; if (coding_mode_selector == 3) coding_mode = get_bits1(gb); for (j = 0; j < (numBands + 1) * 4; j++) { if (band_flags[j >> 2] == 0) continue; coded_components = get_bits(gb,3); for (k=0; k<coded_components; k++) { sfIndx = get_bits(gb,6); pComponent[component_count].pos = j * 64 + (get_bits(gb,6)); max_coded_values = 1024 - pComponent[component_count].pos; coded_values = coded_values_per_component + 1; coded_values = FFMIN(max_coded_values,coded_values); scalefactor = ff_atrac_sf_table[sfIndx] * iMaxQuant[quant_step_index]; readQuantSpectralCoeffs(gb, quant_step_index, coding_mode, mantissa, coded_values); pComponent[component_count].numCoefs = coded_values; pCoef = pComponent[component_count].coef; for (cnt = 0; cnt < coded_values; cnt++) pCoef[cnt] = mantissa[cnt] * scalefactor; component_count++; } } } return component_count; }<SPLIT>[2.684552120793896, 0.3764989246198613, 0.0, 2.6244479239148673, 0.2957251092637858, 0.0, 0.9701672076669112, 0.9946065798247155, 0.9059316288753189, 1.699703585821447, 0.6881503599632689, 2.73582355981869, 0.40961158146510357, 0.0, 0.0, 0.30852482215402843, 0.603378206530822, 2.6734292164821736, 0.3288503970184752, 0.6353133682363457, 1.674211516036959, 0.0, -0.08645738172306322, -0.16222078614455715, 0.7463616652495864, 1.9272675384202815, 1.6986878034543498, -0.21702784222394986, 1.9238735058055194, 0.969587250454179, 0.9940939011734088, 0.9053924298597907, 1.6991165002636506, 2.6191065950439585, 0.0, 0.9653245912203542, 0.9897980601469931, 0.9011791483816026, 1.693548171012695]
0<SPLIT>enum AVPixelFormat ff_fmt_v4l2ff(uint32_t v4l2_fmt, enum AVCodecID codec_id) { int i; for (i = 0; ff_fmt_conversion_table[i].codec_id != AV_CODEC_ID_NONE; i++) { if (ff_fmt_conversion_table[i].v4l2_fmt == v4l2_fmt && ff_fmt_conversion_table[i].codec_id == codec_id) { return ff_fmt_conversion_table[i].ff_fmt; } } return AV_PIX_FMT_NONE; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int init_output_frame(AVFrame **frame, AVCodecContext *output_codec_context, int frame_size) { int error; if (!(*frame = av_frame_alloc())) { fprintf(stderr, "Could not allocate output frame\n"); return AVERROR_EXIT; } (*frame)->nb_samples = frame_size; (*frame)->channel_layout = output_codec_context->channel_layout; (*frame)->format = output_codec_context->sample_fmt; (*frame)->sample_rate = output_codec_context->sample_rate; if ((error = av_frame_get_buffer(*frame, 0)) < 0) { fprintf(stderr, "Could allocate output frame samples (error '%s')\n", get_error_text(error)); av_frame_free(frame); return error; } return 0; }<SPLIT>[1.6020562841584611, -0.1964525029637057, 0.0, 1.559355493837688, -0.2575229764520011, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.02884721983962376, 1.6346889576037051, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.03595125540090747, 1.5905928466936687, -0.24540033704531222, 0.24712242304476825, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.14353953243697165, -0.10760608081136262, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int cmp_color(const void *a, const void *b) { const struct range_box *box1 = a; const struct range_box *box2 = b; return box1->color - box2->color; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold int filter_init(AVFilterContext *ctx) { Frei0rContext *s = ctx->priv; return frei0r_init(ctx, s->dl_name, F0R_PLUGIN_TYPE_FILTER); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int test_butterflies_float(AVFloatDSPContext *fdsp, AVFloatDSPContext *cdsp, const float *v1, const float *v2) { LOCAL_ALIGNED(32, float, cv1, [LEN]); LOCAL_ALIGNED(32, float, cv2, [LEN]); LOCAL_ALIGNED(32, float, ov1, [LEN]); LOCAL_ALIGNED(32, float, ov2, [LEN]); int ret; memcpy(cv1, v1, LEN * sizeof(*v1)); memcpy(cv2, v2, LEN * sizeof(*v2)); memcpy(ov1, v1, LEN * sizeof(*v1)); memcpy(ov2, v2, LEN * sizeof(*v2)); cdsp->butterflies_float(cv1, cv2, LEN); fdsp->butterflies_float(ov1, ov2, LEN); if ((ret = compare_floats(cv1, ov1, LEN, FLT_EPSILON)) || (ret = compare_floats(cv2, ov2, LEN, FLT_EPSILON))) av_log(NULL, AV_LOG_ERROR, "butterflies_float failed\n"); return ret; }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, -0.011671540416283347, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.3615192241061562, -0.22049944857796966, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void apply_lut(HueContext *s, uint8_t *udst, uint8_t *vdst, const int dst_linesize, uint8_t *usrc, uint8_t *vsrc, const int src_linesize, int w, int h) { int i; while (h--) { for (i = 0; i < w; i++) { const int u = usrc[i]; const int v = vsrc[i]; udst[i] = s->lut_u[u][v]; vdst[i] = s->lut_v[u][v]; } usrc += src_linesize; vsrc += src_linesize; udst += dst_linesize; vdst += dst_linesize; } }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.0021777061216379156, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 3.3489446507317613, -0.03595125540090747, -0.26569807294376846, 0.01963846329182043, 0.8941073316973973, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.06167779621789984, 0.12893508214950905, 0.005287286955244392, -0.21702784222394986, 0.23959960763929639, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 0.04739993194876201]
0<SPLIT>static int audio_read_packet(AVFormatContext *s1, AVPacket *pkt) { OSSAudioData *s = s1->priv_data; int ret, bdelay; int64_t cur_time; struct audio_buf_info abufi; if ((ret=av_new_packet(pkt, s->frame_size)) < 0) return ret; ret = read(s->fd, pkt->data, pkt->size); if (ret <= 0){ av_free_packet(pkt); pkt->size = 0; if (ret<0) return AVERROR(errno); else return AVERROR_EOF; } pkt->size = ret; cur_time = av_gettime(); bdelay = ret; if (ioctl(s->fd, SNDCTL_DSP_GETISPACE, &abufi) == 0) { bdelay += abufi.bytes; } cur_time -= (bdelay * 1000000LL) / (s->sample_rate * s->channels); pkt->pts = cur_time; if (s->flip_left && s->channels == 2) { int i; short *p = (short *) pkt->data; for (i = 0; i < ret; i += 4) { *p = ~*p; p += 2; } } return 0; }<SPLIT>[0.21027592277004517, 0.06798661745947907, 0.0, 0.18995094088131478, -0.0021777061216379156, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, -0.27925050329511203, 0.08878386894177331, 0.21894446904158188, 0.0905112586940592, 0.0, 0.0, 0.30852482215402843, 0.022169604774704303, 0.19837465696559078, 0.01963846329182043, 0.5059163865058198, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, 0.11398295627503194, 0.6193893884051743, 0.5697541257882794, -0.21702784222394986, 0.6138826961206794, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, -0.27935383381430245, 0.9056307075691036, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, -0.28182971586402455]
0<SPLIT>static char get_media_type_char(enum AVMediaType type) { switch (type) { case AVMEDIA_TYPE_VIDEO: return 'V'; case AVMEDIA_TYPE_AUDIO: return 'A'; case AVMEDIA_TYPE_DATA: return 'D'; case AVMEDIA_TYPE_SUBTITLE: return 'S'; case AVMEDIA_TYPE_ATTACHMENT:return 'T'; default: return '?'; } }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.7880534307994381, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.1980344553542678, -0.6720729196443977, -0.21702784222394986, 0.23959960763929639, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, 0.04889276383167627, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *in) { AVFilterContext *ctx = inlink->dst; USPPContext *uspp = ctx->priv; AVFilterLink *outlink = ctx->outputs[0]; AVFrame *out = in; int qp_stride = 0; uint8_t *qp_table = NULL; if (!uspp->qp) { qp_table = av_frame_get_qp_table(in, &qp_stride, &uspp->qscale_type); if (qp_table && !uspp->use_bframe_qp && in->pict_type != AV_PICTURE_TYPE_B) { int w, h; if (!qp_stride) { w = FF_CEIL_RSHIFT(inlink->w, 4); h = 1; } else { w = qp_stride; h = FF_CEIL_RSHIFT(inlink->h, 4); } if (w * h > uspp->non_b_qp_alloc_size) { int ret = av_reallocp_array(&uspp->non_b_qp_table, w, h); if (ret < 0) { uspp->non_b_qp_alloc_size = 0; return ret; } uspp->non_b_qp_alloc_size = w * h; } av_assert0(w * h <= uspp->non_b_qp_alloc_size); memcpy(uspp->non_b_qp_table, qp_table, w * h); } } if (uspp->log2_count && !ctx->is_disabled) { if (!uspp->use_bframe_qp && uspp->non_b_qp_table) qp_table = uspp->non_b_qp_table; if (qp_table || uspp->qp) { if (!av_frame_is_writable(in) || (inlink->w & 7) || (inlink->h & 7)) { const int aligned_w = FFALIGN(inlink->w, 8); const int aligned_h = FFALIGN(inlink->h, 8); out = ff_get_video_buffer(outlink, aligned_w, aligned_h); if (!out) { av_frame_free(&in); return AVERROR(ENOMEM); } av_frame_copy_props(out, in); out->width = in->width; out->height = in->height; } filter(uspp, out->data, in->data, out->linesize, in->linesize, inlink->w, inlink->h, qp_table, qp_stride); } } if (in != out) { if (in->data[3]) av_image_copy_plane(out->data[3], out->linesize[3], in ->data[3], in ->linesize[3], inlink->w, inlink->h); av_frame_free(&in); } return ff_filter_frame(outlink, out); }<SPLIT>[0.9834872346524985, 0.6629746384116447, 0.0, 0.9507312480792999, 0.5723491521216792, 0.0, 1.3177536816088504, 1.3480932287791254, 1.2376156019774536, 1.040052222782594, 0.7281081260313685, 1.0054691849094282, 0.7059190240382162, 0.0, 0.0, 0.30852482215402843, 0.6421254466478965, 0.9718292068145229, 0.6159757640503689, 1.4116952586195004, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3950401602637228, 1.1098436946608394, 1.4729010679211356, -0.21702784222394986, 0.7074534682410251, 1.3170847170463484, 1.3475072793347742, 1.2369948159429325, 1.039626388904333, 2.6191065950439585, 0.0, 1.3123839157220905, 1.3427725632242797, 1.2323429545022004, 1.0350888753871217]
0<SPLIT>int main(int argc, char **argv) { uint8_t *input = av_malloc(MAX_INPUT_SIZE * 2); uint8_t *output = input + MAX_INPUT_SIZE; unsigned i, impl, size; int opt; while ((opt = getopt(argc, argv, "hl:a:r:")) != -1) { switch (opt) { case 'l': enabled_libs = optarg; break; case 'a': enabled_algos = optarg; break; case 'r': specified_runs = strtol(optarg, NULL, 0); break; case 'h': default: fprintf(stderr, "Usage: %s [-l libs] [-a algos] [-r runs]\n", argv[0]); if ((USE_EXT_LIBS)) { char buf[1024]; snprintf(buf, sizeof(buf), "%s%s%s", ((USE_EXT_LIBS) & USE_crypto) ? "+crypto" : "", ((USE_EXT_LIBS) & USE_gcrypt) ? "+gcrypt" : "", ((USE_EXT_LIBS) & USE_tomcrypt) ? "+tomcrypt" : ""); fprintf(stderr, "Built with the following external libraries:\n" "make VERSUS=%s\n", buf + 1); } else { fprintf(stderr, "Built without external libraries; use\n" "make VERSUS=crypto+gcrypt+tomcrypt tools/crypto_bench\n" "to enable them.\n"); } exit(opt != 'h'); } } if (!input) fatal_error("out of memory"); for (i = 0; i < MAX_INPUT_SIZE; i += 4) AV_WB32(input + i, i); size = MAX_INPUT_SIZE; for (impl = 0; impl < FF_ARRAY_ELEMS(implementations); impl++) run_implementation(input, output, &implementations[impl], size); av_free(input); return 0; }<SPLIT>[-0.25365086435942685, 0.3764989246198613, 0.0, -0.2665172434374763, 0.2957251092637858, 0.0, 0.7963739706959416, 0.2876332819158955, 0.7400896423242515, 1.3698779043020206, 0.3085515823163217, -0.25297036047912586, 0.40961158146510357, 0.0, 0.0, 0.30852482215402843, 0.23527942541861413, -0.26569807294376846, 0.3288503970184752, 1.0235043134279231, 1.2357461089454749, 0.0, -0.08645738172306322, -0.16222078614455715, 0.21937940777079099, 1.2188335404954318, 1.0213275968547075, 3.3782753486411963, 0.8945950124817165, 0.7958385171580944, 0.28726714485067795, 0.7395912368182198, 1.3693714445839917, 1.7623686513065309, 0.0, 0.791794928969486, 0.2838490539924199, 0.7355972453213037, 1.3643185231999084]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { ReverseContext *s = ctx->priv; av_freep(&s->pts); av_freep(&s->frames); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int vc1_decode_p_mb_intfr(VC1Context *v) { MpegEncContext *s = &v->s; GetBitContext *gb = &s->gb; int i; int mb_pos = s->mb_x + s->mb_y * s->mb_stride; int cbp = 0; int mqdiff, mquant; int ttmb = v->ttfrm; int mb_has_coeffs = 1; int dmv_x, dmv_y; int val; int first_block = 1; int dst_idx, off; int skipped, fourmv = 0, twomv = 0; int block_cbp = 0, pat, block_tt = 0; int idx_mbmode = 0, mvbp; int stride_y, fieldtx; mquant = v->pq; if (v->skip_is_raw) skipped = get_bits1(gb); else skipped = v->s.mbskip_table[mb_pos]; if (!skipped) { if (v->fourmvswitch) idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_INTFR_4MV_MBMODE_VLC_BITS, 2); else idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_INTFR_NON4MV_MBMODE_VLC_BITS, 2); switch (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0]) { case MV_PMODE_INTFR_4MV: fourmv = 1; v->blk_mv_type[s->block_index[0]] = 0; v->blk_mv_type[s->block_index[1]] = 0; v->blk_mv_type[s->block_index[2]] = 0; v->blk_mv_type[s->block_index[3]] = 0; break; case MV_PMODE_INTFR_4MV_FIELD: fourmv = 1; v->blk_mv_type[s->block_index[0]] = 1; v->blk_mv_type[s->block_index[1]] = 1; v->blk_mv_type[s->block_index[2]] = 1; v->blk_mv_type[s->block_index[3]] = 1; break; case MV_PMODE_INTFR_2MV_FIELD: twomv = 1; v->blk_mv_type[s->block_index[0]] = 1; v->blk_mv_type[s->block_index[1]] = 1; v->blk_mv_type[s->block_index[2]] = 1; v->blk_mv_type[s->block_index[3]] = 1; break; case MV_PMODE_INTFR_1MV: v->blk_mv_type[s->block_index[0]] = 0; v->blk_mv_type[s->block_index[1]] = 0; v->blk_mv_type[s->block_index[2]] = 0; v->blk_mv_type[s->block_index[3]] = 0; break; } if (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_INTRA) { for (i = 0; i < 4; i++) { s->current_picture.motion_val[1][s->block_index[i]][0] = 0; s->current_picture.motion_val[1][s->block_index[i]][1] = 0; } v->is_intra[s->mb_x] = 0x3f; s->mb_intra = 1; s->current_picture.mb_type[mb_pos] = MB_TYPE_INTRA; fieldtx = v->fieldtx_plane[mb_pos] = get_bits1(gb); mb_has_coeffs = get_bits1(gb); if (mb_has_coeffs) cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2); v->s.ac_pred = v->acpred_plane[mb_pos] = get_bits1(gb); GET_MQUANT(); s->current_picture.qscale_table[mb_pos] = mquant; s->y_dc_scale = s->y_dc_scale_table[mquant]; s->c_dc_scale = s->c_dc_scale_table[mquant]; dst_idx = 0; for (i = 0; i < 6; i++) { v->a_avail = v->c_avail = 0; v->mb_type[0][s->block_index[i]] = 1; s->dc_val[0][s->block_index[i]] = 0; dst_idx += i >> 2; val = ((cbp >> (5 - i)) & 1); if (i == 2 || i == 3 || !s->first_slice_line) v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]]; if (i == 1 || i == 3 || s->mb_x) v->c_avail = v->mb_type[0][s->block_index[i] - 1]; vc1_decode_intra_block(v, s->block[i], i, val, mquant, (i & 4) ? v->codingset2 : v->codingset); if (CONFIG_GRAY && (i > 3) && (s->avctx->flags & AV_CODEC_FLAG_GRAY)) continue; v->vc1dsp.vc1_inv_trans_8x8(s->block[i]); if (i < 4) { stride_y = s->linesize << fieldtx; off = (fieldtx) ? ((i & 1) * 8) + ((i & 2) >> 1) * s->linesize : (i & 1) * 8 + 4 * (i & 2) * s->linesize; } else { stride_y = s->uvlinesize; off = 0; } s->idsp.put_signed_pixels_clamped(s->block[i], s->dest[dst_idx] + off, stride_y); } } else { mb_has_coeffs = ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][3]; if (mb_has_coeffs) cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2); if (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_2MV_FIELD) { v->twomvbp = get_vlc2(gb, v->twomvbp_vlc->table, VC1_2MV_BLOCK_PATTERN_VLC_BITS, 1); } else { if ((ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_4MV) || (ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][0] == MV_PMODE_INTFR_4MV_FIELD)) { v->fourmvbp = get_vlc2(gb, v->fourmvbp_vlc->table, VC1_4MV_BLOCK_PATTERN_VLC_BITS, 1); } } s->mb_intra = v->is_intra[s->mb_x] = 0; for (i = 0; i < 6; i++) v->mb_type[0][s->block_index[i]] = 0; fieldtx = v->fieldtx_plane[mb_pos] = ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][1]; dst_idx = 0; if (fourmv) { mvbp = v->fourmvbp; for (i = 0; i < 4; i++) { dmv_x = dmv_y = 0; if (mvbp & (8 >> i)) get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0); ff_vc1_pred_mv_intfr(v, i, dmv_x, dmv_y, 0, v->range_x, v->range_y, v->mb_type[0], 0); ff_vc1_mc_4mv_luma(v, i, 0, 0); } ff_vc1_mc_4mv_chroma4(v, 0, 0, 0); } else if (twomv) { mvbp = v->twomvbp; dmv_x = dmv_y = 0; if (mvbp & 2) { get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0); } ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0], 0); ff_vc1_mc_4mv_luma(v, 0, 0, 0); ff_vc1_mc_4mv_luma(v, 1, 0, 0); dmv_x = dmv_y = 0; if (mvbp & 1) { get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0); } ff_vc1_pred_mv_intfr(v, 2, dmv_x, dmv_y, 2, v->range_x, v->range_y, v->mb_type[0], 0); ff_vc1_mc_4mv_luma(v, 2, 0, 0); ff_vc1_mc_4mv_luma(v, 3, 0, 0); ff_vc1_mc_4mv_chroma4(v, 0, 0, 0); } else { mvbp = ff_vc1_mbmode_intfrp[v->fourmvswitch][idx_mbmode][2]; dmv_x = dmv_y = 0; if (mvbp) { get_mvdata_interlaced(v, &dmv_x, &dmv_y, 0); } ff_vc1_pred_mv_intfr(v, 0, dmv_x, dmv_y, 1, v->range_x, v->range_y, v->mb_type[0], 0); ff_vc1_mc_1mv(v, 0); } if (cbp) GET_MQUANT(); s->current_picture.qscale_table[mb_pos] = mquant; if (!v->ttmbf && cbp) ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2); for (i = 0; i < 6; i++) { s->dc_val[0][s->block_index[i]] = 0; dst_idx += i >> 2; val = ((cbp >> (5 - i)) & 1); if (!fieldtx) off = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize); else off = (i & 4) ? 0 : ((i & 1) * 8 + ((i > 1) * s->linesize)); if (val) { pat = vc1_decode_p_block(v, s->block[i], i, mquant, ttmb, first_block, s->dest[dst_idx] + off, (i & 4) ? s->uvlinesize : (s->linesize << fieldtx), CONFIG_GRAY && (i & 4) && (s->avctx->flags & AV_CODEC_FLAG_GRAY), &block_tt); block_cbp |= pat << (i << 2); if (!v->ttmbf && ttmb < 8) ttmb = -1; first_block = 0; } } } } else { s->mb_intra = v->is_intra[s->mb_x] = 0; for (i = 0; i < 6; i++) { v->mb_type[0][s->block_index[i]] = 0; s->dc_val[0][s->block_index[i]] = 0; } s->current_picture.mb_type[mb_pos] = MB_TYPE_SKIP; s->current_picture.qscale_table[mb_pos] = 0; v->blk_mv_type[s->block_index[0]] = 0; v->blk_mv_type[s->block_index[1]] = 0; v->blk_mv_type[s->block_index[2]] = 0; v->blk_mv_type[s->block_index[3]] = 0; ff_vc1_pred_mv_intfr(v, 0, 0, 0, 1, v->range_x, v->range_y, v->mb_type[0], 0); ff_vc1_mc_1mv(v, 0); } if (s->mb_x == s->mb_width - 1) memmove(v->is_intra_base, v->is_intra, sizeof(v->is_intra_base[0])*s->mb_stride); return 0; }<SPLIT>[0.36491818514653585, 3.7040245232782696, 0.0, 0.34210700232091185, 3.508819760920856, 0.0, 2.8818928143475766, 2.9387831490739704, 2.7301934809370603, 1.040052222782594, 3.4052784525940485, 0.3762494122151511, 3.8513364913527965, 0.0, 0.0, 0.30852482215402843, 3.2381905344918893, 0.35306556693537716, 3.6639219679273944, 2.4468711124637066, 4.305003958585864, 0.0, -0.08645738172306322, -0.16222078614455715, 4.259576715108222, 3.7255999946910543, 3.053408216653634, -0.21702784222394986, 3.8888597203327793, 2.880823316711111, 2.937867481060918, 2.7292055533170707, 1.039626388904333, 3.475844538781386, 0.0, 2.8741508759799035, 2.9311578270720693, 2.722580082044891, 1.0350888753871217]
0<SPLIT>static int64_t update_size(AVIOContext *pb, int64_t pos) { int64_t curpos = avio_tell(pb); avio_seek(pb, pos, SEEK_SET); avio_wb32(pb, curpos - pos); avio_seek(pb, curpos, SEEK_SET); return curpos - pos; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int64_t mpegts_get_dts(AVFormatContext *s, int stream_index, int64_t *ppos, int64_t pos_limit) { MpegTSContext *ts = s->priv_data; int64_t pos; int pos47 = ts->pos47_full % ts->raw_packet_size; pos = ((*ppos + ts->raw_packet_size - 1 - pos47) / ts->raw_packet_size) * ts->raw_packet_size + pos47; ff_read_frame_flush(s); if (avio_seek(s->pb, pos, SEEK_SET) < 0) return AV_NOPTS_VALUE; while(pos < pos_limit) { int ret; AVPacket pkt; av_init_packet(&pkt); ret = av_read_frame(s, &pkt); if (ret < 0) return AV_NOPTS_VALUE; av_free_packet(&pkt); if (pkt.dts != AV_NOPTS_VALUE && pkt.pos >= 0) { ff_reduce_index(s, pkt.stream_index); av_add_index_entry(s->streams[pkt.stream_index], pkt.pos, pkt.dts, 0, 0, AVINDEX_KEYFRAME ); if (pkt.stream_index == stream_index && pkt.pos >= *ppos) { *ppos = pkt.pos; return pkt.dts; } } pos = pkt.pos; } return AV_NOPTS_VALUE; }<SPLIT>[-0.25365086435942685, 0.0018768373536828752, 0.0, -0.2665172434374763, -0.06601402370422871, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.031089429262525795, -0.25297036047912586, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, -0.09407211557651925, -0.26569807294376846, -0.04662123679246273, 0.37651940477529405, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.06167779621789984, -0.1980344553542678, 0.23107402248845843, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static MatroskaLevel1Element *matroska_find_level1_elem(MatroskaDemuxContext *matroska, uint32_t id) { int i; MatroskaLevel1Element *elem; if (!is_ebml_id_valid(id)) return NULL; if (id == MATROSKA_ID_CLUSTER) return NULL; if (id != MATROSKA_ID_SEEKHEAD) { for (i = 0; i < matroska->num_level1_elems; i++) { if (matroska->level1_elems[i].id == id) return &matroska->level1_elems[i]; } } if (matroska->num_level1_elems >= FF_ARRAY_ELEMS(matroska->level1_elems)) { av_log(matroska->ctx, AV_LOG_ERROR, "Too many level1 elements or circular seekheads.\n"); return NULL; } elem = &matroska->level1_elems[matroska->num_level1_elems++]; *elem = (MatroskaLevel1Element){.id = id}; return elem; }<SPLIT>[0.5195604475230265, -0.15237931622650824, 0.0, 0.4942630637605089, -0.21496543139694058, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.07104719533062549, 0.5335543553887203, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.13281935569359377, 0.5077564769051636, -0.2012272036557901, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.3615192241061562, -0.3333928163445767, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static av_cold int init(AVFilterContext *ctx) { OCVContext *s = ctx->priv; int i; if (!s->name) { av_log(ctx, AV_LOG_ERROR, "No libopencv filter name specified\n"); return AVERROR(EINVAL); } for (i = 0; i < FF_ARRAY_ELEMS(ocv_filter_entries); i++) { const OCVFilterEntry *entry = &ocv_filter_entries[i]; if (!strcmp(s->name, entry->name)) { s->init = entry->init; s->uninit = entry->uninit; s->end_frame_filter = entry->end_frame_filter; if (!(s->priv = av_mallocz(entry->priv_size))) return AVERROR(ENOMEM); return s->init(ctx, s->params); } } av_log(ctx, AV_LOG_ERROR, "No libopencv filter named '%s'\n", s->name); return AVERROR(EINVAL); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.23624420392447085, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.2490610760448173, -0.26569807294376846, -0.22331377035055117, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *buf) { BiquadsContext *s = inlink->dst->priv; AVFilterLink *outlink = inlink->dst->outputs[0]; AVFrame *out_buf; int nb_samples = buf->nb_samples; int ch; if (av_frame_is_writable(buf)) { out_buf = buf; } else { out_buf = ff_get_audio_buffer(inlink, nb_samples); if (!out_buf) return AVERROR(ENOMEM); av_frame_copy_props(out_buf, buf); } for (ch = 0; ch < av_frame_get_channels(buf); ch++) s->filter(buf->extended_data[ch], out_buf->extended_data[ch], nb_samples, &s->cache[ch].i1, &s->cache[ch].i2, &s->cache[ch].o1, &s->cache[ch].o2, s->b0, s->b1, s->b2, s->a1, s->a2); if (buf != out_buf) av_frame_free(&buf); return ff_filter_frame(outlink, out_buf); }<SPLIT>[-0.25365086435942685, -0.10830612948931077, 0.0, -0.2665172434374763, -0.17240788634188003, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.13098384443277505, -0.25297036047912586, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, -0.26569807294376846, -0.157054070266268, 0.37651940477529405, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.14353953243697165, 0.23107402248845843, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int config_input(AVFilterLink *inlink) { AVFilterContext *ctx = inlink->dst; BlackDetectContext *blackdetect = ctx->priv; blackdetect->black_min_duration = blackdetect->black_min_duration_time / av_q2d(inlink->time_base); blackdetect->pixel_black_th_i = ff_fmt_is_in(inlink->format, yuvj_formats) ? blackdetect->pixel_black_th * 255 : 16 + blackdetect->pixel_black_th * (235 - 16); av_log(blackdetect, AV_LOG_VERBOSE, "black_min_duration:%s pixel_black_th:%f pixel_black_th_i:%d picture_black_ratio_th:%f\n", av_ts2timestr(blackdetect->black_min_duration, &inlink->time_base), blackdetect->pixel_black_th, blackdetect->pixel_black_th_i, blackdetect->picture_black_ratio_th); return 0; }<SPLIT>[-0.09900860198293619, -0.30663546980669937, 0.0, -0.11436118199787926, -0.36391683908965244, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.29081490870517385, -0.09566541730555662, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.11100716297398205, -0.3558331705191175, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int vc1_decode_i_block(VC1Context *v, int16_t block[64], int n, int coded, int codingset) { GetBitContext *gb = &v->s.gb; MpegEncContext *s = &v->s; int dc_pred_dir = 0; int i; int16_t *dc_val; int16_t *ac_val, *ac_val2; int dcdiff, scale; if (n < 4) { dcdiff = get_vlc2(&s->gb, ff_msmp4_dc_luma_vlc[s->dc_table_index].table, DC_VLC_BITS, 3); } else { dcdiff = get_vlc2(&s->gb, ff_msmp4_dc_chroma_vlc[s->dc_table_index].table, DC_VLC_BITS, 3); } if (dcdiff < 0) { av_log(s->avctx, AV_LOG_ERROR, "Illegal DC VLC\n"); return -1; } if (dcdiff) { const int m = (v->pq == 1 || v->pq == 2) ? 3 - v->pq : 0; if (dcdiff == 119 ) { dcdiff = get_bits(gb, 8 + m); } else { if (m) dcdiff = (dcdiff << m) + get_bits(gb, m) - ((1 << m) - 1); } if (get_bits1(gb)) dcdiff = -dcdiff; } dcdiff += vc1_i_pred_dc(&v->s, v->overlap, v->pq, n, &dc_val, &dc_pred_dir); *dc_val = dcdiff; if (n < 4) scale = s->y_dc_scale; else scale = s->c_dc_scale; block[0] = dcdiff * scale; ac_val = s->ac_val[0][0] + s->block_index[n] * 16; ac_val2 = ac_val; if (dc_pred_dir) ac_val -= 16; else ac_val -= 16 * s->block_wrap[n]; scale = v->pq * 2 + v->halfpq; i = !!coded; if (coded) { int last = 0, skip, value; const uint8_t *zz_table; int k; if (v->s.ac_pred) { if (!dc_pred_dir) zz_table = v->zz_8x8[2]; else zz_table = v->zz_8x8[3]; } else zz_table = v->zz_8x8[1]; while (!last) { vc1_decode_ac_coeff(v, &last, &skip, &value, codingset); i += skip; if (i > 63) break; block[zz_table[i++]] = value; } if (s->ac_pred) { int sh; if (dc_pred_dir) { sh = v->left_blk_sh; } else { sh = v->top_blk_sh; ac_val += 8; } for (k = 1; k < 8; k++) block[k << sh] += ac_val[k]; } for (k = 1; k < 8; k++) { ac_val2[k] = block[k << v->left_blk_sh]; ac_val2[k + 8] = block[k << v->top_blk_sh]; } for (k = 1; k < 64; k++) if (block[k]) { block[k] *= scale; if (!v->pquantizer) block[k] += (block[k] < 0) ? -v->pq : v->pq; } } else { int k; memset(ac_val2, 0, 16 * 2); if (s->ac_pred) { int sh; if (dc_pred_dir) { sh = v->left_blk_sh; } else { sh = v->top_blk_sh; ac_val += 8; ac_val2 += 8; } memcpy(ac_val2, ac_val, 8 * 2); for (k = 1; k < 8; k++) { block[k << sh] = ac_val[k] * scale; if (!v->pquantizer && block[k << sh]) block[k << sh] += (block[k << sh] < 0) ? -v->pq : v->pq; } } } if (s->ac_pred) i = 63; s->block_last_index[n] = i; return 0; }<SPLIT>[0.9834872346524985, 1.7207311201043836, 0.0, 0.9507312480792999, 1.593730233443132, 0.0, 2.7080995773766072, 2.7620398245967652, 2.564351494385993, 1.040052222782594, 1.6870945116657614, 1.0054691849094282, 1.7999772735389399, 0.0, 0.0, 0.30852482215402843, 1.572059209457685, 0.9718292068145229, 1.6761309653988996, 1.670489222080552, 2.5511423302199274, 0.0, -0.08645738172306322, -0.16222078614455715, 1.6246654277142452, 2.1997421530067625, 1.5857944356877427, 0.6817979554923368, 2.391727366407248, 2.7070745834150265, 2.761160791980236, 2.5634043602755, 1.039626388904333, 1.7623686513065309, 0.0, 2.7006212137290357, 2.754670575533426, 2.556998178984592, 1.0350888753871217]
1<SPLIT>static int vorbis_parse_setup_hdr_floors(vorbis_context *vc) { GetBitContext *gb = &vc->gb; uint_fast16_t i,j,k; vc->floor_count = get_bits(gb, 6) + 1; vc->floors = av_mallocz(vc->floor_count * sizeof(vorbis_floor)); for (i = 0; i < vc->floor_count; ++i) { vorbis_floor *floor_setup = &vc->floors[i]; floor_setup->floor_type = get_bits(gb, 16); AV_DEBUG(" %d. floor type %d \n", i, floor_setup->floor_type); if (floor_setup->floor_type == 1) { uint_fast8_t maximum_class = 0; uint_fast8_t rangebits; uint_fast16_t floor1_values = 2; floor_setup->decode = vorbis_floor1_decode; floor_setup->data.t1.partitions = get_bits(gb, 5); AV_DEBUG(" %d.floor: %d partitions \n", i, floor_setup->data.t1.partitions); for (j = 0; j < floor_setup->data.t1.partitions; ++j) { floor_setup->data.t1.partition_class[j] = get_bits(gb, 4); if (floor_setup->data.t1.partition_class[j] > maximum_class) maximum_class = floor_setup->data.t1.partition_class[j]; AV_DEBUG(" %d. floor %d partition class %d \n", i, j, floor_setup->data.t1.partition_class[j]); } AV_DEBUG(" maximum class %d \n", maximum_class); floor_setup->data.t1.maximum_class = maximum_class; for (j = 0; j <= maximum_class; ++j) { floor_setup->data.t1.class_dimensions[j] = get_bits(gb, 3) + 1; floor_setup->data.t1.class_subclasses[j] = get_bits(gb, 2); AV_DEBUG(" %d floor %d class dim: %d subclasses %d \n", i, j, floor_setup->data.t1.class_dimensions[j], floor_setup->data.t1.class_subclasses[j]); if (floor_setup->data.t1.class_subclasses[j]) { GET_VALIDATED_INDEX(floor_setup->data.t1.class_masterbook[j], 8, vc->codebook_count) AV_DEBUG(" masterbook: %d \n", floor_setup->data.t1.class_masterbook[j]); } for (k = 0; k < (1 << floor_setup->data.t1.class_subclasses[j]); ++k) { int16_t bits = get_bits(gb, 8) - 1; if (bits != -1) VALIDATE_INDEX(bits, vc->codebook_count) floor_setup->data.t1.subclass_books[j][k] = bits; AV_DEBUG(" book %d. : %d \n", k, floor_setup->data.t1.subclass_books[j][k]); } } floor_setup->data.t1.multiplier = get_bits(gb, 2) + 1; floor_setup->data.t1.x_list_dim = 2; for (j = 0; j < floor_setup->data.t1.partitions; ++j) floor_setup->data.t1.x_list_dim+=floor_setup->data.t1.class_dimensions[floor_setup->data.t1.partition_class[j]]; floor_setup->data.t1.list = av_mallocz(floor_setup->data.t1.x_list_dim * sizeof(vorbis_floor1_entry)); rangebits = get_bits(gb, 4); floor_setup->data.t1.list[0].x = 0; floor_setup->data.t1.list[1].x = (1 << rangebits); for (j = 0; j < floor_setup->data.t1.partitions; ++j) { for (k = 0; k < floor_setup->data.t1.class_dimensions[floor_setup->data.t1.partition_class[j]]; ++k, ++floor1_values) { floor_setup->data.t1.list[floor1_values].x = get_bits(gb, rangebits); AV_DEBUG(" %d. floor1 Y coord. %d \n", floor1_values, floor_setup->data.t1.list[floor1_values].x); } } ff_vorbis_ready_floor1_list(floor_setup->data.t1.list, floor_setup->data.t1.x_list_dim); } else if (floor_setup->floor_type == 0) { uint_fast8_t max_codebook_dim = 0; floor_setup->decode = vorbis_floor0_decode; floor_setup->data.t0.order = get_bits(gb, 8); floor_setup->data.t0.rate = get_bits(gb, 16); floor_setup->data.t0.bark_map_size = get_bits(gb, 16); floor_setup->data.t0.amplitude_bits = get_bits(gb, 6); if (floor_setup->data.t0.amplitude_bits == 0) { av_log(vc->avccontext, AV_LOG_ERROR, "Floor 0 amplitude bits is 0.\n"); return -1; } floor_setup->data.t0.amplitude_offset = get_bits(gb, 8); floor_setup->data.t0.num_books = get_bits(gb, 4) + 1; floor_setup->data.t0.book_list = av_malloc(floor_setup->data.t0.num_books); if (!floor_setup->data.t0.book_list) return -1; { int idx; uint_fast8_t book_idx; for (idx = 0; idx < floor_setup->data.t0.num_books; ++idx) { GET_VALIDATED_INDEX(floor_setup->data.t0.book_list[idx], 8, vc->codebook_count) if (vc->codebooks[book_idx].dimensions > max_codebook_dim) max_codebook_dim = vc->codebooks[book_idx].dimensions; } } create_map(vc, i); { floor_setup->data.t0.lsp = av_malloc((floor_setup->data.t0.order+1 + max_codebook_dim) * sizeof(float)); if (!floor_setup->data.t0.lsp) return -1; } AV_DEBUG("floor0 order: %u\n", floor_setup->data.t0.order); AV_DEBUG("floor0 rate: %u\n", floor_setup->data.t0.rate); AV_DEBUG("floor0 bark map size: %u\n", floor_setup->data.t0.bark_map_size); AV_DEBUG("floor0 amplitude bits: %u\n", floor_setup->data.t0.amplitude_bits); AV_DEBUG("floor0 amplitude offset: %u\n", floor_setup->data.t0.amplitude_offset); AV_DEBUG("floor0 number of books: %u\n", floor_setup->data.t0.num_books); AV_DEBUG("floor0 book list pointer: %p\n", floor_setup->data.t0.book_list); { int idx; for (idx = 0; idx < floor_setup->data.t0.num_books; ++idx) { AV_DEBUG(" Book %d: %u\n", idx+1, floor_setup->data.t0.book_list[idx]); } } } else { av_log(vc->avccontext, AV_LOG_ERROR, "Invalid floor type!\n"); return -1; } } return 0; }<SPLIT>[6.2413241554531815, 1.941097053790371, 0.0, 6.124037337025599, 1.8065179587184346, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 2.566165365163955, 6.3538372528107825, 2.027906075518257, 0.0, 0.0, 0.30852482215402843, 2.4244984920333246, 6.231320145787262, 1.8969966323465102, 0.6353133682363457, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 2.221911986190213, -0.03454968660237938, 0.4568607580216725, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void videotoolbox_uninit(AVCodecContext *s) { InputStream *ist = s->opaque; VTContext *vt = ist->hwaccel_ctx; ist->hwaccel_uninit = NULL; ist->hwaccel_retrieve_data = NULL; av_frame_free(&vt->tmp_frame); if (ist->hwaccel_id == HWACCEL_VIDEOTOOLBOX) { #if CONFIG_VIDEOTOOLBOX av_videotoolbox_default_free(s); #endif } else { #if CONFIG_VDA av_vda_default_free(s); #endif } av_freep(&ist->hwaccel_ctx); }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.44417943729816173, -0.5292594673383866, -0.2988828158747199, 0.0, 0.13403667075800713, 2.1569430876889752, -0.4129993012037634, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int config_props_input(AVFilterLink *inlink) { AVFilterContext *ctx = inlink->dst; RemovelogoContext *s = ctx->priv; if (inlink->w != s->mask_w || inlink->h != s->mask_h) { av_log(ctx, AV_LOG_INFO, "Mask image size %dx%d does not match with the input video size %dx%d\n", s->mask_w, s->mask_h, inlink->w, inlink->h); return AVERROR(EINVAL); } return 0; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>DECLARE_COLOR_FUNCS(bgr, 2, 1, 0) static int config_input(AVFilterLink *inlink) { AVFilterContext *ctx = inlink->dst; DCTdnoizContext *s = ctx->priv; int i, x, y, bx, by, linesize, *iweights, max_slice_h, slice_h; const int bsize = 1 << s->n; switch (inlink->format) { case AV_PIX_FMT_BGR24: s->color_decorrelation = color_decorrelation_bgr; s->color_correlation = color_correlation_bgr; break; case AV_PIX_FMT_RGB24: s->color_decorrelation = color_decorrelation_rgb; s->color_correlation = color_correlation_rgb; break; default: av_assert0(0); } s->pr_width = inlink->w - (inlink->w - bsize) % s->step; s->pr_height = inlink->h - (inlink->h - bsize) % s->step; if (s->pr_width != inlink->w) av_log(ctx, AV_LOG_WARNING, "The last %d horizontal pixels won't be denoised\n", inlink->w - s->pr_width); if (s->pr_height != inlink->h) av_log(ctx, AV_LOG_WARNING, "The last %d vertical pixels won't be denoised\n", inlink->h - s->pr_height); max_slice_h = s->pr_height / ((s->bsize - 1) * 2); s->nb_threads = FFMIN3(MAX_THREADS, ctx->graph->nb_threads, max_slice_h); av_log(ctx, AV_LOG_DEBUG, "threads: [max=%d hmax=%d user=%d] => %d\n", MAX_THREADS, max_slice_h, ctx->graph->nb_threads, s->nb_threads); s->p_linesize = linesize = FFALIGN(s->pr_width, 32); for (i = 0; i < 2; i++) { s->cbuf[i][0] = av_malloc_array(linesize * s->pr_height, sizeof(*s->cbuf[i][0])); s->cbuf[i][1] = av_malloc_array(linesize * s->pr_height, sizeof(*s->cbuf[i][1])); s->cbuf[i][2] = av_malloc_array(linesize * s->pr_height, sizeof(*s->cbuf[i][2])); if (!s->cbuf[i][0] || !s->cbuf[i][1] || !s->cbuf[i][2]) return AVERROR(ENOMEM); } if (s->expr_str) { for (i = 0; i < s->nb_threads; i++) { int ret = av_expr_parse(&s->expr[i], s->expr_str, var_names, NULL, NULL, NULL, NULL, 0, ctx); if (ret < 0) return ret; } } slice_h = (int)ceilf(s->pr_height / (float)s->nb_threads) + (s->bsize - 1) * 2; for (i = 0; i < s->nb_threads; i++) { s->slices[i] = av_malloc_array(linesize, slice_h * sizeof(*s->slices[i])); if (!s->slices[i]) return AVERROR(ENOMEM); } s->weights = av_malloc(s->pr_height * linesize * sizeof(*s->weights)); if (!s->weights) return AVERROR(ENOMEM); iweights = av_calloc(s->pr_height, linesize * sizeof(*iweights)); if (!iweights) return AVERROR(ENOMEM); for (y = 0; y < s->pr_height - bsize + 1; y += s->step) for (x = 0; x < s->pr_width - bsize + 1; x += s->step) for (by = 0; by < bsize; by++) for (bx = 0; bx < bsize; bx++) iweights[(y + by)*linesize + x + bx]++; for (y = 0; y < s->pr_height; y++) for (x = 0; x < s->pr_width; x++) s->weights[y*linesize + x] = 1. / iweights[y*linesize + x]; av_free(iweights); return 0; }<SPLIT>[0.5195604475230265, 0.8613039787290333, 0.0, 0.4942630637605089, 0.7851368773969819, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.8479814242356677, 0.5335543553887203, 0.9110549458196018, 0.0, 0.0, 0.30852482215402843, 0.7777407870576574, 0.5077564769051636, 0.8368414309979795, 1.0235043134279231, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 1.203079621731209, 0.8918640029916549, 1.8115811712209564, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static av_cold int init(AVFilterContext *ctx) { ColorMatrixContext *color = ctx->priv; if (color->dest == COLOR_MODE_NONE) { av_log(ctx, AV_LOG_ERROR, "Unspecified destination color space\n"); return AVERROR(EINVAL); } if (color->source == color->dest) { av_log(ctx, AV_LOG_ERROR, "Source and destination color space must not be identical\n"); return AVERROR(EINVAL); } calc_coefficients(ctx); return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int write_fragments(struct Tracks *tracks, int start_index, AVIOContext *in, const char *basename, int split, int ismf, const char* output_prefix) { char dirname[2048], filename[2048], idxname[2048]; int i, j, ret = 0, fragment_ret; FILE* out = NULL; if (ismf) { snprintf(idxname, sizeof(idxname), "%s%s.ismf", output_prefix, basename); out = fopen(idxname, "w"); if (!out) { ret = AVERROR(errno); perror(idxname); goto fail; } } for (i = start_index; i < tracks->nb_tracks; i++) { struct Track *track = tracks->tracks[i]; const char *type = track->is_video ? "video" : "audio"; snprintf(dirname, sizeof(dirname), "%sQualityLevels(%d)", output_prefix, track->bitrate); if (split) { if (mkdir(dirname, 0777) == -1 && errno != EEXIST) { ret = AVERROR(errno); perror(dirname); goto fail; } } for (j = 0; j < track->chunks; j++) { snprintf(filename, sizeof(filename), "%s/Fragments(%s=%"PRId64")", dirname, type, track->offsets[j].time); avio_seek(in, track->offsets[j].offset, SEEK_SET); if (ismf) fprintf(out, "%s %"PRId64, filename, avio_tell(in)); if (split) fragment_ret = write_fragment(filename, in); else fragment_ret = skip_fragment(in); if (ismf) fprintf(out, " %"PRId64"\n", avio_tell(in)); if (fragment_ret != 0) { fprintf(stderr, "failed fragment %d in track %d (%s)\n", j, track->track_id, track->name); ret = fragment_ret; } } } fail: if (out) fclose(out); return ret; }<SPLIT>[-0.25365086435942685, 0.4646452980942562, 0.0, -0.2665172434374763, 0.38084019937390684, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, 0.3884671144525211, -0.25297036047912586, 0.5007831022568305, 0.0, 0.0, 0.30852482215402843, 0.31277390565276314, -0.26569807294376846, 0.4171966637975194, 1.2822982768889746, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2896437087679637, 0.8918640029916549, 1.6986878034543498, 0.6817979554923368, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { AVFilterFormats *formats; AVFilterChannelLayouts *layouts; static const enum AVSampleFormat sample_fmts[] = { AV_SAMPLE_FMT_S16P, AV_SAMPLE_FMT_S32P, AV_SAMPLE_FMT_FLTP, AV_SAMPLE_FMT_DBLP, AV_SAMPLE_FMT_NONE }; int ret; layouts = ff_all_channel_layouts(); if (!layouts) return AVERROR(ENOMEM); ret = ff_set_common_channel_layouts(ctx, layouts); if (ret < 0) return ret; formats = ff_make_format_list(sample_fmts); if (!formats) return AVERROR(ENOMEM); ret = ff_set_common_formats(ctx, formats); if (ret < 0) return ret; formats = ff_all_samplerates(); if (!formats) return AVERROR(ENOMEM); return ff_set_common_samplerates(ctx, formats); }<SPLIT>[-0.25365086435942685, -0.020159756014915854, 0.0, -0.2665172434374763, -0.08729279623175898, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.051068312296575644, -0.25297036047912586, -0.0006602620976677653, 0.0, 0.0, 0.30852482215402843, -0.1134457356350565, -0.26569807294376846, -0.06870780348722379, 0.37651940477529405, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, 0.0744401592322129, 0.34396739025506545, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>void av_xtea_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt) { int i; if (decrypt) { while (count--) { xtea_crypt_ecb(ctx, dst, src, decrypt, iv); src += 8; dst += 8; } } else { while (count--) { if (iv) { for (i = 0; i < 8; i++) dst[i] = src[i] ^ iv[i]; xtea_crypt_ecb(ctx, dst, dst, decrypt, NULL); memcpy(iv, dst, 8); } else { xtea_crypt_ecb(ctx, dst, src, decrypt, NULL); } src += 8; dst += 8; } } }<SPLIT>[-0.25365086435942685, -0.10830612948931077, 0.0, -0.2665172434374763, -0.17240788634188003, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, -0.13098384443277505, -0.25297036047912586, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, -0.26569807294376846, -0.157054070266268, -0.270465503877335, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.3070243011888601, -0.4462861841111837, -0.21702784222394986, -0.13468348084208653, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 1.7623686513065309, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static int mov_write_tkhd_tag(AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track, AVStream *st) { int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE, track->timescale, AV_ROUND_UP); int version = duration < INT32_MAX ? 0 : 1; int flags = MOV_TKHD_FLAG_IN_MOVIE; int rotation = 0; int group = 0; uint32_t *display_matrix = NULL; int display_matrix_size, i; if (st) { if (mov->per_stream_grouping) group = st->index; else group = st->codec->codec_type; display_matrix = (uint32_t*)av_stream_get_side_data(st, AV_PKT_DATA_DISPLAYMATRIX, &display_matrix_size); if (display_matrix && display_matrix_size < 9 * sizeof(*display_matrix)) display_matrix = NULL; } if (track->flags & MOV_TRACK_ENABLED) flags |= MOV_TKHD_FLAG_ENABLED; if (track->mode == MODE_ISM) version = 1; (version == 1) ? avio_wb32(pb, 104) : avio_wb32(pb, 92); ffio_wfourcc(pb, "tkhd"); avio_w8(pb, version); avio_wb24(pb, flags); if (version == 1) { avio_wb64(pb, track->time); avio_wb64(pb, track->time); } else { avio_wb32(pb, track->time); avio_wb32(pb, track->time); } avio_wb32(pb, track->track_id); avio_wb32(pb, 0); if (!track->entry && mov->mode == MODE_ISM) (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff); else if (!track->entry) (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0); else (version == 1) ? avio_wb64(pb, duration) : avio_wb32(pb, duration); avio_wb32(pb, 0); avio_wb32(pb, 0); avio_wb16(pb, 0); avio_wb16(pb, group); if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO) avio_wb16(pb, 0x0100); else avio_wb16(pb, 0); avio_wb16(pb, 0); if (st && st->metadata) { AVDictionaryEntry *rot = av_dict_get(st->metadata, "rotate", NULL, 0); rotation = (rot && rot->value) ? atoi(rot->value) : 0; } if (display_matrix) { for (i = 0; i < 9; i++) avio_wb32(pb, display_matrix[i]); } else if (rotation == 90) { write_matrix(pb, 0, 1, -1, 0, track->enc->height, 0); } else if (rotation == 180) { write_matrix(pb, -1, 0, 0, -1, track->enc->width, track->enc->height); } else if (rotation == 270) { write_matrix(pb, 0, -1, 1, 0, 0, track->enc->width); } else { write_matrix(pb, 1, 0, 0, 1, 0, 0); } if (st && (track->enc->codec_type == AVMEDIA_TYPE_VIDEO || track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE)) { if (track->mode == MODE_MOV) { avio_wb32(pb, track->enc->width << 16); avio_wb32(pb, track->height << 16); } else { int64_t track_width_1616 = av_rescale(st->sample_aspect_ratio.num, track->enc->width * 0x10000LL, st->sample_aspect_ratio.den); if (!track_width_1616 || track->height != track->enc->height || track_width_1616 > UINT32_MAX) track_width_1616 = track->enc->width * 0x10000U; avio_wb32(pb, track_width_1616); avio_wb32(pb, track->height * 0x10000U); } } else { avio_wb32(pb, 0); avio_wb32(pb, 0); } return 0x5c; }<SPLIT>[0.21027592277004517, 1.3461090328382055, 0.0, 0.18995094088131478, 1.2319911004751174, 0.0, 1.3177536816088504, 1.3480932287791254, 1.2376156019774536, -0.27925050329511203, 1.2475590849166647, 0.21894446904158188, 1.4124983101741002, 0.0, 0.0, 0.30852482215402843, 1.1458395681698652, 0.19837465696559078, 1.3006593315879615, 1.2822982768889746, 0.9068970536268617, 0.0, -0.08645738172306322, -0.16222078614455715, 1.09768317023545, 0.8373690800743588, 1.0213275968547075, -0.21702784222394986, 0.6138826961206794, 1.3170847170463484, 1.3475072793347742, 1.2369948159429325, -0.27935383381430245, 0.9056307075691036, 0.0, 1.3123839157220905, 1.3427725632242797, 1.2323429545022004, -0.28182971586402455]
0<SPLIT>static av_cold int adpcm_encode_close(AVCodecContext *avctx) { ADPCMEncodeContext *s = avctx->priv_data; av_freep(&s->paths); av_freep(&s->node_buf); av_freep(&s->nodep_buf); av_freep(&s->trellis_hash); return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void BAYER_RENAME(rgb24_interpolate)(const uint8_t *src, int src_stride, uint8_t *dst, int dst_stride, int width) { int i; BAYER_TO_RGB24_COPY src += 2 * BAYER_SIZEOF; dst += 6; for (i = 2 ; i < width - 2; i+= 2) { BAYER_TO_RGB24_INTERPOLATE src += 2 * BAYER_SIZEOF; dst += 6; } if (width > 2) { BAYER_TO_RGB24_COPY } }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_cold int aac_parse_init(AVCodecParserContext *s1) { AACAC3ParseContext *s = s1->priv_data; s->header_size = AAC_ADTS_HEADER_SIZE; s->sync = aac_sync; return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void update_sample_display(VideoState *is, short *samples, int samples_size) { int size, len; size = samples_size / sizeof(short); while (size > 0) { len = SAMPLE_ARRAY_SIZE - is->sample_array_index; if (len > size) len = size; memcpy(is->sample_array + is->sample_array_index, samples, len * sizeof(short)); samples += len; is->sample_array_index += len; if (is->sample_array_index >= SAMPLE_ARRAY_SIZE) is->sample_array_index = 0; size -= len; } }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.5292594673383866, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.1980344553542678, -0.4462861841111837, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int request_frame(AVFilterLink *link) { AVFilterContext *ctx = link->src; ThumbContext *thumb = ctx->priv; do { int ret = ff_request_frame(ctx->inputs[0]); if (ret == AVERROR_EOF && thumb->n) { ret = ff_filter_frame(link, get_best_frame(ctx)); if (ret < 0) return ret; ret = AVERROR_EOF; } if (ret < 0) return ret; } while (thumb->n); return 0; }<SPLIT>[0.05563366039355449, -0.2845988764381006, 0.0, 0.037794879441717756, -0.34263806656212215, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.25085714263707415, 0.061639525868012635, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, 0.04368374699580437, -0.33374660382435645, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static inline struct rgbvec interp_tetrahedral(const LUT3DContext *lut3d, const struct rgbvec *s) { const int prev[] = {PREV(s->r), PREV(s->g), PREV(s->b)}; const int next[] = {NEXT(s->r), NEXT(s->g), NEXT(s->b)}; const struct rgbvec d = {s->r - prev[0], s->g - prev[1], s->b - prev[2]}; const struct rgbvec c000 = lut3d->lut[prev[0]][prev[1]][prev[2]]; const struct rgbvec c111 = lut3d->lut[next[0]][next[1]][next[2]]; struct rgbvec c; if (d.r > d.g) { if (d.g > d.b) { const struct rgbvec c100 = lut3d->lut[next[0]][prev[1]][prev[2]]; const struct rgbvec c110 = lut3d->lut[next[0]][next[1]][prev[2]]; c.r = (1-d.r) * c000.r + (d.r-d.g) * c100.r + (d.g-d.b) * c110.r + (d.b) * c111.r; c.g = (1-d.r) * c000.g + (d.r-d.g) * c100.g + (d.g-d.b) * c110.g + (d.b) * c111.g; c.b = (1-d.r) * c000.b + (d.r-d.g) * c100.b + (d.g-d.b) * c110.b + (d.b) * c111.b; } else if (d.r > d.b) { const struct rgbvec c100 = lut3d->lut[next[0]][prev[1]][prev[2]]; const struct rgbvec c101 = lut3d->lut[next[0]][prev[1]][next[2]]; c.r = (1-d.r) * c000.r + (d.r-d.b) * c100.r + (d.b-d.g) * c101.r + (d.g) * c111.r; c.g = (1-d.r) * c000.g + (d.r-d.b) * c100.g + (d.b-d.g) * c101.g + (d.g) * c111.g; c.b = (1-d.r) * c000.b + (d.r-d.b) * c100.b + (d.b-d.g) * c101.b + (d.g) * c111.b; } else { const struct rgbvec c001 = lut3d->lut[prev[0]][prev[1]][next[2]]; const struct rgbvec c101 = lut3d->lut[next[0]][prev[1]][next[2]]; c.r = (1-d.b) * c000.r + (d.b-d.r) * c001.r + (d.r-d.g) * c101.r + (d.g) * c111.r; c.g = (1-d.b) * c000.g + (d.b-d.r) * c001.g + (d.r-d.g) * c101.g + (d.g) * c111.g; c.b = (1-d.b) * c000.b + (d.b-d.r) * c001.b + (d.r-d.g) * c101.b + (d.g) * c111.b; } } else { if (d.b > d.g) { const struct rgbvec c001 = lut3d->lut[prev[0]][prev[1]][next[2]]; const struct rgbvec c011 = lut3d->lut[prev[0]][next[1]][next[2]]; c.r = (1-d.b) * c000.r + (d.b-d.g) * c001.r + (d.g-d.r) * c011.r + (d.r) * c111.r; c.g = (1-d.b) * c000.g + (d.b-d.g) * c001.g + (d.g-d.r) * c011.g + (d.r) * c111.g; c.b = (1-d.b) * c000.b + (d.b-d.g) * c001.b + (d.g-d.r) * c011.b + (d.r) * c111.b; } else if (d.b > d.r) { const struct rgbvec c010 = lut3d->lut[prev[0]][next[1]][prev[2]]; const struct rgbvec c011 = lut3d->lut[prev[0]][next[1]][next[2]]; c.r = (1-d.g) * c000.r + (d.g-d.b) * c010.r + (d.b-d.r) * c011.r + (d.r) * c111.r; c.g = (1-d.g) * c000.g + (d.g-d.b) * c010.g + (d.b-d.r) * c011.g + (d.r) * c111.g; c.b = (1-d.g) * c000.b + (d.g-d.b) * c010.b + (d.b-d.r) * c011.b + (d.r) * c111.b; } else { const struct rgbvec c010 = lut3d->lut[prev[0]][next[1]][prev[2]]; const struct rgbvec c110 = lut3d->lut[next[0]][next[1]][prev[2]]; c.r = (1-d.g) * c000.r + (d.g-d.r) * c010.r + (d.r-d.b) * c110.r + (d.b) * c111.r; c.g = (1-d.g) * c000.g + (d.g-d.r) * c010.g + (d.r-d.b) * c110.g + (d.b) * c111.g; c.b = (1-d.g) * c000.b + (d.g-d.r) * c010.b + (d.r-d.b) * c110.b + (d.b) * c111.b; } } return c; }<SPLIT>[-0.25365086435942685, 0.48668189146285495, 0.0, -0.2665172434374763, 0.40211897190143714, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, -0.27925050329511203, 0.40844599748657096, -0.25297036047912586, 0.5235759824547622, 0.0, 0.0, 0.30852482215402843, 0.3321475257113004, -0.26569807294376846, 0.43928323049228046, 1.670489222080552, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, 0.6058330632552409, 0.7283792342397666, 1.5857944356877427, -0.21702784222394986, -0.04111270872174079, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, -0.27935383381430245, 0.9056307075691036, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, -0.28182971586402455]
0<SPLIT>static int select_sample_rate(AVCodec *codec) { const int *p; int best_samplerate = 0; if (!codec->supported_samplerates) return 44100; p = codec->supported_samplerates; while (*p) { best_samplerate = FFMAX(*p, best_samplerate); p++; } return best_samplerate; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.39986248560786075, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.1980344553542678, -0.4462861841111837, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int check(char *file) { uint8_t buffer[SIZE]; int fd, flags = O_RDONLY; int ret = 0; #ifdef O_BINARY flags |= O_BINARY; #endif if (file) fd = open(file, flags); else fd = 0; if (fd == -1) { printf("%s=OPEN-FAILED: %s:", av_hash_get_name(hash), strerror(errno)); ret = 1; goto end; } av_hash_init(hash); for (;;) { int size = read(fd, buffer, SIZE); if (size < 0) { int err = errno; close(fd); finish(); printf("+READ-FAILED: %s", strerror(err)); ret = 2; goto end; } else if(!size) break; av_hash_update(hash, buffer, size); } close(fd); finish(); end: if (file) printf(" *%s", file); printf("\n"); return ret; }<SPLIT>[-0.25365086435942685, 0.15613299093387398, 0.0, -0.2665172434374763, 0.08293738398848315, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 1.040052222782594, 0.10876275197582316, -0.25297036047912586, 0.11330413889199094, 0.0, 0.0, 0.30852482215402843, 0.04154322483324156, -0.26569807294376846, 0.04172502998658149, 0.5059163865058198, 1.674211516036959, 0.0, 0.02378964451747194, 0.9973611507722091, 0.21937940777079099, 1.327823386330024, 0.9084342290881006, 3.3782753486411963, 1.1753073288427536, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 1.039626388904333, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 1.0350888753871217]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { SineContext *sine = ctx->priv; av_freep(&sine->sin); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int mov_write_esds_tag(AVIOContext *pb, MOVTrack *track) { int64_t pos = avio_tell(pb); int decoder_specific_info_len = track->vos_len ? 5 + track->vos_len : 0; unsigned avg_bitrate; avio_wb32(pb, 0); ffio_wfourcc(pb, "esds"); avio_wb32(pb, 0); put_descr(pb, 0x03, 3 + 5+13 + decoder_specific_info_len + 5+1); avio_wb16(pb, track->track_id); avio_w8(pb, 0x00); put_descr(pb, 0x04, 13 + decoder_specific_info_len); if ((track->enc->codec_id == AV_CODEC_ID_MP2 || track->enc->codec_id == AV_CODEC_ID_MP3) && track->enc->sample_rate > 24000) avio_w8(pb, 0x6B); else avio_w8(pb, ff_codec_get_tag(ff_mp4_obj_type, track->enc->codec_id)); if (track->enc->codec_id == AV_CODEC_ID_DVD_SUBTITLE) avio_w8(pb, (0x38 << 2) | 1); else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO) avio_w8(pb, 0x15); else avio_w8(pb, 0x11); avio_wb24(pb, track->enc->rc_buffer_size >> 3); avg_bitrate = compute_avg_bitrate(track); avio_wb32(pb, FFMAX3(track->enc->bit_rate, track->enc->rc_max_rate, avg_bitrate)); avio_wb32(pb, avg_bitrate); if (track->vos_len) { put_descr(pb, 0x05, track->vos_len); avio_write(pb, track->vos_data, track->vos_len); } put_descr(pb, 0x06, 1); avio_w8(pb, 0x02); return update_size(pb, pos); }<SPLIT>[0.9834872346524985, 0.13409639756527525, 0.0, 0.9507312480792999, 0.06165861146095288, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.24861493321417213, 1.0054691849094282, 0.1588898992878544, 0.0, 0.0, 0.30852482215402843, 0.17715856524300236, 0.9718292068145229, 0.08589816337610359, 0.8941073316973973, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 0.14911510677361828, 0.0744401592322129, 0.6826474935548865, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int process_command(AVFilterContext *ctx, const char *cmd, const char *args, char *res, int res_len, int flags) { VolumeContext *vol = ctx->priv; int ret = AVERROR(ENOSYS); if (!strcmp(cmd, "volume")) { if ((ret = set_expr(&vol->volume_pexpr, args, ctx)) < 0) return ret; if (vol->eval_mode == EVAL_MODE_ONCE) set_volume(ctx); } return ret; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.14106852214680915, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.1980344553542678, -0.22049944857796966, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>int main(void) { AVCodec *enc = NULL, *dec = NULL; AVCodecContext *enc_ctx = NULL, *dec_ctx = NULL; uint64_t channel_layouts[] = {AV_CH_LAYOUT_STEREO, AV_CH_LAYOUT_5POINT1_BACK, AV_CH_LAYOUT_SURROUND, AV_CH_LAYOUT_STEREO_DOWNMIX}; int sample_rates[] = {8000, 44100, 48000, 192000}; int cl, sr; avcodec_register_all(); enc = avcodec_find_encoder(AV_CODEC_ID_FLAC); if (!enc) { av_log(NULL, AV_LOG_ERROR, "Can't find encoder\n"); return 1; } dec = avcodec_find_decoder(AV_CODEC_ID_FLAC); if (!dec) { av_log(NULL, AV_LOG_ERROR, "Can't find decoder\n"); return 1; } for (cl = 0; cl < FF_ARRAY_ELEMS(channel_layouts); cl++) { for (sr = 0; sr < FF_ARRAY_ELEMS(sample_rates); sr++) { if (init_encoder(enc, &enc_ctx, channel_layouts[cl], sample_rates[sr]) != 0) return 1; if (init_decoder(dec, &dec_ctx, channel_layouts[cl]) != 0) return 1; if (run_test(enc, dec, enc_ctx, dec_ctx) != 0) return 1; close_encoder(&enc_ctx); close_decoder(&dec_ctx); } } return 0; }<SPLIT>[-0.25365086435942685, 0.04595002409088034, 0.0, -0.2665172434374763, -0.02345647864916818, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, 0.008868336805573909, -0.25297036047912586, 0.06771837849612745, 0.0, 0.0, 0.30852482215402843, -0.05532487545944473, -0.26569807294376846, -0.0024481034029406237, 0.7647103499668715, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, 0.07885080577644558, 0.3469147738186936, 0.6826474935548865, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *picref) { AVFilterContext *ctx = inlink->dst; AVFilterLink *outlink = ctx->outputs[0]; AssContext *ass = ctx->priv; int detect_change = 0; double time_ms = picref->pts * av_q2d(inlink->time_base) * 1000; ASS_Image *image = ass_render_frame(ass->renderer, ass->track, time_ms, &detect_change); if (detect_change) av_log(ctx, AV_LOG_DEBUG, "Change happened at time ms:%f\n", time_ms); overlay_ass_image(ass, picref, image); return ff_filter_frame(outlink, picref); }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.011671540416283347, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.3070243011888601, 0.005287286955244392, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int request_frame(AVFilterLink *outlink) { StackContext *s = outlink->src->priv; return ff_framesync_request_frame(&s->fs, outlink); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int get_sample_rate(const char *samplerate) { int ret = strtol(samplerate, NULL, 0); return FFMAX(ret, 0); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { SelectContext *select = ctx->priv; int i; av_expr_free(select->expr); select->expr = NULL; for (i = 0; i < ctx->nb_outputs; i++) av_freep(&ctx->output_pads[i].name); if (select->do_scene_detect) { av_frame_free(&select->prev_picref); } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
1<SPLIT>int ff_h264_slice_context_init(H264Context *h, H264SliceContext *sl) { ERContext *er = &sl->er; int mb_array_size = h->mb_height * h->mb_stride; int y_size = (2 * h->mb_width + 1) * (2 * h->mb_height + 1); int c_size = h->mb_stride * (h->mb_height + 1); int yc_size = y_size + 2 * c_size; int x, y, i; sl->ref_cache[0][scan8[5] + 1] = sl->ref_cache[0][scan8[7] + 1] = sl->ref_cache[0][scan8[13] + 1] = sl->ref_cache[1][scan8[5] + 1] = sl->ref_cache[1][scan8[7] + 1] = sl->ref_cache[1][scan8[13] + 1] = PART_NOT_AVAILABLE; if (sl != h->slice_ctx) { memset(er, 0, sizeof(*er)); } else if (CONFIG_ERROR_RESILIENCE) { er->avctx = h->avctx; er->decode_mb = h264_er_decode_mb; er->opaque = h; er->quarter_sample = 1; er->mb_num = h->mb_num; er->mb_width = h->mb_width; er->mb_height = h->mb_height; er->mb_stride = h->mb_stride; er->b8_stride = h->mb_width * 2 + 1; FF_ALLOCZ_OR_GOTO(h->avctx, er->mb_index2xy, (h->mb_num + 1) * sizeof(int), fail); for (y = 0; y < h->mb_height; y++) for (x = 0; x < h->mb_width; x++) er->mb_index2xy[x + y * h->mb_width] = x + y * h->mb_stride; er->mb_index2xy[h->mb_height * h->mb_width] = (h->mb_height - 1) * h->mb_stride + h->mb_width; FF_ALLOCZ_OR_GOTO(h->avctx, er->error_status_table, mb_array_size * sizeof(uint8_t), fail); FF_ALLOC_OR_GOTO(h->avctx, er->er_temp_buffer, h->mb_height * h->mb_stride, fail); FF_ALLOCZ_OR_GOTO(h->avctx, sl->dc_val_base, yc_size * sizeof(int16_t), fail); er->dc_val[0] = sl->dc_val_base + h->mb_width * 2 + 2; er->dc_val[1] = sl->dc_val_base + y_size + h->mb_stride + 1; er->dc_val[2] = er->dc_val[1] + c_size; for (i = 0; i < yc_size; i++) sl->dc_val_base[i] = 1024; } return 0; fail: return AVERROR(ENOMEM); }<SPLIT>[1.9113408089114425, 0.4426087047256575, 0.0, 1.863667616716882, 0.3595614268463766, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.6481925938951691, 1.9492988439508436, 0.4779902220588988, 0.0, 0.0, 0.30852482215402843, 0.5646309664137475, 1.8999746666332415, 0.39511009710275835, 0.37651940477529405, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5355687622580682, 0.18343000506680518, 0.5697541257882794, 0.6817979554923368, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>AVFilterChannelLayouts *ff_all_channel_layouts(void) { AVFilterChannelLayouts *ret = av_mallocz(sizeof(*ret)); if (!ret) return NULL; ret->all_layouts = 1; return ret; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int config_input(AVFilterLink *inlink) { AVFilterContext *ctx = inlink->dst; AudioVectorScopeContext *s = ctx->priv; int nb_samples; nb_samples = FFMAX(1024, ((double)inlink->sample_rate / av_q2d(s->frame_rate)) + 0.5); inlink->partial_buf_size = inlink->min_samples = inlink->max_samples = nb_samples; return 0; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void flush(AVCodecContext *avctx) { AACContext *ac= avctx->priv_data; int type, i, j; for (type = 3; type >= 0; type--) { for (i = 0; i < MAX_ELEM_ID; i++) { ChannelElement *che = ac->che[type][i]; if (che) { for (j = 0; j <= 1; j++) { memset(che->ch[j].saved, 0, sizeof(che->ch[j].saved)); } } } } }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.3070243011888601, -0.3333928163445767, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int load_textfile(AVFilterContext *ctx) { DrawTextContext *s = ctx->priv; int err; uint8_t *textbuf; uint8_t *tmp; size_t textbuf_size; if ((err = av_file_map(s->textfile, &textbuf, &textbuf_size, 0, ctx)) < 0) { av_log(ctx, AV_LOG_ERROR, "The text file '%s' could not be read or is empty\n", s->textfile); return err; } if (textbuf_size > SIZE_MAX - 1 || !(tmp = av_realloc(s->text, textbuf_size + 1))) { av_file_unmap(textbuf, textbuf_size); return AVERROR(ENOMEM); } s->text = tmp; memcpy(s->text, textbuf, textbuf_size); s->text[textbuf_size] = 0; av_file_unmap(textbuf, textbuf_size); return 0; }<SPLIT>[-0.25365086435942685, -0.15237931622650824, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.17094161050087475, -0.25297036047912586, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, 0.24712242304476825, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.03454968660237938, 0.11818065472185141, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>void ff_rm_free_rmstream (RMStream *rms) { av_free_packet(&rms->pkt); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int iec61883_parse_queue_hdv(struct iec61883_data *dv, AVPacket *pkt) { DVPacket *packet; int size; while (dv->queue_first) { packet = dv->queue_first; size = avpriv_mpegts_parse_packet(dv->mpeg_demux, pkt, packet->buf, packet->len); dv->queue_first = packet->next; av_freep(&packet->buf); av_freep(&packet); dv->packets--; if (size > 0) return size; } return -1; }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int rtp_new_av_stream(HTTPContext *c, int stream_index, struct sockaddr_in *dest_addr, HTTPContext *rtsp_c) { AVFormatContext *ctx; AVStream *st; char *ipaddr; URLContext *h = NULL; uint8_t *dummy_buf; int max_packet_size; void *st_internal; ctx = avformat_alloc_context(); if (!ctx) return -1; ctx->oformat = av_guess_format("rtp", NULL, NULL); st = avformat_new_stream(ctx, NULL); if (!st) goto fail; st_internal = st->internal; if (!c->stream->feed || c->stream->feed == c->stream) unlayer_stream(st, c->stream->streams[stream_index]); else unlayer_stream(st, c->stream->feed->streams[c->stream->feed_streams[stream_index]]); av_assert0(st->priv_data == NULL); av_assert0(st->internal == st_internal); ipaddr = inet_ntoa(dest_addr->sin_addr); switch(c->rtp_protocol) { case RTSP_LOWER_TRANSPORT_UDP: case RTSP_LOWER_TRANSPORT_UDP_MULTICAST: if (c->stream->is_multicast) { int ttl; ttl = c->stream->multicast_ttl; if (!ttl) ttl = 16; snprintf(ctx->filename, sizeof(ctx->filename), "rtp: ipaddr, ntohs(dest_addr->sin_port), ttl); } else { snprintf(ctx->filename, sizeof(ctx->filename), "rtp: } if (ffurl_open(&h, ctx->filename, AVIO_FLAG_WRITE, NULL, NULL) < 0) goto fail; c->rtp_handles[stream_index] = h; max_packet_size = h->max_packet_size; break; case RTSP_LOWER_TRANSPORT_TCP: c->rtsp_c = rtsp_c; max_packet_size = RTSP_TCP_MAX_PACKET_SIZE; break; default: goto fail; } http_log("%s:%d - - \"PLAY %s/streamid=%d %s\"\n", ipaddr, ntohs(dest_addr->sin_port), c->stream->filename, stream_index, c->protocol); if (ffio_open_dyn_packet_buf(&ctx->pb, max_packet_size) < 0) goto fail; if (avformat_write_header(ctx, NULL) < 0) { fail: if (h) ffurl_close(h); av_free(st); av_free(ctx); return -1; } avio_close_dyn_buf(ctx->pb, &dummy_buf); ctx->pb = NULL; av_free(dummy_buf); c->rtp_ctx[stream_index] = ctx; return 0; }<SPLIT>[0.9834872346524985, 0.971486945572027, 0.0, 0.9507312480792999, 0.870251967507103, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 1.040052222782594, 1.0078124885080664, 1.0054691849094282, 1.0250193468092605, 0.0, 0.0, 0.30852482215402843, 0.9133561274674181, 0.9718292068145229, 0.9251876977770237, 1.9292831855416035, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, 0.7814938157481727, 1.0008538488262473, 1.5857944356877427, 0.6817979554923368, 0.33317037975964214, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 1.039626388904333, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 1.0350888753871217]
0<SPLIT>static void abgrToA_c(uint8_t *_dst, const uint8_t *src, const uint8_t *unused1, const uint8_t *unused2, int width, uint32_t *unused) { int16_t *dst = (int16_t *)_dst; int i; for (i=0; i<width; i++) { dst[i]= src[4*i]<<6; } }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.4705090699407485, -0.6720729196443977, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int av_write_uncoded_frame_query(AVFormatContext *s, int stream_index) { av_assert0(s->oformat); if (!s->oformat->write_uncoded_frame) return AVERROR(ENOSYS); return s->oformat->write_uncoded_frame(s, stream_index, NULL, AV_WRITE_UNCODED_FRAME_QUERY); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void push_output_configuration(AACContext *ac) { if (ac->oc[1].status == OC_LOCKED || ac->oc[0].status == OC_NONE) { ac->oc[0] = ac->oc[1]; } ac->oc[1].status = OC_NONE; } static void push_output_configuration(AACContext *ac) { if (ac->oc[1].status == OC_LOCKED || ac->oc[0].status == OC_NONE) { ac->oc[0] = ac->oc[1]; } ac->oc[1].status = OC_NONE; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.7880534307994381, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void toggle_mute(VideoState *is) { is->muted = !is->muted; }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void draw_blank_frame(AVFilterContext *ctx, AVFrame *out_buf) { TileContext *tile = ctx->priv; AVFilterLink *inlink = ctx->inputs[0]; unsigned x0, y0; get_current_tile_pos(ctx, &x0, &y0); ff_fill_rectangle(&tile->draw, &tile->blank, out_buf->data, out_buf->linesize, x0, y0, inlink->w, inlink->h); tile->current++; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.4705090699407485, -0.3333928163445767, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int write_chapter(NUTContext *nut, AVIOContext *bc, int id) { AVIOContext *dyn_bc; uint8_t *dyn_buf = NULL; AVDictionaryEntry *t = NULL; AVChapter *ch = nut->avf->chapters[id]; int ret, dyn_size, count = 0; ret = avio_open_dyn_buf(&dyn_bc); if (ret < 0) return ret; ff_put_v(bc, 0); put_s(bc, id + 1); put_tt(nut, nut->chapter[id].time_base, bc, ch->start); ff_put_v(bc, ch->end - ch->start); while ((t = av_dict_get(ch->metadata, "", t, AV_DICT_IGNORE_SUFFIX))) count += add_info(dyn_bc, t->key, t->value); ff_put_v(bc, count); dyn_size = avio_close_dyn_buf(dyn_bc, &dyn_buf); avio_write(bc, dyn_buf, dyn_size); av_freep(&dyn_buf); return 0; }<SPLIT>[-0.25365086435942685, -0.17441590959510697, 0.0, -0.2665172434374763, -0.23624420392447085, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1909204935349246, -0.25297036047912586, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.26569807294376846, -0.22331377035055117, 0.5059163865058198, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, 0.12893508214950905, 0.5697541257882794, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static char *get_metadata_val(AVFrame *insamples, const char *key) { AVDictionaryEntry *e = av_dict_get(insamples->metadata, key, NULL, 0); return e && e->value ? e->value : NULL; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int64_t log16(uint64_t a) { int i; int out = 0; if (a < 1 << 16) return -log16((1LL << 32) / a); a <<= 16; for (i = 20; i >= 0; i--) { int64_t b = exp16_table[i]; if (a < (b << 16)) continue; out |= 1 << i; a = ((a / b) << 16) + (((a % b) << 16) + b / 2) / b; } return out; }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.5292594673383866, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.1980344553542678, -0.5591795518777907, -0.21702784222394986, 0.14602883551895066, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>enum AVSampleFormat av_get_alt_sample_fmt(enum AVSampleFormat sample_fmt, int planar) { if (sample_fmt < 0 || sample_fmt >= AV_SAMPLE_FMT_NB) return AV_SAMPLE_FMT_NONE; if (sample_fmt_info[sample_fmt].planar == planar) return sample_fmt; return sample_fmt_info[sample_fmt].altform; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.7880534307994381, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5250039928580447, -0.6720729196443977, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static uint8_t *interpolate_bilinear(uint8_t *dst_color, const uint8_t *src, int src_linesize, int src_linestep, int x, int y, int max_x, int max_y) { int int_x = av_clip(x>>16, 0, max_x); int int_y = av_clip(y>>16, 0, max_y); int frac_x = x&0xFFFF; int frac_y = y&0xFFFF; int i; int int_x1 = FFMIN(int_x+1, max_x); int int_y1 = FFMIN(int_y+1, max_y); for (i = 0; i < src_linestep; i++) { int s00 = src[src_linestep * int_x + i + src_linesize * int_y ]; int s01 = src[src_linestep * int_x1 + i + src_linesize * int_y ]; int s10 = src[src_linestep * int_x + i + src_linesize * int_y1]; int s11 = src[src_linestep * int_x1 + i + src_linesize * int_y1]; int s0 = (((1<<16) - frac_x)*s00 + frac_x*s01); int s1 = (((1<<16) - frac_x)*s10 + frac_x*s11); dst_color[i] = ((int64_t)((1<<16) - frac_y)*s0 + (int64_t)frac_y*s1) >> 32; } return dst_color; }<SPLIT>[-0.25365086435942685, -0.17441590959510697, 0.0, -0.2665172434374763, -0.23624420392447085, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1909204935349246, -0.25297036047912586, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.26569807294376846, -0.22331377035055117, 0.8941073316973973, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, 0.29241985090139744, 0.9084342290881006, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int read_sm_data(AVFormatContext *s, AVIOContext *bc, AVPacket *pkt, int is_meta, int64_t maxpos) { int count = ffio_read_varlen(bc); int skip_start = 0; int skip_end = 0; int channels = 0; int64_t channel_layout = 0; int sample_rate = 0; int width = 0; int height = 0; int i, ret; for (i=0; i<count; i++) { uint8_t name[256], str_value[256], type_str[256]; int value; if (avio_tell(bc) >= maxpos) return AVERROR_INVALIDDATA; ret = get_str(bc, name, sizeof(name)); if (ret < 0) { av_log(s, AV_LOG_ERROR, "get_str failed while reading sm data\n"); return ret; } value = get_s(bc); if (value == -1) { ret = get_str(bc, str_value, sizeof(str_value)); if (ret < 0) { av_log(s, AV_LOG_ERROR, "get_str failed while reading sm data\n"); return ret; } av_log(s, AV_LOG_WARNING, "Unknown string %s / %s\n", name, str_value); } else if (value == -2) { uint8_t *dst = NULL; int64_t v64, value_len; ret = get_str(bc, type_str, sizeof(type_str)); if (ret < 0) { av_log(s, AV_LOG_ERROR, "get_str failed while reading sm data\n"); return ret; } value_len = ffio_read_varlen(bc); if (avio_tell(bc) + value_len >= maxpos) return AVERROR_INVALIDDATA; if (!strcmp(name, "Palette")) { dst = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, value_len); } else if (!strcmp(name, "Extradata")) { dst = av_packet_new_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, value_len); } else if (sscanf(name, "CodecSpecificSide%"SCNd64"", &v64) == 1) { dst = av_packet_new_side_data(pkt, AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL, value_len + 8); if(!dst) return AVERROR(ENOMEM); AV_WB64(dst, v64); dst += 8; } else if (!strcmp(name, "ChannelLayout") && value_len == 8) { channel_layout = avio_rl64(bc); continue; } else { av_log(s, AV_LOG_WARNING, "Unknown data %s / %s\n", name, type_str); avio_skip(bc, value_len); continue; } if(!dst) return AVERROR(ENOMEM); avio_read(bc, dst, value_len); } else if (value == -3) { value = get_s(bc); } else if (value == -4) { value = ffio_read_varlen(bc); } else if (value < -4) { get_s(bc); } else { if (!strcmp(name, "SkipStart")) { skip_start = value; } else if (!strcmp(name, "SkipEnd")) { skip_end = value; } else if (!strcmp(name, "Channels")) { channels = value; } else if (!strcmp(name, "SampleRate")) { sample_rate = value; } else if (!strcmp(name, "Width")) { width = value; } else if (!strcmp(name, "Height")) { height = value; } else { av_log(s, AV_LOG_WARNING, "Unknown integer %s\n", name); } } } if (channels || channel_layout || sample_rate || width || height) { uint8_t *dst = av_packet_new_side_data(pkt, AV_PKT_DATA_PARAM_CHANGE, 28); if (!dst) return AVERROR(ENOMEM); bytestream_put_le32(&dst, AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT*(!!channels) + AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT*(!!channel_layout) + AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE*(!!sample_rate) + AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS*(!!(width|height)) ); if (channels) bytestream_put_le32(&dst, channels); if (channel_layout) bytestream_put_le64(&dst, channel_layout); if (sample_rate) bytestream_put_le32(&dst, sample_rate); if (width || height){ bytestream_put_le32(&dst, width); bytestream_put_le32(&dst, height); } } if (skip_start || skip_end) { uint8_t *dst = av_packet_new_side_data(pkt, AV_PKT_DATA_SKIP_SAMPLES, 10); if (!dst) return AVERROR(ENOMEM); AV_WL32(dst, skip_start); AV_WL32(dst+4, skip_end); } if (avio_tell(bc) >= maxpos) return AVERROR_INVALIDDATA; return 0; }<SPLIT>[-0.25365086435942685, 1.9190604604217723, 0.0, -0.2665172434374763, 1.7852391861909045, 0.0, 3.4032725252604856, 3.4690131225055856, 3.559403413692397, 3.0190063118991532, 1.7070733946998113, -0.25297036047912586, 2.0051131953203254, 0.0, 0.0, 0.30852482215402843, 1.5914328295162223, -0.26569807294376846, 1.874910065651749, 2.317474130733181, 3.9761549032672514, 0.0, -0.08645738172306322, -0.16222078614455715, 1.6246654277142452, 2.6901964592624275, 2.1502612745207776, -0.21702784222394986, 2.859581227008977, 3.402069516599365, 3.467987548302966, 3.5582115185249252, 3.018096722982286, 1.7623686513065309, 0.0, 3.394739862732508, 3.4606195816879994, 3.5504895973463855, 3.0104667622638415]
0<SPLIT>static void set_tty_echo(int on) { #if HAVE_TERMIOS_H struct termios tty; if (tcgetattr(0, &tty) == 0) { if (on) tty.c_lflag |= ECHO; else tty.c_lflag &= ~ECHO; tcsetattr(0, TCSANOW, &tty); } #endif }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.593275147243893, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.6429585375510112, -0.7880534307994381, -0.518115519420462, 0.0, 0.5750247757201478, 0.9973611507722091, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int mov_write_string_metadata(AVFormatContext *s, AVIOContext *pb, const char *name, const char *tag, int long_style) { int l, lang = 0, len, len2; AVDictionaryEntry *t, *t2 = NULL; char tag2[16]; if (!(t = av_dict_get(s->metadata, tag, NULL, 0))) return 0; len = strlen(t->key); snprintf(tag2, sizeof(tag2), "%s-", tag); while ((t2 = av_dict_get(s->metadata, tag2, t2, AV_DICT_IGNORE_SUFFIX))) { len2 = strlen(t2->key); if (len2 == len + 4 && !strcmp(t->value, t2->value) && (l = ff_mov_iso639_to_lang(&t2->key[len2 - 3], 1)) >= 0) { lang = l; break; } } return mov_write_string_tag(pb, name, t->value, lang, long_style); }<SPLIT>[-0.25365086435942685, -0.1964525029637057, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.21089937656897445, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, 0.5059163865058198, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, 0.0744401592322129, 0.4568607580216725, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *buf) { AVFilterContext *ctx = inlink->dst; AlphaMergeContext *merge = ctx->priv; int ret = 0; int is_alpha = (inlink == ctx->inputs[1]); struct FFBufQueue *queue = (is_alpha ? &merge->queue_alpha : &merge->queue_main); ff_bufqueue_add(ctx, queue, buf); do { AVFrame *main_buf, *alpha_buf; if (!ff_bufqueue_peek(&merge->queue_main, 0) || !ff_bufqueue_peek(&merge->queue_alpha, 0)) break; main_buf = ff_bufqueue_get(&merge->queue_main); alpha_buf = ff_bufqueue_get(&merge->queue_alpha); merge->frame_requested = 0; draw_frame(ctx, main_buf, alpha_buf); ret = ff_filter_frame(ctx->outputs[0], main_buf); av_frame_free(&alpha_buf); } while (ret >= 0); return ret; }<SPLIT>[-0.25365086435942685, -0.17441590959510697, 0.0, -0.2665172434374763, -0.23624420392447085, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.1909204935349246, -0.25297036047912586, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.26569807294376846, -0.22331377035055117, 0.37651940477529405, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, 0.0744401592322129, 0.34396739025506545, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { AVFilterFormats *fmts_list = ff_make_format_list(formats_supported); if (!fmts_list) return AVERROR(ENOMEM); return ff_set_common_formats(ctx, fmts_list); }<SPLIT>[-0.09900860198293619, -0.5049648101240879, 0.0, -0.11436118199787926, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.09566541730555662, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.11100716297398205, -0.554612270771967, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { return ff_set_common_formats(ctx, ff_draw_supported_pixel_formats(0)); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int request_frame(AVFilterLink *outlink) { BlendContext *s = outlink->src->priv; return ff_dualinput_request_frame(&s->dinput, outlink); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int select_input_picture(MpegEncContext *s) { int i, ret; for (i = 1; i < MAX_PICTURE_COUNT; i++) s->reordered_input_picture[i - 1] = s->reordered_input_picture[i]; s->reordered_input_picture[MAX_PICTURE_COUNT - 1] = NULL; if (!s->reordered_input_picture[0] && s->input_picture[0]) { if (s->avctx->frame_skip_threshold || s->avctx->frame_skip_factor) { if (s->picture_in_gop_number < s->gop_size && s->next_picture_ptr && skip_check(s, s->input_picture[0], s->next_picture_ptr)) { av_frame_unref(s->input_picture[0]->f); ff_vbv_update(s, 0); goto no_output_pic; } } if ( !s->next_picture_ptr || s->intra_only) { s->reordered_input_picture[0] = s->input_picture[0]; s->reordered_input_picture[0]->f->pict_type = AV_PICTURE_TYPE_I; s->reordered_input_picture[0]->f->coded_picture_number = s->coded_picture_number++; } else { int b_frames; if (s->avctx->flags & AV_CODEC_FLAG_PASS2) { for (i = 0; i < s->max_b_frames + 1; i++) { int pict_num = s->input_picture[0]->f->display_picture_number + i; if (pict_num >= s->rc_context.num_entries) break; if (!s->input_picture[i]) { s->rc_context.entry[pict_num - 1].new_pict_type = AV_PICTURE_TYPE_P; break; } s->input_picture[i]->f->pict_type = s->rc_context.entry[pict_num].new_pict_type; } } if (s->avctx->b_frame_strategy == 0) { b_frames = s->max_b_frames; while (b_frames && !s->input_picture[b_frames]) b_frames--; } else if (s->avctx->b_frame_strategy == 1) { for (i = 1; i < s->max_b_frames + 1; i++) { if (s->input_picture[i] && s->input_picture[i]->b_frame_score == 0) { s->input_picture[i]->b_frame_score = get_intra_count(s, s->input_picture[i ]->f->data[0], s->input_picture[i - 1]->f->data[0], s->linesize) + 1; } } for (i = 0; i < s->max_b_frames + 1; i++) { if (!s->input_picture[i] || s->input_picture[i]->b_frame_score - 1 > s->mb_num / s->avctx->b_sensitivity) break; } b_frames = FFMAX(0, i - 1); for (i = 0; i < b_frames + 1; i++) { s->input_picture[i]->b_frame_score = 0; } } else if (s->avctx->b_frame_strategy == 2) { b_frames = estimate_best_b_count(s); } else { av_log(s->avctx, AV_LOG_ERROR, "illegal b frame strategy\n"); b_frames = 0; } emms_c(); for (i = b_frames - 1; i >= 0; i--) { int type = s->input_picture[i]->f->pict_type; if (type && type != AV_PICTURE_TYPE_B) b_frames = i; } if (s->input_picture[b_frames]->f->pict_type == AV_PICTURE_TYPE_B && b_frames == s->max_b_frames) { av_log(s->avctx, AV_LOG_ERROR, "warning, too many b frames in a row\n"); } if (s->picture_in_gop_number + b_frames >= s->gop_size) { if ((s->mpv_flags & FF_MPV_FLAG_STRICT_GOP) && s->gop_size > s->picture_in_gop_number) { b_frames = s->gop_size - s->picture_in_gop_number - 1; } else { if (s->avctx->flags & AV_CODEC_FLAG_CLOSED_GOP) b_frames = 0; s->input_picture[b_frames]->f->pict_type = AV_PICTURE_TYPE_I; } } if ((s->avctx->flags & AV_CODEC_FLAG_CLOSED_GOP) && b_frames && s->input_picture[b_frames]->f->pict_type == AV_PICTURE_TYPE_I) b_frames--; s->reordered_input_picture[0] = s->input_picture[b_frames]; if (s->reordered_input_picture[0]->f->pict_type != AV_PICTURE_TYPE_I) s->reordered_input_picture[0]->f->pict_type = AV_PICTURE_TYPE_P; s->reordered_input_picture[0]->f->coded_picture_number = s->coded_picture_number++; for (i = 0; i < b_frames; i++) { s->reordered_input_picture[i + 1] = s->input_picture[i]; s->reordered_input_picture[i + 1]->f->pict_type = AV_PICTURE_TYPE_B; s->reordered_input_picture[i + 1]->f->coded_picture_number = s->coded_picture_number++; } } } no_output_pic: if (s->reordered_input_picture[0]) { s->reordered_input_picture[0]->reference = s->reordered_input_picture[0]->f->pict_type != AV_PICTURE_TYPE_B ? 3 : 0; ff_mpeg_unref_picture(s->avctx, &s->new_picture); if ((ret = ff_mpeg_ref_picture(s->avctx, &s->new_picture, s->reordered_input_picture[0]))) return ret; if (s->reordered_input_picture[0]->shared || s->avctx->rc_buffer_size) { Picture *pic; int i = ff_find_unused_picture(s->avctx, s->picture, 0); if (i < 0) return i; pic = &s->picture[i]; pic->reference = s->reordered_input_picture[0]->reference; if (alloc_picture(s, pic, 0) < 0) { return -1; } ret = av_frame_copy_props(pic->f, s->reordered_input_picture[0]->f); if (ret < 0) return ret; av_frame_unref(s->reordered_input_picture[0]->f); s->reordered_input_picture[0]->shared = 0; s->current_picture_ptr = pic; } else { s->current_picture_ptr = s->reordered_input_picture[0]; for (i = 0; i < 4; i++) { s->new_picture.f->data[i] += INPLACE_OFFSET; } } ff_mpeg_unref_picture(s->avctx, &s->current_picture); if ((ret = ff_mpeg_ref_picture(s->avctx, &s->current_picture, s->current_picture_ptr)) < 0) return ret; s->picture_number = s->new_picture.f->display_picture_number; } else { ff_mpeg_unref_picture(s->avctx, &s->new_picture); } return 0; }<SPLIT>[0.8288449722760078, 2.5581216681111356, 0.0, 0.798575186639703, 2.4023235894892823, 0.0, 3.924652236173394, 3.9992430959372007, 3.7252454002434643, 3.0190063118991532, 2.426313183925606, 0.8481642417358589, 2.6661067210603457, 0.0, 0.0, 0.30852482215402843, 2.2888831516235637, 0.8171382968447365, 2.5154204997998195, 1.4116952586195004, 2.4415259784470567, 0.0, -0.08645738172306322, -0.16222078614455715, 1.9408547822015223, 2.908176150931612, 1.4729010679211356, -0.21702784222394986, 3.7952889482124337, 3.9233157164876196, 3.998107615545014, 3.724012711566496, 3.018096722982286, 3.475844538781386, 0.0, 3.9153288494851126, 3.990081336303929, 3.7160715004066844, 3.0104667622638415]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { Frei0rContext *s = ctx->priv; AVFilterFormats *formats = NULL; if (s->plugin_info.color_model == F0R_COLOR_MODEL_BGRA8888) { ff_add_format(&formats, AV_PIX_FMT_BGRA); } else if (s->plugin_info.color_model == F0R_COLOR_MODEL_RGBA8888) { ff_add_format(&formats, AV_PIX_FMT_RGBA); } else { static const enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_BGRA, AV_PIX_FMT_ARGB, AV_PIX_FMT_ABGR, AV_PIX_FMT_ARGB, AV_PIX_FMT_NONE }; formats = ff_make_format_list(pix_fmts); } if (!formats) return AVERROR(ENOMEM); return ff_set_common_formats(ctx, formats); }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.14106852214680915, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.25252937827156396, -0.10760608081136262, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>int main(void) { AVDES d; int i; #ifdef GENTABLES int j; #endif uint64_t key[3]; uint64_t data; uint64_t ct; uint64_t roundkeys[16]; srand(av_gettime()); key[0] = AV_RB64(test_key); data = AV_RB64(plain); gen_roundkeys(roundkeys, key[0]); if (des_encdec(data, roundkeys, 0) != AV_RB64(crypt)) { printf("Test 1 failed\n"); return 1; } av_des_init(&d, test_key, 64, 0); av_des_crypt(&d, tmp, plain, 1, NULL, 0); if (memcmp(tmp, crypt, sizeof(crypt))) { printf("Public API decryption failed\n"); return 1; } if (!run_test(0, 0) || !run_test(0, 1) || !run_test(1, 0) || !run_test(1, 1)) { printf("Partial Monte-Carlo test failed\n"); return 1; } for (i = 0; i < 1000; i++) { key[0] = rand64(); key[1] = rand64(); key[2] = rand64(); data = rand64(); av_des_init(&d, (uint8_t*)key, 192, 0); av_des_crypt(&d, (uint8_t*)&ct, (uint8_t*)&data, 1, NULL, 0); av_des_init(&d, (uint8_t*)key, 192, 1); av_des_crypt(&d, (uint8_t*)&ct, (uint8_t*)&ct, 1, NULL, 1); if (ct != data) { printf("Test 2 failed\n"); return 1; } } #ifdef GENTABLES printf("static const uint32_t S_boxes_P_shuffle[8][64] = {\n"); for (i = 0; i < 8; i++) { printf(" {"); for (j = 0; j < 64; j++) { uint32_t v = S_boxes[i][j >> 1]; v = j & 1 ? v >> 4 : v & 0xf; v <<= 28 - 4 * i; v = shuffle(v, P_shuffle, sizeof(P_shuffle)); printf((j & 7) == 0 ? "\n " : " "); printf("0x%08X,", v); } printf("\n },\n"); } printf("};\n"); #endif return 0; }<SPLIT>[-0.25365086435942685, 0.6189014516744473, 0.0, -0.2665172434374763, 0.5297916070666188, 0.0, 0.44878749675400254, 0.46437660639310047, 0.9059316288753189, 1.3698779043020206, 0.52831929569087, -0.25297036047912586, 0.22726853988164963, 0.0, 0.0, 0.30852482215402843, 0.44838924606252395, -0.26569807294376846, 0.15215786346038676, 0.6353133682363457, 0.9068970536268617, 0.0, 1.5672480118849643, 2.1569430876889752, 0.9220224177425181, 0.8918640029916549, 0.5697541257882794, -0.21702784222394986, 1.081736556722408, 0.4483410505659248, 0.46397383393136066, 0.9053924298597907, 1.3693714445839917, 0.9056307075691036, 0.0, 0.4447356044677496, 0.4603363055310632, 0.9011791483816026, 1.3643185231999084]
0<SPLIT>unsigned long WINAPI libAVMemInputPin_AddRef(libAVMemInputPin *this) { libAVPin *pin = (libAVPin *) ((uint8_t *) this - imemoffset); dshowdebug("libAVMemInputPin_AddRef(%p)\n", this); return libAVPin_AddRef(pin); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void dilate_end_frame_filter(AVFilterContext *ctx, IplImage *inimg, IplImage *outimg) { OCVContext *s = ctx->priv; DilateContext *dilate = s->priv; cvDilate(inimg, outimg, dilate->kernel, dilate->nb_iterations); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>const char *av_get_sample_fmt_name(enum AVSampleFormat sample_fmt) { if (sample_fmt < 0 || sample_fmt >= AV_SAMPLE_FMT_NB) return NULL; return sample_fmt_info[sample_fmt].name; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void avfilter_graph_set_auto_convert(AVFilterGraph *graph, unsigned flags) { graph->disable_auto_convert = flags; }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int mkv_query_codec(enum AVCodecID codec_id, int std_compliance) { int i; for (i = 0; ff_mkv_codec_tags[i].id != AV_CODEC_ID_NONE; i++) if (ff_mkv_codec_tags[i].id == codec_id) return 1; if (std_compliance < FF_COMPLIANCE_NORMAL) { enum AVMediaType type = avcodec_get_type(codec_id); if (type == AVMEDIA_TYPE_VIDEO || type == AVMEDIA_TYPE_AUDIO) return 1; } return 0; }<SPLIT>[-0.09900860198293619, -0.3727452499124955, 0.0, -0.11436118199787926, -0.42775315667224323, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.3507515578073234, -0.09566541730555662, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.11100716297398205, -0.42209287060340067, -0.5292594673383866, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.1980344553542678, -0.22049944857796966, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { HueContext *hue = ctx->priv; av_expr_free(hue->brightness_pexpr); av_expr_free(hue->hue_deg_pexpr); av_expr_free(hue->hue_pexpr); av_expr_free(hue->saturation_pexpr); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void decorrelation(PSContext *ps, INTFLOAT (*out)[32][2], const INTFLOAT (*s)[32][2], int is34) { LOCAL_ALIGNED_16(INTFLOAT, power, [34], [PS_QMF_TIME_SLOTS]); LOCAL_ALIGNED_16(INTFLOAT, transient_gain, [34], [PS_QMF_TIME_SLOTS]); INTFLOAT *peak_decay_nrg = ps->peak_decay_nrg; INTFLOAT *power_smooth = ps->power_smooth; INTFLOAT *peak_decay_diff_smooth = ps->peak_decay_diff_smooth; INTFLOAT (*delay)[PS_QMF_TIME_SLOTS + PS_MAX_DELAY][2] = ps->delay; INTFLOAT (*ap_delay)[PS_AP_LINKS][PS_QMF_TIME_SLOTS + PS_MAX_AP_DELAY][2] = ps->ap_delay; #if !USE_FIXED const float transient_impact = 1.5f; const float a_smooth = 0.25f; #endif const int8_t *k_to_i = is34 ? k_to_i_34 : k_to_i_20; int i, k, m, n; int n0 = 0, nL = 32; const INTFLOAT peak_decay_factor = Q31(0.76592833836465f); memset(power, 0, 34 * sizeof(*power)); if (is34 != ps->is34bands_old) { memset(ps->peak_decay_nrg, 0, sizeof(ps->peak_decay_nrg)); memset(ps->power_smooth, 0, sizeof(ps->power_smooth)); memset(ps->peak_decay_diff_smooth, 0, sizeof(ps->peak_decay_diff_smooth)); memset(ps->delay, 0, sizeof(ps->delay)); memset(ps->ap_delay, 0, sizeof(ps->ap_delay)); } for (k = 0; k < NR_BANDS[is34]; k++) { int i = k_to_i[k]; ps->dsp.add_squares(power[i], s[k], nL - n0); } #if USE_FIXED for (i = 0; i < NR_PAR_BANDS[is34]; i++) { for (n = n0; n < nL; n++) { int decayed_peak; int denom; decayed_peak = (int)(((int64_t)peak_decay_factor * \ peak_decay_nrg[i] + 0x40000000) >> 31); peak_decay_nrg[i] = FFMAX(decayed_peak, power[i][n]); power_smooth[i] += (power[i][n] - power_smooth[i] + 2) >> 2; peak_decay_diff_smooth[i] += (peak_decay_nrg[i] - power[i][n] - \ peak_decay_diff_smooth[i] + 2) >> 2; denom = peak_decay_diff_smooth[i] + (peak_decay_diff_smooth[i] >> 1); if (denom > power_smooth[i]) { int p = power_smooth[i]; while (denom < 0x40000000) { denom <<= 1; p <<= 1; } transient_gain[i][n] = p / (denom >> 16); } else { transient_gain[i][n] = 1 << 16; } } } #else for (i = 0; i < NR_PAR_BANDS[is34]; i++) { for (n = n0; n < nL; n++) { float decayed_peak = peak_decay_factor * peak_decay_nrg[i]; float denom; peak_decay_nrg[i] = FFMAX(decayed_peak, power[i][n]); power_smooth[i] += a_smooth * (power[i][n] - power_smooth[i]); peak_decay_diff_smooth[i] += a_smooth * (peak_decay_nrg[i] - power[i][n] - peak_decay_diff_smooth[i]); denom = transient_impact * peak_decay_diff_smooth[i]; transient_gain[i][n] = (denom > power_smooth[i]) ? power_smooth[i] / denom : 1.0f; } } #endif for (k = 0; k < NR_ALLPASS_BANDS[is34]; k++) { int b = k_to_i[k]; #if USE_FIXED int g_decay_slope; if (k - DECAY_CUTOFF[is34] <= 0) { g_decay_slope = 1 << 30; } else if (k - DECAY_CUTOFF[is34] >= 20) { g_decay_slope = 0; } else { g_decay_slope = (1 << 30) - DECAY_SLOPE * (k - DECAY_CUTOFF[is34]); } #else float g_decay_slope = 1.f - DECAY_SLOPE * (k - DECAY_CUTOFF[is34]); g_decay_slope = av_clipf(g_decay_slope, 0.f, 1.f); #endif memcpy(delay[k], delay[k]+nL, PS_MAX_DELAY*sizeof(delay[k][0])); memcpy(delay[k]+PS_MAX_DELAY, s[k], numQMFSlots*sizeof(delay[k][0])); for (m = 0; m < PS_AP_LINKS; m++) { memcpy(ap_delay[k][m], ap_delay[k][m]+numQMFSlots, 5*sizeof(ap_delay[k][m][0])); } ps->dsp.decorrelate(out[k], delay[k] + PS_MAX_DELAY - 2, ap_delay[k], phi_fract[is34][k], (const INTFLOAT (*)[2]) Q_fract_allpass[is34][k], transient_gain[b], g_decay_slope, nL - n0); } for (; k < SHORT_DELAY_BAND[is34]; k++) { int i = k_to_i[k]; memcpy(delay[k], delay[k]+nL, PS_MAX_DELAY*sizeof(delay[k][0])); memcpy(delay[k]+PS_MAX_DELAY, s[k], numQMFSlots*sizeof(delay[k][0])); ps->dsp.mul_pair_single(out[k], delay[k] + PS_MAX_DELAY - 14, transient_gain[i], nL - n0); } for (; k < NR_BANDS[is34]; k++) { int i = k_to_i[k]; memcpy(delay[k], delay[k]+nL, PS_MAX_DELAY*sizeof(delay[k][0])); memcpy(delay[k]+PS_MAX_DELAY, s[k], numQMFSlots*sizeof(delay[k][0])); ps->dsp.mul_pair_single(out[k], delay[k] + PS_MAX_DELAY - 1, transient_gain[i], nL - n0); } }<SPLIT>[1.4474140217819704, 1.764804306841581, 0.0, 1.4071994323980908, 1.6362877784981926, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 1.7869889268360106, 1.477384014430136, 0.8882620656216701, 0.0, 0.0, 0.30852482215402843, 1.6689273097503714, 1.4359019367238823, 0.7926682976084574, 1.5410922403500262, -0.07965011232897776, 0.0, 3.661941510455132, 4.4761069615225075, 2.011119083198695, 0.6193893884051743, 1.8115811712209564, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int cqueue_empty(cqueue *q) { return !q->nb_elements; }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int64_t parse_time_or_die(const char *context, const char *timestr, int is_duration) { int64_t us; if (av_parse_time(&us, timestr, is_duration) < 0) { av_log(NULL, AV_LOG_FATAL, "Invalid %s specification for %s: %s\n", is_duration ? "duration" : "date", context, timestr); exit_program(1); } return us; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.41601414702345235, -0.4462861841111837, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void extract_from_packed(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize, int width, int height, int depth, int step, int comp) { int x, y; for (y = 0; y < height; y++) { switch (depth) { case 1: for (x = 0; x < width; x++) dst[x] = src[x * step + comp]; break; case 2: for (x = 0; x < width; x++) { dst[x * 2 ] = src[x * step + comp * 2 ]; dst[x * 2 + 1] = src[x * step + comp * 2 + 1]; } break; } dst += dst_linesize; src += src_linesize; } }<SPLIT>[-0.25365086435942685, -0.1964525029637057, 0.0, -0.2665172434374763, 0.21061001915366473, 0.0, 0.27499425978303293, 0.11088995743869048, 0.24256368267104944, -0.27925050329511203, -0.21089937656897445, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 3.3489446507317613, 0.1577849451844651, -0.26569807294376846, 0.24050413023943099, 0.37651940477529405, 1.0165134053997327, 0.0, -0.08645738172306322, -0.16222078614455715, 0.21937940777079099, 0.8918640029916549, -0.22049944857796966, 1.5806237532086234, 1.5495904173241366, 0.27459231726984007, 0.11056045576999526, 0.24218765769350709, -0.27935383381430245, 1.7623686513065309, 0.0, 1.1388542534712223, 0.8133108086083498, 1.0667610514419015, 0.04739993194876201]
0<SPLIT>static av_always_inline float flt16_trunc(float pf) { union av_intfloat32 pun; pun.f = pf; pun.i &= 0xFFFF0000U; return pun.f; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int mov_write_tmpo_tag(AVIOContext *pb, AVFormatContext *s) { AVDictionaryEntry *t = av_dict_get(s->metadata, "tmpo", NULL, 0); int size = 0, tmpo = t ? atoi(t->value) : 0; if (tmpo) { size = 26; avio_wb32(pb, size); ffio_wfourcc(pb, "tmpo"); avio_wb32(pb, size-8); ffio_wfourcc(pb, "data"); avio_wb32(pb, 0x15); avio_wb32(pb, 0); avio_wb16(pb, tmpo); } return size; }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.14106852214680915, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.14353953243697165, 0.005287286955244392, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static inline void writer_print_section_header(WriterContext *wctx, int section_id) { int parent_section_id; wctx->level++; av_assert0(wctx->level < SECTION_MAX_NB_LEVELS); parent_section_id = wctx->level ? (wctx->section[wctx->level-1])->id : SECTION_ID_NONE; wctx->nb_item[wctx->level] = 0; wctx->section[wctx->level] = &wctx->sections[section_id]; if (section_id == SECTION_ID_PACKETS_AND_FRAMES) { wctx->nb_section_packet = wctx->nb_section_frame = wctx->nb_section_packet_frame = 0; } else if (parent_section_id == SECTION_ID_PACKETS_AND_FRAMES) { wctx->nb_section_packet_frame = section_id == SECTION_ID_PACKET ? wctx->nb_section_packet : wctx->nb_section_frame; } if (wctx->writer->print_section_header) wctx->writer->print_section_header(wctx); }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>void av_image_fill_max_pixsteps(int max_pixsteps[4], int max_pixstep_comps[4], const AVPixFmtDescriptor *pixdesc) { int i; memset(max_pixsteps, 0, 4*sizeof(max_pixsteps[0])); if (max_pixstep_comps) memset(max_pixstep_comps, 0, 4*sizeof(max_pixstep_comps[0])); for (i = 0; i < 4; i++) { const AVComponentDescriptor *comp = &(pixdesc->comp[i]); if ((comp->step_minus1+1) > max_pixsteps[comp->plane]) { max_pixsteps[comp->plane] = comp->step_minus1+1; if (max_pixstep_comps) max_pixstep_comps[comp->plane] = i; } } }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.270465503877335, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.14353953243697165, -0.4462861841111837, -0.21702784222394986, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static inline void plot_freq(ShowFreqsContext *s, int ch, double a, int f, uint8_t fg[4], int *prev_y, AVFrame *out, AVFilterLink *outlink) { const int w = s->w; const float avg = s->avg_data[ch][f]; const float bsize = get_bsize(s, f); const int sx = get_sx(s, f); int x, y, i; switch(s->ascale) { case AS_SQRT: a = 1.0 - sqrt(a); break; case AS_CBRT: a = 1.0 - cbrt(a); break; case AS_LOG: a = log(av_clipd(a, 1e-6, 1)) / log(1e-6); break; case AS_LINEAR: a = 1.0 - a; break; } y = a * outlink->h - 1; if (y < 0) return; switch (s->avg) { case 0: y = s->avg_data[ch][f] = !outlink->frame_count ? y : FFMIN(avg, y); break; case 1: break; default: s->avg_data[ch][f] = avg + y * (y - avg) / (FFMIN(outlink->frame_count + 1, s->avg) * y); y = s->avg_data[ch][f]; break; } switch(s->mode) { case LINE: if (*prev_y == -1) { *prev_y = y; } if (y <= *prev_y) { for (x = sx + 1; x < sx + bsize && x < w; x++) draw_dot(out, x, y, fg); for (i = y; i <= *prev_y; i++) draw_dot(out, sx, i, fg); } else { for (i = *prev_y; i <= y; i++) draw_dot(out, sx, i, fg); for (x = sx + 1; x < sx + bsize && x < w; x++) draw_dot(out, x, i - 1, fg); } *prev_y = y; break; case BAR: for (x = sx; x < sx + bsize && x < w; x++) for (i = y; i < outlink->h; i++) draw_dot(out, x, i, fg); break; case DOT: for (x = sx; x < sx + bsize && x < w; x++) draw_dot(out, x, y, fg); break; } }<SPLIT>[-0.25365086435942685, 0.7951941986232371, 0.0, -0.2665172434374763, 0.7000217872868608, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.6881503599632689, -0.25297036047912586, 0.8426763052258066, 0.0, 0.0, 0.30852482215402843, 0.603378206530822, -0.26569807294376846, 0.7484951642189352, 0.7647103499668715, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.9220224177425181, 0.23792492798410134, 0.9084342290881006, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void add_stream(OutputStream *ost, AVFormatContext *oc, AVCodec **codec, enum AVCodecID codec_id) { AVCodecContext *c; int i; *codec = avcodec_find_encoder(codec_id); if (!(*codec)) { fprintf(stderr, "Could not find encoder for '%s'\n", avcodec_get_name(codec_id)); exit(1); } ost->st = avformat_new_stream(oc, *codec); if (!ost->st) { fprintf(stderr, "Could not allocate stream\n"); exit(1); } ost->st->id = oc->nb_streams-1; c = ost->st->codec; switch ((*codec)->type) { case AVMEDIA_TYPE_AUDIO: c->sample_fmt = (*codec)->sample_fmts ? (*codec)->sample_fmts[0] : AV_SAMPLE_FMT_FLTP; c->bit_rate = 64000; c->sample_rate = 44100; if ((*codec)->supported_samplerates) { c->sample_rate = (*codec)->supported_samplerates[0]; for (i = 0; (*codec)->supported_samplerates[i]; i++) { if ((*codec)->supported_samplerates[i] == 44100) c->sample_rate = 44100; } } c->channels = av_get_channel_layout_nb_channels(c->channel_layout); c->channel_layout = AV_CH_LAYOUT_STEREO; if ((*codec)->channel_layouts) { c->channel_layout = (*codec)->channel_layouts[0]; for (i = 0; (*codec)->channel_layouts[i]; i++) { if ((*codec)->channel_layouts[i] == AV_CH_LAYOUT_STEREO) c->channel_layout = AV_CH_LAYOUT_STEREO; } } c->channels = av_get_channel_layout_nb_channels(c->channel_layout); ost->st->time_base = (AVRational){ 1, c->sample_rate }; break; case AVMEDIA_TYPE_VIDEO: c->codec_id = codec_id; c->bit_rate = 400000; c->width = 352; c->height = 288; ost->st->time_base = (AVRational){ 1, STREAM_FRAME_RATE }; c->time_base = ost->st->time_base; c->gop_size = 12; c->pix_fmt = STREAM_PIX_FMT; if (c->codec_id == AV_CODEC_ID_MPEG2VIDEO) { c->max_b_frames = 2; } if (c->codec_id == AV_CODEC_ID_MPEG1VIDEO) { c->mb_decision = 2; } break; default: break; } if (oc->oformat->flags & AVFMT_GLOBALHEADER) c->flags |= AV_CODEC_FLAG_GLOBAL_HEADER; }<SPLIT>[1.4474140217819704, 0.7951941986232371, 0.0, 1.4071994323980908, 0.7000217872868608, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, 0.9079180733378172, 1.477384014430136, 0.8426763052258066, 0.0, 0.0, 0.30852482215402843, 0.8164880271747319, 1.4359019367238823, 0.7484951642189352, 0.37651940477529405, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.6760973642524136, -0.03454968660237938, 0.11818065472185141, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static void update_lls(LLSModel *m, const double *var) { int i, j; for (i = 0; i <= m->indep_count; i++) { for (j = i; j <= m->indep_count; j++) { m->covariance[i][j] += var[i] * var[j]; } } }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void mxf_gen_umid(AVFormatContext *s) { MXFContext *mxf = s->priv_data; uint32_t seed = av_get_random_seed(); uint64_t umid = seed + 0x5294713400000000LL; AV_WB64(mxf->umid , umid); AV_WB64(mxf->umid+8, umid>>8); mxf->instance_number = seed & 0xFFFFFF; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static inline void get_strl(AVIOContext *pb, char *buf, int buf_size, int len) { int i; char *q, r; q = buf; for(i=0;i<len;i++) { r = avio_r8(pb); if (i < buf_size - 1) *q++ = r; } if (buf_size > 0) *q = '\0'; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.270465503877335, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, 0.01994523631491676, -0.22049944857796966, -0.21702784222394986, 0.23959960763929639, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static int rtp_read_header(AVFormatContext *s) { uint8_t recvbuf[RTP_MAX_PACKET_LENGTH]; char host[500], sdp[500]; int ret, port; URLContext* in = NULL; int payload_type; AVCodecContext codec = { 0 }; struct sockaddr_storage addr; AVIOContext pb; socklen_t addrlen = sizeof(addr); RTSPState *rt = s->priv_data; if (!ff_network_init()) return AVERROR(EIO); ret = ffurl_open(&in, s->filename, AVIO_FLAG_READ, &s->interrupt_callback, NULL); if (ret) goto fail; while (1) { ret = ffurl_read(in, recvbuf, sizeof(recvbuf)); if (ret == AVERROR(EAGAIN)) continue; if (ret < 0) goto fail; if (ret < 12) { av_log(s, AV_LOG_WARNING, "Received too short packet\n"); continue; } if ((recvbuf[0] & 0xc0) != 0x80) { av_log(s, AV_LOG_WARNING, "Unsupported RTP version packet " "received\n"); continue; } if (RTP_PT_IS_RTCP(recvbuf[1])) continue; payload_type = recvbuf[1] & 0x7f; break; } getsockname(ffurl_get_file_handle(in), (struct sockaddr*) &addr, &addrlen); ffurl_close(in); in = NULL; if (ff_rtp_get_codec_info(&codec, payload_type)) { av_log(s, AV_LOG_ERROR, "Unable to receive RTP payload type %d " "without an SDP file describing it\n", payload_type); goto fail; } if (codec.codec_type != AVMEDIA_TYPE_DATA) { av_log(s, AV_LOG_WARNING, "Guessing on RTP content - if not received " "properly you need an SDP file " "describing it\n"); } av_url_split(NULL, 0, NULL, 0, host, sizeof(host), &port, NULL, 0, s->filename); snprintf(sdp, sizeof(sdp), "v=0\r\nc=IN IP%d %s\r\nm=%s %d RTP/AVP %d\r\n", addr.ss_family == AF_INET ? 4 : 6, host, codec.codec_type == AVMEDIA_TYPE_DATA ? "application" : codec.codec_type == AVMEDIA_TYPE_VIDEO ? "video" : "audio", port, payload_type); av_log(s, AV_LOG_VERBOSE, "SDP:\n%s\n", sdp); ffio_init_context(&pb, sdp, strlen(sdp), 0, NULL, NULL, NULL, NULL); s->pb = &pb; ff_network_close(); rt->media_type_mask = (1 << (AVMEDIA_TYPE_SUBTITLE+1)) - 1; ret = sdp_read_header(s); s->pb = NULL; return ret; fail: if (in) ffurl_close(in); ff_network_close(); return ret; }<SPLIT>[-0.09900860198293619, 0.971486945572027, 0.0, -0.11436118199787926, 0.870251967507103, 0.0, 1.1439604446378808, 1.1713499043019204, 1.0717736154263862, 2.3593549488603003, 0.8679603072697175, -0.09566541730555662, 1.0250193468092605, 0.0, 0.0, 0.30852482215402843, 0.7777407870576574, -0.11100716297398205, 0.9251876977770237, 1.5410922403500262, 1.454978812491217, 0.0, -0.08645738172306322, -0.16222078614455715, 0.7814938157481727, 1.8727726155029853, 2.0373679067541706, 0.6817979554923368, 1.4560196452037908, 1.143335983750264, 1.1708005902540914, 1.0711936229013617, 2.3586066116229683, 0.9056307075691036, 0.0, 1.1388542534712223, 1.1662853116856364, 1.0667610514419015, 2.352007466638268]
0<SPLIT>static av_cold int init(AVFilterContext *ctx) { VignetteContext *s = ctx->priv; #define PARSE_EXPR(name) do { \ int ret = av_expr_parse(&s->name##_pexpr, s->name##_expr, var_names, \ NULL, NULL, NULL, NULL, 0, ctx); \ if (ret < 0) { \ av_log(ctx, AV_LOG_ERROR, "Unable to parse expression for '" \ AV_STRINGIFY(name) "'\n"); \ return ret; \ } \ } while (0) PARSE_EXPR(angle); PARSE_EXPR(x0); PARSE_EXPR(y0); return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.3265555562789663, -0.26569807294376846, -0.33374660382435645, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, 0.417570182313826, -0.377867150705177, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int cqueue_enqueue(cqueue *q, double element) { int i; av_assert2(q->nb_elements != q->size); i = (q->first + q->nb_elements) % q->size; q->elements[i] = element; q->nb_elements++; return 0; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void packet_queue_destroy(PacketQueue *q) { packet_queue_flush(q); SDL_DestroyMutex(q->mutex); SDL_DestroyCond(q->cond); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int config_props(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; FliteContext *flite = ctx->priv; outlink->sample_rate = flite->wave->sample_rate; outlink->time_base = (AVRational){1, flite->wave->sample_rate}; av_log(ctx, AV_LOG_VERBOSE, "voice:%s fmt:%s sample_rate:%d\n", flite->voice_str, av_get_sample_fmt_name(outlink->format), outlink->sample_rate); return 0; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void compact_print_section_header(WriterContext *wctx) { CompactContext *compact = wctx->priv; const struct section *section = wctx->section[wctx->level]; const struct section *parent_section = wctx->level ? wctx->section[wctx->level-1] : NULL; compact->terminate_line[wctx->level] = 1; compact->has_nested_elems[wctx->level] = 0; av_bprint_clear(&wctx->section_pbuf[wctx->level]); if (!(section->flags & SECTION_FLAG_IS_ARRAY) && parent_section && !(parent_section->flags & (SECTION_FLAG_IS_WRAPPER|SECTION_FLAG_IS_ARRAY))) { compact->nested_section[wctx->level] = 1; compact->has_nested_elems[wctx->level-1] = 1; av_bprintf(&wctx->section_pbuf[wctx->level], "%s%s:", wctx->section_pbuf[wctx->level-1].str, (char *)av_x_if_null(section->element_name, section->name)); wctx->nb_item[wctx->level] = wctx->nb_item[wctx->level-1]; } else { if (parent_section && compact->has_nested_elems[wctx->level-1] && (section->flags & SECTION_FLAG_IS_ARRAY)) { compact->terminate_line[wctx->level-1] = 0; printf("\n"); } if (compact->print_section && !(section->flags & (SECTION_FLAG_IS_WRAPPER|SECTION_FLAG_IS_ARRAY))) printf("%s%c", section->name, compact->item_sep); } }<SPLIT>[-0.25365086435942685, -0.04219634938351458, 0.0, -0.2665172434374763, -0.10857156875928925, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.07104719533062549, -0.25297036047912586, -0.023453142295599506, 0.0, 0.0, 0.30852482215402843, -0.13281935569359377, -0.26569807294376846, -0.09079437018198484, -0.011671540416283347, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.14353953243697165, 0.005287286955244392, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void envelope(VectorscopeContext *s, AVFrame *out) { if (!s->envelope) { return; } else if (s->envelope == 1) { envelope_instant(s, out); } else { envelope_peak(s, out); } }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int allyuv_query_formats(AVFilterContext *ctx) { static const enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_YUV444P, AV_PIX_FMT_GBRP, AV_PIX_FMT_NONE }; AVFilterFormats *fmts_list = ff_make_format_list(pix_fmts); if (!fmts_list) return AVERROR(ENOMEM); return ff_set_common_formats(ctx, fmts_list); }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void *av_opt_ptr(const AVClass *class, void *obj, const char *name) { const AVOption *opt= av_opt_find2(&class, name, NULL, 0, AV_OPT_SEARCH_FAKE_OBJ, NULL); if(!opt) return NULL; return (uint8_t*)obj + opt->offset; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void mxf_write_preface(AVFormatContext *s) { MXFContext *mxf = s->priv_data; AVIOContext *pb = s->pb; mxf_write_metadata_key(pb, 0x012f00); PRINT_KEY(s, "preface key", pb->buf_ptr - 16); klv_encode_ber_length(pb, 130 + 16LL * DESCRIPTOR_COUNT(mxf->essence_container_count)); mxf_write_local_tag(pb, 16, 0x3C0A); mxf_write_uuid(pb, Preface, 0); PRINT_KEY(s, "preface uid", pb->buf_ptr - 16); mxf_write_local_tag(pb, 8, 0x3B02); avio_wb64(pb, mxf->timestamp); mxf_write_local_tag(pb, 2, 0x3B05); avio_wb16(pb, 258); mxf_write_local_tag(pb, 16 + 8, 0x3B06); mxf_write_refs_count(pb, 1); mxf_write_uuid(pb, Identification, 0); mxf_write_local_tag(pb, 16, 0x3B03); mxf_write_uuid(pb, ContentStorage, 0); mxf_write_local_tag(pb, 16, 0x3B09); if (s->oformat == &ff_mxf_opatom_muxer) avio_write(pb, opatom_ul, 16); else avio_write(pb, op1a_ul, 16); mxf_write_local_tag(pb, 8 + 16LL * DESCRIPTOR_COUNT(mxf->essence_container_count), 0x3B0A); mxf_write_essence_container_refs(s); mxf_write_local_tag(pb, 8, 0x3B0B); avio_wb64(pb, 0); }<SPLIT>[0.9834872346524985, -0.020159756014915854, 0.0, 0.9507312480792999, -0.08729279623175898, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.10876275197582316, 1.0054691849094282, -0.0006602620976677653, 0.0, 0.0, 0.30852482215402843, 0.04154322483324156, 0.9718292068145229, -0.06870780348722379, 0.5059163865058198, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.14911510677361828, -0.08904460951967552, 0.4568607580216725, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { IVI4DecContext *ctx = avctx->priv_data; const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; int result, p, b; init_get_bits(&ctx->gb, buf, buf_size * 8); result = decode_pic_hdr(ctx, avctx); if (result) { av_log(avctx, AV_LOG_ERROR, "Error decoding picture header\n"); return result; } switch_buffers(ctx); if (ctx->frame_type < FRAMETYPE_NULL_FIRST) { for (p = 0; p < 3; p++) { for (b = 0; b < ctx->planes[p].num_bands; b++) { result = decode_band(ctx, p, &ctx->planes[p].bands[b], avctx); if (result) { av_log(avctx, AV_LOG_ERROR, "Error decoding band: %d, plane: %d\n", b, p); return result; } } } } if (ctx->frame_type == FRAMETYPE_INTRA) { while (get_bits(&ctx->gb, 8)); skip_bits_long(&ctx->gb, 64); if (get_bits_left(&ctx->gb) > 18 && show_bits(&ctx->gb, 18) == 0x3FFF8) av_log(avctx, AV_LOG_ERROR, "Buffer contains IP frames!\n"); } if (ctx->frame.data[0]) avctx->release_buffer(avctx, &ctx->frame); ctx->frame.reference = 0; if ((result = avctx->get_buffer(avctx, &ctx->frame)) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return result; } if (ctx->is_scalable) { ff_ivi_recompose_haar(&ctx->planes[0], ctx->frame.data[0], ctx->frame.linesize[0], 4); } else { ff_ivi_output_plane(&ctx->planes[0], ctx->frame.data[0], ctx->frame.linesize[0]); } ff_ivi_output_plane(&ctx->planes[2], ctx->frame.data[1], ctx->frame.linesize[1]); ff_ivi_output_plane(&ctx->planes[1], ctx->frame.data[2], ctx->frame.linesize[2]); *data_size = sizeof(AVFrame); *(AVFrame*)data = ctx->frame; return buf_size; }<SPLIT>[1.9113408089114425, 0.4426087047256575, 0.0, 1.863667616716882, 0.3595614268463766, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 0.380400859743741, 0.6481925938951691, 1.9492988439508436, 0.4779902220588988, 0.0, 0.0, 0.30852482215402843, 0.5646309664137475, 1.8999746666332415, 0.39511009710275835, 1.0235043134279231, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3599080097651364, 0.7828741571570628, 1.0213275968547075, -0.21702784222394986, 0.5203119240003335, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 0.3801362775450152, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 0.3766295797615486]
0<SPLIT>static void expand_filename_template(AVBPrint *bp, const char *template, struct tm *tm) { int c; while ((c = *(template++))) { if (c == '%') { if (!(c = *(template++))) break; switch (c) { case 'p': av_bprintf(bp, "%s", program_name); break; case 't': av_bprintf(bp, "%04d%02d%02d-%02d%02d%02d", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec); break; case '%': av_bprint_chars(bp, c, 1); break; } } else { av_bprint_chars(bp, c, 1); } } }<SPLIT>[-0.25365086435942685, -0.08626953612071205, 0.0, -0.2665172434374763, -0.15112911381434976, 0.0, 0.6225807337249721, 0.2876332819158955, 0.5742476557731842, 0.7102265412631674, -0.1110049613987252, -0.25297036047912586, -0.06903890269146298, 0.0, 0.0, 0.30852482215402843, -0.17156659581066827, -0.26569807294376846, -0.13496750357150694, -0.270465503877335, 0.7972807018539907, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, 0.29241985090139744, -0.3333928163445767, 2.47944955092491, 0.5203119240003335, 0.6220897838620095, 0.28726714485067795, 0.5737900437766489, 0.7098813332246741, 1.7623686513065309, 0.0, 0.6182652667186178, 0.2838490539924199, 0.5700153422610048, 0.7058592275743352]
0<SPLIT>static int opt_old2new(void *optctx, const char *opt, const char *arg) { OptionsContext *o = optctx; char *s = av_asprintf("%s:%c", opt + 1, *opt); int ret = parse_option(o, s, arg, options); av_free(s); return ret; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.39986248560786075, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.3070243011888601, -0.22049944857796966, -0.21702784222394986, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>static inline int vp3_dequant(Vp3DecodeContext *s, Vp3Fragment *frag, int plane, int inter, DCTELEM block[64]) { int16_t *dequantizer = s->qmat[frag->qpi][inter][plane]; uint8_t *perm = s->scantable.permutated; int i = 0; do { int token = *s->dct_tokens[plane][i]; switch (token & 3) { case 0: if (--token < 4) s->dct_tokens[plane][i]++; else *s->dct_tokens[plane][i] = token & ~3; goto end; case 1: s->dct_tokens[plane][i]++; i += (token >> 2) & 0x7f; block[perm[i]] = (token >> 9) * dequantizer[perm[i]]; i++; break; case 2: block[perm[i]] = (token >> 2) * dequantizer[perm[i]]; s->dct_tokens[plane][i++]++; break; default: return i; } } while (i < 64); end: block[0] = frag->dc * s->qmat[0][inter][plane][0]; return i; }<SPLIT>[0.05563366039355449, 0.06798661745947907, 0.0, 0.037794879441717756, -0.0021777061216379156, 0.0, 0.27499425978303293, -0.06585336703851451, 0.24256368267104944, 1.040052222782594, 0.06880498590772346, 0.061639525868012635, 0.0905112586940592, 0.0, 0.0, 0.30852482215402843, 0.0027959847161670454, 0.04368374699580437, 0.01963846329182043, -0.39986248560786075, 1.1261297571726039, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, 0.40140969673598975, -0.4462861841111837, 3.3782753486411963, 0.7074534682410251, 0.27459231726984007, -0.06614623331068743, 0.24218765769350709, 1.039626388904333, 0.9056307075691036, 0.0, 0.2712059422168815, -0.06912544908486672, 0.23885153614040697, 1.0350888753871217]
0<SPLIT>static void new_connection(int server_fd, int is_rtsp) { struct sockaddr_in from_addr; socklen_t len; int fd; HTTPContext *c = NULL; len = sizeof(from_addr); fd = accept(server_fd, (struct sockaddr *)&from_addr, &len); if (fd < 0) { http_log("error during accept %s\n", strerror(errno)); return; } if (ff_socket_nonblock(fd, 1) < 0) av_log(NULL, AV_LOG_WARNING, "ff_socket_nonblock failed\n"); if (nb_connections >= config.nb_max_connections) { http_send_too_busy_reply(fd); goto fail; } c = av_mallocz(sizeof(HTTPContext)); if (!c) goto fail; c->fd = fd; c->poll_entry = NULL; c->from_addr = from_addr; c->buffer_size = IOBUFFER_INIT_SIZE; c->buffer = av_malloc(c->buffer_size); if (!c->buffer) goto fail; c->next = first_http_ctx; first_http_ctx = c; nb_connections++; start_wait_request(c, is_rtsp); return; fail: if (c) { av_freep(&c->buffer); av_free(c); } closesocket(fd); }<SPLIT>[-0.09900860198293619, 0.24427936440826892, 0.0, -0.11436118199787926, 0.16805247409860422, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, 1.040052222782594, 0.2086571671460724, -0.09566541730555662, 0.2728543002775131, 0.0, 0.0, 0.30852482215402843, 0.13841132512592785, -0.11100716297398205, 0.19633099684990887, 0.8941073316973973, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2545115582693773, 0.8918640029916549, 1.1342209646213146, -0.21702784222394986, 0.6138826961206794, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, 1.039626388904333, 0.04889276383167627, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 1.0350888753871217]
1<SPLIT>#define ff_log2_16bit ff_log2_16bit_c static av_always_inline av_const int ff_log2_16bit_c(unsigned int v) { int n = 0; if (v & 0xff00) { v >>= 8; n += 8; } n += ff_log2_tab[v]; return n; }<SPLIT>[-0.09900860198293619, -0.43885503001829174, 0.0, -0.11436118199787926, -0.47031070172730377, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.41068820690947294, -0.09566541730555662, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.11100716297398205, -0.48835257068768384, -0.6586564490689124, 0.029966239443893296, 0.0, -0.08645738172306322, 0.417570182313826, -0.5183957526995224, -0.3615192241061562, -0.5591795518777907, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int read_connect(URLContext *s, RTMPContext *rt) { RTMPPacket pkt = { 0 }; uint8_t *p; const uint8_t *cp; int ret; char command[64]; int stringlen; double seqnum; uint8_t tmpstr[256]; GetByteContext gbc; if ((ret = ff_rtmp_packet_read(rt->stream, &pkt, rt->in_chunk_size, &rt->prev_pkt[0], &rt->nb_prev_pkt[0])) < 0) return ret; if (pkt.type == RTMP_PT_CHUNK_SIZE) { if ((ret = handle_chunk_size(s, &pkt)) < 0) return ret; ff_rtmp_packet_destroy(&pkt); if ((ret = ff_rtmp_packet_read(rt->stream, &pkt, rt->in_chunk_size, &rt->prev_pkt[0], &rt->nb_prev_pkt[0])) < 0) return ret; } cp = pkt.data; bytestream2_init(&gbc, cp, pkt.size); if (ff_amf_read_string(&gbc, command, sizeof(command), &stringlen)) { av_log(s, AV_LOG_ERROR, "Unable to read command string\n"); ff_rtmp_packet_destroy(&pkt); return AVERROR_INVALIDDATA; } if (strcmp(command, "connect")) { av_log(s, AV_LOG_ERROR, "Expecting connect, got %s\n", command); ff_rtmp_packet_destroy(&pkt); return AVERROR_INVALIDDATA; } ret = ff_amf_read_number(&gbc, &seqnum); if (ret) av_log(s, AV_LOG_WARNING, "SeqNum not found\n"); ret = ff_amf_get_field_value(gbc.buffer, gbc.buffer + bytestream2_get_bytes_left(&gbc), "app", tmpstr, sizeof(tmpstr)); if (ret) av_log(s, AV_LOG_WARNING, "App field not found in connect\n"); if (!ret && strcmp(tmpstr, rt->app)) av_log(s, AV_LOG_WARNING, "App field don't match up: %s <-> %s\n", tmpstr, rt->app); ff_rtmp_packet_destroy(&pkt); if ((ret = ff_rtmp_packet_create(&pkt, RTMP_NETWORK_CHANNEL, RTMP_PT_SERVER_BW, 0, 4)) < 0) return ret; p = pkt.data; bytestream_put_be32(&p, rt->server_bw); pkt.size = p - pkt.data; ret = ff_rtmp_packet_write(rt->stream, &pkt, rt->out_chunk_size, &rt->prev_pkt[1], &rt->nb_prev_pkt[1]); ff_rtmp_packet_destroy(&pkt); if (ret < 0) return ret; if ((ret = ff_rtmp_packet_create(&pkt, RTMP_NETWORK_CHANNEL, RTMP_PT_CLIENT_BW, 0, 5)) < 0) return ret; p = pkt.data; bytestream_put_be32(&p, rt->server_bw); bytestream_put_byte(&p, 2); pkt.size = p - pkt.data; ret = ff_rtmp_packet_write(rt->stream, &pkt, rt->out_chunk_size, &rt->prev_pkt[1], &rt->nb_prev_pkt[1]); ff_rtmp_packet_destroy(&pkt); if (ret < 0) return ret; if ((ret = ff_rtmp_packet_create(&pkt, RTMP_NETWORK_CHANNEL, RTMP_PT_PING, 0, 6)) < 0) return ret; p = pkt.data; bytestream_put_be16(&p, 0); bytestream_put_be32(&p, 0); ret = ff_rtmp_packet_write(rt->stream, &pkt, rt->out_chunk_size, &rt->prev_pkt[1], &rt->nb_prev_pkt[1]); ff_rtmp_packet_destroy(&pkt); if (ret < 0) return ret; if ((ret = ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_CHUNK_SIZE, 0, 4)) < 0) return ret; p = pkt.data; bytestream_put_be32(&p, rt->out_chunk_size); ret = ff_rtmp_packet_write(rt->stream, &pkt, rt->out_chunk_size, &rt->prev_pkt[1], &rt->nb_prev_pkt[1]); ff_rtmp_packet_destroy(&pkt); if (ret < 0) return ret; if ((ret = ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE, 0, RTMP_PKTDATA_DEFAULT_SIZE)) < 0) return ret; p = pkt.data; ff_amf_write_string(&p, "_result"); ff_amf_write_number(&p, seqnum); ff_amf_write_object_start(&p); ff_amf_write_field_name(&p, "fmsVer"); ff_amf_write_string(&p, "FMS/3,0,1,123"); ff_amf_write_field_name(&p, "capabilities"); ff_amf_write_number(&p, 31); ff_amf_write_object_end(&p); ff_amf_write_object_start(&p); ff_amf_write_field_name(&p, "level"); ff_amf_write_string(&p, "status"); ff_amf_write_field_name(&p, "code"); ff_amf_write_string(&p, "NetConnection.Connect.Success"); ff_amf_write_field_name(&p, "description"); ff_amf_write_string(&p, "Connection succeeded."); ff_amf_write_field_name(&p, "objectEncoding"); ff_amf_write_number(&p, 0); ff_amf_write_object_end(&p); pkt.size = p - pkt.data; ret = ff_rtmp_packet_write(rt->stream, &pkt, rt->out_chunk_size, &rt->prev_pkt[1], &rt->nb_prev_pkt[1]); ff_rtmp_packet_destroy(&pkt); if (ret < 0) return ret; if ((ret = ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE, 0, 30)) < 0) return ret; p = pkt.data; ff_amf_write_string(&p, "onBWDone"); ff_amf_write_number(&p, 0); ff_amf_write_null(&p); ff_amf_write_number(&p, 8192); pkt.size = p - pkt.data; ret = ff_rtmp_packet_write(rt->stream, &pkt, rt->out_chunk_size, &rt->prev_pkt[1], &rt->nb_prev_pkt[1]); ff_rtmp_packet_destroy(&pkt); return ret; }<SPLIT>[0.6742027098995172, 2.271645954319352, 0.0, 0.6464191252001059, 2.1256995466313886, 0.0, 2.5343063404056374, 2.5852965001195605, 2.3985095078349254, 4.668134719496286, 2.146608821448908, 0.6908592985622897, 2.3697992784872333, 0.0, 0.0, 0.30852482215402843, 2.017652470804042, 0.66244738687495, 2.228295132767926, 2.5762680941942326, 2.0030605713555723, 0.0, -0.08645738172306322, -0.16222078614455715, 2.432704889181731, 2.472216767593243, 2.1502612745207776, -0.21702784222394986, 2.485298138527594, 2.5333258501189415, 2.584454102899553, 2.3976031672339286, 4.66682200138058, 0.9056307075691036, 0.0, 2.5270915514781676, 2.5781833239947827, 2.391416275924293, 4.656615001327775]
0<SPLIT>static int asf_deinterleave(AVFormatContext *s, ASFPacket *asf_pkt, int st_num) { ASFContext *asf = s->priv_data; ASFStream *asf_st = asf->asf_st[st_num]; unsigned char *p = asf_pkt->avpkt.data; uint16_t pkt_len = asf->asf_st[st_num]->virtual_pkt_len; uint16_t chunk_len = asf->asf_st[st_num]->virtual_chunk_len; int nchunks = pkt_len / chunk_len; AVPacket pkt; int pos = 0, j, l, ret; if ((ret = av_new_packet(&pkt, asf_pkt->data_size)) < 0) return ret; while (asf_pkt->data_size >= asf_st->span * pkt_len + pos) { if (pos >= asf_pkt->data_size) { break; } for (l = 0; l < pkt_len; l++) { if (pos >= asf_pkt->data_size) { break; } for (j = 0; j < asf_st->span; j++) { if ((pos + chunk_len) >= asf_pkt->data_size) break; memcpy(pkt.data + pos, p + (j * nchunks + l) * chunk_len, chunk_len); pos += chunk_len; } } p += asf_st->span * pkt_len; if (p > asf_pkt->avpkt.data + asf_pkt->data_size) break; } av_free_packet(&asf_pkt->avpkt); asf_pkt->avpkt = pkt; return 0; }<SPLIT>[-0.25365086435942685, 0.15613299093387398, 0.0, -0.2665172434374763, 0.08293738398848315, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.10876275197582316, -0.25297036047912586, 0.18168277948578615, 0.0, 0.0, 0.30852482215402843, 0.04154322483324156, -0.26569807294376846, 0.10798473007086465, -0.011671540416283347, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, 0.11398295627503194, -0.03454968660237938, 0.23107402248845843, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int av_opencl_get_device_list(AVOpenCLDeviceList **device_list) { int ret = 0; *device_list = av_mallocz(sizeof(AVOpenCLDeviceList)); if (!(*device_list)) { av_log(&opencl_ctx, AV_LOG_ERROR, "Could not allocate opencl device list\n"); return AVERROR(ENOMEM); } ret = get_device_list(*device_list); if (ret < 0) { av_log(&opencl_ctx, AV_LOG_ERROR, "Could not get device list from environment\n"); free_device_list(*device_list); av_freep(device_list); return ret; } return ret; }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, 0.11772544131424245, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.08904460951967552, 0.005287286955244392, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int rm_sync(AVFormatContext *s, int64_t *timestamp, int *flags, int *stream_index, int64_t *pos){ RMDemuxContext *rm = s->priv_data; AVIOContext *pb = s->pb; AVStream *st; uint32_t state=0xFFFFFFFF; while(!avio_feof(pb)){ int len, num, i; int mlti_id; *pos= avio_tell(pb) - 3; if(rm->remaining_len > 0){ num= rm->current_stream; mlti_id = 0; len= rm->remaining_len; *timestamp = AV_NOPTS_VALUE; *flags= 0; }else{ state= (state<<8) + avio_r8(pb); if(state == MKBETAG('I', 'N', 'D', 'X')){ int n_pkts, expected_len; len = avio_rb32(pb); avio_skip(pb, 2); n_pkts = avio_rb32(pb); expected_len = 20 + n_pkts * 14; if (len == 20) len = expected_len; else if (len != expected_len) av_log(s, AV_LOG_WARNING, "Index size %d (%d pkts) is wrong, should be %d.\n", len, n_pkts, expected_len); len -= 14; if(len<0) continue; goto skip; } else if (state == MKBETAG('D','A','T','A')) { av_log(s, AV_LOG_WARNING, "DATA tag in middle of chunk, file may be broken.\n"); } if(state > (unsigned)0xFFFF || state <= 12) continue; len=state - 12; state= 0xFFFFFFFF; num = avio_rb16(pb); *timestamp = avio_rb32(pb); mlti_id = (avio_r8(pb)>>1)-1<<16; mlti_id = FFMAX(mlti_id, 0); *flags = avio_r8(pb); } for(i=0;i<s->nb_streams;i++) { st = s->streams[i]; if (mlti_id + num == st->id) break; } if (i == s->nb_streams) { skip: avio_skip(pb, len); rm->remaining_len = 0; continue; } *stream_index= i; return len; } return -1; }<SPLIT>[0.05563366039355449, 0.729084418517441, 0.0, 0.037794879441717756, 0.63618546970427, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.668171476929219, 0.061639525868012635, 0.7742976646320114, 0.0, 0.0, 0.30852482215402843, 0.5840045864722848, 0.04368374699580437, 0.6822354641346521, 0.7647103499668715, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 0.7814938157481727, 0.23792492798410134, 1.0213275968547075, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void ff_row_fdct_mmx(int16_t *data, const uint8_t *pixels, ptrdiff_t line_size, int cnt); av_cold void ff_fspp_init_x86(FSPPContext *s) { int cpu_flags = av_get_cpu_flags(); if (EXTERNAL_MMX(cpu_flags)) { s->store_slice = ff_store_slice_mmx; s->store_slice2 = ff_store_slice2_mmx; s->mul_thrmat = ff_mul_thrmat_mmx; s->column_fidct = ff_column_fidct_mmx; s->row_idct = ff_row_idct_mmx; s->row_fdct = ff_row_fdct_mmx; } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int mkv_write_packet_internal(AVFormatContext *s, AVPacket *pkt, int add_cue) { MatroskaMuxContext *mkv = s->priv_data; AVIOContext *pb = s->pb; AVCodecContext *codec = s->streams[pkt->stream_index]->codec; int keyframe = !!(pkt->flags & AV_PKT_FLAG_KEY); int duration = pkt->duration; int ret; int64_t ts = mkv->tracks[pkt->stream_index].write_dts ? pkt->dts : pkt->pts; int64_t relative_packet_pos; int dash_tracknum = mkv->is_dash ? mkv->dash_track_number : pkt->stream_index + 1; if (ts == AV_NOPTS_VALUE) { av_log(s, AV_LOG_ERROR, "Can't write packet with unknown timestamp\n"); return AVERROR(EINVAL); } ts += mkv->tracks[pkt->stream_index].ts_offset; if (mkv->cluster_pos != -1) { int64_t cluster_time = ts - mkv->cluster_pts + mkv->tracks[pkt->stream_index].ts_offset; if ((int16_t)cluster_time != cluster_time) { av_log(s, AV_LOG_WARNING, "Starting new cluster due to timestamp\n"); mkv_start_new_cluster(s, pkt); } } if (!s->pb->seekable) { if (!mkv->dyn_bc) { ret = avio_open_dyn_buf(&mkv->dyn_bc); if (ret < 0) { av_log(s, AV_LOG_ERROR, "Failed to open dynamic buffer\n"); return ret; } } pb = mkv->dyn_bc; } if (mkv->cluster_pos == -1) { mkv->cluster_pos = avio_tell(s->pb); mkv->cluster = start_ebml_master(pb, MATROSKA_ID_CLUSTER, 0); put_ebml_uint(pb, MATROSKA_ID_CLUSTERTIMECODE, FFMAX(0, ts)); mkv->cluster_pts = FFMAX(0, ts); } relative_packet_pos = avio_tell(s->pb) - mkv->cluster.pos; if (codec->codec_type != AVMEDIA_TYPE_SUBTITLE) { mkv_write_block(s, pb, MATROSKA_ID_SIMPLEBLOCK, pkt, keyframe); if (s->pb->seekable && (codec->codec_type == AVMEDIA_TYPE_VIDEO && keyframe || add_cue)) { ret = mkv_add_cuepoint(mkv->cues, pkt->stream_index, dash_tracknum, ts, mkv->cluster_pos, relative_packet_pos, -1); if (ret < 0) return ret; } } else { if (codec->codec_id == AV_CODEC_ID_WEBVTT) { duration = mkv_write_vtt_blocks(s, pb, pkt); } else { ebml_master blockgroup = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP, mkv_blockgroup_size(pkt->size)); if (pkt->convergence_duration > 0) { duration = pkt->convergence_duration; } mkv_write_block(s, pb, MATROSKA_ID_BLOCK, pkt, 1); put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration); end_ebml_master(pb, blockgroup); } if (s->pb->seekable) { ret = mkv_add_cuepoint(mkv->cues, pkt->stream_index, dash_tracknum, ts, mkv->cluster_pos, relative_packet_pos, duration); if (ret < 0) return ret; } } mkv->duration = FFMAX(mkv->duration, ts + duration); if (mkv->stream_durations) mkv->stream_durations[pkt->stream_index] = FFMAX(mkv->stream_durations[pkt->stream_index], ts + duration); return 0; }<SPLIT>[0.05563366039355449, 0.9274137588348296, 0.0, 0.037794879441717756, 0.8276944224520424, 0.0, 2.012926629492729, 2.0550665266879453, 1.9009835481817232, 2.3593549488603003, 0.8479814242356677, 0.061639525868012635, 0.9794335864133971, 0.0, 0.0, 0.30852482215402843, 0.7583671669991201, 0.04368374699580437, 0.8810145643875016, 1.1529012951584487, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, 0.6409652137538272, 1.1643386175781356, 1.0213275968547075, -0.21702784222394986, 1.1753073288427536, 2.0120796502306875, 2.054334035657505, 1.9001995881092162, 2.3586066116229683, 1.7623686513065309, 0.0, 2.006502564725563, 2.048721569378853, 1.8946705667433963, 2.352007466638268]
0<SPLIT>static void draw_frame(AVFilterContext *ctx, AVFrame *main_buf, AVFrame *alpha_buf) { AlphaMergeContext *merge = ctx->priv; int h = main_buf->height; if (merge->is_packed_rgb) { int x, y; uint8_t *pin, *pout; for (y = 0; y < h; y++) { pin = alpha_buf->data[0] + y * alpha_buf->linesize[0]; pout = main_buf->data[0] + y * main_buf->linesize[0] + merge->rgba_map[A]; for (x = 0; x < main_buf->width; x++) { *pout = *pin; pin += 1; pout += 4; } } } else { int y; const int main_linesize = main_buf->linesize[A]; const int alpha_linesize = alpha_buf->linesize[Y]; for (y = 0; y < h && y < alpha_buf->height; y++) { memcpy(main_buf->data[A] + y * main_linesize, alpha_buf->data[Y] + y * alpha_linesize, FFMIN(main_linesize, alpha_linesize)); } } }<SPLIT>[-0.25365086435942685, -0.020159756014915854, 0.0, -0.2665172434374763, -0.08729279623175898, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.051068312296575644, -0.25297036047912586, -0.0006602620976677653, 0.0, 0.0, 0.30852482215402843, -0.1134457356350565, -0.26569807294376846, -0.06870780348722379, 0.37651940477529405, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, -0.03454968660237938, 0.11818065472185141, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void x11grab_draw_region_win(X11GrabContext *s) { Display *dpy = s->dpy; Window win = s->region_win; int screen = DefaultScreen(dpy); GC gc = XCreateGC(dpy, win, 0, 0); XSetForeground(dpy, gc, WhitePixel(dpy, screen)); XSetBackground(dpy, gc, BlackPixel(dpy, screen)); XSetLineAttributes(dpy, gc, REGION_WIN_BORDER, LineDoubleDash, 0, 0); XDrawRectangle(dpy, win, gc, 1, 1, (s->width + REGION_WIN_BORDER * 2) - 1 * 2 - 1, (s->height + REGION_WIN_BORDER * 2) - 1 * 2 - 1); XFreeGC(dpy, gc); }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.011671540416283347, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.1980344553542678, 0.23107402248845843, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int ff_set_common_samplerates(AVFilterContext *ctx, AVFilterFormats *samplerates) { SET_COMMON_FORMATS(ctx, samplerates, in_samplerates, out_samplerates, ff_formats_ref, formats); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>AVRC4 *av_rc4_alloc(void) { return av_mallocz(sizeof(struct AVRC4)); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int alloc_buffer(PullupContext *s, PullupBuffer *b) { int i; if (b->planes[0]) return 0; for (i = 0; i < s->nb_planes; i++) { b->planes[i] = av_malloc(s->planeheight[i] * s->planewidth[i]); } if (s->nb_planes == 1) b->planes[1] = av_malloc(4*256); return 0; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int decode_extension_payload(AACContext *ac, GetBitContext *gb, int cnt, ChannelElement *che, enum RawDataBlockType elem_type) { int crc_flag = 0; int res = cnt; int type = get_bits(gb, 4); if (ac->avctx->debug & FF_DEBUG_STARTCODE) av_log(ac->avctx, AV_LOG_DEBUG, "extension type: %d len:%d\n", type, cnt); switch (type) { case EXT_SBR_DATA_CRC: crc_flag++; case EXT_SBR_DATA: if (!che) { av_log(ac->avctx, AV_LOG_ERROR, "SBR was found before the first channel element.\n"); return res; } else if (!ac->oc[1].m4ac.sbr) { av_log(ac->avctx, AV_LOG_ERROR, "SBR signaled to be not-present but was found in the bitstream.\n"); skip_bits_long(gb, 8 * cnt - 4); return res; } else if (ac->oc[1].m4ac.sbr == -1 && ac->oc[1].status == OC_LOCKED) { av_log(ac->avctx, AV_LOG_ERROR, "Implicit SBR was found with a first occurrence after the first frame.\n"); skip_bits_long(gb, 8 * cnt - 4); return res; } else if (ac->oc[1].m4ac.ps == -1 && ac->oc[1].status < OC_LOCKED && ac->avctx->channels == 1) { ac->oc[1].m4ac.sbr = 1; ac->oc[1].m4ac.ps = 1; ac->avctx->profile = FF_PROFILE_AAC_HE_V2; output_configure(ac, ac->oc[1].layout_map, ac->oc[1].layout_map_tags, ac->oc[1].status, 1); } else { ac->oc[1].m4ac.sbr = 1; ac->avctx->profile = FF_PROFILE_AAC_HE; } res = AAC_RENAME(ff_decode_sbr_extension)(ac, &che->sbr, gb, crc_flag, cnt, elem_type); break; case EXT_DYNAMIC_RANGE: res = decode_dynamic_range(&ac->che_drc, gb); break; case EXT_FILL: decode_fill(ac, gb, 8 * cnt - 4); break; case EXT_FILL_DATA: case EXT_DATA_ELEMENT: default: skip_bits_long(gb, 8 * cnt - 4); break; }; return res; }<SPLIT>[-0.25365086435942685, 0.42057211135705874, 0.0, -0.2665172434374763, 0.33828265431884635, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 1.040052222782594, 0.3485093483844214, -0.25297036047912586, 0.45519734186096705, 0.0, 0.0, 0.30852482215402843, 0.27402666553568866, -0.26569807294376846, 0.3730235304079973, 0.5059163865058198, 1.454978812491217, 0.0, -0.08645738172306322, -0.16222078614455715, 0.32477585926655006, 0.8373690800743588, 0.4568607580216725, 1.5806237532086234, 0.8945950124817165, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 1.039626388904333, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 1.0350888753871217]
0<SPLIT>static void print(AVTreeNode *t, int depth) { int i; for (i = 0; i < depth * 4; i++) av_log(NULL, AV_LOG_ERROR, " "); if (t) { av_log(NULL, AV_LOG_ERROR, "Node %p %2d %p\n", t, t->state, t->elem); print(t->child[0], depth + 1); print(t->child[1], depth + 1); } else av_log(NULL, AV_LOG_ERROR, "NULL\n"); }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.4705090699407485, -0.5591795518777907, 0.6817979554923368, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void av_hmac_free(AVHMAC *c) { if (!c) return; av_freep(&c->hash); av_free(c); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void av_opencl_uninit(void) { int i; cl_int status; LOCK_OPENCL; opencl_ctx.init_count--; if (opencl_ctx.is_user_created) goto end; if (opencl_ctx.init_count > 0) goto end; if (opencl_ctx.command_queue) { status = clReleaseCommandQueue(opencl_ctx.command_queue); if (status != CL_SUCCESS) { av_log(&opencl_ctx, AV_LOG_ERROR, "Could not release OpenCL command queue: %s\n", av_opencl_errstr(status)); } opencl_ctx.command_queue = NULL; } if (opencl_ctx.context) { status = clReleaseContext(opencl_ctx.context); if (status != CL_SUCCESS) { av_log(&opencl_ctx, AV_LOG_ERROR, "Could not release OpenCL context: %s\n", av_opencl_errstr(status)); } opencl_ctx.context = NULL; } for (i = 0; i < opencl_ctx.kernel_code_count; i++) { opencl_ctx.kernel_code[i].is_compiled = 0; } free_device_list(&opencl_ctx.device_list); end: if (opencl_ctx.init_count <= 0) av_opt_free(&opencl_ctx); UNLOCK_OPENCL; }<SPLIT>[-0.25365086435942685, 0.11205980419667652, 0.0, -0.2665172434374763, 0.04037983893342262, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 0.380400859743741, 0.06880498590772346, -0.25297036047912586, 0.13609701908992267, 0.0, 0.0, 0.30852482215402843, 0.0027959847161670454, -0.26569807294376846, 0.06381159668134254, 0.11772544131424245, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.06167779621789984, 0.23792492798410134, 0.11818065472185141, 0.6817979554923368, 0.23959960763929639, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 0.3801362775450152, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 0.3766295797615486]
0<SPLIT>static int config_output(AVFilterLink *outlink) { int ret; AVFilterContext *ctx = outlink->src; PaletteUseContext *s = ctx->priv; outlink->w = ctx->inputs[0]->w; outlink->h = ctx->inputs[0]->h; outlink->time_base = ctx->inputs[0]->time_base; if ((ret = ff_dualinput_init(ctx, &s->dinput)) < 0) return ret; return 0; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void free_side_data(AVFrameSideData **ptr_sd) { AVFrameSideData *sd = *ptr_sd; av_buffer_unref(&sd->buf); av_dict_free(&sd->metadata); av_freep(ptr_sd); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static struct playlist *new_playlist(HLSContext *c, const char *url, const char *base) { struct playlist *pls = av_mallocz(sizeof(struct playlist)); if (!pls) return NULL; reset_packet(&pls->pkt); ff_make_absolute_url(pls->url, sizeof(pls->url), base, url); pls->seek_timestamp = AV_NOPTS_VALUE; pls->is_id3_timestamped = -1; pls->id3_mpegts_timestamp = AV_NOPTS_VALUE; dynarray_add(&c->playlists, &c->n_playlists, pls); return pls; }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.3070243011888601, -0.10760608081136262, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void envelope_instant(WaveformContext *s, AVFrame *out, int plane, int component) { const int dst_linesize = out->linesize[component]; const uint8_t bg = s->bg_color[component]; const int is_chroma = (component == 1 || component == 2); const int shift_w = (is_chroma ? s->desc->log2_chroma_w : 0); const int shift_h = (is_chroma ? s->desc->log2_chroma_h : 0); const int dst_h = FF_CEIL_RSHIFT(out->height, shift_h); const int dst_w = FF_CEIL_RSHIFT(out->width, shift_w); const int start = s->estart[plane]; const int end = s->eend[plane]; uint8_t *dst; int x, y; if (s->mode) { for (x = 0; x < dst_w; x++) { for (y = start; y < end; y++) { dst = out->data[component] + y * dst_linesize + x; if (dst[0] != bg) { dst[0] = 255; break; } } for (y = end - 1; y >= start; y--) { dst = out->data[component] + y * dst_linesize + x; if (dst[0] != bg) { dst[0] = 255; break; } } } } else { for (y = 0; y < dst_h; y++) { dst = out->data[component] + y * dst_linesize; for (x = start; x < end; x++) { if (dst[x] != bg) { dst[x] = 255; break; } } for (x = end - 1; x >= start; x--) { if (dst[x] != bg) { dst[x] = 255; break; } } } } }<SPLIT>[-0.25365086435942685, 0.39853551798846004, 0.0, -0.2665172434374763, 0.31700388179131606, 0.0, 1.49154691857982, 1.5248365532563304, 1.5692995750795884, 3.34883199341858, 0.3285304653503715, -0.25297036047912586, 0.4324044616630353, 0.0, 0.0, 0.30852482215402843, 0.2546530454771514, -0.26569807294376846, 0.35093696371323624, 0.5059163865058198, 0.9068970536268617, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5004366117594818, 1.4368132321646163, 0.5697541257882794, -0.21702784222394986, 2.0174442779258652, 1.4908334503424332, 1.524213968415457, 1.5685972020260743, 3.347841778661945, 2.6191065950439585, 0.0, 1.4859135779729586, 1.519259814762923, 1.5635067606227984, 3.339696410076628]
1<SPLIT>static av_cold int rl2_read_header(AVFormatContext *s) { AVIOContext *pb = s->pb; AVStream *st; unsigned int frame_count; unsigned int audio_frame_counter = 0; unsigned int video_frame_counter = 0; unsigned int back_size; unsigned short sound_rate; unsigned short rate; unsigned short channels; unsigned short def_sound_size; unsigned int signature; unsigned int pts_den = 11025; unsigned int pts_num = 1103; unsigned int* chunk_offset = NULL; int* chunk_size = NULL; int* audio_size = NULL; int i; int ret = 0; avio_skip(pb,4); back_size = avio_rl32(pb); signature = avio_rb32(pb); avio_skip(pb, 4); frame_count = avio_rl32(pb); if(back_size > INT_MAX/2 || frame_count > INT_MAX / sizeof(uint32_t)) return AVERROR_INVALIDDATA; avio_skip(pb, 2); sound_rate = avio_rl16(pb); rate = avio_rl16(pb); channels = avio_rl16(pb); def_sound_size = avio_rl16(pb); st = avformat_new_stream(s, NULL); if(!st) return AVERROR(ENOMEM); st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO; st->codecpar->codec_id = AV_CODEC_ID_RL2; st->codecpar->codec_tag = 0; st->codecpar->width = 320; st->codecpar->height = 200; st->codecpar->extradata_size = EXTRADATA1_SIZE; if(signature == RLV3_TAG && back_size > 0) st->codecpar->extradata_size += back_size; if(ff_get_extradata(s, st->codecpar, pb, st->codecpar->extradata_size) < 0) return AVERROR(ENOMEM); if(sound_rate){ if (!channels || channels > 42) { av_log(s, AV_LOG_ERROR, "Invalid number of channels: %d\n", channels); return AVERROR_INVALIDDATA; } pts_num = def_sound_size; pts_den = rate; st = avformat_new_stream(s, NULL); if (!st) return AVERROR(ENOMEM); st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO; st->codecpar->codec_id = AV_CODEC_ID_PCM_U8; st->codecpar->codec_tag = 1; st->codecpar->channels = channels; st->codecpar->bits_per_coded_sample = 8; st->codecpar->sample_rate = rate; st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate * st->codecpar->bits_per_coded_sample; st->codecpar->block_align = st->codecpar->channels * st->codecpar->bits_per_coded_sample / 8; avpriv_set_pts_info(st,32,1,rate); } avpriv_set_pts_info(s->streams[0], 32, pts_num, pts_den); chunk_size = av_malloc(frame_count * sizeof(uint32_t)); audio_size = av_malloc(frame_count * sizeof(uint32_t)); chunk_offset = av_malloc(frame_count * sizeof(uint32_t)); if(!chunk_size || !audio_size || !chunk_offset){ av_free(chunk_size); av_free(audio_size); av_free(chunk_offset); return AVERROR(ENOMEM); } for(i=0; i < frame_count;i++) chunk_size[i] = avio_rl32(pb); for(i=0; i < frame_count;i++) chunk_offset[i] = avio_rl32(pb); for(i=0; i < frame_count;i++) audio_size[i] = avio_rl32(pb) & 0xFFFF; for(i=0;i<frame_count;i++){ if(chunk_size[i] < 0 || audio_size[i] > chunk_size[i]){ ret = AVERROR_INVALIDDATA; break; } if(sound_rate && audio_size[i]){ av_add_index_entry(s->streams[1], chunk_offset[i], audio_frame_counter,audio_size[i], 0, AVINDEX_KEYFRAME); audio_frame_counter += audio_size[i] / channels; } av_add_index_entry(s->streams[0], chunk_offset[i] + audio_size[i], video_frame_counter,chunk_size[i]-audio_size[i],0,AVINDEX_KEYFRAME); ++video_frame_counter; } av_free(chunk_size); av_free(audio_size); av_free(chunk_offset); return ret; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 3.6895403539920464, 1.4660575982779505, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 1.804542650160132, 3.7562655862706786, 1.5436115652303333, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 2.221911986190213, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int xv_write_frame(AVFormatContext *s, int stream_index, AVFrame **frame, unsigned flags) { if ((flags & AV_WRITE_UNCODED_FRAME_QUERY)) return 0; return write_picture(s, (AVPicture *)*frame); }<SPLIT>[-0.09900860198293619, -0.5049648101240879, 0.0, -0.11436118199787926, -0.5554257918374248, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4706248560116225, -0.09566541730555662, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.11100716297398205, -0.554612270771967, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5250039928580447, -0.6720729196443977, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void get_str8(AVIOContext *pb, char *buf, int buf_size) { get_strl(pb, buf, buf_size, avio_r8(pb)); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>static void gmc_mmx(uint8_t *dst, uint8_t *src, int stride, int h, int ox, int oy, int dxx, int dxy, int dyx, int dyy, int shift, int r, int width, int height) { const int w = 8; const int ix = ox >> (16 + shift); const int iy = oy >> (16 + shift); const int oxs = ox >> 4; const int oys = oy >> 4; const int dxxs = dxx >> 4; const int dxys = dxy >> 4; const int dyxs = dyx >> 4; const int dyys = dyy >> 4; const uint16_t r4[4] = { r, r, r, r }; const uint16_t dxy4[4] = { dxys, dxys, dxys, dxys }; const uint16_t dyy4[4] = { dyys, dyys, dyys, dyys }; const uint64_t shift2 = 2 * shift; #define MAX_STRIDE 4096U #define MAX_H 8U uint8_t edge_buf[(MAX_H + 1) * MAX_STRIDE]; int x, y; const int dxw = (dxx - (1 << (16 + shift))) * (w - 1); const int dyh = (dyy - (1 << (16 + shift))) * (h - 1); const int dxh = dxy * (h - 1); const int dyw = dyx * (w - 1); int need_emu = (unsigned) ix >= width - w || (unsigned) iy >= height - h; if ( ((ox ^ (ox + dxw)) | (ox ^ (ox + dxh)) | (ox ^ (ox + dxw + dxh)) | (oy ^ (oy + dyw)) | (oy ^ (oy + dyh)) | (oy ^ (oy + dyw + dyh))) >> (16 + shift) || (dxx | dxy | dyx | dyy) & 15 || (need_emu && (h > MAX_H || stride > MAX_STRIDE))) { ff_gmc_c(dst, src, stride, h, ox, oy, dxx, dxy, dyx, dyy, shift, r, width, height); return; } src += ix + iy * stride; if (need_emu) { ff_emulated_edge_mc_8(edge_buf, src, stride, stride, w + 1, h + 1, ix, iy, width, height); src = edge_buf; } __asm__ volatile ( "movd %0, %%mm6 \n\t" "pxor %%mm7, %%mm7 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" :: "r" (1 << shift)); for (x = 0; x < w; x += 4) { uint16_t dx4[4] = { oxs - dxys + dxxs * (x + 0), oxs - dxys + dxxs * (x + 1), oxs - dxys + dxxs * (x + 2), oxs - dxys + dxxs * (x + 3) }; uint16_t dy4[4] = { oys - dyys + dyxs * (x + 0), oys - dyys + dyxs * (x + 1), oys - dyys + dyxs * (x + 2), oys - dyys + dyxs * (x + 3) }; for (y = 0; y < h; y++) { __asm__ volatile ( "movq %0, %%mm4 \n\t" "movq %1, %%mm5 \n\t" "paddw %2, %%mm4 \n\t" "paddw %3, %%mm5 \n\t" "movq %%mm4, %0 \n\t" "movq %%mm5, %1 \n\t" "psrlw $12, %%mm4 \n\t" "psrlw $12, %%mm5 \n\t" : "+m" (*dx4), "+m" (*dy4) : "m" (*dxy4), "m" (*dyy4)); __asm__ volatile ( "movq %%mm6, %%mm2 \n\t" "movq %%mm6, %%mm1 \n\t" "psubw %%mm4, %%mm2 \n\t" "psubw %%mm5, %%mm1 \n\t" "movq %%mm2, %%mm0 \n\t" "movq %%mm4, %%mm3 \n\t" "pmullw %%mm1, %%mm0 \n\t" "pmullw %%mm5, %%mm3 \n\t" "pmullw %%mm5, %%mm2 \n\t" "pmullw %%mm4, %%mm1 \n\t" "movd %4, %%mm5 \n\t" "movd %3, %%mm4 \n\t" "punpcklbw %%mm7, %%mm5 \n\t" "punpcklbw %%mm7, %%mm4 \n\t" "pmullw %%mm5, %%mm3 \n\t" "pmullw %%mm4, %%mm2 \n\t" "movd %2, %%mm5 \n\t" "movd %1, %%mm4 \n\t" "punpcklbw %%mm7, %%mm5 \n\t" "punpcklbw %%mm7, %%mm4 \n\t" "pmullw %%mm5, %%mm1 \n\t" "pmullw %%mm4, %%mm0 \n\t" "paddw %5, %%mm1 \n\t" "paddw %%mm3, %%mm2 \n\t" "paddw %%mm1, %%mm0 \n\t" "paddw %%mm2, %%mm0 \n\t" "psrlw %6, %%mm0 \n\t" "packuswb %%mm0, %%mm0 \n\t" "movd %%mm0, %0 \n\t" : "=m" (dst[x + y * stride]) : "m" (src[0]), "m" (src[1]), "m" (src[stride]), "m" (src[stride + 1]), "m" (*r4), "m" (shift2)); src += stride; } src += 4 - h * stride; } }<SPLIT>[1.7566985465349518, 1.7207311201043836, 0.0, 1.7115115552772848, 1.593730233443132, 0.0, 0.27499425978303293, 0.2876332819158955, 1.0717736154263862, -0.27925050329511203, 1.7869889268360106, 1.7919939007772745, 1.7543915131430763, 0.0, 0.0, 0.30852482215402843, 1.6689273097503714, 1.7452837566634551, 1.6319578320093775, 2.0586801672721293, 2.4415259784470567, 0.0, -0.08645738172306322, 0.9973611507722091, 0.5707009127566546, 1.0008538488262473, 1.6986878034543498, -0.21702784222394986, 0.33317037975964214, 0.27459231726984007, 0.28726714485067795, 1.0711936229013617, -0.27935383381430245, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 1.0667610514419015, -0.28182971586402455]
0<SPLIT>DEFINE_WRITER_CLASS(ini); static char *ini_escape_str(AVBPrint *dst, const char *src) { int i = 0; char c = 0; while (c = src[i++]) { switch (c) { case '\b': av_bprintf(dst, "%s", "\\b"); break; case '\f': av_bprintf(dst, "%s", "\\f"); break; case '\n': av_bprintf(dst, "%s", "\\n"); break; case '\r': av_bprintf(dst, "%s", "\\r"); break; case '\t': av_bprintf(dst, "%s", "\\t"); break; case '\\': case '#' : case '=' : case ':' : av_bprint_chars(dst, '\\', 1); default: if ((unsigned char)c < 32) av_bprintf(dst, "\\x00%02x", c & 0xff); else av_bprint_chars(dst, c, 1); break; } } return dst->str; }<SPLIT>[-0.25365086435942685, -0.10830612948931077, 0.0, -0.2665172434374763, -0.15112911381434976, 0.0, 1.3177536816088504, -0.06585336703851451, 1.2376156019774536, 2.0295292673408736, -0.13098384443277505, -0.25297036047912586, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.17156659581066827, -0.26569807294376846, -0.13496750357150694, -0.14106852214680915, 1.1261297571726039, 0.0, -0.08645738172306322, -0.16222078614455715, -0.06167779621789984, 0.9463589259089511, -0.22049944857796966, 6.074752741790056, 1.1753073288427536, 1.3170847170463484, -0.06614623331068743, 1.2369948159429325, 2.0288615559433096, 0.9056307075691036, 0.0, 1.3123839157220905, -0.06912544908486672, 1.2323429545022004, 2.0227778188254817]
0<SPLIT>static void pmt_cb(MpegTSFilter *filter, const uint8_t *section, int section_len) { MpegTSContext *ts = filter->u.section_filter.opaque; MpegTSSectionFilter *tssf = &filter->u.section_filter; SectionHeader h1, *h = &h1; PESContext *pes; AVStream *st; const uint8_t *p, *p_end, *desc_list_end; int program_info_length, pcr_pid, pid, stream_type; int desc_list_len; uint32_t prog_reg_desc = 0; int mp4_descr_count = 0; Mp4Descr mp4_descr[MAX_MP4_DESCR_COUNT] = { { 0 } }; int i; av_log(ts->stream, AV_LOG_TRACE, "PMT: len %i\n", section_len); hex_dump_debug(ts->stream, section, section_len); p_end = section + section_len - 4; p = section; if (parse_section_header(h, &p, p_end) < 0) return; if (skip_identical(h, tssf)) return; av_log(ts->stream, AV_LOG_TRACE, "sid=0x%x sec_num=%d/%d version=%d\n", h->id, h->sec_num, h->last_sec_num, h->version); if (h->tid != PMT_TID) return; if (!ts->scan_all_pmts && ts->skip_changes) return; if (!ts->skip_clear) clear_program(ts, h->id); pcr_pid = get16(&p, p_end); if (pcr_pid < 0) return; pcr_pid &= 0x1fff; add_pid_to_pmt(ts, h->id, pcr_pid); set_pcr_pid(ts->stream, h->id, pcr_pid); av_log(ts->stream, AV_LOG_TRACE, "pcr_pid=0x%x\n", pcr_pid); program_info_length = get16(&p, p_end); if (program_info_length < 0) return; program_info_length &= 0xfff; while (program_info_length >= 2) { uint8_t tag, len; tag = get8(&p, p_end); len = get8(&p, p_end); av_log(ts->stream, AV_LOG_TRACE, "program tag: 0x%02x len=%d\n", tag, len); if (len > program_info_length - 2) break; program_info_length -= len + 2; if (tag == 0x1d) { get8(&p, p_end); get8(&p, p_end); len -= 2; mp4_read_iods(ts->stream, p, len, mp4_descr + mp4_descr_count, &mp4_descr_count, MAX_MP4_DESCR_COUNT); } else if (tag == 0x05 && len >= 4) { prog_reg_desc = bytestream_get_le32(&p); len -= 4; } p += len; } p += program_info_length; if (p >= p_end) goto out; if (!ts->stream->nb_streams) ts->stop_parse = 2; set_pmt_found(ts, h->id); for (;;) { st = 0; pes = NULL; stream_type = get8(&p, p_end); if (stream_type < 0) break; pid = get16(&p, p_end); if (pid < 0) goto out; pid &= 0x1fff; if (pid == ts->current_pid) goto out; if (ts->pids[pid] && ts->pids[pid]->type == MPEGTS_PES) { pes = ts->pids[pid]->u.pes_filter.opaque; if (!pes->st) { pes->st = avformat_new_stream(pes->stream, NULL); if (!pes->st) goto out; pes->st->id = pes->pid; } st = pes->st; } else if (stream_type != 0x13) { if (ts->pids[pid]) mpegts_close_filter(ts, ts->pids[pid]); pes = add_pes_stream(ts, pid, pcr_pid); if (pes) { st = avformat_new_stream(pes->stream, NULL); if (!st) goto out; st->id = pes->pid; } } else { int idx = ff_find_stream_index(ts->stream, pid); if (idx >= 0) { st = ts->stream->streams[idx]; } else { st = avformat_new_stream(ts->stream, NULL); if (!st) goto out; st->id = pid; st->codec->codec_type = AVMEDIA_TYPE_DATA; } } if (!st) goto out; if (pes && !pes->stream_type) mpegts_set_stream_info(st, pes, stream_type, prog_reg_desc); add_pid_to_pmt(ts, h->id, pid); ff_program_add_stream_index(ts->stream, h->id, st->index); desc_list_len = get16(&p, p_end); if (desc_list_len < 0) goto out; desc_list_len &= 0xfff; desc_list_end = p + desc_list_len; if (desc_list_end > p_end) goto out; for (;;) { if (ff_parse_mpeg2_descriptor(ts->stream, st, stream_type, &p, desc_list_end, mp4_descr, mp4_descr_count, pid, ts) < 0) break; if (pes && prog_reg_desc == AV_RL32("HDMV") && stream_type == 0x83 && pes->sub_st) { ff_program_add_stream_index(ts->stream, h->id, pes->sub_st->index); pes->sub_st->codec->codec_tag = st->codec->codec_tag; } } p = desc_list_end; } if (!ts->pids[pcr_pid]) mpegts_open_pcr_filter(ts, pcr_pid); out: for (i = 0; i < mp4_descr_count; i++) av_free(mp4_descr[i].dec_config_descr); }<SPLIT>[0.21027592277004517, 2.4920118880053392, 0.0, 0.18995094088131478, 2.338487271906691, 0.0, 4.619825184057273, 4.70621639384602, 4.388613346447734, 8.296217216209978, 2.2864610026872567, 0.21894446904158188, 2.597728080466551, 0.0, 0.0, 0.30852482215402843, 2.153267811213803, 0.19837465696559078, 2.4491607997155365, 2.7056650759247582, 3.537689496175767, 0.0, -0.08645738172306322, -0.16222078614455715, 2.573233491176077, 4.107064455112127, 2.8276214811204197, 6.074752741790056, 4.076001264573471, 4.618310649671958, 4.704934371867745, 4.38721748373278, 8.294017613856827, 2.6191065950439585, 0.0, 4.609447498488585, 4.696030342458503, 4.37839911264788, 8.278141127268427]
0<SPLIT>static int config_output(AVFilterLink *outlink) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(outlink->format); const int depth = desc->comp[0].depth_minus1 + 1; VectorscopeContext *s = outlink->src->priv; s->intensity = s->fintensity * ((1 << depth) - 1); outlink->h = outlink->w = 1 << depth; outlink->sample_aspect_ratio = (AVRational){1,1}; return 0; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void start_wait_request(HTTPContext *c, int is_rtsp) { c->buffer_ptr = c->buffer; c->buffer_end = c->buffer + c->buffer_size - 1; c->state = is_rtsp ? RTSPSTATE_WAIT_REQUEST : HTTPSTATE_WAIT_REQUEST; c->timeout = cur_time + (is_rtsp ? RTSP_REQUEST_TIMEOUT : HTTP_REQUEST_TIMEOUT); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void update_context(VignetteContext *s, AVFilterLink *inlink, AVFrame *frame) { int x, y; float *dst = s->fmap; int dst_linesize = s->fmap_linesize; if (frame) { s->var_values[VAR_N] = inlink->frame_count; s->var_values[VAR_T] = TS2T(frame->pts, inlink->time_base); s->var_values[VAR_PTS] = TS2D(frame->pts); } else { s->var_values[VAR_N] = NAN; s->var_values[VAR_T] = NAN; s->var_values[VAR_PTS] = NAN; } s->angle = av_expr_eval(s->angle_pexpr, s->var_values, NULL); s->x0 = av_expr_eval(s->x0_pexpr, s->var_values, NULL); s->y0 = av_expr_eval(s->y0_pexpr, s->var_values, NULL); if (isnan(s->x0) || isnan(s->y0) || isnan(s->angle)) s->eval_mode = EVAL_MODE_FRAME; s->angle = av_clipf(s->angle, 0, M_PI_2); if (s->backward) { for (y = 0; y < inlink->h; y++) { for (x = 0; x < inlink->w; x++) dst[x] = 1. / get_natural_factor(s, x, y); dst += dst_linesize; } } else { for (y = 0; y < inlink->h; y++) { for (x = 0; x < inlink->w; x++) dst[x] = get_natural_factor(s, x, y); dst += dst_linesize; } } }<SPLIT>[-0.25365086435942685, 0.0900232108280778, 0.0, -0.2665172434374763, 0.01910106640589235, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.04882610287367361, -0.25297036047912586, 0.11330413889199094, 0.0, 0.0, 0.30852482215402843, -0.016577635342370212, -0.26569807294376846, 0.04172502998658149, 0.37651940477529405, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.21937940777079099, -0.03454968660237938, 0.34396739025506545, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int handle_connection(HTTPContext *c) { int len, ret; uint8_t *ptr; switch(c->state) { case HTTPSTATE_WAIT_REQUEST: case RTSPSTATE_WAIT_REQUEST: if ((c->timeout - cur_time) < 0) return -1; if (c->poll_entry->revents & (POLLERR | POLLHUP)) return -1; if (!(c->poll_entry->revents & POLLIN)) return 0; read_loop: if (!(len = recv(c->fd, c->buffer_ptr, 1, 0))) return -1; if (len < 0) { if (ff_neterrno() != AVERROR(EAGAIN) && ff_neterrno() != AVERROR(EINTR)) return -1; break; } c->buffer_ptr += len; ptr = c->buffer_ptr; if ((ptr >= c->buffer + 2 && !memcmp(ptr-2, "\n\n", 2)) || (ptr >= c->buffer + 4 && !memcmp(ptr-4, "\r\n\r\n", 4))) { if (c->state == HTTPSTATE_WAIT_REQUEST) ret = http_parse_request(c); else ret = rtsp_parse_request(c); if (ret < 0) return -1; } else if (ptr >= c->buffer_end) { return -1; } else goto read_loop; break; case HTTPSTATE_SEND_HEADER: if (c->poll_entry->revents & (POLLERR | POLLHUP)) return -1; if (!(c->poll_entry->revents & POLLOUT)) return 0; len = send(c->fd, c->buffer_ptr, c->buffer_end - c->buffer_ptr, 0); if (len < 0) { if (ff_neterrno() != AVERROR(EAGAIN) && ff_neterrno() != AVERROR(EINTR)) { goto close_connection; } break; } c->buffer_ptr += len; if (c->stream) c->stream->bytes_served += len; c->data_count += len; if (c->buffer_ptr >= c->buffer_end) { av_freep(&c->pb_buffer); if (c->http_error) return -1; c->state = HTTPSTATE_SEND_DATA_HEADER; c->buffer_ptr = c->buffer_end = c->buffer; } break; case HTTPSTATE_SEND_DATA: case HTTPSTATE_SEND_DATA_HEADER: case HTTPSTATE_SEND_DATA_TRAILER: if (!c->is_packetized) { if (c->poll_entry->revents & (POLLERR | POLLHUP)) return -1; if (!(c->poll_entry->revents & POLLOUT)) return 0; } if (http_send_data(c) < 0) return -1; if (c->state == HTTPSTATE_SEND_DATA_TRAILER) return -1; if (c->stream->single_frame && c->data_count > c->cur_frame_bytes && c->cur_frame_bytes > 0) { close_connection(c); } break; case HTTPSTATE_RECEIVE_DATA: if (c->poll_entry->revents & (POLLERR | POLLHUP)) return -1; if (!(c->poll_entry->revents & POLLIN)) return 0; if (http_receive_data(c) < 0) return -1; break; case HTTPSTATE_WAIT_FEED: if (c->poll_entry->revents & (POLLIN | POLLERR | POLLHUP)) return -1; break; case RTSPSTATE_SEND_REPLY: if (c->poll_entry->revents & (POLLERR | POLLHUP)) goto close_connection; if (!(c->poll_entry->revents & POLLOUT)) return 0; len = send(c->fd, c->buffer_ptr, c->buffer_end - c->buffer_ptr, 0); if (len < 0) { if (ff_neterrno() != AVERROR(EAGAIN) && ff_neterrno() != AVERROR(EINTR)) { goto close_connection; } break; } c->buffer_ptr += len; c->data_count += len; if (c->buffer_ptr >= c->buffer_end) { av_freep(&c->pb_buffer); start_wait_request(c, 1); } break; case RTSPSTATE_SEND_PACKET: if (c->poll_entry->revents & (POLLERR | POLLHUP)) { av_freep(&c->packet_buffer); return -1; } if (!(c->poll_entry->revents & POLLOUT)) return 0; len = send(c->fd, c->packet_buffer_ptr, c->packet_buffer_end - c->packet_buffer_ptr, 0); if (len < 0) { if (ff_neterrno() != AVERROR(EAGAIN) && ff_neterrno() != AVERROR(EINTR)) { av_freep(&c->packet_buffer); return -1; } break; } c->packet_buffer_ptr += len; if (c->packet_buffer_ptr >= c->packet_buffer_end) { av_freep(&c->packet_buffer); c->state = RTSPSTATE_WAIT_REQUEST; } break; case HTTPSTATE_READY: break; default: return -1; } return 0; close_connection: av_freep(&c->pb_buffer); return -1; }<SPLIT>[3.61240569505284, 2.4920118880053392, 0.0, 3.5373842925524492, 2.338487271906691, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 2.7259964294363535, 3.6796532188601057, 2.597728080466551, 0.0, 0.0, 0.30852482215402843, 2.5794874525016223, 3.601574676300892, 2.4491607997155365, 0.7647103499668715, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 1.6597975782128316, 0.3469147738186936, 1.0213275968547075, 0.6817979554923368, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void *av_malloc(size_t size) { int has_memory; __coverity_negative_sink__(size); if(has_memory) return __coverity_alloc__(size); else return 0; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.39986248560786075, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.3070243011888601, -0.4462861841111837, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int config_input(AVFilterLink *inlink) { AVFilterContext *ctx = inlink->dst; ColorMatrixContext *color = ctx->priv; const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(inlink->format); color->hsub = pix_desc->log2_chroma_w; color->vsub = pix_desc->log2_chroma_h; av_log(ctx, AV_LOG_VERBOSE, "%s -> %s\n", color_modes[color->source], color_modes[color->dest]); return 0; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void frame_queue_destory(FrameQueue *f) { int i; for (i = 0; i < f->max_size; i++) { Frame *vp = &f->queue[i]; frame_queue_unref_item(vp); av_frame_free(&vp->frame); } SDL_DestroyMutex(f->mutex); SDL_DestroyCond(f->cond); }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.14106852214680915, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int decode_i_frame(FourXContext *f, const uint8_t *buf, int length) { int x, y, ret; const int width = f->avctx->width; const int height = f->avctx->height; const unsigned int bitstream_size = AV_RL32(buf); unsigned int prestream_size; const uint8_t *prestream; if (bitstream_size > (1 << 26)) return AVERROR_INVALIDDATA; if (length < bitstream_size + 12) { av_log(f->avctx, AV_LOG_ERROR, "packet size too small\n"); return AVERROR_INVALIDDATA; } prestream_size = 4 * AV_RL32(buf + bitstream_size + 4); prestream = buf + bitstream_size + 12; if (prestream_size + bitstream_size + 12 != length || prestream_size > (1 << 26)) { av_log(f->avctx, AV_LOG_ERROR, "size mismatch %d %d %d\n", prestream_size, bitstream_size, length); return AVERROR_INVALIDDATA; } prestream = read_huffman_tables(f, prestream, prestream_size); if (!prestream) { av_log(f->avctx, AV_LOG_ERROR, "Error reading Huffman tables.\n"); return AVERROR_INVALIDDATA; } av_assert0(prestream <= buf + length); init_get_bits(&f->gb, buf + 4, 8 * bitstream_size); prestream_size = length + buf - prestream; av_fast_padded_malloc(&f->bitstream_buffer, &f->bitstream_buffer_size, prestream_size); if (!f->bitstream_buffer) return AVERROR(ENOMEM); f->bbdsp.bswap_buf(f->bitstream_buffer, (const uint32_t *) prestream, prestream_size / 4); init_get_bits(&f->pre_gb, f->bitstream_buffer, 8 * prestream_size); f->last_dc = 0 * 128 * 8 * 8; for (y = 0; y < height; y += 16) { for (x = 0; x < width; x += 16) { if ((ret = decode_i_mb(f)) < 0) return ret; idct_put(f, x, y); } } if (get_vlc2(&f->pre_gb, f->pre_vlc.table, ACDC_VLC_BITS, 3) != 256) av_log(f->avctx, AV_LOG_ERROR, "end mismatch\n"); return 0; }<SPLIT>[-0.25365086435942685, 0.42057211135705874, 0.0, -0.2665172434374763, 0.33828265431884635, 0.0, 0.6225807337249721, 0.6411199308703055, 0.7400896423242515, 0.7102265412631674, 0.3485093483844214, -0.25297036047912586, 0.45519734186096705, 0.0, 0.0, 0.30852482215402843, 0.27402666553568866, -0.26569807294376846, 0.3730235304079973, 1.1529012951584487, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, 0.4301723107623091, 0.9463589259089511, 1.2471143323879217, -0.21702784222394986, 0.6138826961206794, 0.6220897838620095, 0.6406805230120434, 0.7395912368182198, 0.7098813332246741, 1.7623686513065309, 0.0, 0.6182652667186178, 0.6368235570697065, 0.7355972453213037, 0.7058592275743352]
0<SPLIT>static void writer_print_data(WriterContext *wctx, const char *name, uint8_t *data, int size) { AVBPrint bp; int offset = 0, l, i; av_bprint_init(&bp, 0, AV_BPRINT_SIZE_UNLIMITED); av_bprintf(&bp, "\n"); while (size) { av_bprintf(&bp, "%08x: ", offset); l = FFMIN(size, 16); for (i = 0; i < l; i++) { av_bprintf(&bp, "%02x", data[i]); if (i & 1) av_bprintf(&bp, " "); } av_bprint_chars(&bp, ' ', 41 - 2 * i - i / 2); for (i = 0; i < l; i++) av_bprint_chars(&bp, data[i] - 32U < 95 ? data[i] : '.', 1); av_bprintf(&bp, "\n"); offset += l; data += l; size -= l; } writer_print_string(wctx, name, bp.str, 0); av_bprint_finalize(&bp, NULL); }<SPLIT>[-0.25365086435942685, -0.08626953612071205, 0.0, -0.2665172434374763, -0.15112911381434976, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.1110049613987252, -0.25297036047912586, -0.06903890269146298, 0.0, 0.0, 0.30852482215402843, -0.17156659581066827, -0.26569807294376846, -0.13496750357150694, 0.24712242304476825, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, 0.18343000506680518, 0.23107402248845843, -0.21702784222394986, 0.14602883551895066, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int mov_write_avid_tag(AVIOContext *pb, MOVTrack *track) { int i; int interlaced; int cid; if (track->vos_data && track->vos_len > 0x29) { if (track->vos_data[0] == 0x00 && track->vos_data[1] == 0x00 && track->vos_data[2] == 0x02 && track->vos_data[3] == 0x80 && (track->vos_data[4] == 0x01 || track->vos_data[4] == 0x02)) { interlaced = (track->vos_data[5] & 2); cid = AV_RB32(track->vos_data + 0x28); } else { av_log(NULL, AV_LOG_WARNING, "Could not locate DNxHD bit stream in vos_data\n"); return 0; } } else { av_log(NULL, AV_LOG_WARNING, "Could not locate DNxHD bit stream, vos_data too small\n"); return 0; } avio_wb32(pb, 24); ffio_wfourcc(pb, "ACLR"); ffio_wfourcc(pb, "ACLR"); ffio_wfourcc(pb, "0001"); if (track->enc->color_range == AVCOL_RANGE_MPEG || track->enc->color_range == AVCOL_RANGE_UNSPECIFIED) { avio_wb32(pb, 1); } else { avio_wb32(pb, 2); } avio_wb32(pb, 0); avio_wb32(pb, 24); ffio_wfourcc(pb, "APRG"); ffio_wfourcc(pb, "APRG"); ffio_wfourcc(pb, "0001"); avio_wb32(pb, 1); avio_wb32(pb, 0); avio_wb32(pb, 120); ffio_wfourcc(pb, "ARES"); ffio_wfourcc(pb, "ARES"); ffio_wfourcc(pb, "0001"); avio_wb32(pb, cid); avio_wb32(pb, track->enc->width); if (interlaced) { avio_wb32(pb, track->enc->height / 2); avio_wb32(pb, 2); avio_wb32(pb, 0); avio_wb32(pb, 4); } else { avio_wb32(pb, track->enc->height); avio_wb32(pb, 1); avio_wb32(pb, 0); if (track->enc->height == 1080) avio_wb32(pb, 5); else avio_wb32(pb, 6); } for (i = 0; i < 10; i++) avio_wb64(pb, 0); return 0; }<SPLIT>[0.21027592277004517, 0.7070478251488422, 0.0, 0.18995094088131478, 0.6149066971767397, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 0.380400859743741, 0.668171476929219, 0.21894446904158188, 0.7515047844340796, 0.0, 0.0, 0.30852482215402843, 0.5840045864722848, 0.19837465696559078, 0.660148897439891, 0.24712242304476825, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, 0.7463616652495864, 0.12893508214950905, 0.11818065472185141, -0.21702784222394986, 0.14602883551895066, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 0.3801362775450152, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 0.3766295797615486]
0<SPLIT>static int mov_write_iods_tag(AVIOContext *pb, MOVMuxContext *mov) { int i, has_audio = 0, has_video = 0; int64_t pos = avio_tell(pb); int audio_profile = mov->iods_audio_profile; int video_profile = mov->iods_video_profile; for (i = 0; i < mov->nb_streams; i++) { if (mov->tracks[i].entry > 0 || mov->flags & FF_MOV_FLAG_EMPTY_MOOV) { has_audio |= mov->tracks[i].enc->codec_type == AVMEDIA_TYPE_AUDIO; has_video |= mov->tracks[i].enc->codec_type == AVMEDIA_TYPE_VIDEO; } } if (audio_profile < 0) audio_profile = 0xFF - has_audio; if (video_profile < 0) video_profile = 0xFF - has_video; avio_wb32(pb, 0x0); ffio_wfourcc(pb, "iods"); avio_wb32(pb, 0); put_descr(pb, 0x10, 7); avio_wb16(pb, 0x004f); avio_w8(pb, 0xff); avio_w8(pb, 0xff); avio_w8(pb, audio_profile); avio_w8(pb, video_profile); avio_w8(pb, 0xff); return update_size(pb, pos); }<SPLIT>[-0.25365086435942685, -0.04219634938351458, 0.0, -0.2665172434374763, -0.10857156875928925, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.07104719533062549, -0.25297036047912586, -0.023453142295599506, 0.0, 0.0, 0.30852482215402843, -0.13281935569359377, -0.26569807294376846, -0.09079437018198484, 0.37651940477529405, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, 0.043718655277859224, 0.12893508214950905, 0.4568607580216725, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void framesync_sync_level_update(FFFrameSync *fs) { unsigned i, level = 0; for (i = 0; i < fs->nb_in; i++) if (fs->in[i].state != STATE_EOF) level = FFMAX(level, fs->in[i].sync); av_assert0(level <= fs->sync_level); if (level < fs->sync_level) av_log(fs, AV_LOG_VERBOSE, "Sync level %u\n", level); if (level) fs->sync_level = level; else fs->eof = 1; }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int checkasm_bench_func(void) { return !state.num_failed && state.bench_pattern && !strncmp(state.current_func->name, state.bench_pattern, state.bench_pattern_len); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void swap_channel_layouts(AVFilterGraph *graph) { int i; for (i = 0; i < graph->nb_filters; i++) swap_channel_layouts_on_filter(graph->filters[i]); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold int source_init(AVFilterContext *ctx) { Frei0rContext *s = ctx->priv; s->time_base.num = s->framerate.den; s->time_base.den = s->framerate.num; return frei0r_init(ctx, s->dl_name, F0R_PLUGIN_TYPE_SOURCE); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void wait_frame(AVFormatContext *s, AVPacket *pkt) { XCBGrabContext *c = s->priv_data; int64_t curtime, delay; int64_t frame_time = av_rescale_q(1, c->time_base, AV_TIME_BASE_Q); c->time_frame += frame_time; for (;;) { curtime = av_gettime(); delay = c->time_frame - curtime; if (delay <= 0) break; av_usleep(delay); } pkt->pts = curtime; }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.3070243011888601, -0.5591795518777907, 2.47944955092491, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *in) { AVFilterContext *ctx = inlink->dst; ColorChannelMixerContext *s = ctx->priv; AVFilterLink *outlink = ctx->outputs[0]; const uint8_t roffset = s->rgba_map[R]; const uint8_t goffset = s->rgba_map[G]; const uint8_t boffset = s->rgba_map[B]; const uint8_t aoffset = s->rgba_map[A]; const uint8_t *srcrow = in->data[0]; uint8_t *dstrow; AVFrame *out; int i, j; if (av_frame_is_writable(in)) { out = in; } else { out = ff_get_video_buffer(outlink, outlink->w, outlink->h); if (!out) { av_frame_free(&in); return AVERROR(ENOMEM); } av_frame_copy_props(out, in); } dstrow = out->data[0]; switch (outlink->format) { case AV_PIX_FMT_BGR24: case AV_PIX_FMT_RGB24: for (i = 0; i < outlink->h; i++) { const uint8_t *src = srcrow; uint8_t *dst = dstrow; for (j = 0; j < outlink->w * 3; j += 3) { const uint8_t rin = src[j + roffset]; const uint8_t gin = src[j + goffset]; const uint8_t bin = src[j + boffset]; dst[j + roffset] = av_clip_uint8(s->lut[R][R][rin] + s->lut[R][G][gin] + s->lut[R][B][bin]); dst[j + goffset] = av_clip_uint8(s->lut[G][R][rin] + s->lut[G][G][gin] + s->lut[G][B][bin]); dst[j + boffset] = av_clip_uint8(s->lut[B][R][rin] + s->lut[B][G][gin] + s->lut[B][B][bin]); } srcrow += in->linesize[0]; dstrow += out->linesize[0]; } break; case AV_PIX_FMT_0BGR: case AV_PIX_FMT_0RGB: case AV_PIX_FMT_BGR0: case AV_PIX_FMT_RGB0: for (i = 0; i < outlink->h; i++) { const uint8_t *src = srcrow; uint8_t *dst = dstrow; for (j = 0; j < outlink->w * 4; j += 4) { const uint8_t rin = src[j + roffset]; const uint8_t gin = src[j + goffset]; const uint8_t bin = src[j + boffset]; dst[j + roffset] = av_clip_uint8(s->lut[R][R][rin] + s->lut[R][G][gin] + s->lut[R][B][bin]); dst[j + goffset] = av_clip_uint8(s->lut[G][R][rin] + s->lut[G][G][gin] + s->lut[G][B][bin]); dst[j + boffset] = av_clip_uint8(s->lut[B][R][rin] + s->lut[B][G][gin] + s->lut[B][B][bin]); if (in != out) dst[j + aoffset] = 0; } srcrow += in->linesize[0]; dstrow += out->linesize[0]; } break; case AV_PIX_FMT_ABGR: case AV_PIX_FMT_ARGB: case AV_PIX_FMT_BGRA: case AV_PIX_FMT_RGBA: for (i = 0; i < outlink->h; i++) { const uint8_t *src = srcrow; uint8_t *dst = dstrow; for (j = 0; j < outlink->w * 4; j += 4) { const uint8_t rin = src[j + roffset]; const uint8_t gin = src[j + goffset]; const uint8_t bin = src[j + boffset]; const uint8_t ain = src[j + aoffset]; dst[j + roffset] = av_clip_uint8(s->lut[R][R][rin] + s->lut[R][G][gin] + s->lut[R][B][bin] + s->lut[R][A][ain]); dst[j + goffset] = av_clip_uint8(s->lut[G][R][rin] + s->lut[G][G][gin] + s->lut[G][B][bin] + s->lut[G][A][ain]); dst[j + boffset] = av_clip_uint8(s->lut[B][R][rin] + s->lut[B][G][gin] + s->lut[B][B][bin] + s->lut[B][A][ain]); dst[j + aoffset] = av_clip_uint8(s->lut[A][R][rin] + s->lut[A][G][gin] + s->lut[A][B][bin] + s->lut[A][A][ain]); } srcrow += in->linesize[0]; dstrow += out->linesize[0]; } break; case AV_PIX_FMT_BGR48: case AV_PIX_FMT_RGB48: for (i = 0; i < outlink->h; i++) { const uint16_t *src = (const uint16_t *)srcrow; uint16_t *dst = (uint16_t *)dstrow; for (j = 0; j < outlink->w * 3; j += 3) { const uint16_t rin = src[j + roffset]; const uint16_t gin = src[j + goffset]; const uint16_t bin = src[j + boffset]; dst[j + roffset] = av_clip_uint16(s->lut[R][R][rin] + s->lut[R][G][gin] + s->lut[R][B][bin]); dst[j + goffset] = av_clip_uint16(s->lut[G][R][rin] + s->lut[G][G][gin] + s->lut[G][B][bin]); dst[j + boffset] = av_clip_uint16(s->lut[B][R][rin] + s->lut[B][G][gin] + s->lut[B][B][bin]); } srcrow += in->linesize[0]; dstrow += out->linesize[0]; } break; case AV_PIX_FMT_BGRA64: case AV_PIX_FMT_RGBA64: for (i = 0; i < outlink->h; i++) { const uint16_t *src = (const uint16_t *)srcrow; uint16_t *dst = (uint16_t *)dstrow; for (j = 0; j < outlink->w * 4; j += 4) { const uint16_t rin = src[j + roffset]; const uint16_t gin = src[j + goffset]; const uint16_t bin = src[j + boffset]; const uint16_t ain = src[j + aoffset]; dst[j + roffset] = av_clip_uint16(s->lut[R][R][rin] + s->lut[R][G][gin] + s->lut[R][B][bin] + s->lut[R][A][ain]); dst[j + goffset] = av_clip_uint16(s->lut[G][R][rin] + s->lut[G][G][gin] + s->lut[G][B][bin] + s->lut[G][A][ain]); dst[j + boffset] = av_clip_uint16(s->lut[B][R][rin] + s->lut[B][G][gin] + s->lut[B][B][bin] + s->lut[B][A][ain]); dst[j + aoffset] = av_clip_uint16(s->lut[A][R][rin] + s->lut[A][G][gin] + s->lut[A][B][bin] + s->lut[A][A][ain]); } srcrow += in->linesize[0]; dstrow += out->linesize[0]; } } if (in != out) av_frame_free(&in); return ff_filter_frame(ctx->outputs[0], out); }<SPLIT>[-0.25365086435942685, 2.99885353548311, 0.0, -0.2665172434374763, 2.8278990400398873, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 2.686038663368254, -0.25297036047912586, 3.121964325018981, 0.0, 0.0, 0.30852482215402843, 2.5407402123845477, -0.26569807294376846, 2.9571518336950406, 3.8702379114994905, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 2.7488942436690085, 1.4368132321646163, 3.3920883199534546, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int ffserver_set_float_param(float *dest, const char *value, float factor, float min, float max, FFServerConfig *config, const char *error_msg, ...) { double tmp; char *tailp; if (!value || !value[0]) goto error; errno = 0; tmp = strtod(value, &tailp); if (tmp < min || tmp > max) goto error; if (factor) tmp *= factor; if (tailp[0] || errno) goto error; if (dest) *dest = tmp; return 0; error: if (config) { va_list vl; va_start(vl, error_msg); vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, error_msg, vl); va_end(vl); } return AVERROR(EINVAL); }<SPLIT>[-0.25365086435942685, 0.0018768373536828752, 0.0, -0.2665172434374763, -0.06601402370422871, 0.0, 0.6225807337249721, 0.6411199308703055, 0.9059316288753189, 0.7102265412631674, -0.031089429262525795, -0.25297036047912586, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, -0.09407211557651925, -0.26569807294376846, -0.04662123679246273, 0.5059163865058198, 0.7972807018539907, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, 0.4559046196532859, 0.11818065472185141, -0.21702784222394986, 0.7074534682410251, 0.6220897838620095, 0.6406805230120434, 0.9053924298597907, 0.7098813332246741, 0.04889276383167627, 0.0, 0.6182652667186178, 0.6368235570697065, 0.9011791483816026, 0.7058592275743352]
0<SPLIT>static inline void RENAME(deInterlaceL5)(uint8_t src[], int stride, uint8_t *tmp, uint8_t *tmp2) { #if (TEMPLATE_PP_MMXEXT || TEMPLATE_PP_3DNOW) && HAVE_6REGS src+= stride*4; __asm__ volatile( "lea (%0, %1), %%"REG_a" \n\t" "lea (%%"REG_a", %1, 4), %%"REG_d" \n\t" "pxor %%mm7, %%mm7 \n\t" "movq (%2), %%mm0 \n\t" "movq (%3), %%mm1 \n\t" #define REAL_DEINT_L5(t1,t2,a,b,c)\ "movq " #a ", %%mm2 \n\t"\ "movq " #b ", %%mm3 \n\t"\ "movq " #c ", %%mm4 \n\t"\ PAVGB(t2, %%mm3) \ PAVGB(t1, %%mm4) \ "movq %%mm2, %%mm5 \n\t"\ "movq %%mm2, " #t1 " \n\t"\ "punpcklbw %%mm7, %%mm2 \n\t"\ "punpckhbw %%mm7, %%mm5 \n\t"\ "movq %%mm2, %%mm6 \n\t"\ "paddw %%mm2, %%mm2 \n\t"\ "paddw %%mm6, %%mm2 \n\t"\ "movq %%mm5, %%mm6 \n\t"\ "paddw %%mm5, %%mm5 \n\t"\ "paddw %%mm6, %%mm5 \n\t"\ "movq %%mm3, %%mm6 \n\t"\ "punpcklbw %%mm7, %%mm3 \n\t"\ "punpckhbw %%mm7, %%mm6 \n\t"\ "paddw %%mm3, %%mm3 \n\t"\ "paddw %%mm6, %%mm6 \n\t"\ "paddw %%mm3, %%mm2 \n\t"\ "paddw %%mm6, %%mm5 \n\t"\ "movq %%mm4, %%mm6 \n\t"\ "punpcklbw %%mm7, %%mm4 \n\t"\ "punpckhbw %%mm7, %%mm6 \n\t"\ "psubw %%mm4, %%mm2 \n\t"\ "psubw %%mm6, %%mm5 \n\t"\ "psraw $2, %%mm2 \n\t"\ "psraw $2, %%mm5 \n\t"\ "packuswb %%mm5, %%mm2 \n\t"\ "movq %%mm2, " #a " \n\t"\ #define DEINT_L5(t1,t2,a,b,c) REAL_DEINT_L5(t1,t2,a,b,c) DEINT_L5(%%mm0, %%mm1, (%0) , (%%REGa) , (%%REGa, %1) ) DEINT_L5(%%mm1, %%mm0, (%%REGa) , (%%REGa, %1) , (%%REGa, %1, 2)) DEINT_L5(%%mm0, %%mm1, (%%REGa, %1) , (%%REGa, %1, 2), (%0, %1, 4) ) DEINT_L5(%%mm1, %%mm0, (%%REGa, %1, 2), (%0, %1, 4) , (%%REGd) ) DEINT_L5(%%mm0, %%mm1, (%0, %1, 4) , (%%REGd) , (%%REGd, %1) ) DEINT_L5(%%mm1, %%mm0, (%%REGd) , (%%REGd, %1) , (%%REGd, %1, 2)) DEINT_L5(%%mm0, %%mm1, (%%REGd, %1) , (%%REGd, %1, 2), (%0, %1, 8) ) DEINT_L5(%%mm1, %%mm0, (%%REGd, %1, 2), (%0, %1, 8) , (%%REGd, %1, 4)) "movq %%mm0, (%2) \n\t" "movq %%mm1, (%3) \n\t" : : "r" (src), "r" ((x86_reg)stride), "r"(tmp), "r"(tmp2) : "%"REG_a, "%"REG_d ); #else int x; src+= stride*4; for(x=0; x<8; x++){ int t1= tmp[x]; int t2= tmp2[x]; int t3= src[0]; src[stride*0]= av_clip_uint8((-(t1 + src[stride*2]) + 2*(t2 + src[stride*1]) + 6*t3 + 4)>>3); t1= src[stride*1]; src[stride*1]= av_clip_uint8((-(t2 + src[stride*3]) + 2*(t3 + src[stride*2]) + 6*t1 + 4)>>3); t2= src[stride*2]; src[stride*2]= av_clip_uint8((-(t3 + src[stride*4]) + 2*(t1 + src[stride*3]) + 6*t2 + 4)>>3); t3= src[stride*3]; src[stride*3]= av_clip_uint8((-(t1 + src[stride*5]) + 2*(t2 + src[stride*4]) + 6*t3 + 4)>>3); t1= src[stride*4]; src[stride*4]= av_clip_uint8((-(t2 + src[stride*6]) + 2*(t3 + src[stride*5]) + 6*t1 + 4)>>3); t2= src[stride*5]; src[stride*5]= av_clip_uint8((-(t3 + src[stride*7]) + 2*(t1 + src[stride*6]) + 6*t2 + 4)>>3); t3= src[stride*6]; src[stride*6]= av_clip_uint8((-(t1 + src[stride*8]) + 2*(t2 + src[stride*7]) + 6*t3 + 4)>>3); t1= src[stride*7]; src[stride*7]= av_clip_uint8((-(t2 + src[stride*9]) + 2*(t3 + src[stride*8]) + 6*t1 + 4)>>3); tmp[x]= t3; tmp2[x]= t1; src++; } #endif }<SPLIT>[0.05563366039355449, 1.1918528792580143, 0.0, 0.037794879441717756, 1.0830396927824055, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 1.0877280206442659, -0.25297036047912586, -0.023453142295599506, 0.0, 0.0, 0.30852482215402843, 0.9908506077015672, -0.26569807294376846, -0.09079437018198484, -0.14106852214680915, -0.4084991676475909, 0.0, 5.97712906150637, 5.635688898439274, 0.2545115582693773, -0.25252937827156396, -0.22049944857796966, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int config_output(AVFilterLink *outlink) { outlink->flags |= FF_LINK_FLAG_REQUEST_LOOP; return 0; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void av_audio_fifo_reset(AVAudioFifo *af) { int i; for (i = 0; i < af->nb_buffers; i++) av_fifo_reset(af->buf[i]); af->nb_samples = 0; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static AVStream * new_stream(AVFormatContext *s, AVStream *st, int sid, int codec_type) { if (st) { if (st->codec->extradata) { av_freep(&st->codec->extradata); st->codec->extradata_size = 0; } } else { WtvStream *wst = av_mallocz(sizeof(WtvStream)); if (!wst) return NULL; st = avformat_new_stream(s, NULL); if (!st) { av_free(wst); return NULL; } st->id = sid; st->priv_data = wst; } st->codec->codec_type = codec_type; st->need_parsing = AVSTREAM_PARSE_FULL; avpriv_set_pts_info(st, 64, 1, 10000000); return st; }<SPLIT>[-0.25365086435942685, -0.13034272285790952, 0.0, -0.2665172434374763, -0.1936866588694103, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.1509627274668249, -0.25297036047912586, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.21031383592774278, -0.26569807294376846, -0.17914063696102905, -0.14106852214680915, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.25252937827156396, -0.22049944857796966, -0.21702784222394986, -0.22825425296243224, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void tea_crypt_ecb(AVTEA *ctx, uint8_t *dst, const uint8_t *src, int decrypt, uint8_t *iv) { uint32_t v0, v1; int rounds = ctx->rounds; uint32_t k0, k1, k2, k3; k0 = ctx->key[0]; k1 = ctx->key[1]; k2 = ctx->key[2]; k3 = ctx->key[3]; v0 = AV_RB32(src); v1 = AV_RB32(src + 4); if (decrypt) { int i; uint32_t delta = 0x9E3779B9U, sum = delta * (rounds / 2); for (i = 0; i < rounds / 2; i++) { v1 -= ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3); v0 -= ((v1 << 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1); sum -= delta; } if (iv) { v0 ^= AV_RB32(iv); v1 ^= AV_RB32(iv + 4); memcpy(iv, src, 8); } } else { int i; uint32_t sum = 0, delta = 0x9E3779B9U; for (i = 0; i < rounds / 2; i++) { sum += delta; v0 += ((v1 << 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1); v1 += ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3); } } AV_WB32(dst, v0); AV_WB32(dst + 4, v1); }<SPLIT>[-0.25365086435942685, 0.15613299093387398, 0.0, -0.2665172434374763, 0.08293738398848315, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 0.10876275197582316, -0.25297036047912586, 0.18168277948578615, 0.0, 0.0, 0.30852482215402843, 0.04154322483324156, -0.26569807294376846, 0.10798473007086465, 0.11772544131424245, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2896437087679637, 0.0744401592322129, -0.10760608081136262, -0.21702784222394986, 0.23959960763929639, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static void clear_programs(MpegTSContext *ts) { av_freep(&ts->prg); ts->nb_prg = 0; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int config_output(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; ConcatContext *cat = ctx->priv; unsigned out_no = FF_OUTLINK_IDX(outlink); unsigned in_no = out_no, seg; AVFilterLink *inlink = ctx->inputs[in_no]; outlink->time_base = AV_TIME_BASE_Q; outlink->w = inlink->w; outlink->h = inlink->h; outlink->sample_aspect_ratio = inlink->sample_aspect_ratio; outlink->format = inlink->format; for (seg = 1; seg < cat->nb_segments; seg++) { inlink = ctx->inputs[in_no += ctx->nb_outputs]; if (!outlink->sample_aspect_ratio.num) outlink->sample_aspect_ratio = inlink->sample_aspect_ratio; if (outlink->w != inlink->w || outlink->h != inlink->h || outlink->sample_aspect_ratio.num != inlink->sample_aspect_ratio.num && inlink->sample_aspect_ratio.num || outlink->sample_aspect_ratio.den != inlink->sample_aspect_ratio.den) { av_log(ctx, AV_LOG_ERROR, "Input link %s parameters " "(size %dx%d, SAR %d:%d) do not match the corresponding " "output link %s parameters (%dx%d, SAR %d:%d)\n", ctx->input_pads[in_no].name, inlink->w, inlink->h, inlink->sample_aspect_ratio.num, inlink->sample_aspect_ratio.den, ctx->input_pads[out_no].name, outlink->w, outlink->h, outlink->sample_aspect_ratio.num, outlink->sample_aspect_ratio.den); if (!cat->unsafe) return AVERROR(EINVAL); } } return 0; }<SPLIT>[0.05563366039355449, 0.13409639756527525, 0.0, 0.037794879441717756, 0.06165861146095288, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.128741635009873, 0.061639525868012635, 0.1588898992878544, 0.0, 0.0, 0.30852482215402843, 0.060916844891778815, 0.04368374699580437, 0.08589816337610359, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.3070243011888601, -0.10760608081136262, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size) { if(pc->overread){ av_dlog(NULL, "overread %d, state:%X next:%d index:%d o_index:%d\n", pc->overread, pc->state, next, pc->index, pc->overread_index); av_dlog(NULL, "%X %X %X %X\n", (*buf)[0], (*buf)[1], (*buf)[2], (*buf)[3]); } for(; pc->overread>0; pc->overread--){ pc->buffer[pc->index++]= pc->buffer[pc->overread_index++]; } if(!*buf_size && next == END_NOT_FOUND){ next= 0; } pc->last_index= pc->index; if(next == END_NOT_FOUND){ void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, (*buf_size) + pc->index + FF_INPUT_BUFFER_PADDING_SIZE); if(!new_buffer) return AVERROR(ENOMEM); pc->buffer = new_buffer; memcpy(&pc->buffer[pc->index], *buf, *buf_size); pc->index += *buf_size; return -1; } *buf_size= pc->overread_index= pc->index + next; if(pc->index){ void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, next + pc->index + FF_INPUT_BUFFER_PADDING_SIZE); if(!new_buffer) return AVERROR(ENOMEM); pc->buffer = new_buffer; if (next > -FF_INPUT_BUFFER_PADDING_SIZE) memcpy(&pc->buffer[pc->index], *buf, next + FF_INPUT_BUFFER_PADDING_SIZE); pc->index = 0; *buf= pc->buffer; } for(;next < 0; next++){ pc->state = (pc->state<<8) | pc->buffer[pc->last_index + next]; pc->state64 = (pc->state64<<8) | pc->buffer[pc->last_index + next]; pc->overread++; } if(pc->overread){ av_dlog(NULL, "overread %d, state:%X next:%d index:%d o_index:%d\n", pc->overread, pc->state, next, pc->index, pc->overread_index); av_dlog(NULL, "%X %X %X %X\n", (*buf)[0], (*buf)[1],(*buf)[2],(*buf)[3]); } return 0; }<SPLIT>[2.2206253336644237, 0.39853551798846004, 0.0, 2.167979739596076, 0.31700388179131606, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, -0.27925050329511203, 0.6481925938951691, 2.2639087302979823, 0.4324044616630353, 0.0, 0.0, 0.30852482215402843, 0.5646309664137475, 2.2093564865728146, 0.35093696371323624, -0.14106852214680915, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2896437087679637, 0.23792492798410134, -0.10760608081136262, 0.6817979554923368, 0.42674115187998785, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, -0.27935383381430245, 0.04889276383167627, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, -0.28182971586402455]
0<SPLIT>long WINAPI libAVMemInputPin_Receive(libAVMemInputPin *this, IMediaSample *sample) { libAVPin *pin = (libAVPin *) ((uint8_t *) this - imemoffset); enum dshowDeviceType devtype = pin->filter->type; void *priv_data; AVFormatContext *s; uint8_t *buf; int buf_size; int index; int64_t curtime; int64_t orig_curtime; int64_t graphtime; const char *devtypename = (devtype == VideoDevice) ? "video" : "audio"; IReferenceClock *clock = pin->filter->clock; int64_t dummy; struct dshow_ctx *ctx; dshowdebug("libAVMemInputPin_Receive(%p)\n", this); if (!sample) return E_POINTER; IMediaSample_GetTime(sample, &orig_curtime, &dummy); orig_curtime += pin->filter->start_time; IReferenceClock_GetTime(clock, &graphtime); if (devtype == VideoDevice) { IReferenceClock_GetTime(clock, &curtime); } else { IMediaSample_GetTime(sample, &curtime, &dummy); if(curtime > 400000000000000000LL) { av_log(NULL, AV_LOG_DEBUG, "dshow dropping initial (or ending) audio frame with odd PTS too high %"PRId64"\n", curtime); return S_OK; } curtime += pin->filter->start_time; } buf_size = IMediaSample_GetActualDataLength(sample); IMediaSample_GetPointer(sample, &buf); priv_data = pin->filter->priv_data; s = priv_data; ctx = s->priv_data; index = pin->filter->stream_index; av_log(NULL, AV_LOG_VERBOSE, "dshow passing through packet of type %s size %8d " "timestamp %"PRId64" orig timestamp %"PRId64" graph timestamp %"PRId64" diff %"PRId64" %s\n", devtypename, buf_size, curtime, orig_curtime, graphtime, graphtime - orig_curtime, ctx->device_name[devtype]); pin->filter->callback(priv_data, index, buf, buf_size, curtime, devtype); return S_OK; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.34210700232091185, 0.2744463367362555, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.29340028559422593, 0.35306556693537716, 0.3067638303237141, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.4653044612608955, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
1<SPLIT>void ff_ivi_process_empty_tile(AVCodecContext *avctx, IVIBandDesc *band, IVITile *tile, int32_t mv_scale) { int x, y, need_mc, mbn, blk, num_blocks, mv_x, mv_y, mc_type; int offs, mb_offset, row_offset; IVIMbInfo *mb, *ref_mb; const int16_t *src; int16_t *dst; void (*mc_no_delta_func)(int16_t *buf, const int16_t *ref_buf, uint32_t pitch, int mc_type); offs = tile->ypos * band->pitch + tile->xpos; mb = tile->mbs; ref_mb = tile->ref_mbs; row_offset = band->mb_size * band->pitch; need_mc = 0; for (y = tile->ypos; y < (tile->ypos + tile->height); y += band->mb_size) { mb_offset = offs; for (x = tile->xpos; x < (tile->xpos + tile->width); x += band->mb_size) { mb->xpos = x; mb->ypos = y; mb->buf_offs = mb_offset; mb->type = 1; mb->cbp = 0; if (!band->qdelta_present && !band->plane && !band->band_num) { mb->q_delta = band->glob_quant; mb->mv_x = 0; mb->mv_y = 0; } if (band->inherit_qdelta && ref_mb) mb->q_delta = ref_mb->q_delta; if (band->inherit_mv) { if (mv_scale) { mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale); mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale); } else { mb->mv_x = ref_mb->mv_x; mb->mv_y = ref_mb->mv_y; } need_mc |= mb->mv_x || mb->mv_y; } mb++; if (ref_mb) ref_mb++; mb_offset += band->mb_size; } offs += row_offset; } if (band->inherit_mv && need_mc) { num_blocks = (band->mb_size != band->blk_size) ? 4 : 1; mc_no_delta_func = (band->blk_size == 8) ? ff_ivi_mc_8x8_no_delta : ff_ivi_mc_4x4_no_delta; for (mbn = 0, mb = tile->mbs; mbn < tile->num_MBs; mb++, mbn++) { mv_x = mb->mv_x; mv_y = mb->mv_y; if (!band->is_halfpel) { mc_type = 0; } else { mc_type = ((mv_y & 1) << 1) | (mv_x & 1); mv_x >>= 1; mv_y >>= 1; } for (blk = 0; blk < num_blocks; blk++) { offs = mb->buf_offs + band->blk_size * ((blk & 1) + !!(blk & 2) * band->pitch); mc_no_delta_func(band->buf + offs, band->ref_buf + offs + mv_y * band->pitch + mv_x, band->pitch, mc_type); } } } else { src = band->ref_buf + tile->ypos * band->pitch + tile->xpos; dst = band->buf + tile->ypos * band->pitch + tile->xpos; for (y = 0; y < tile->height; y++) { memcpy(dst, src, tile->width*sizeof(band->buf[0])); src += band->pitch; dst += band->pitch; } } }<SPLIT>[1.9113408089114425, 1.059633319046422, 0.0, 1.863667616716882, 0.9553670576172241, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 1.207601318848565, 1.9492988439508436, 1.1161908676009875, 0.0, 0.0, 0.30852482215402843, 1.1070923280527907, 1.8999746666332415, 1.013533964556068, 0.24712242304476825, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 1.2382117722297952, 0.29241985090139744, 1.0213275968547075, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int config_props(AVFilterLink *inlink) { int p; AVFilterContext *ctx = inlink->dst; EdgeDetectContext *edgedetect = ctx->priv; edgedetect->nb_planes = inlink->format == AV_PIX_FMT_GRAY8 ? 1 : 3; for (p = 0; p < edgedetect->nb_planes; p++) { struct plane_info *plane = &edgedetect->planes[p]; plane->tmpbuf = av_malloc(inlink->w * inlink->h); plane->gradients = av_calloc(inlink->w * inlink->h, sizeof(*plane->gradients)); plane->directions = av_malloc(inlink->w * inlink->h); if (!plane->tmpbuf || !plane->gradients || !plane->directions) return AVERROR(ENOMEM); } return 0; }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.3070243011888601, -0.10760608081136262, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int configure_output_audio_filter(FilterGraph *fg, OutputFilter *ofilter, AVFilterInOut *out) { OutputStream *ost = ofilter->ost; OutputFile *of = output_files[ost->file_index]; AVCodecContext *codec = ost->enc_ctx; AVFilterContext *last_filter = out->filter_ctx; int pad_idx = out->pad_idx; char *sample_fmts, *sample_rates, *channel_layouts; char name[255]; int ret; snprintf(name, sizeof(name), "out_%d_%d", ost->file_index, ost->index); ret = avfilter_graph_create_filter(&ofilter->filter, avfilter_get_by_name("abuffersink"), name, NULL, NULL, fg->graph); if (ret < 0) return ret; if ((ret = av_opt_set_int(ofilter->filter, "all_channel_counts", 1, AV_OPT_SEARCH_CHILDREN)) < 0) return ret; #define AUTO_INSERT_FILTER(opt_name, filter_name, arg) do { \ AVFilterContext *filt_ctx; \ \ av_log(NULL, AV_LOG_INFO, opt_name " is forwarded to lavfi " \ "similarly to -af " filter_name "=%s.\n", arg); \ \ ret = avfilter_graph_create_filter(&filt_ctx, \ avfilter_get_by_name(filter_name), \ filter_name, arg, NULL, fg->graph); \ if (ret < 0) \ return ret; \ \ ret = avfilter_link(last_filter, pad_idx, filt_ctx, 0); \ if (ret < 0) \ return ret; \ \ last_filter = filt_ctx; \ pad_idx = 0; \ } while (0) if (ost->audio_channels_mapped) { int i; AVBPrint pan_buf; av_bprint_init(&pan_buf, 256, 8192); av_bprintf(&pan_buf, "0x%"PRIx64, av_get_default_channel_layout(ost->audio_channels_mapped)); for (i = 0; i < ost->audio_channels_mapped; i++) if (ost->audio_channels_map[i] != -1) av_bprintf(&pan_buf, "|c%d=c%d", i, ost->audio_channels_map[i]); AUTO_INSERT_FILTER("-map_channel", "pan", pan_buf.str); av_bprint_finalize(&pan_buf, NULL); } if (codec->channels && !codec->channel_layout) codec->channel_layout = av_get_default_channel_layout(codec->channels); sample_fmts = choose_sample_fmts(ofilter); sample_rates = choose_sample_rates(ofilter); channel_layouts = choose_channel_layouts(ofilter); if (sample_fmts || sample_rates || channel_layouts) { AVFilterContext *format; char args[256]; args[0] = 0; if (sample_fmts) av_strlcatf(args, sizeof(args), "sample_fmts=%s:", sample_fmts); if (sample_rates) av_strlcatf(args, sizeof(args), "sample_rates=%s:", sample_rates); if (channel_layouts) av_strlcatf(args, sizeof(args), "channel_layouts=%s:", channel_layouts); av_freep(&sample_fmts); av_freep(&sample_rates); av_freep(&channel_layouts); snprintf(name, sizeof(name), "format_out_%d_%d", ost->file_index, ost->index); ret = avfilter_graph_create_filter(&format, avfilter_get_by_name("aformat"), name, args, NULL, fg->graph); if (ret < 0) return ret; ret = avfilter_link(last_filter, pad_idx, format, 0); if (ret < 0) return ret; last_filter = format; pad_idx = 0; } if (audio_volume != 256 && 0) { char args[256]; snprintf(args, sizeof(args), "%f", audio_volume / 256.); AUTO_INSERT_FILTER("-vol", "volume", args); } if (ost->apad && of->shortest) { char args[256]; int i; for (i=0; i<of->ctx->nb_streams; i++) if (of->ctx->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) break; if (i<of->ctx->nb_streams) { snprintf(args, sizeof(args), "%s", ost->apad); AUTO_INSERT_FILTER("-apad", "apad", args); } } snprintf(name, sizeof(name), "trim for output stream %d:%d", ost->file_index, ost->index); ret = insert_trim(of->start_time, of->recording_time, &last_filter, &pad_idx, name); if (ret < 0) return ret; if ((ret = avfilter_link(last_filter, pad_idx, ofilter->filter, 0)) < 0) return ret; return 0; }<SPLIT>[-0.25365086435942685, 1.6546213399985874, 0.0, -0.2665172434374763, 1.5298939158605411, 0.0, 3.577065762231455, 3.6457564469827908, 3.7252454002434643, 6.317263127093419, 1.467326798291213, -0.25297036047912586, 1.708805752747213, 0.0, 0.0, 0.30852482215402843, 1.3589493888137751, -0.26569807294376846, 1.5877846986198554, 2.1880771490026554, 2.8799913855385406, 0.0, -0.08645738172306322, 0.417570182313826, 1.5544011267170725, 3.3441355342699812, 2.2631546422873847, -0.21702784222394986, 3.8888597203327793, 3.57581824989545, 3.644694237383649, 3.724012711566496, 6.315547279778874, 2.6191065950439585, 0.0, 3.5682695249833762, 3.6371068332266425, 3.7160715004066844, 6.302763240391707]
0<SPLIT>static void seek_chapter(VideoState *is, int incr) { int64_t pos = get_master_clock(is) * AV_TIME_BASE; int i; if (!is->ic->nb_chapters) return; for (i = 0; i < is->ic->nb_chapters; i++) { AVChapter *ch = is->ic->chapters[i]; if (av_compare_ts(pos, AV_TIME_BASE_Q, ch->start, ch->time_base) < 0) { i--; break; } } i += incr; i = FFMAX(i, 0); if (i >= is->ic->nb_chapters) return; av_log(NULL, AV_LOG_VERBOSE, "Seeking to chapter %d.\n", i); stream_seek(is, av_rescale_q(is->ic->chapters[i]->start, is->ic->chapters[i]->time_base, AV_TIME_BASE_Q), 0, 0); }<SPLIT>[-0.09900860198293619, -0.1964525029637057, 0.0, -0.11436118199787926, -0.2575229764520011, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.1909204935349246, -0.09566541730555662, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.11100716297398205, -0.24540033704531222, -0.14106852214680915, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.03454968660237938, -0.10760608081136262, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static void read_sbr_noise(SpectralBandReplication *sbr, GetBitContext *gb, SBRData *ch_data, int ch) { int i, j; VLC_TYPE (*t_huff)[2], (*f_huff)[2]; int t_lav, f_lav; int delta = (ch == 1 && sbr->bs_coupling == 1) + 1; if (sbr->bs_coupling && ch) { t_huff = vlc_sbr[T_HUFFMAN_NOISE_BAL_3_0DB].table; t_lav = vlc_sbr_lav[T_HUFFMAN_NOISE_BAL_3_0DB]; f_huff = vlc_sbr[F_HUFFMAN_ENV_BAL_3_0DB].table; f_lav = vlc_sbr_lav[F_HUFFMAN_ENV_BAL_3_0DB]; } else { t_huff = vlc_sbr[T_HUFFMAN_NOISE_3_0DB].table; t_lav = vlc_sbr_lav[T_HUFFMAN_NOISE_3_0DB]; f_huff = vlc_sbr[F_HUFFMAN_ENV_3_0DB].table; f_lav = vlc_sbr_lav[F_HUFFMAN_ENV_3_0DB]; } #if USE_FIXED for (i = 0; i < ch_data->bs_num_noise; i++) { if (ch_data->bs_df_noise[i]) { for (j = 0; j < sbr->n_q; j++) ch_data->noise_facs[i + 1][j].mant = ch_data->noise_facs[i][j].mant + delta * (get_vlc2(gb, t_huff, 9, 2) - t_lav); } else { ch_data->noise_facs[i + 1][0].mant = delta * get_bits(gb, 5); for (j = 1; j < sbr->n_q; j++) ch_data->noise_facs[i + 1][j].mant = ch_data->noise_facs[i + 1][j - 1].mant + delta * (get_vlc2(gb, f_huff, 9, 3) - f_lav); } } #else for (i = 0; i < ch_data->bs_num_noise; i++) { if (ch_data->bs_df_noise[i]) { for (j = 0; j < sbr->n_q; j++) ch_data->noise_facs[i + 1][j] = ch_data->noise_facs[i][j] + delta * (get_vlc2(gb, t_huff, 9, 2) - t_lav); } else { ch_data->noise_facs[i + 1][0] = delta * get_bits(gb, 5); for (j = 1; j < sbr->n_q; j++) ch_data->noise_facs[i + 1][j] = ch_data->noise_facs[i + 1][j - 1] + delta * (get_vlc2(gb, f_huff, 9, 3) - f_lav); } } #endif memcpy(ch_data->noise_facs[0], ch_data->noise_facs[ch_data->bs_num_noise], sizeof(ch_data->noise_facs[0])); }<SPLIT>[-0.09900860198293619, 0.3103891445140651, 0.0, -0.11436118199787926, 0.231888791681195, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.268593816248222, -0.09566541730555662, 0.04492549829819571, 0.0, 0.0, 0.30852482215402843, 0.19653218530153962, -0.11100716297398205, -0.024534670097701678, 0.24712242304476825, -0.2988828158747199, 0.0, 1.0160128806822883, 1.5771521192305922, 0.3950401602637228, -0.14353953243697165, 0.23107402248845843, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int main(int argc, char **argv) { if (argc < 2) { av_log(NULL, AV_LOG_ERROR, "Incorrect input: expected %s <name of a video file>\nNote that test works only for huffyuv, flv and mpeg4 decoders\n", argv[0]); return 1; } av_register_all(); if (video_decode(argv[1]) != 0) return 1; return 0; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.39986248560786075, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.1980344553542678, -0.4462861841111837, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>static void update_mb_info(MpegEncContext *s, int startcode) { if (!s->mb_info) return; if (put_bits_count(&s->pb) - s->prev_mb_info*8 >= s->mb_info*8) { s->mb_info_size += 12; s->prev_mb_info = s->last_mb_info; } if (startcode) { s->prev_mb_info = put_bits_count(&s->pb)/8; return; } s->last_mb_info = put_bits_count(&s->pb)/8; if (!s->mb_info_size) s->mb_info_size += 12; write_mb_info(s); }<SPLIT>[0.36491818514653585, -0.2845988764381006, 0.0, 0.34210700232091185, -0.34263806656212215, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.380400859743741, -0.21089937656897445, 0.3762494122151511, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, 0.35306556693537716, -0.33374660382435645, -0.5292594673383866, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.3070243011888601, -0.5591795518777907, -0.21702784222394986, -0.04111270872174079, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.3801362775450152, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.3766295797615486]
0<SPLIT>static int gdigrab_read_close(AVFormatContext *s1) { struct gdigrab *s = s1->priv_data; if (s->show_region) gdigrab_region_wnd_destroy(s1, s); if (s->source_hdc) ReleaseDC(s->hwnd, s->source_hdc); if (s->dest_hdc) DeleteDC(s->dest_hdc); if (s->hbmp) DeleteObject(s->hbmp); if (s->source_hdc) DeleteDC(s->source_hdc); return 0; }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.3070243011888601, -0.10760608081136262, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void windowing_and_mdct_ltp(AACContext *ac, INTFLOAT *out, INTFLOAT *in, IndividualChannelStream *ics) { const INTFLOAT *lwindow = ics->use_kb_window[0] ? AAC_RENAME(ff_aac_kbd_long_1024) : AAC_RENAME(ff_sine_1024); const INTFLOAT *swindow = ics->use_kb_window[0] ? AAC_RENAME(ff_aac_kbd_short_128) : AAC_RENAME(ff_sine_128); const INTFLOAT *lwindow_prev = ics->use_kb_window[1] ? AAC_RENAME(ff_aac_kbd_long_1024) : AAC_RENAME(ff_sine_1024); const INTFLOAT *swindow_prev = ics->use_kb_window[1] ? AAC_RENAME(ff_aac_kbd_short_128) : AAC_RENAME(ff_sine_128); if (ics->window_sequence[0] != LONG_STOP_SEQUENCE) { ac->fdsp->vector_fmul(in, in, lwindow_prev, 1024); } else { memset(in, 0, 448 * sizeof(*in)); ac->fdsp->vector_fmul(in + 448, in + 448, swindow_prev, 128); } if (ics->window_sequence[0] != LONG_START_SEQUENCE) { ac->fdsp->vector_fmul_reverse(in + 1024, in + 1024, lwindow, 1024); } else { ac->fdsp->vector_fmul_reverse(in + 1024 + 448, in + 1024 + 448, swindow, 128); memset(in + 1024 + 576, 0, 448 * sizeof(*in)); } ac->mdct_ltp.mdct_calc(&ac->mdct_ltp, out, in); }<SPLIT>[-0.25365086435942685, -0.1964525029637057, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.21089937656897445, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, -0.011671540416283347, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.25252937827156396, -0.10760608081136262, -0.21702784222394986, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *inpicref) { AVFilterContext *ctx = inlink->dst; AVFilterLink *outlink = ctx->outputs[0]; TelecineContext *s = ctx->priv; int i, len, ret = 0, nout = 0; if (s->start_time == AV_NOPTS_VALUE) s->start_time = inpicref->pts; len = s->pattern[s->pattern_pos] - '0'; s->pattern_pos++; if (!s->pattern[s->pattern_pos]) s->pattern_pos = 0; if (!len) { av_frame_free(&inpicref); return 0; } if (s->occupied) { for (i = 0; i < s->nb_planes; i++) { av_image_copy_plane(s->frame[nout]->data[i] + s->frame[nout]->linesize[i] * s->first_field, s->frame[nout]->linesize[i] * 2, s->temp->data[i] + s->temp->linesize[i] * s->first_field, s->temp->linesize[i] * 2, s->stride[i], (s->planeheight[i] - s->first_field + 1) / 2); av_image_copy_plane(s->frame[nout]->data[i] + s->frame[nout]->linesize[i] * !s->first_field, s->frame[nout]->linesize[i] * 2, inpicref->data[i] + inpicref->linesize[i] * !s->first_field, inpicref->linesize[i] * 2, s->stride[i], (s->planeheight[i] - !s->first_field + 1) / 2); } nout++; len--; s->occupied = 0; } while (len >= 2) { for (i = 0; i < s->nb_planes; i++) av_image_copy_plane(s->frame[nout]->data[i], s->frame[nout]->linesize[i], inpicref->data[i], inpicref->linesize[i], s->stride[i], s->planeheight[i]); nout++; len -= 2; } if (len >= 1) { for (i = 0; i < s->nb_planes; i++) av_image_copy_plane(s->temp->data[i], s->temp->linesize[i], inpicref->data[i], inpicref->linesize[i], s->stride[i], s->planeheight[i]); s->occupied = 1; } for (i = 0; i < nout; i++) { AVFrame *frame = av_frame_clone(s->frame[i]); if (!frame) { av_frame_free(&inpicref); return AVERROR(ENOMEM); } av_frame_copy_props(frame, inpicref); frame->pts = ((s->start_time == AV_NOPTS_VALUE) ? 0 : s->start_time) + av_rescale(outlink->frame_count, s->ts_unit.num, s->ts_unit.den); ret = ff_filter_frame(outlink, frame); } av_frame_free(&inpicref); return ret; }<SPLIT>[0.36491818514653585, 0.8172307919918359, 0.0, 0.34210700232091185, 0.7213005598143911, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, -0.27925050329511203, 0.7880447751335181, 0.3762494122151511, 0.8654691854237383, 0.0, 0.0, 0.30852482215402843, 0.7002463068235083, 0.35306556693537716, 0.7705817309136963, 0.24712242304476825, 0.7972807018539907, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5707009127566546, 0.6738843113224704, 0.4568607580216725, -0.21702784222394986, 0.8010242403613708, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, -0.27935383381430245, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, -0.28182971586402455]
0<SPLIT>static int open_input_file(InputFile *ifile, const char *filename) { int err, i, orig_nb_streams; AVFormatContext *fmt_ctx = NULL; AVDictionaryEntry *t; AVDictionary **opts; int scan_all_pmts_set = 0; fmt_ctx = avformat_alloc_context(); if (!fmt_ctx) { print_error(filename, AVERROR(ENOMEM)); exit_program(1); } fmt_ctx->flags |= AVFMT_FLAG_KEEP_SIDE_DATA; if (!av_dict_get(format_opts, "scan_all_pmts", NULL, AV_DICT_MATCH_CASE)) { av_dict_set(&format_opts, "scan_all_pmts", "1", AV_DICT_DONT_OVERWRITE); scan_all_pmts_set = 1; } if ((err = avformat_open_input(&fmt_ctx, filename, iformat, &format_opts)) < 0) { print_error(filename, err); return err; } ifile->fmt_ctx = fmt_ctx; if (scan_all_pmts_set) av_dict_set(&format_opts, "scan_all_pmts", NULL, AV_DICT_MATCH_CASE); if ((t = av_dict_get(format_opts, "", NULL, AV_DICT_IGNORE_SUFFIX))) { av_log(NULL, AV_LOG_ERROR, "Option %s not found.\n", t->key); return AVERROR_OPTION_NOT_FOUND; } opts = setup_find_stream_info_opts(fmt_ctx, codec_opts); orig_nb_streams = fmt_ctx->nb_streams; err = avformat_find_stream_info(fmt_ctx, opts); for (i = 0; i < orig_nb_streams; i++) av_dict_free(&opts[i]); av_freep(&opts); if (err < 0) { print_error(filename, err); return err; } av_dump_format(fmt_ctx, 0, filename, 0); ifile->streams = av_mallocz_array(fmt_ctx->nb_streams, sizeof(*ifile->streams)); if (!ifile->streams) exit(1); ifile->nb_streams = fmt_ctx->nb_streams; for (i = 0; i < fmt_ctx->nb_streams; i++) { InputStream *ist = &ifile->streams[i]; AVStream *stream = fmt_ctx->streams[i]; AVCodec *codec; ist->st = stream; if (stream->codecpar->codec_id == AV_CODEC_ID_PROBE) { av_log(NULL, AV_LOG_WARNING, "Failed to probe codec for input stream %d\n", stream->index); continue; } codec = avcodec_find_decoder(stream->codecpar->codec_id); if (!codec) { av_log(NULL, AV_LOG_WARNING, "Unsupported codec with id %d for input stream %d\n", stream->codecpar->codec_id, stream->index); continue; } { AVDictionary *opts = filter_codec_opts(codec_opts, stream->codecpar->codec_id, fmt_ctx, stream, codec); ist->dec_ctx = avcodec_alloc_context3(codec); if (!ist->dec_ctx) exit(1); err = avcodec_parameters_to_context(ist->dec_ctx, stream->codecpar); if (err < 0) exit(1); if (do_show_log) { av_dict_set(&codec_opts, "threads", "1", 0); } av_codec_set_pkt_timebase(ist->dec_ctx, stream->time_base); ist->dec_ctx->framerate = stream->avg_frame_rate; if (avcodec_open2(ist->dec_ctx, codec, &opts) < 0) { av_log(NULL, AV_LOG_WARNING, "Could not open codec for input stream %d\n", stream->index); exit(1); } if ((t = av_dict_get(opts, "", NULL, AV_DICT_IGNORE_SUFFIX))) { av_log(NULL, AV_LOG_ERROR, "Option %s for input stream %d not found\n", t->key, stream->index); return AVERROR_OPTION_NOT_FOUND; } } } ifile->fmt_ctx = fmt_ctx; return 0; }<SPLIT>[0.5195604475230265, 1.3681456262068041, 0.0, 0.4942630637605089, 1.2532698730026477, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 0.7102265412631674, 1.3074957340188142, 0.5335543553887203, 1.4352911903720318, 0.0, 0.0, 0.30852482215402843, 1.203960428345477, 0.5077564769051636, 1.3227458982827227, 2.0586801672721293, 0.6876643500811196, 0.0, -0.08645738172306322, -0.16222078614455715, 1.2382117722297952, 1.4368132321646163, 2.0373679067541706, -0.21702784222394986, 0.8010242403613708, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 0.7098813332246741, 0.04889276383167627, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 0.7058592275743352]
0<SPLIT>static void video_display(VideoState *is) { if (!window) video_open(is); SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255); SDL_RenderClear(renderer); if (is->audio_st && is->show_mode != SHOW_MODE_VIDEO) video_audio_display(is); else if (is->video_st) video_image_display(is); SDL_RenderPresent(renderer); }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.011671540416283347, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3615192241061562, -0.10760608081136262, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void avfilter_unref_bufferp(AVFilterBufferRef **ref) { FF_DISABLE_DEPRECATION_WARNINGS avfilter_unref_buffer(*ref); FF_ENABLE_DEPRECATION_WARNINGS *ref = NULL; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void checkasm_report(const char *name, ...) { static int prev_checked, prev_failed, max_length; if (state.num_checked > prev_checked) { int pad_length = max_length + 4; va_list arg; print_cpu_name(); pad_length -= fprintf(stderr, " - %s.", state.current_test_name); va_start(arg, name); pad_length -= vfprintf(stderr, name, arg); va_end(arg); fprintf(stderr, "%*c", FFMAX(pad_length, 0) + 2, '['); if (state.num_failed == prev_failed) color_printf(COLOR_GREEN, "OK"); else color_printf(COLOR_RED, "FAILED"); fprintf(stderr, "]\n"); prev_checked = state.num_checked; prev_failed = state.num_failed; } else if (!state.cpu_flag) { int length = strlen(state.current_test_name); va_list arg; va_start(arg, name); length += vsnprintf(NULL, 0, name, arg); va_end(arg); if (length > max_length) max_length = length; } }<SPLIT>[-0.09900860198293619, -0.020159756014915854, 0.0, -0.11436118199787926, -0.08729279623175898, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.031089429262525795, -0.09566541730555662, -0.0006602620976677653, 0.0, 0.0, 0.30852482215402843, -0.09407211557651925, -0.11100716297398205, -0.06870780348722379, 0.6353133682363457, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, 0.3469147738186936, 0.7955408613214935, -0.21702784222394986, -0.04111270872174079, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static int mov_write_hvcc_tag(AVIOContext *pb, MOVTrack *track) { int64_t pos = avio_tell(pb); avio_wb32(pb, 0); ffio_wfourcc(pb, "hvcC"); ff_isom_write_hvcc(pb, track->vos_data, track->vos_len, 0); return update_size(pb, pos); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.4705090699407485, -0.3333928163445767, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void open_audio(AVFormatContext *oc, AVCodec *codec, OutputStream *ost, AVDictionary *opt_arg) { AVCodecContext *c; int nb_samples; int ret; AVDictionary *opt = NULL; c = ost->st->codec; av_dict_copy(&opt, opt_arg, 0); ret = avcodec_open2(c, codec, &opt); av_dict_free(&opt); if (ret < 0) { fprintf(stderr, "Could not open audio codec: %s\n", av_err2str(ret)); exit(1); } ost->t = 0; ost->tincr = 2 * M_PI * 110.0 / c->sample_rate; ost->tincr2 = 2 * M_PI * 110.0 / c->sample_rate / c->sample_rate; if (c->codec->capabilities & AV_CODEC_CAP_VARIABLE_FRAME_SIZE) nb_samples = 10000; else nb_samples = c->frame_size; ost->frame = alloc_audio_frame(c->sample_fmt, c->channel_layout, c->sample_rate, nb_samples); ost->tmp_frame = alloc_audio_frame(AV_SAMPLE_FMT_S16, c->channel_layout, c->sample_rate, nb_samples); ost->swr_ctx = swr_alloc(); if (!ost->swr_ctx) { fprintf(stderr, "Could not allocate resampler context\n"); exit(1); } av_opt_set_int (ost->swr_ctx, "in_channel_count", c->channels, 0); av_opt_set_int (ost->swr_ctx, "in_sample_rate", c->sample_rate, 0); av_opt_set_sample_fmt(ost->swr_ctx, "in_sample_fmt", AV_SAMPLE_FMT_S16, 0); av_opt_set_int (ost->swr_ctx, "out_channel_count", c->channels, 0); av_opt_set_int (ost->swr_ctx, "out_sample_rate", c->sample_rate, 0); av_opt_set_sample_fmt(ost->swr_ctx, "out_sample_fmt", c->sample_fmt, 0); if ((ret = swr_init(ost->swr_ctx)) < 0) { fprintf(stderr, "Failed to initialize the resampling context\n"); exit(1); } }<SPLIT>[0.6742027098995172, 0.24427936440826892, 0.0, 0.6464191252001059, 0.16805247409860422, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 0.7102265412631674, 0.3085515823163217, 0.6908592985622897, 0.2728543002775131, 0.0, 0.0, 0.30852482215402843, 0.23527942541861413, 0.66244738687495, 0.19633099684990887, 0.7647103499668715, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2896437087679637, 0.5103995425705821, 0.6826474935548865, 0.6817979554923368, 0.23959960763929639, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 0.7098813332246741, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 0.7058592275743352]
0<SPLIT>static int request_frame(AVFilterLink *outlink) { SSIMContext *s = outlink->src->priv; return ff_dualinput_request_frame(&s->dinput, outlink); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold int opengl_prepare_vertex(AVFormatContext *s) { OpenGLContext *opengl = s->priv_data; int tex_w, tex_h; if (opengl->window_width > opengl->max_viewport_width || opengl->window_height > opengl->max_viewport_height) { opengl->window_width = FFMIN(opengl->window_width, opengl->max_viewport_width); opengl->window_height = FFMIN(opengl->window_height, opengl->max_viewport_height); av_log(opengl, AV_LOG_WARNING, "Too big viewport requested, limited to %dx%d", opengl->window_width, opengl->window_height); } glViewport(0, 0, opengl->window_width, opengl->window_height); opengl_make_ortho(opengl->projection_matrix, - (float)opengl->window_width / 2.0f, (float)opengl->window_width / 2.0f, - (float)opengl->window_height / 2.0f, (float)opengl->window_height / 2.0f, 1.0f, -1.0f); opengl_make_identity(opengl->model_view_matrix); opengl_compute_display_area(s); opengl->vertex[0].z = opengl->vertex[1].z = opengl->vertex[2].z = opengl->vertex[3].z = 0.0f; opengl->vertex[0].x = opengl->vertex[1].x = - (float)opengl->picture_width / 2.0f; opengl->vertex[2].x = opengl->vertex[3].x = (float)opengl->picture_width / 2.0f; opengl->vertex[1].y = opengl->vertex[2].y = - (float)opengl->picture_height / 2.0f; opengl->vertex[0].y = opengl->vertex[3].y = (float)opengl->picture_height / 2.0f; opengl_get_texture_size(opengl, opengl->width, opengl->height, &tex_w, &tex_h); opengl->vertex[0].s0 = 0.0f; opengl->vertex[0].t0 = 0.0f; opengl->vertex[1].s0 = 0.0f; opengl->vertex[1].t0 = (float)opengl->height / (float)tex_h; opengl->vertex[2].s0 = (float)opengl->width / (float)tex_w; opengl->vertex[2].t0 = (float)opengl->height / (float)tex_h; opengl->vertex[3].s0 = (float)opengl->width / (float)tex_w; opengl->vertex[3].t0 = 0.0f; opengl->glprocs.glBindBuffer(FF_GL_ARRAY_BUFFER, opengl->vertex_buffer); opengl->glprocs.glBufferData(FF_GL_ARRAY_BUFFER, sizeof(opengl->vertex), opengl->vertex, FF_GL_STATIC_DRAW); opengl->glprocs.glBindBuffer(FF_GL_ARRAY_BUFFER, 0); OPENGL_ERROR_CHECK(opengl); return 0; fail: return AVERROR_EXTERNAL; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, 0.10421615651601342, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.060916844891778815, -0.26569807294376846, 0.1300712967656257, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.32477585926655006, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int connect_ports(AVFilterContext *ctx, AVFilterLink *link) { LADSPAContext *s = ctx->priv; int i, j; s->nb_handles = s->nb_inputs == 1 && s->nb_outputs == 1 ? link->channels : 1; s->handles = av_calloc(s->nb_handles, sizeof(*s->handles)); if (!s->handles) return AVERROR(ENOMEM); for (i = 0; i < s->nb_handles; i++) { s->handles[i] = s->desc->instantiate(s->desc, link->sample_rate); if (!s->handles[i]) { av_log(ctx, AV_LOG_ERROR, "Could not instantiate plugin.\n"); return AVERROR_EXTERNAL; } for (j = 0; j < s->nb_inputcontrols; j++) s->desc->connect_port(s->handles[i], s->icmap[j], s->ictlv + j); for (j = 0; j < s->nb_outputcontrols; j++) s->desc->connect_port(s->handles[i], s->ocmap[j], &s->octlv[j]); if (s->desc->activate) s->desc->activate(s->handles[i]); } av_log(ctx, AV_LOG_DEBUG, "handles: %d\n", s->nb_handles); return 0; }<SPLIT>[0.05563366039355449, -0.13034272285790952, 0.0, 0.037794879441717756, -0.1936866588694103, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.1110049613987252, 0.061639525868012635, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.17156659581066827, 0.04368374699580437, -0.17914063696102905, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, -0.3615192241061562, -0.22049944857796966, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int opt_vsync(void *optctx, const char *opt, const char *arg) { if (!av_strcasecmp(arg, "cfr")) video_sync_method = VSYNC_CFR; else if (!av_strcasecmp(arg, "vfr")) video_sync_method = VSYNC_VFR; else if (!av_strcasecmp(arg, "passthrough")) video_sync_method = VSYNC_PASSTHROUGH; else if (!av_strcasecmp(arg, "drop")) video_sync_method = VSYNC_DROP; if (video_sync_method == VSYNC_AUTO) video_sync_method = parse_number_or_die("vsync", arg, OPT_INT, VSYNC_AUTO, VSYNC_VFR); return 0; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold int init(AVFilterContext *ctx) { uint8_t r, g, b; SignalstatsContext *s = ctx->priv; if (s->outfilter != FILTER_NONE) s->filters |= 1 << s->outfilter; r = s->rgba_color[0]; g = s->rgba_color[1]; b = s->rgba_color[2]; s->yuv_color[0] = (( 66*r + 129*g + 25*b + (1<<7)) >> 8) + 16; s->yuv_color[1] = ((-38*r + -74*g + 112*b + (1<<7)) >> 8) + 128; s->yuv_color[2] = ((112*r + -94*g + -18*b + (1<<7)) >> 8) + 128; return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>int av_opt_query_ranges(AVOptionRanges **ranges_arg, void *obj, const char *key, int flags) { int ret; const AVClass *c = *(AVClass**)obj; int (*callback)(AVOptionRanges **, void *obj, const char *key, int flags) = NULL; if (c->version > (52 << 16 | 11 << 8)) callback = c->query_ranges; if (!callback) callback = av_opt_query_ranges_default; ret = callback(ranges_arg, obj, key, flags); if (ret >= 0) { if (!(flags & AV_OPT_MULTI_COMPONENT_RANGE)) ret = 1; (*ranges_arg)->nb_components = ret; } return ret; }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.39986248560786075, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.3070243011888601, -0.4462861841111837, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>av_cold int ff_ac3_encode_init(AVCodecContext *avctx) { AC3EncodeContext *s = avctx->priv_data; int ret, frame_size_58; s->avctx = avctx; s->eac3 = avctx->codec_id == AV_CODEC_ID_EAC3; ff_ac3_common_init(); ret = validate_options(s); if (ret) return ret; avctx->frame_size = AC3_BLOCK_SIZE * s->num_blocks; avctx->initial_padding = AC3_BLOCK_SIZE; s->bitstream_mode = avctx->audio_service_type; if (s->bitstream_mode == AV_AUDIO_SERVICE_TYPE_KARAOKE) s->bitstream_mode = 0x7; s->bits_written = 0; s->samples_written = 0; frame_size_58 = (( s->frame_size >> 2) + ( s->frame_size >> 4)) << 1; s->crc_inv[0] = pow_poly((CRC16_POLY >> 1), (8 * frame_size_58) - 16, CRC16_POLY); if (s->bit_alloc.sr_code == 1) { frame_size_58 = (((s->frame_size+2) >> 2) + ((s->frame_size+2) >> 4)) << 1; s->crc_inv[1] = pow_poly((CRC16_POLY >> 1), (8 * frame_size_58) - 16, CRC16_POLY); } if (CONFIG_AC3_FIXED_ENCODER && s->fixed_point) { s->mdct_end = ff_ac3_fixed_mdct_end; s->mdct_init = ff_ac3_fixed_mdct_init; s->allocate_sample_buffers = ff_ac3_fixed_allocate_sample_buffers; } else if (CONFIG_AC3_ENCODER || CONFIG_EAC3_ENCODER) { s->mdct_end = ff_ac3_float_mdct_end; s->mdct_init = ff_ac3_float_mdct_init; s->allocate_sample_buffers = ff_ac3_float_allocate_sample_buffers; } if (CONFIG_EAC3_ENCODER && s->eac3) s->output_frame_header = ff_eac3_output_frame_header; else s->output_frame_header = ac3_output_frame_header; set_bandwidth(s); exponent_init(s); bit_alloc_init(s); ret = s->mdct_init(s); if (ret) goto init_fail; ret = allocate_buffers(s); if (ret) goto init_fail; ff_audiodsp_init(&s->adsp); ff_me_cmp_init(&s->mecc, avctx); ff_ac3dsp_init(&s->ac3dsp, avctx->flags & AV_CODEC_FLAG_BITEXACT); dprint_options(s); return 0; init_fail: ff_ac3_encode_close(avctx); return ret; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.037794879441717756, 0.4446765169564977, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.40964200594544947, 0.04368374699580437, 0.4834563638818026, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.6760973642524136, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { WaveformContext *s = ctx->priv; av_freep(&s->peak); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static inline void movecb(void *addr, int delta) { SndioData *s = addr; s->hwpos += delta * s->channels * s->bps; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>int ff_h264_decode_sei(H264Context *h){ MpegEncContext * const s = &h->s; while(get_bits_count(&s->gb) + 16 < s->gb.size_in_bits){ int size, type; type=0; do{ type+= show_bits(&s->gb, 8); }while(get_bits(&s->gb, 8) == 255); size=0; do{ size+= show_bits(&s->gb, 8); }while(get_bits(&s->gb, 8) == 255); if(s->avctx->debug&FF_DEBUG_STARTCODE) av_log(h->s.avctx, AV_LOG_DEBUG, "SEI %d len:%d\n", type, size); switch(type){ case SEI_TYPE_PIC_TIMING: if(decode_picture_timing(h) < 0) return -1; break; case SEI_TYPE_USER_DATA_UNREGISTERED: if(decode_unregistered_user_data(h, size) < 0) return -1; break; case SEI_TYPE_RECOVERY_POINT: if(decode_recovery_point(h) < 0) return -1; break; case SEI_BUFFERING_PERIOD: if(decode_buffering_period(h) < 0) return -1; break; default: skip_bits(&s->gb, 8*size); } align_get_bits(&s->gb); } return 0; }<SPLIT>[0.9834872346524985, 0.1781695843024727, 0.0, 0.9507312480792999, 0.10421615651601342, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.2885726992822718, 1.0054691849094282, 0.2044756596837179, 0.0, 0.0, 0.30852482215402843, 0.21590580536007686, 0.9718292068145229, 0.1300712967656257, 0.6353133682363457, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, 0.01994523631491676, 0.5697541257882794, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static inline void yuvPlanartoyuy2_c(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst, int width, int height, int lumStride, int chromStride, int dstStride, int vertLumPerChroma) { int y, i; const int chromWidth = width >> 1; for (y = 0; y < height; y++) { #if HAVE_FAST_64BIT uint64_t *ldst = (uint64_t *)dst; const uint8_t *yc = ysrc, *uc = usrc, *vc = vsrc; for (i = 0; i < chromWidth; i += 2) { uint64_t k = yc[0] + (uc[0] << 8) + (yc[1] << 16) + ((unsigned) vc[0] << 24); uint64_t l = yc[2] + (uc[1] << 8) + (yc[3] << 16) + ((unsigned) vc[1] << 24); *ldst++ = k + (l << 32); yc += 4; uc += 2; vc += 2; } #else int *idst = (int32_t *)dst; const uint8_t *yc = ysrc, *uc = usrc, *vc = vsrc; for (i = 0; i < chromWidth; i++) { #if HAVE_BIGENDIAN *idst++ = (yc[0] << 24) + (uc[0] << 16) + (yc[1] << 8) + (vc[0] << 0); #else *idst++ = yc[0] + (uc[0] << 8) + (yc[1] << 16) + (vc[0] << 24); #endif yc += 2; uc++; vc++; } #endif if ((y & (vertLumPerChroma - 1)) == vertLumPerChroma - 1) { usrc += chromStride; vsrc += chromStride; } ysrc += lumStride; dst += dstStride; } }<SPLIT>[-0.25365086435942685, 0.35446233125126253, 0.0, -0.2665172434374763, 0.2744463367362555, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.2885726992822718, -0.25297036047912586, -0.06903890269146298, 0.0, 0.0, 0.30852482215402843, 0.21590580536007686, -0.26569807294376846, -0.13496750357150694, 0.24712242304476825, -0.07965011232897776, 0.0, 1.457000985644429, 3.3165250246057414, 0.2545115582693773, -0.03454968660237938, -0.22049944857796966, -0.21702784222394986, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static int ff_filter_frame_framed(AVFilterLink *link, AVFrame *frame); void ff_tlog_ref(void *ctx, AVFrame *ref, int end) { av_unused char buf[16]; ff_tlog(ctx, "ref[%p buf:%p data:%p linesize[%d, %d, %d, %d] pts:%"PRId64" pos:%"PRId64, ref, ref->buf, ref->data[0], ref->linesize[0], ref->linesize[1], ref->linesize[2], ref->linesize[3], ref->pts, av_frame_get_pkt_pos(ref)); if (ref->width) { ff_tlog(ctx, " a:%d/%d s:%dx%d i:%c iskey:%d type:%c", ref->sample_aspect_ratio.num, ref->sample_aspect_ratio.den, ref->width, ref->height, !ref->interlaced_frame ? 'P' : ref->top_field_first ? 'T' : 'B', ref->key_frame, av_get_picture_type_char(ref->pict_type)); } if (ref->nb_samples) { ff_tlog(ctx, " cl:%"PRId64"d n:%d r:%d", ref->channel_layout, ref->nb_samples, ref->sample_rate); } ff_tlog(ctx, "]%s", end ? "\n" : ""); }<SPLIT>[-0.25365086435942685, -0.10830612948931077, 0.0, -0.2665172434374763, -0.15112911381434976, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.13098384443277505, -0.25297036047912586, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.17156659581066827, -0.26569807294376846, -0.13496750357150694, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3615192241061562, -0.4462861841111837, -0.21702784222394986, -0.22825425296243224, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>FF_DISABLE_DEPRECATION_WARNINGS static void compat_free_buffer(void *opaque, uint8_t *data) { AVFilterBufferRef *buf = opaque; AV_NOWARN_DEPRECATED( avfilter_unref_buffer(buf); ) }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static PullupField *make_field_queue(PullupContext *s, int len) { PullupField *head, *f; f = head = av_mallocz(sizeof(*head)); if (!f) return NULL; if (alloc_metrics(s, f) < 0) { av_free(f); return NULL; } for (; len > 0; len--) { f->next = av_mallocz(sizeof(*f->next)); if (!f->next) { free_field_queue(head); return NULL; } f->next->prev = f; f = f->next; if (alloc_metrics(s, f) < 0) { free_field_queue(head); return NULL; } } f->next = head; head->prev = f; return head; }<SPLIT>[-0.25365086435942685, -0.06423294275211332, 0.0, -0.2665172434374763, -0.12985034128681952, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, -0.09102607836467534, -0.25297036047912586, -0.04624602249353125, 0.0, 0.0, 0.30852482215402843, -0.152192975752131, -0.26569807294376846, -0.1128809368767459, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.14353953243697165, -0.3333928163445767, 0.6817979554923368, -0.04111270872174079, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>const int av_sha512_size = sizeof(AVSHA512); struct AVSHA512 *av_sha512_alloc(void) { return av_mallocz(sizeof(struct AVSHA512)); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int ff_free_filters(SwsContext *c) { int i; if (c->desc) { for (i = 0; i < c->numDesc; ++i) av_freep(&c->desc[i].instance); av_freep(&c->desc); } if (c->slice) { for (i = 0; i < c->numSlice; ++i) free_slice(&c->slice[i]); av_freep(&c->slice); } return 0; }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.3615192241061562, -0.4462861841111837, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
1<SPLIT>static int h264_slice_header_init(H264Context *h) { int nb_slices = (HAVE_THREADS && h->avctx->active_thread_type & FF_THREAD_SLICE) ? h->avctx->thread_count : 1; int i, ret; ff_set_sar(h->avctx, h->sps.sar); av_pix_fmt_get_chroma_sub_sample(h->avctx->pix_fmt, &h->chroma_x_shift, &h->chroma_y_shift); if (h->sps.timing_info_present_flag) { int64_t den = h->sps.time_scale; if (h->x264_build < 44U) den *= 2; av_reduce(&h->avctx->framerate.den, &h->avctx->framerate.num, h->sps.num_units_in_tick * h->avctx->ticks_per_frame, den, 1 << 30); } ff_h264_free_tables(h); h->first_field = 0; h->prev_interlaced_frame = 1; init_scan_tables(h); ret = ff_h264_alloc_tables(h); if (ret < 0) { av_log(h->avctx, AV_LOG_ERROR, "Could not allocate memory\n"); goto fail; } #if FF_API_CAP_VDPAU if (h->avctx->codec && h->avctx->codec->capabilities & AV_CODEC_CAP_HWACCEL_VDPAU && (h->sps.bit_depth_luma != 8 || h->sps.chroma_format_idc > 1)) { av_log(h->avctx, AV_LOG_ERROR, "VDPAU decoding does not support video colorspace.\n"); ret = AVERROR_INVALIDDATA; goto fail; } #endif if (h->sps.bit_depth_luma < 8 || h->sps.bit_depth_luma > 14 || h->sps.bit_depth_luma == 11 || h->sps.bit_depth_luma == 13 ) { av_log(h->avctx, AV_LOG_ERROR, "Unsupported bit depth %d\n", h->sps.bit_depth_luma); ret = AVERROR_INVALIDDATA; goto fail; } h->cur_bit_depth_luma = h->avctx->bits_per_raw_sample = h->sps.bit_depth_luma; h->cur_chroma_format_idc = h->sps.chroma_format_idc; h->pixel_shift = h->sps.bit_depth_luma > 8; h->chroma_format_idc = h->sps.chroma_format_idc; h->bit_depth_luma = h->sps.bit_depth_luma; ff_h264dsp_init(&h->h264dsp, h->sps.bit_depth_luma, h->sps.chroma_format_idc); ff_h264chroma_init(&h->h264chroma, h->sps.bit_depth_chroma); ff_h264qpel_init(&h->h264qpel, h->sps.bit_depth_luma); ff_h264_pred_init(&h->hpc, h->avctx->codec_id, h->sps.bit_depth_luma, h->sps.chroma_format_idc); ff_videodsp_init(&h->vdsp, h->sps.bit_depth_luma); if (nb_slices > H264_MAX_THREADS || (nb_slices > h->mb_height && h->mb_height)) { int max_slices; if (h->mb_height) max_slices = FFMIN(H264_MAX_THREADS, h->mb_height); else max_slices = H264_MAX_THREADS; av_log(h->avctx, AV_LOG_WARNING, "too many threads/slices %d," " reducing to %d\n", nb_slices, max_slices); nb_slices = max_slices; } h->slice_context_count = nb_slices; if (!HAVE_THREADS || !(h->avctx->active_thread_type & FF_THREAD_SLICE)) { ret = ff_h264_slice_context_init(h, &h->slice_ctx[0]); if (ret < 0) { av_log(h->avctx, AV_LOG_ERROR, "context_init() failed.\n"); goto fail; } } else { for (i = 0; i < h->slice_context_count; i++) { H264SliceContext *sl = &h->slice_ctx[i]; sl->h264 = h; sl->intra4x4_pred_mode = h->intra4x4_pred_mode + i * 8 * 2 * h->mb_stride; sl->mvd_table[0] = h->mvd_table[0] + i * 8 * 2 * h->mb_stride; sl->mvd_table[1] = h->mvd_table[1] + i * 8 * 2 * h->mb_stride; if ((ret = ff_h264_slice_context_init(h, sl)) < 0) { av_log(h->avctx, AV_LOG_ERROR, "context_init() failed.\n"); goto fail; } } } h->context_initialized = 1; return 0; fail: ff_h264_free_tables(h); h->context_initialized = 0; return ret; }<SPLIT>[2.065983071287933, 1.3901822195754028, 0.0, 2.015823678156479, 1.274548645530178, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 1.040052222782594, 1.5272634473933626, 2.106603787124413, 1.2301552685906463, 0.0, 0.0, 0.30852482215402843, 1.417070248989387, 2.054665576603028, 1.123966798029873, 1.4116952586195004, 0.5780479983082486, 0.0, 0.7955188282012181, 0.9973611507722091, 1.1679474712326225, 1.0553487717435432, 1.3600077001545285, 0.6817979554923368, 0.6138826961206794, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 1.039626388904333, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 1.0350888753871217]
0<SPLIT>static int do_colorkey_slice(AVFilterContext *avctx, void *arg, int jobnr, int nb_jobs) { AVFrame *frame = arg; const int slice_start = (frame->height * jobnr) / nb_jobs; const int slice_end = (frame->height * (jobnr + 1)) / nb_jobs; ColorkeyContext *ctx = avctx->priv; int o, x, y; for (y = slice_start; y < slice_end; ++y) { for (x = 0; x < frame->width; ++x) { o = frame->linesize[0] * y + x * 4; frame->data[0][o + ctx->co[3]] = do_colorkey_pixel(ctx, frame->data[0][o + ctx->co[0]], frame->data[0][o + ctx->co[1]], frame->data[0][o + ctx->co[2]]); } } return 0; }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.14353953243697165, -0.10760608081136262, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
1<SPLIT>int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end, const uint8_t *name, uint8_t *dst, int dst_size) { int namelen = strlen(name); int len; while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) { len = ff_amf_tag_size(data, data_end); if (len < 0) len = data_end - data; data += len; } if (data_end - data < 3) return -1; data++; for (;;) { int size = bytestream_get_be16(&data); if (!size) break; if (size < 0 || size >= data_end - data) return -1; data += size; if (size == namelen && !memcmp(data-size, name, namelen)) { switch (*data++) { case AMF_DATA_TYPE_NUMBER: snprintf(dst, dst_size, "%g", av_int2double(AV_RB64(data))); break; case AMF_DATA_TYPE_BOOL: snprintf(dst, dst_size, "%s", *data ? "true" : "false"); break; case AMF_DATA_TYPE_STRING: len = bytestream_get_be16(&data); av_strlcpy(dst, data, FFMIN(len+1, dst_size)); break; default: return -1; } return 0; } len = ff_amf_tag_size(data, data_end); if (len < 0 || len >= data_end - data) return -1; data += len; } return -1; }<SPLIT>[-0.09900860198293619, 0.33242573788266383, 0.0, -0.11436118199787926, 0.25316756420872527, 0.0, 0.6225807337249721, 0.6411199308703055, 0.5742476557731842, 1.699703585821447, 0.2885726992822718, -0.09566541730555662, 0.3640258210692401, 0.0, 0.0, 0.30852482215402843, 0.21590580536007686, -0.11100716297398205, 0.28467726362895307, 0.24712242304476825, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, 0.21937940777079099, 0.7283792342397666, 0.5697541257882794, 2.47944955092491, 0.5203119240003335, 0.6220897838620095, 0.6406805230120434, 0.5737900437766489, 1.6991165002636506, 0.9056307075691036, 0.0, 0.6182652667186178, 0.6368235570697065, 0.5700153422610048, 1.693548171012695]
0<SPLIT>void av_murmur3_init_seeded(AVMurMur3 *c, uint64_t seed) { memset(c, 0, sizeof(*c)); c->h1 = c->h2 = seed; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void av_cold uninit(AVFilterContext *ctx) { ZMQContext *zmq = ctx->priv; zmq_close(zmq->responder); zmq_ctx_destroy(zmq->zmq); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int request_frame(AVFilterLink *outlink) { AVFilterLink *inlink = outlink->src->inputs[0]; int ret; ret = ff_request_frame(inlink); if (ret == AVERROR_EOF) { ret = push_samples(outlink); return ret < 0 ? ret : ret > 0 ? 0 : AVERROR_EOF; } return ret; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.41601414702345235, -0.4462861841111837, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_cold int init(AVFilterContext *ctx, AVDictionary **opts) { ResampleContext *s = ctx->priv; const AVClass *avr_class = avresample_get_class(); AVDictionaryEntry *e = NULL; while ((e = av_dict_get(*opts, "", e, AV_DICT_IGNORE_SUFFIX))) { if (av_opt_find(&avr_class, e->key, NULL, 0, AV_OPT_SEARCH_FAKE_OBJ | AV_OPT_SEARCH_CHILDREN)) av_dict_set(&s->options, e->key, e->value, 0); } e = NULL; while ((e = av_dict_get(s->options, "", e, AV_DICT_IGNORE_SUFFIX))) av_dict_set(opts, e->key, NULL, 0); av_dict_set(&s->options, "in_channel_layout", NULL, 0); av_dict_set(&s->options, "out_channel_layout", NULL, 0); av_dict_set(&s->options, "in_sample_fmt", NULL, 0); av_dict_set(&s->options, "out_sample_fmt", NULL, 0); av_dict_set(&s->options, "in_sample_rate", NULL, 0); av_dict_set(&s->options, "out_sample_rate", NULL, 0); return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.11436118199787926, -0.2575229764520011, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.2490610760448173, -0.11100716297398205, -0.24540033704531222, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>int av_hash_alloc(AVHashContext **ctx, const char *name) { AVHashContext *res; int i; *ctx = NULL; for (i = 0; i < NUM_HASHES; i++) if (av_strcasecmp(name, hashdesc[i].name) == 0) break; if (i >= NUM_HASHES) return AVERROR(EINVAL); res = av_mallocz(sizeof(*res)); if (!res) return AVERROR(ENOMEM); res->type = i; switch (i) { case MD5: res->ctx = av_md5_alloc(); break; case MURMUR3: res->ctx = av_murmur3_alloc(); break; case RIPEMD128: case RIPEMD160: case RIPEMD256: case RIPEMD320: res->ctx = av_ripemd_alloc(); break; case SHA160: case SHA224: case SHA256: res->ctx = av_sha_alloc(); break; case SHA512_224: case SHA512_256: case SHA384: case SHA512: res->ctx = av_sha512_alloc(); break; case CRC32: res->crctab = av_crc_get_table(AV_CRC_32_IEEE_LE); break; case ADLER32: break; } if (i != ADLER32 && i != CRC32 && !res->ctx) { av_free(res); return AVERROR(ENOMEM); } *ctx = res; return 0; }<SPLIT>[-0.25365086435942685, 0.13409639756527525, 0.0, -0.2665172434374763, 0.06165861146095288, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.08878386894177331, -0.25297036047912586, 0.1588898992878544, 0.0, 0.0, 0.30852482215402843, 0.022169604774704303, -0.26569807294376846, 0.08589816337610359, 0.6353133682363457, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2545115582693773, 0.4559046196532859, 0.4568607580216725, -0.21702784222394986, 0.42674115187998785, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int asf_read_data(AVFormatContext *s, const GUIDParseTable *g) { ASFContext *asf = s->priv_data; AVIOContext *pb = s->pb; uint64_t size = asf->data_size = avio_rl64(pb); int i; if (!asf->data_reached) { asf->data_reached = 1; asf->data_offset = asf->offset; } for (i = 0; i < asf->nb_streams; i++) { if (!(asf->b_flags & ASF_FLAG_BROADCAST)) s->streams[i]->duration = asf->duration; } asf->nb_mult_left = 0; asf->sub_left = 0; asf->state = PARSE_PACKET_HEADER; asf->return_subpayload = 0; asf->packet_size_internal = 0; avio_skip(pb, 16); size = avio_rl64(pb); if (size != asf->nb_packets) av_log(s, AV_LOG_WARNING, "Number of Packets from File Properties Object is not equal to Total" "Datapackets value! num of packets %"PRIu64" total num %"PRIu64".\n", size, asf->nb_packets); avio_skip(pb, 2); asf->first_packet_offset = avio_tell(pb); if (pb->seekable && !(asf->b_flags & ASF_FLAG_BROADCAST)) align_position(pb, asf->offset, asf->data_size); return 0; }<SPLIT>[-0.25365086435942685, 0.04595002409088034, 0.0, -0.2665172434374763, -0.02345647864916818, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.008868336805573909, -0.25297036047912586, 0.06771837849612745, 0.0, 0.0, 0.30852482215402843, -0.05532487545944473, -0.26569807294376846, -0.0024481034029406237, -0.011671540416283347, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.043718655277859224, -0.25252937827156396, -0.10760608081136262, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void log_packet(const AVFormatContext *fmt_ctx, const AVPacket *pkt, const char *tag) { AVRational *time_base = &fmt_ctx->streams[pkt->stream_index]->time_base; printf("%s: pts:%s pts_time:%s dts:%s dts_time:%s duration:%s duration_time:%s stream_index:%d\n", tag, av_ts2str(pkt->pts), av_ts2timestr(pkt->pts, time_base), av_ts2str(pkt->dts), av_ts2timestr(pkt->dts, time_base), av_ts2str(pkt->duration), av_ts2timestr(pkt->duration, time_base), pkt->stream_index); }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int func_eval_expr(AVFilterContext *ctx, AVBPrint *bp, char *fct, unsigned argc, char **argv, int tag) { DrawTextContext *s = ctx->priv; double res; int ret; ret = av_expr_parse_and_eval(&res, argv[0], var_names, s->var_values, NULL, NULL, fun2_names, fun2, &s->prng, 0, ctx); if (ret < 0) av_log(ctx, AV_LOG_ERROR, "Expression '%s' for the expr text expansion function is not valid\n", argv[0]); else av_bprintf(bp, "%f", res); return ret; }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.011671540416283347, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.3615192241061562, -0.22049944857796966, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static double psnr(double d) { return -10.0 * log10(d); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void list_formats(AVFormatContext *ctx, int type) { const struct video_data *s = ctx->priv_data; struct v4l2_fmtdesc vfd = { .type = V4L2_BUF_TYPE_VIDEO_CAPTURE }; while(!v4l2_ioctl(s->fd, VIDIOC_ENUM_FMT, &vfd)) { enum AVCodecID codec_id = ff_fmt_v4l2codec(vfd.pixelformat); enum AVPixelFormat pix_fmt = ff_fmt_v4l2ff(vfd.pixelformat, codec_id); vfd.index++; if (!(vfd.flags & V4L2_FMT_FLAG_COMPRESSED) && type & V4L_RAWFORMATS) { const char *fmt_name = av_get_pix_fmt_name(pix_fmt); av_log(ctx, AV_LOG_INFO, "Raw : %11s : %20s :", fmt_name ? fmt_name : "Unsupported", vfd.description); } else if (vfd.flags & V4L2_FMT_FLAG_COMPRESSED && type & V4L_COMPFORMATS) { const AVCodecDescriptor *desc = avcodec_descriptor_get(codec_id); av_log(ctx, AV_LOG_INFO, "Compressed: %11s : %20s :", desc ? desc->name : "Unsupported", vfd.description); } else { continue; } #ifdef V4L2_FMT_FLAG_EMULATED if (vfd.flags & V4L2_FMT_FLAG_EMULATED) av_log(ctx, AV_LOG_INFO, " Emulated :"); #endif #if HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE list_framesizes(ctx, vfd.pixelformat); #endif av_log(ctx, AV_LOG_INFO, "\n"); } }<SPLIT>[-0.25365086435942685, 0.06798661745947907, 0.0, -0.2665172434374763, -0.0021777061216379156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.02884721983962376, -0.25297036047912586, -0.06903890269146298, 0.0, 0.0, 0.30852482215402843, -0.03595125540090747, -0.26569807294376846, -0.13496750357150694, 0.24712242304476825, -0.518115519420462, 0.0, 0.24428369699854227, 2.1569430876889752, -0.2373385487108316, 0.18343000506680518, 1.0213275968547075, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int av_parse_video_size(int *width_ptr, int *height_ptr, const char *str) { int i; int n = FF_ARRAY_ELEMS(video_size_abbrs); const char *p; int width = 0, height = 0; for (i = 0; i < n; i++) { if (!strcmp(video_size_abbrs[i].abbr, str)) { width = video_size_abbrs[i].width; height = video_size_abbrs[i].height; break; } } if (i == n) { width = strtol(str, (void*)&p, 10); if (*p) p++; height = strtol(p, (void*)&p, 10); if (*p) return AVERROR(EINVAL); } if (width <= 0 || height <= 0) return AVERROR(EINVAL); *width_ptr = width; *height_ptr = height; return 0; }<SPLIT>[-0.09900860198293619, -0.06423294275211332, 0.0, -0.11436118199787926, -0.12985034128681952, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 0.380400859743741, -0.07104719533062549, -0.09566541730555662, -0.04624602249353125, 0.0, 0.0, 0.30852482215402843, -0.13281935569359377, -0.11100716297398205, -0.1128809368767459, 0.11772544131424245, 0.7972807018539907, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, 0.5103995425705821, 0.23107402248845843, -0.21702784222394986, 0.7074534682410251, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 0.3801362775450152, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 0.3766295797615486]
0<SPLIT>static void smooth_end_frame_filter(AVFilterContext *ctx, IplImage *inimg, IplImage *outimg) { OCVContext *s = ctx->priv; SmoothContext *smooth = s->priv; cvSmooth(inimg, outimg, smooth->type, smooth->param1, smooth->param2, smooth->param3, smooth->param4); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int opt_video_codec(void *optctx, const char *opt, const char *arg) { OptionsContext *o = optctx; return parse_option(o, "codec:v", arg, options); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int check_xfixes(xcb_connection_t *conn) { xcb_xfixes_query_version_cookie_t cookie; xcb_xfixes_query_version_reply_t *reply; cookie = xcb_xfixes_query_version(conn, XCB_XFIXES_MAJOR_VERSION, XCB_XFIXES_MINOR_VERSION); reply = xcb_xfixes_query_version_reply(conn, cookie, NULL); if (reply) { free(reply); return 1; } return 0; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.39986248560786075, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.3615192241061562, -0.4462861841111837, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void RENAME(yuv2rgb565_X_ar)(SwsContext *c, const int16_t *lumFilter, const int16_t **lumSrc, int lumFilterSize, const int16_t *chrFilter, const int16_t **chrUSrc, const int16_t **chrVSrc, int chrFilterSize, const int16_t **alpSrc, uint8_t *dest, int dstW, int dstY) { x86_reg dummy=0; x86_reg dstW_reg = dstW; x86_reg uv_off = c->uv_offx2; YSCALEYUV2PACKEDX_ACCURATE YSCALEYUV2RGBX "pxor %%mm7, %%mm7 \n\t" #ifdef DITHER1XBPP "paddusb "BLUE_DITHER"(%0), %%mm2\n\t" "paddusb "GREEN_DITHER"(%0), %%mm4\n\t" "paddusb "RED_DITHER"(%0), %%mm5\n\t" #endif WRITERGB16(%4, "%5", %%REGa) YSCALEYUV2PACKEDX_END }<SPLIT>[-0.09900860198293619, -0.1964525029637057, 0.0, -0.11436118199787926, -0.2575229764520011, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.1909204935349246, -0.09566541730555662, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.11100716297398205, -0.3558331705191175, -0.7880534307994381, -0.518115519420462, 0.0, 0.24428369699854227, 0.9973611507722091, -0.5886600536966952, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void rm_read_metadata(AVFormatContext *s, AVIOContext *pb, int wide) { char buf[1024]; int i; for (i=0; i<FF_ARRAY_ELEMS(ff_rm_metadata); i++) { int len = wide ? avio_rb16(pb) : avio_r8(pb); get_strl(pb, buf, sizeof(buf), len); av_dict_set(&s->metadata, ff_rm_metadata[i], buf, 0); } }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.011671540416283347, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.25252937827156396, 0.11818065472185141, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void ff_aac_search_for_is(AACEncContext *s, AVCodecContext *avctx, ChannelElement *cpe) { SingleChannelElement *sce0 = &cpe->ch[0]; SingleChannelElement *sce1 = &cpe->ch[1]; int start = 0, count = 0, w, w2, g, i; const float freq_mult = avctx->sample_rate/(1024.0f/sce0->ics.num_windows)/2.0f; if (!cpe->common_window) return; for (w = 0; w < sce0->ics.num_windows; w += sce0->ics.group_len[w]) { start = 0; for (g = 0; g < sce0->ics.num_swb; g++) { if (start*freq_mult > INT_STEREO_LOW_LIMIT*(s->lambda/170.0f) && cpe->ch[0].band_type[w*16+g] != NOISE_BT && !cpe->ch[0].zeroes[w*16+g] && cpe->ch[1].band_type[w*16+g] != NOISE_BT && !cpe->ch[1].zeroes[w*16+g]) { float ener0 = 0.0f, ener1 = 0.0f, ener01 = 0.0f; struct AACISError ph_err1, ph_err2, *erf; for (w2 = 0; w2 < sce0->ics.group_len[w]; w2++) { for (i = 0; i < sce0->ics.swb_sizes[g]; i++) { float coef0 = sce0->pcoeffs[start+(w+w2)*128+i]; float coef1 = sce1->pcoeffs[start+(w+w2)*128+i]; ener0 += coef0*coef0; ener1 += coef1*coef1; ener01 += (coef0 + coef1)*(coef0 + coef1); } } ph_err1 = ff_aac_is_encoding_err(s, cpe, start, w, g, ener0, ener1, ener01, 0, -1); ph_err2 = ff_aac_is_encoding_err(s, cpe, start, w, g, ener0, ener1, ener01, 0, +1); erf = ph_err1.error < ph_err2.error ? &ph_err1 : &ph_err2; if (erf->pass) { cpe->is_mask[w*16+g] = 1; cpe->ch[0].is_ener[w*16+g] = sqrt(ener0/ener01); cpe->ch[1].is_ener[w*16+g] = ener0/ener1; cpe->ch[1].band_type[w*16+g] = erf->phase ? INTENSITY_BT : INTENSITY_BT2; count++; } } start += sce0->ics.swb_sizes[g]; } } cpe->is_mode = !!count; }<SPLIT>[-0.25365086435942685, 0.2883525511454664, 0.0, -0.2665172434374763, 0.21061001915366473, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.22863605018012226, -0.25297036047912586, 0.3184400606733766, 0.0, 0.0, 0.30852482215402843, 0.1577849451844651, -0.26569807294376846, 0.24050413023943099, 0.24712242304476825, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3950401602637228, 0.40140969673598975, 1.2471143323879217, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int hvcc_parse_pps(GetBitContext *gb, HEVCDecoderConfigurationRecord *hvcc) { uint8_t tiles_enabled_flag, entropy_coding_sync_enabled_flag; get_ue_golomb_long(gb); get_ue_golomb_long(gb); skip_bits(gb, 7); get_ue_golomb_long(gb); get_ue_golomb_long(gb); get_se_golomb_long(gb); skip_bits(gb, 2); if (get_bits1(gb)) get_ue_golomb_long(gb); get_se_golomb_long(gb); get_se_golomb_long(gb); skip_bits(gb, 4); tiles_enabled_flag = get_bits1(gb); entropy_coding_sync_enabled_flag = get_bits1(gb); if (entropy_coding_sync_enabled_flag && tiles_enabled_flag) hvcc->parallelismType = 0; else if (entropy_coding_sync_enabled_flag) hvcc->parallelismType = 3; else if (tiles_enabled_flag) hvcc->parallelismType = 2; else hvcc->parallelismType = 1; return 0; }<SPLIT>[2.529909858417405, -0.04219634938351458, 0.0, 2.47229186247527, -0.10857156875928925, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.2885726992822718, 2.5785186166451206, -0.023453142295599506, 0.0, 0.0, 0.30852482215402843, 0.21590580536007686, 2.5187383065123874, -0.09079437018198484, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>const char *postproc_configuration(void) { return FFMPEG_CONFIGURATION; }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static const AVClass *child_class_next(const AVClass *prev) { return prev ? NULL : avcodec_dct_get_class(); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static AVFrame *do_ssim(AVFilterContext *ctx, AVFrame *main, const AVFrame *ref) { AVDictionary **metadata = avpriv_frame_get_metadatap(main); SSIMContext *s = ctx->priv; float c[4], ssimv = 0.0; int i; s->nb_frames++; for (i = 0; i < s->nb_components; i++) { c[i] = ssim_plane(&s->dsp, main->data[i], main->linesize[i], ref->data[i], ref->linesize[i], s->planewidth[i], s->planeheight[i], s->temp); ssimv += s->coefs[i] * c[i]; s->ssim[i] += c[i]; } for (i = 0; i < s->nb_components; i++) { int cidx = s->is_rgb ? s->rgba_map[i] : i; set_meta(metadata, "lavfi.ssim.", s->comps[i], c[cidx]); } s->ssim_total += ssimv; set_meta(metadata, "lavfi.ssim.All", 0, ssimv); set_meta(metadata, "lavfi.ssim.dB", 0, ssim_db(ssimv, 1.0)); if (s->stats_file) { fprintf(s->stats_file, "n:%"PRId64" ", s->nb_frames); for (i = 0; i < s->nb_components; i++) { int cidx = s->is_rgb ? s->rgba_map[i] : i; fprintf(s->stats_file, "%c:%f ", s->comps[i], c[cidx]); } fprintf(s->stats_file, "All:%f (%f)\n", ssimv, ssim_db(ssimv, 1.0)); } return main; }<SPLIT>[-0.25365086435942685, 0.04595002409088034, 0.0, -0.2665172434374763, -0.02345647864916818, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.008868336805573909, -0.25297036047912586, 0.06771837849612745, 0.0, 0.0, 0.30852482215402843, -0.05532487545944473, -0.26569807294376846, -0.0024481034029406237, 0.37651940477529405, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.14911510677361828, -0.08904460951967552, 0.34396739025506545, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void set_contrast(EQContext *eq) { eq->contrast = av_clipf(av_expr_eval(eq->contrast_pexpr, eq->var_values, eq), -1000.0, 1000.0); eq->param[0].contrast = eq->contrast; eq->param[0].lut_clean = 0; check_values(&eq->param[0], eq); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int request_frame(AVFilterLink *outlink) { ShowSpectrumContext *s = outlink->src->priv; AVFilterLink *inlink = outlink->src->inputs[0]; unsigned i; int ret; s->req_fullfilled = 0; do { ret = ff_request_frame(inlink); if (ret == AVERROR_EOF && s->sliding == FULLFRAME && s->xpos > 0 && s->outpicref) { for (i = 0; i < outlink->h; i++) { memset(s->outpicref->data[0] + i * s->outpicref->linesize[0] + s->xpos, 0, outlink->w - s->xpos); memset(s->outpicref->data[1] + i * s->outpicref->linesize[1] + s->xpos, 128, outlink->w - s->xpos); memset(s->outpicref->data[2] + i * s->outpicref->linesize[2] + s->xpos, 128, outlink->w - s->xpos); } ret = ff_filter_frame(outlink, s->outpicref); s->outpicref = NULL; s->req_fullfilled = 1; } } while (!s->req_fullfilled && ret >= 0); return ret; }<SPLIT>[-0.25365086435942685, -0.15237931622650824, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.17094161050087475, -0.25297036047912586, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, -0.3615192241061562, -0.22049944857796966, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int opt_size(enum AVOptionType type) { switch(type) { case AV_OPT_TYPE_INT: case AV_OPT_TYPE_FLAGS: return sizeof(int); case AV_OPT_TYPE_DURATION: case AV_OPT_TYPE_CHANNEL_LAYOUT: case AV_OPT_TYPE_INT64: return sizeof(int64_t); case AV_OPT_TYPE_DOUBLE: return sizeof(double); case AV_OPT_TYPE_FLOAT: return sizeof(float); case AV_OPT_TYPE_STRING: return sizeof(uint8_t*); case AV_OPT_TYPE_VIDEO_RATE: case AV_OPT_TYPE_RATIONAL: return sizeof(AVRational); case AV_OPT_TYPE_BINARY: return sizeof(uint8_t*) + sizeof(int); case AV_OPT_TYPE_IMAGE_SIZE:return sizeof(int[2]); case AV_OPT_TYPE_PIXEL_FMT: return sizeof(enum AVPixelFormat); case AV_OPT_TYPE_SAMPLE_FMT:return sizeof(enum AVSampleFormat); case AV_OPT_TYPE_COLOR: return 4; } return 0; }<SPLIT>[-0.25365086435942685, -0.1964525029637057, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.21089937656897445, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, -0.5292594673383866, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.03454968660237938, -0.4462861841111837, -0.21702784222394986, 0.33317037975964214, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, 0.04889276383167627, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>av_cold int AC3_NAME(mdct_init)(AC3EncodeContext *s) { int ret = ff_mdct_init(&s->mdct, 9, 0, -1.0); s->mdct_window = ff_ac3_window; return ret; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>int ff_framesync_process_frame(FFFrameSync *fs, unsigned all) { int ret, count = 0; av_assert0(fs->on_event); while (1) { ff_framesync_next(fs); if (fs->eof || !fs->frame_ready) break; if ((ret = fs->on_event(fs)) < 0) return ret; ff_framesync_drop(fs); count++; if (!all) break; } if (!count && fs->eof) return AVERROR_EOF; return count; }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 1.040052222782594, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, -0.270465503877335, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, 0.0744401592322129, -0.22049944857796966, -0.21702784222394986, 0.33317037975964214, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 1.039626388904333, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 1.0350888753871217]
0<SPLIT>static int process_command(AVFilterContext *ctx, const char *cmd, const char *args, char *res, int res_len, int flags) { LADSPA_Data value; unsigned long port; if (sscanf(cmd, "c%ld", &port) + sscanf(args, "%f", &value) != 2) return AVERROR(EINVAL); return set_control(ctx, port, value); }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.14106852214680915, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.4705090699407485, -0.3333928163445767, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int write_streamheader(AVFormatContext *avctx, AVIOContext *bc, AVStream *st, int i) { NUTContext *nut = avctx->priv_data; AVCodecContext *codec = st->codec; ff_put_v(bc, i); switch (codec->codec_type) { case AVMEDIA_TYPE_VIDEO: ff_put_v(bc, 0); break; case AVMEDIA_TYPE_AUDIO: ff_put_v(bc, 1); break; case AVMEDIA_TYPE_SUBTITLE: ff_put_v(bc, 2); break; default: ff_put_v(bc, 3); break; } ff_put_v(bc, 4); if (codec->codec_tag) { avio_wl32(bc, codec->codec_tag); } else { av_log(avctx, AV_LOG_ERROR, "No codec tag defined for stream %d\n", i); return AVERROR(EINVAL); } ff_put_v(bc, nut->stream[i].time_base - nut->time_base); ff_put_v(bc, nut->stream[i].msb_pts_shift); ff_put_v(bc, nut->stream[i].max_pts_distance); ff_put_v(bc, codec->has_b_frames); avio_w8(bc, 0); ff_put_v(bc, codec->extradata_size); avio_write(bc, codec->extradata, codec->extradata_size); switch (codec->codec_type) { case AVMEDIA_TYPE_AUDIO: ff_put_v(bc, codec->sample_rate); ff_put_v(bc, 1); ff_put_v(bc, codec->channels); break; case AVMEDIA_TYPE_VIDEO: ff_put_v(bc, codec->width); ff_put_v(bc, codec->height); if (st->sample_aspect_ratio.num <= 0 || st->sample_aspect_ratio.den <= 0) { ff_put_v(bc, 0); ff_put_v(bc, 0); } else { ff_put_v(bc, st->sample_aspect_ratio.num); ff_put_v(bc, st->sample_aspect_ratio.den); } ff_put_v(bc, 0); break; default: break; } return 0; }<SPLIT>[-0.25365086435942685, 0.4426087047256575, 0.0, -0.2665172434374763, 0.3595614268463766, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.3684882314184712, -0.25297036047912586, 0.4779902220588988, 0.0, 0.0, 0.30852482215402843, 0.29340028559422593, -0.26569807294376846, 0.39511009710275835, 0.11772544131424245, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5707009127566546, -0.25252937827156396, -0.10760608081136262, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int parse_optgroup(void *optctx, OptionGroup *g) { int i, ret; av_log(NULL, AV_LOG_DEBUG, "Parsing a group of options: %s %s.\n", g->group_def->name, g->arg); for (i = 0; i < g->nb_opts; i++) { Option *o = &g->opts[i]; if (g->group_def->flags && !(g->group_def->flags & o->opt->flags)) { av_log(NULL, AV_LOG_ERROR, "Option %s (%s) cannot be applied to " "%s %s -- you are trying to apply an input option to an " "output file or vice versa. Move this option before the " "file it belongs to.\n", o->key, o->opt->help, g->group_def->name, g->arg); return AVERROR(EINVAL); } av_log(NULL, AV_LOG_DEBUG, "Applying option %s (%s) with argument %s.\n", o->key, o->opt->help, o->val); ret = write_option(optctx, o->opt, o->key, o->val); if (ret < 0) return ret; } av_log(NULL, AV_LOG_DEBUG, "Successfully parsed a group of options.\n"); return 0; }<SPLIT>[-0.25365086435942685, -0.10830612948931077, 0.0, -0.2665172434374763, -0.17240788634188003, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.13098384443277505, -0.25297036047912586, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, -0.26569807294376846, -0.157054070266268, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.3615192241061562, -0.22049944857796966, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>int ff_dwt_decode(DWTContext *s, void *t) { switch (s->type) { case FF_DWT97: dwt_decode97_float(s, t); break; case FF_DWT97_INT: dwt_decode97_int(s, t); break; case FF_DWT53: dwt_decode53(s, t); break; default: return -1; } return 0; }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.4705090699407485, -0.4462861841111837, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold int decode_init(AVCodecContext *avctx) { Mpeg4DecContext *ctx = avctx->priv_data; MpegEncContext *s = &ctx->m; int ret; ctx->divx_version = ctx->divx_build = ctx->xvid_build = ctx->lavc_build = -1; if ((ret = ff_h263_decode_init(avctx)) < 0) return ret; ff_mpeg4videodec_static_init(); s->h263_pred = 1; s->low_delay = 0; s->decode_mb = mpeg4_decode_mb; ctx->time_increment_bits = 4; avctx->chroma_sample_location = AVCHROMA_LOC_LEFT; avctx->internal->allocate_progress = 1; return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void do_rematrixing(AC3DecodeContext *s) { int bnd, i; int end, bndend; end = FFMIN(s->end_freq[1], s->end_freq[2]); for (bnd = 0; bnd < s->num_rematrixing_bands; bnd++) { if (s->rematrixing_flags[bnd]) { bndend = FFMIN(end, ff_ac3_rematrix_band_tab[bnd + 1]); for (i = ff_ac3_rematrix_band_tab[bnd]; i < bndend; i++) { int tmp0 = s->fixed_coeffs[1][i]; s->fixed_coeffs[1][i] += s->fixed_coeffs[2][i]; s->fixed_coeffs[2][i] = tmp0 - s->fixed_coeffs[2][i]; } } } }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.3615192241061562, -0.10760608081136262, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *in) { AVFilterContext *ctx = inlink->dst; HQDN3DContext *s = ctx->priv; AVFilterLink *outlink = ctx->outputs[0]; AVFrame *out; int c, direct = av_frame_is_writable(in) && !ctx->is_disabled; if (direct) { out = in; } else { out = ff_get_video_buffer(outlink, outlink->w, outlink->h); if (!out) { av_frame_free(&in); return AVERROR(ENOMEM); } av_frame_copy_props(out, in); } for (c = 0; c < 3; c++) { denoise(s, in->data[c], out->data[c], s->line, &s->frame_prev[c], FF_CEIL_RSHIFT(in->width, (!!c * s->hsub)), FF_CEIL_RSHIFT(in->height, (!!c * s->vsub)), in->linesize[c], out->linesize[c], s->coefs[c ? CHROMA_SPATIAL : LUMA_SPATIAL], s->coefs[c ? CHROMA_TMP : LUMA_TMP]); } if (ctx->is_disabled) { av_frame_free(&out); return ff_filter_frame(outlink, in); } if (!direct) av_frame_free(&in); return ff_filter_frame(outlink, out); }<SPLIT>[-0.25365086435942685, 0.0900232108280778, 0.0, -0.2665172434374763, 0.01910106640589235, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 0.04882610287367361, -0.25297036047912586, 0.11330413889199094, 0.0, 0.0, 0.30852482215402843, -0.016577635342370212, -0.26569807294376846, 0.04172502998658149, 0.24712242304476825, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, 0.18343000506680518, 0.34396739025506545, -0.21702784222394986, 0.05245806339860493, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static void gradfun_blur_line_sse2(uint16_t *dc, uint16_t *buf, const uint16_t *buf1, const uint8_t *src, int src_linesize, int width) { intptr_t x = -2 * width; if (((intptr_t) src | src_linesize) & 15) ff_gradfun_blur_line_movdqu_sse2(x, buf + width, buf1 + width, dc + width, src + width * 2, src + width * 2 + src_linesize); else ff_gradfun_blur_line_movdqa_sse2(x, buf + width, buf1 + width, dc + width, src + width * 2, src + width * 2 + src_linesize); }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold int init(AVFilterContext *ctx) { FormatContext *s = ctx->priv; char *cur, *sep; int nb_formats = 1; int i; int ret; if (!s->pix_fmts) { av_log(ctx, AV_LOG_ERROR, "Empty output format string.\n"); return AVERROR(EINVAL); } cur = s->pix_fmts; while ((cur = strchr(cur, '|'))) { nb_formats++; if (*cur) cur++; } s->formats = av_malloc_array(nb_formats + 1, sizeof(*s->formats)); if (!s->formats) return AVERROR(ENOMEM); cur = s->pix_fmts; for (i = 0; i < nb_formats; i++) { sep = strchr(cur, '|'); if (sep) *sep++ = 0; if ((ret = ff_parse_pixel_format(&s->formats[i], cur, ctx)) < 0) return ret; cur = sep; } s->formats[nb_formats] = AV_PIX_FMT_NONE; if (!strcmp(ctx->filter->name, "noformat")) { const AVPixFmtDescriptor *desc = NULL; enum AVPixelFormat *formats_allowed; int nb_formats_lavu = 0, nb_formats_allowed = 0; while ((desc = av_pix_fmt_desc_next(desc))) nb_formats_lavu++; formats_allowed = av_malloc_array(nb_formats_lavu + 1, sizeof(*formats_allowed)); if (!formats_allowed) return AVERROR(ENOMEM); while ((desc = av_pix_fmt_desc_next(desc))) { enum AVPixelFormat pix_fmt = av_pix_fmt_desc_get_id(desc); for (i = 0; i < nb_formats; i++) { if (s->formats[i] == pix_fmt) break; } if (i < nb_formats) continue; formats_allowed[nb_formats_allowed++] = pix_fmt; } formats_allowed[nb_formats_allowed] = AV_PIX_FMT_NONE; av_freep(&s->formats); s->formats = formats_allowed; } return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.4942630637605089, 0.4659552894840279, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.4871364861795985, 0.5077564769051636, 0.5055429305765636, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5707009127566546, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>WINDOW_FUNC(eight_short) { const float *swindow = sce->ics.use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128; const float *pwindow = sce->ics.use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128; const float *in = audio + 448; float *out = sce->ret_buf; int w; for (w = 0; w < 8; w++) { fdsp->vector_fmul (out, in, w ? pwindow : swindow, 128); out += 128; in += 128; fdsp->vector_fmul_reverse(out, in, swindow, 128); out += 128; } }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.14106852214680915, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.1980344553542678, -0.22049944857796966, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int parse_psfile(AVFilterContext *ctx, const char *fname) { CurvesContext *curves = ctx->priv; uint8_t *buf; size_t size; int i, ret, av_unused(version), nb_curves; AVBPrint ptstr; static const int comp_ids[] = {3, 0, 1, 2}; av_bprint_init(&ptstr, 0, AV_BPRINT_SIZE_AUTOMATIC); ret = av_file_map(fname, &buf, &size, 0, NULL); if (ret < 0) return ret; #define READ16(dst) do { \ if (size < 2) { \ ret = AVERROR_INVALIDDATA; \ goto end; \ } \ dst = AV_RB16(buf); \ buf += 2; \ size -= 2; \ } while (0) READ16(version); READ16(nb_curves); for (i = 0; i < FFMIN(nb_curves, FF_ARRAY_ELEMS(comp_ids)); i++) { int nb_points, n; av_bprint_clear(&ptstr); READ16(nb_points); for (n = 0; n < nb_points; n++) { int y, x; READ16(y); READ16(x); av_bprintf(&ptstr, "%f/%f ", x / 255., y / 255.); } if (*ptstr.str) { char **pts = &curves->comp_points_str[comp_ids[i]]; if (!*pts) { *pts = av_strdup(ptstr.str); av_log(ctx, AV_LOG_DEBUG, "curves %d (intid=%d) [%d points]: [%s]\n", i, comp_ids[i], nb_points, *pts); if (!*pts) { ret = AVERROR(ENOMEM); goto end; } } } } end: av_bprint_finalize(&ptstr, NULL); av_file_unmap(buf, size); return ret; }<SPLIT>[-0.25365086435942685, 0.4646452980942562, 0.0, -0.2665172434374763, 0.38084019937390684, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, 1.3698779043020206, 0.3884671144525211, -0.25297036047912586, 0.4779902220588988, 0.0, 0.0, 0.30852482215402843, 0.31277390565276314, -0.26569807294376846, 0.39511009710275835, 1.2822982768889746, 0.029966239443893296, 0.0, -0.08645738172306322, 0.417570182313826, 0.5355687622580682, 1.2188335404954318, 1.8115811712209564, 0.6817979554923368, 0.5203119240003335, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, 1.3693714445839917, 0.9056307075691036, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 1.3643185231999084]
0<SPLIT>static av_cold int config_props(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; ASetRateContext *sr = ctx->priv; AVFilterLink *inlink = ctx->inputs[0]; AVRational intb = ctx->inputs[0]->time_base; int inrate = inlink->sample_rate; if (intb.num == 1 && intb.den == inrate) { outlink->time_base.num = 1; outlink->time_base.den = outlink->sample_rate; } else { outlink->time_base = intb; sr->rescale_pts = 1; if (av_q2d(intb) > 1.0 / FFMAX(inrate, outlink->sample_rate)) av_log(ctx, AV_LOG_WARNING, "Time base is inaccurate\n"); } return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>char *av_stristr(const char *s1, const char *s2) { if (!*s2) return (char*)(intptr_t)s1; do if (av_stristart(s1, s2, NULL)) return (char*)(intptr_t)s1; while (*s1++); return NULL; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int config_input(AVFilterLink *inlink) { Super2xSaIContext *sai = inlink->dst->priv; sai->hi_pixel_mask = 0xFEFEFEFE; sai->lo_pixel_mask = 0x01010101; sai->q_hi_pixel_mask = 0xFCFCFCFC; sai->q_lo_pixel_mask = 0x03030303; sai->bpp = 4; switch (inlink->format) { case AV_PIX_FMT_RGB24: case AV_PIX_FMT_BGR24: sai->bpp = 3; break; case AV_PIX_FMT_RGB565BE: case AV_PIX_FMT_BGR565BE: sai->is_be = 1; case AV_PIX_FMT_RGB565LE: case AV_PIX_FMT_BGR565LE: sai->hi_pixel_mask = 0xF7DEF7DE; sai->lo_pixel_mask = 0x08210821; sai->q_hi_pixel_mask = 0xE79CE79C; sai->q_lo_pixel_mask = 0x18631863; sai->bpp = 2; break; case AV_PIX_FMT_BGR555BE: case AV_PIX_FMT_RGB555BE: sai->is_be = 1; case AV_PIX_FMT_BGR555LE: case AV_PIX_FMT_RGB555LE: sai->hi_pixel_mask = 0x7BDE7BDE; sai->lo_pixel_mask = 0x04210421; sai->q_hi_pixel_mask = 0x739C739C; sai->q_lo_pixel_mask = 0x0C630C63; sai->bpp = 2; break; } return 0; }<SPLIT>[-0.25365086435942685, 0.1781695843024727, 0.0, -0.2665172434374763, 0.10421615651601342, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.128741635009873, -0.25297036047912586, 0.2044756596837179, 0.0, 0.0, 0.30852482215402843, 0.060916844891778815, -0.26569807294376846, 0.1300712967656257, -0.7880534307994381, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 0.11398295627503194, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void nv12ToUV_c(uint8_t *dstU, uint8_t *dstV, const uint8_t *unused0, const uint8_t *src1, const uint8_t *src2, int width, uint32_t *unused) { nvXXtoUV_c(dstU, dstV, src1, width); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int request_frame(AVFilterLink *outlink) { LUT3DContext *s = outlink->src->priv; return ff_dualinput_request_frame(&s->dinput, outlink); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void apply_channel_coupling(AC3EncodeContext *s) { LOCAL_ALIGNED_16(CoefType, cpl_coords, [AC3_MAX_BLOCKS], [AC3_MAX_CHANNELS][16]); #if CONFIG_AC3ENC_FLOAT LOCAL_ALIGNED_16(int32_t, fixed_cpl_coords, [AC3_MAX_BLOCKS], [AC3_MAX_CHANNELS][16]); #else int32_t (*fixed_cpl_coords)[AC3_MAX_CHANNELS][16] = cpl_coords; #endif int av_uninit(blk), ch, bnd, i, j; CoefSumType energy[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][16] = {{{0}}}; int cpl_start, num_cpl_coefs; memset(cpl_coords, 0, AC3_MAX_BLOCKS * sizeof(*cpl_coords)); #if CONFIG_AC3ENC_FLOAT memset(fixed_cpl_coords, 0, AC3_MAX_BLOCKS * sizeof(*cpl_coords)); #endif cpl_start = s->start_freq[CPL_CH] - 1; num_cpl_coefs = FFALIGN(s->num_cpl_subbands * 12 + 1, 32); cpl_start = FFMIN(256, cpl_start + num_cpl_coefs) - num_cpl_coefs; for (blk = 0; blk < s->num_blocks; blk++) { AC3Block *block = &s->blocks[blk]; CoefType *cpl_coef = &block->mdct_coef[CPL_CH][cpl_start]; if (!block->cpl_in_use) continue; memset(cpl_coef, 0, num_cpl_coefs * sizeof(*cpl_coef)); for (ch = 1; ch <= s->fbw_channels; ch++) { CoefType *ch_coef = &block->mdct_coef[ch][cpl_start]; if (!block->channel_in_cpl[ch]) continue; for (i = 0; i < num_cpl_coefs; i++) cpl_coef[i] += ch_coef[i]; } clip_coefficients(&s->adsp, cpl_coef, num_cpl_coefs); } bnd = 0; i = s->start_freq[CPL_CH]; while (i < s->cpl_end_freq) { int band_size = s->cpl_band_sizes[bnd]; for (ch = CPL_CH; ch <= s->fbw_channels; ch++) { for (blk = 0; blk < s->num_blocks; blk++) { AC3Block *block = &s->blocks[blk]; if (!block->cpl_in_use || (ch > CPL_CH && !block->channel_in_cpl[ch])) continue; for (j = 0; j < band_size; j++) { CoefType v = block->mdct_coef[ch][i+j]; MAC_COEF(energy[blk][ch][bnd], v, v); } } } i += band_size; bnd++; } for (blk = 0; blk < s->num_blocks; blk++) { AC3Block *block = &s->blocks[blk]; if (!block->cpl_in_use) continue; for (ch = 1; ch <= s->fbw_channels; ch++) { if (!block->channel_in_cpl[ch]) continue; for (bnd = 0; bnd < s->num_cpl_bands; bnd++) { cpl_coords[blk][ch][bnd] = calc_cpl_coord(energy[blk][ch][bnd], energy[blk][CPL_CH][bnd]); } } } for (blk = 0; blk < s->num_blocks; blk++) { AC3Block *block = &s->blocks[blk]; AC3Block *block0 = blk ? &s->blocks[blk-1] : NULL; memset(block->new_cpl_coords, 0, sizeof(block->new_cpl_coords)); if (block->cpl_in_use) { if (blk == 0 || !block0->cpl_in_use) { for (ch = 1; ch <= s->fbw_channels; ch++) block->new_cpl_coords[ch] = 1; } else { for (ch = 1; ch <= s->fbw_channels; ch++) { if (!block->channel_in_cpl[ch]) continue; if (!block0->channel_in_cpl[ch]) { block->new_cpl_coords[ch] = 1; } else { CoefSumType coord_diff = 0; for (bnd = 0; bnd < s->num_cpl_bands; bnd++) { coord_diff += FFABS(cpl_coords[blk-1][ch][bnd] - cpl_coords[blk ][ch][bnd]); } coord_diff /= s->num_cpl_bands; if (coord_diff > NEW_CPL_COORD_THRESHOLD) block->new_cpl_coords[ch] = 1; } } } } } for (bnd = 0; bnd < s->num_cpl_bands; bnd++) { blk = 0; while (blk < s->num_blocks) { int av_uninit(blk1); AC3Block *block = &s->blocks[blk]; if (!block->cpl_in_use) { blk++; continue; } for (ch = 1; ch <= s->fbw_channels; ch++) { CoefSumType energy_ch, energy_cpl; if (!block->channel_in_cpl[ch]) continue; energy_cpl = energy[blk][CPL_CH][bnd]; energy_ch = energy[blk][ch][bnd]; blk1 = blk+1; while (blk1 < s->num_blocks && !s->blocks[blk1].new_cpl_coords[ch]) { if (s->blocks[blk1].cpl_in_use) { energy_cpl += energy[blk1][CPL_CH][bnd]; energy_ch += energy[blk1][ch][bnd]; } blk1++; } cpl_coords[blk][ch][bnd] = calc_cpl_coord(energy_ch, energy_cpl); } blk = blk1; } } for (blk = 0; blk < s->num_blocks; blk++) { AC3Block *block = &s->blocks[blk]; if (!block->cpl_in_use) continue; #if CONFIG_AC3ENC_FLOAT s->ac3dsp.float_to_fixed24(fixed_cpl_coords[blk][1], cpl_coords[blk][1], s->fbw_channels * 16); #endif s->ac3dsp.extract_exponents(block->cpl_coord_exp[1], fixed_cpl_coords[blk][1], s->fbw_channels * 16); for (ch = 1; ch <= s->fbw_channels; ch++) { int bnd, min_exp, max_exp, master_exp; if (!block->new_cpl_coords[ch]) continue; min_exp = max_exp = block->cpl_coord_exp[ch][0]; for (bnd = 1; bnd < s->num_cpl_bands; bnd++) { int exp = block->cpl_coord_exp[ch][bnd]; min_exp = FFMIN(exp, min_exp); max_exp = FFMAX(exp, max_exp); } master_exp = ((max_exp - 15) + 2) / 3; master_exp = FFMAX(master_exp, 0); while (min_exp < master_exp * 3) master_exp--; for (bnd = 0; bnd < s->num_cpl_bands; bnd++) { block->cpl_coord_exp[ch][bnd] = av_clip(block->cpl_coord_exp[ch][bnd] - master_exp * 3, 0, 15); } block->cpl_master_exp[ch] = master_exp; for (bnd = 0; bnd < s->num_cpl_bands; bnd++) { int cpl_exp = block->cpl_coord_exp[ch][bnd]; int cpl_mant = (fixed_cpl_coords[blk][ch][bnd] << (5 + cpl_exp + master_exp * 3)) >> 24; if (cpl_exp == 15) cpl_mant >>= 1; else cpl_mant -= 16; block->cpl_coord_mant[ch][bnd] = cpl_mant; } } } if (CONFIG_EAC3_ENCODER && s->eac3) ff_eac3_set_cpl_states(s); }<SPLIT>[2.529909858417405, 2.976816942114511, 0.0, 2.47229186247527, 2.8066202675123573, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 3.0256796749471015, 2.5785186166451206, 2.8256568824458683, 0.0, 0.0, 0.30852482215402843, 2.8700917533796813, 2.5187383065123874, 2.6700264666631472, 1.5410922403500262, -0.4084991676475909, 0.0, 0.4647777494796126, 3.8963159930641242, 3.4515372536407356, 0.6738843113224704, 1.9244745389875635, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int64_t get_s(AVIOContext *bc) { int64_t v = ffio_read_varlen(bc) + 1; if (v & 1) return -(v >> 1); else return (v >> 1); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void show_help_default(const char *opt, const char *arg) { av_log_set_callback(log_callback_help); show_usage(); show_help_options(options, "Main options:", 0, OPT_EXPERT, 0); show_help_options(options, "Advanced options:", OPT_EXPERT, 0, 0); printf("\n"); show_help_children(avcodec_get_class(), AV_OPT_FLAG_DECODING_PARAM); show_help_children(avformat_get_class(), AV_OPT_FLAG_DECODING_PARAM); #if !CONFIG_AVFILTER show_help_children(sws_get_class(), AV_OPT_FLAG_ENCODING_PARAM); #else show_help_children(avfilter_get_class(), AV_OPT_FLAG_FILTERING_PARAM); #endif printf("\nWhile playing:\n" "q, ESC quit\n" "f toggle full screen\n" "p, SPC pause\n" "m toggle mute\n" "9, 0 decrease and increase volume respectively\n" "/, * decrease and increase volume respectively\n" "a cycle audio channel in the current program\n" "v cycle video channel\n" "t cycle subtitle channel in the current program\n" "c cycle program\n" "w cycle video filters or show modes\n" "s activate frame-step mode\n" "left/right seek backward/forward 10 seconds\n" "down/up seek backward/forward 1 minute\n" "page down/page up seek backward/forward 10 minutes\n" "right mouse click seek to percentage in file corresponding to fraction of width\n" "left double-click toggle full screen\n" ); }<SPLIT>[-0.25365086435942685, 0.0900232108280778, 0.0, -0.2665172434374763, 0.01910106640589235, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.04882610287367361, -0.25297036047912586, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, -0.016577635342370212, -0.26569807294376846, -0.04662123679246273, 0.11772544131424245, 1.78382786780983, 0.0, 0.02378964451747194, 1.5771521192305922, -0.3427350002065907, -0.08904460951967552, 0.11818065472185141, -0.21702784222394986, -0.22825425296243224, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void yae_advance_to_next_frag(ATempoContext *atempo) { const double fragment_step = atempo->tempo * (double)(atempo->window / 2); const AudioFragment *prev; AudioFragment *frag; atempo->nfrag++; prev = yae_prev_frag(atempo); frag = yae_curr_frag(atempo); frag->position[0] = prev->position[0] + (int64_t)fragment_step; frag->position[1] = prev->position[1] + atempo->window / 2; frag->nsamples = 0; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.4705090699407485, -0.3333928163445767, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int ff_fill_line_with_color(uint8_t *line[4], int pixel_step[4], int w, uint8_t dst_color[4], enum AVPixelFormat pix_fmt, uint8_t rgba_color[4], int *is_packed_rgba, uint8_t rgba_map_ptr[4]) { uint8_t rgba_map[4] = {0}; int i; const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(pix_fmt); int hsub; av_assert0(pix_desc); hsub = pix_desc->log2_chroma_w; *is_packed_rgba = ff_fill_rgba_map(rgba_map, pix_fmt) >= 0; if (*is_packed_rgba) { pixel_step[0] = (av_get_bits_per_pixel(pix_desc))>>3; for (i = 0; i < 4; i++) dst_color[rgba_map[i]] = rgba_color[i]; line[0] = av_malloc_array(w, pixel_step[0]); if (!line[0]) return AVERROR(ENOMEM); for (i = 0; i < w; i++) memcpy(line[0] + i * pixel_step[0], dst_color, pixel_step[0]); if (rgba_map_ptr) memcpy(rgba_map_ptr, rgba_map, sizeof(rgba_map[0]) * 4); } else { int plane; dst_color[0] = RGB_TO_Y_CCIR(rgba_color[0], rgba_color[1], rgba_color[2]); dst_color[1] = RGB_TO_U_CCIR(rgba_color[0], rgba_color[1], rgba_color[2], 0); dst_color[2] = RGB_TO_V_CCIR(rgba_color[0], rgba_color[1], rgba_color[2], 0); dst_color[3] = rgba_color[3]; for (plane = 0; plane < 4; plane++) { int line_size; int hsub1 = (plane == 1 || plane == 2) ? hsub : 0; pixel_step[plane] = 1; line_size = FF_CEIL_RSHIFT(w, hsub1) * pixel_step[plane]; line[plane] = av_malloc(line_size); if (!line[plane]) { while(plane && line[plane-1]) av_freep(&line[--plane]); return AVERROR(ENOMEM); } memset(line[plane], dst_color[plane], line_size); } } return 0; }<SPLIT>[-0.25365086435942685, 0.3103891445140651, 0.0, -0.2665172434374763, 0.231888791681195, 0.0, 0.27499425978303293, 0.2876332819158955, 0.4084056692221168, -0.27925050329511203, 0.24861493321417213, -0.25297036047912586, 0.34123294087130834, 0.0, 0.0, 0.30852482215402843, 0.17715856524300236, -0.26569807294376846, 0.262590696934192, 1.9292831855416035, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, 0.4653044612608955, 0.8918640029916549, 1.5857944356877427, -0.21702784222394986, 0.23959960763929639, 0.27459231726984007, 0.28726714485067795, 0.40798885073507796, -0.27935383381430245, 1.7623686513065309, 0.0, 0.2712059422168815, 0.2838490539924199, 0.4044334392007059, -0.28182971586402455]
0<SPLIT>static int write_headers(AVFormatContext *avctx, AVIOContext *bc) { NUTContext *nut = avctx->priv_data; AVIOContext *dyn_bc; int i, ret; ff_metadata_conv_ctx(avctx, ff_nut_metadata_conv, NULL); ret = avio_open_dyn_buf(&dyn_bc); if (ret < 0) return ret; write_mainheader(nut, dyn_bc); put_packet(nut, bc, dyn_bc, 1, MAIN_STARTCODE); for (i = 0; i < nut->avf->nb_streams; i++) { ret = avio_open_dyn_buf(&dyn_bc); if (ret < 0) return ret; ret = write_streamheader(avctx, dyn_bc, nut->avf->streams[i], i); if (ret < 0) return ret; put_packet(nut, bc, dyn_bc, 1, STREAM_STARTCODE); } ret = avio_open_dyn_buf(&dyn_bc); if (ret < 0) return ret; write_globalinfo(nut, dyn_bc); put_packet(nut, bc, dyn_bc, 1, INFO_STARTCODE); for (i = 0; i < nut->avf->nb_streams; i++) { ret = avio_open_dyn_buf(&dyn_bc); if (ret < 0) return ret; ret = write_streaminfo(nut, dyn_bc, i); if (ret < 0) return ret; if (ret > 0) put_packet(nut, bc, dyn_bc, 1, INFO_STARTCODE); else ffio_free_dyn_buf(&dyn_bc); } for (i = 0; i < nut->avf->nb_chapters; i++) { ret = avio_open_dyn_buf(&dyn_bc); if (ret < 0) return ret; ret = write_chapter(nut, dyn_bc, i); if (ret < 0) { ffio_free_dyn_buf(&dyn_bc); return ret; } put_packet(nut, bc, dyn_bc, 1, INFO_STARTCODE); } nut->last_syncpoint_pos = INT_MIN; nut->header_count++; return 0; }<SPLIT>[-0.25365086435942685, 0.48668189146285495, 0.0, -0.2665172434374763, 0.40211897190143714, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, 0.40844599748657096, -0.25297036047912586, 0.5235759824547622, 0.0, 0.0, 0.30852482215402843, 0.3321475257113004, -0.26569807294376846, 0.43928323049228046, 0.5059163865058198, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, 0.6409652137538272, 0.18343000506680518, 0.4568607580216725, -0.21702784222394986, -0.04111270872174079, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>int main(int argc, char **argv) { AVBPrint src; char c, *src_buf, *recv_buf; int recv_buf_size, ret; void *zmq_ctx, *socket; const char *bind_address = "tcp: const char *infilename = NULL; FILE *infile = NULL; zmq_msg_t msg; while ((c = getopt(argc, argv, "b:hi:")) != -1) { switch (c) { case 'b': bind_address = optarg; break; case 'h': usage(); return 0; case 'i': infilename = optarg; break; case '?': return 1; } } if (!infilename || !strcmp(infilename, "-")) { infilename = "stdin"; infile = stdin; } else { infile = fopen(infilename, "r"); } if (!infile) { av_log(NULL, AV_LOG_ERROR, "Impossible to open input file '%s': %s\n", infilename, strerror(errno)); return 1; } zmq_ctx = zmq_ctx_new(); if (!zmq_ctx) { av_log(NULL, AV_LOG_ERROR, "Could not create ZMQ context: %s\n", zmq_strerror(errno)); return 1; } socket = zmq_socket(zmq_ctx, ZMQ_REQ); if (!socket) { av_log(NULL, AV_LOG_ERROR, "Could not create ZMQ socket: %s\n", zmq_strerror(errno)); ret = 1; goto end; } if (zmq_connect(socket, bind_address) == -1) { av_log(NULL, AV_LOG_ERROR, "Could not bind ZMQ responder to address '%s': %s\n", bind_address, zmq_strerror(errno)); ret = 1; goto end; } av_bprint_init(&src, 1, AV_BPRINT_SIZE_UNLIMITED); while ((c = fgetc(infile)) != EOF) av_bprint_chars(&src, c, 1); av_bprint_chars(&src, 0, 1); if (!av_bprint_is_complete(&src)) { av_log(NULL, AV_LOG_ERROR, "Could not allocate a buffer for the source string\n"); av_bprint_finalize(&src, NULL); ret = 1; goto end; } av_bprint_finalize(&src, &src_buf); if (zmq_send(socket, src_buf, strlen(src_buf), 0) == -1) { av_log(NULL, AV_LOG_ERROR, "Could not send message: %s\n", zmq_strerror(errno)); ret = 1; goto end; } if (zmq_msg_init(&msg) == -1) { av_log(NULL, AV_LOG_ERROR, "Could not initialize receiving message: %s\n", zmq_strerror(errno)); ret = 1; goto end; } if (zmq_msg_recv(&msg, socket, 0) == -1) { av_log(NULL, AV_LOG_ERROR, "Could not receive message: %s\n", zmq_strerror(errno)); zmq_msg_close(&msg); ret = 1; goto end; } recv_buf_size = zmq_msg_size(&msg) + 1; recv_buf = av_malloc(recv_buf_size); if (!recv_buf) { av_log(NULL, AV_LOG_ERROR, "Could not allocate receiving message buffer\n"); zmq_msg_close(&msg); ret = 1; goto end; } memcpy(recv_buf, zmq_msg_data(&msg), recv_buf_size); recv_buf[recv_buf_size-1] = 0; printf("%s\n", recv_buf); zmq_msg_close(&msg); av_free(recv_buf); end: zmq_close(socket); zmq_ctx_destroy(zmq_ctx); return ret; }<SPLIT>[-0.09900860198293619, 1.6105481532613901, 0.0, -0.11436118199787926, 1.4873363708054808, 0.0, 2.186719866463698, 1.7015798777335354, 2.0668255347327906, 4.33830903797686, 1.447347915257163, -0.09566541730555662, 1.6860128725492811, 0.0, 0.0, 0.30852482215402843, 1.3395757687552379, -0.11100716297398205, 1.5656981319250942, 3.2232530028468616, 4.195387606812993, 0.0, -0.08645738172306322, -0.16222078614455715, 1.4841368257198997, 3.9435796863602386, 3.5049816877200617, 1.5806237532086234, 3.701718176092088, 2.185828383526772, 1.7009206574961395, 2.066000781150787, 4.337076945700922, 0.9056307075691036, 0.0, 2.180032226976431, 1.6957470663015664, 2.0602524698036953, 4.3273853535149875]
0<SPLIT>static void free_segment_list(struct playlist *pls) { int i; for (i = 0; i < pls->n_segments; i++) { av_freep(&pls->segments[i]->key); av_freep(&pls->segments[i]->url); av_freep(&pls->segments[i]); } av_freep(&pls->segments); pls->n_segments = 0; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { FSPPContext *fspp = ctx->priv; av_freep(&fspp->temp); av_freep(&fspp->src); av_freep(&fspp->non_b_qp_table); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { AVFilterFormats *formats = NULL; int fmt; for (fmt = 0; av_pix_fmt_desc_get(fmt); fmt++) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(fmt); if (is_planar_yuv(desc)) ff_add_format(&formats, fmt); } return ff_set_common_formats(ctx, formats); }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.011671540416283347, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.1980344553542678, -0.10760608081136262, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int mxf_parse_structural_metadata(MXFContext *mxf) { MXFPackage *material_package = NULL; int i, j, k, ret; av_log(mxf->fc, AV_LOG_TRACE, "metadata sets count %d\n", mxf->metadata_sets_count); for (i = 0; i < mxf->packages_count; i++) { material_package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i], MaterialPackage); if (material_package) break; } if (!material_package) { av_log(mxf->fc, AV_LOG_ERROR, "no material package found\n"); return AVERROR_INVALIDDATA; } mxf_add_umid_metadata(&mxf->fc->metadata, "material_package_umid", material_package); if (material_package->name && material_package->name[0]) av_dict_set(&mxf->fc->metadata, "material_package_name", material_package->name, 0); mxf_parse_package_comments(mxf, &mxf->fc->metadata, material_package); for (i = 0; i < material_package->tracks_count; i++) { MXFPackage *source_package = NULL; MXFTrack *material_track = NULL; MXFTrack *source_track = NULL; MXFTrack *temp_track = NULL; MXFDescriptor *descriptor = NULL; MXFStructuralComponent *component = NULL; MXFTimecodeComponent *mxf_tc = NULL; UID *essence_container_ul = NULL; const MXFCodecUL *codec_ul = NULL; const MXFCodecUL *container_ul = NULL; const MXFCodecUL *pix_fmt_ul = NULL; AVStream *st; AVTimecode tc; int flags; if (!(material_track = mxf_resolve_strong_ref(mxf, &material_package->tracks_refs[i], Track))) { av_log(mxf->fc, AV_LOG_ERROR, "could not resolve material track strong ref\n"); continue; } if ((component = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, TimecodeComponent))) { mxf_tc = (MXFTimecodeComponent*)component; flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0; if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) { mxf_add_timecode_metadata(&mxf->fc->metadata, "timecode", &tc); } } if (!(material_track->sequence = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, Sequence))) { av_log(mxf->fc, AV_LOG_ERROR, "could not resolve material track sequence strong ref\n"); continue; } for (j = 0; j < material_track->sequence->structural_components_count; j++) { component = mxf_resolve_strong_ref(mxf, &material_track->sequence->structural_components_refs[j], TimecodeComponent); if (!component) continue; mxf_tc = (MXFTimecodeComponent*)component; flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0; if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) { mxf_add_timecode_metadata(&mxf->fc->metadata, "timecode", &tc); break; } } for (j = 0; j < material_track->sequence->structural_components_count; j++) { component = mxf_resolve_sourceclip(mxf, &material_track->sequence->structural_components_refs[j]); if (!component) continue; source_package = mxf_resolve_source_package(mxf, component->source_package_uid); if (!source_package) { av_log(mxf->fc, AV_LOG_TRACE, "material track %d: no corresponding source package found\n", material_track->track_id); break; } for (k = 0; k < source_package->tracks_count; k++) { if (!(temp_track = mxf_resolve_strong_ref(mxf, &source_package->tracks_refs[k], Track))) { av_log(mxf->fc, AV_LOG_ERROR, "could not resolve source track strong ref\n"); ret = AVERROR_INVALIDDATA; goto fail_and_free; } if (temp_track->track_id == component->source_track_id) { source_track = temp_track; break; } } if (!source_track) { av_log(mxf->fc, AV_LOG_ERROR, "material track %d: no corresponding source track found\n", material_track->track_id); break; } } if (!source_track || !component) continue; if (!(source_track->sequence = mxf_resolve_strong_ref(mxf, &source_track->sequence_ref, Sequence))) { av_log(mxf->fc, AV_LOG_ERROR, "could not resolve source track sequence strong ref\n"); ret = AVERROR_INVALIDDATA; goto fail_and_free; } if (memcmp(material_track->sequence->data_definition_ul, source_track->sequence->data_definition_ul, 16)) { av_log(mxf->fc, AV_LOG_ERROR, "material track %d: DataDefinition mismatch\n", material_track->track_id); continue; } st = avformat_new_stream(mxf->fc, NULL); if (!st) { av_log(mxf->fc, AV_LOG_ERROR, "could not allocate stream\n"); ret = AVERROR(ENOMEM); goto fail_and_free; } st->id = source_track->track_id; st->priv_data = source_track; source_package->descriptor = mxf_resolve_strong_ref(mxf, &source_package->descriptor_ref, AnyType); descriptor = mxf_resolve_multidescriptor(mxf, source_package->descriptor, source_track->track_id); if (descriptor && descriptor->duration != AV_NOPTS_VALUE) source_track->original_duration = st->duration = FFMIN(descriptor->duration, component->duration); else source_track->original_duration = st->duration = component->duration; if (st->duration == -1) st->duration = AV_NOPTS_VALUE; st->start_time = component->start_position; if (material_track->edit_rate.num <= 0 || material_track->edit_rate.den <= 0) { av_log(mxf->fc, AV_LOG_WARNING, "Invalid edit rate (%d/%d) found on stream #%d, " "defaulting to 25/1\n", material_track->edit_rate.num, material_track->edit_rate.den, st->index); material_track->edit_rate = (AVRational){25, 1}; } avpriv_set_pts_info(st, 64, material_track->edit_rate.den, material_track->edit_rate.num); source_track->edit_rate = material_track->edit_rate; PRINT_KEY(mxf->fc, "data definition ul", source_track->sequence->data_definition_ul); codec_ul = mxf_get_codec_ul(ff_mxf_data_definition_uls, &source_track->sequence->data_definition_ul); st->codec->codec_type = codec_ul->id; if (!descriptor) { av_log(mxf->fc, AV_LOG_INFO, "source track %d: stream %d, no descriptor found\n", source_track->track_id, st->index); continue; } PRINT_KEY(mxf->fc, "essence codec ul", descriptor->essence_codec_ul); PRINT_KEY(mxf->fc, "essence container ul", descriptor->essence_container_ul); essence_container_ul = &descriptor->essence_container_ul; if (IS_KLV_KEY(essence_container_ul, mxf_encrypted_essence_container)) { av_log(mxf->fc, AV_LOG_INFO, "broken encrypted mxf file\n"); for (k = 0; k < mxf->metadata_sets_count; k++) { MXFMetadataSet *metadata = mxf->metadata_sets[k]; if (metadata->type == CryptoContext) { essence_container_ul = &((MXFCryptoContext *)metadata)->source_container_ul; break; } } } codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->essence_codec_ul); st->codec->codec_id = (enum AVCodecID)codec_ul->id; if (st->codec->codec_id == AV_CODEC_ID_NONE) { codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->codec_ul); st->codec->codec_id = (enum AVCodecID)codec_ul->id; } av_log(mxf->fc, AV_LOG_VERBOSE, "%s: Universal Label: ", avcodec_get_name(st->codec->codec_id)); for (k = 0; k < 16; k++) { av_log(mxf->fc, AV_LOG_VERBOSE, "%.2x", descriptor->essence_codec_ul[k]); if (!(k+1 & 19) || k == 5) av_log(mxf->fc, AV_LOG_VERBOSE, "."); } av_log(mxf->fc, AV_LOG_VERBOSE, "\n"); mxf_add_umid_metadata(&st->metadata, "file_package_umid", source_package); if (source_package->name && source_package->name[0]) av_dict_set(&st->metadata, "file_package_name", source_package->name, 0); mxf_parse_physical_source_package(mxf, source_track, st); if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { source_track->intra_only = mxf_is_intra_only(descriptor); container_ul = mxf_get_codec_ul(mxf_picture_essence_container_uls, essence_container_ul); if (st->codec->codec_id == AV_CODEC_ID_NONE) st->codec->codec_id = container_ul->id; st->codec->width = descriptor->width; st->codec->height = descriptor->height; switch (descriptor->frame_layout) { case FullFrame: st->codec->field_order = AV_FIELD_PROGRESSIVE; break; case OneField: av_log(mxf->fc, AV_LOG_INFO, "OneField frame layout isn't currently supported\n"); break; case MixedFields: break; case SegmentedFrame: st->codec->field_order = AV_FIELD_PROGRESSIVE; case SeparateFields: switch (descriptor->field_dominance) { case MXF_TFF: st->codec->field_order = AV_FIELD_TT; break; case MXF_BFF: st->codec->field_order = AV_FIELD_BB; break; default: avpriv_request_sample(mxf->fc, "Field dominance %d support", descriptor->field_dominance); case 0: break; } st->codec->height *= 2; break; default: av_log(mxf->fc, AV_LOG_INFO, "Unknown frame layout type: %d\n", descriptor->frame_layout); } if (st->codec->codec_id == AV_CODEC_ID_RAWVIDEO) { st->codec->pix_fmt = descriptor->pix_fmt; if (st->codec->pix_fmt == AV_PIX_FMT_NONE) { pix_fmt_ul = mxf_get_codec_ul(ff_mxf_pixel_format_uls, &descriptor->essence_codec_ul); st->codec->pix_fmt = (enum AVPixelFormat)pix_fmt_ul->id; if (st->codec->pix_fmt == AV_PIX_FMT_NONE) { st->codec->codec_tag = mxf_get_codec_ul(ff_mxf_codec_tag_uls, &descriptor->essence_codec_ul)->id; if (!st->codec->codec_tag) { if (descriptor->horiz_subsampling == 2 && descriptor->vert_subsampling == 1 && descriptor->component_depth == 8) { st->codec->pix_fmt = AV_PIX_FMT_UYVY422; } } } } } st->need_parsing = AVSTREAM_PARSE_HEADERS; if (material_track->sequence->origin) { av_dict_set_int(&st->metadata, "material_track_origin", material_track->sequence->origin, 0); } if (source_track->sequence->origin) { av_dict_set_int(&st->metadata, "source_track_origin", source_track->sequence->origin, 0); } if (descriptor->aspect_ratio.num && descriptor->aspect_ratio.den) st->display_aspect_ratio = descriptor->aspect_ratio; } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { container_ul = mxf_get_codec_ul(mxf_sound_essence_container_uls, essence_container_ul); if (st->codec->codec_id == AV_CODEC_ID_NONE || (st->codec->codec_id == AV_CODEC_ID_PCM_ALAW && (enum AVCodecID)container_ul->id != AV_CODEC_ID_NONE)) st->codec->codec_id = (enum AVCodecID)container_ul->id; st->codec->channels = descriptor->channels; st->codec->bits_per_coded_sample = descriptor->bits_per_sample; if (descriptor->sample_rate.den > 0) { st->codec->sample_rate = descriptor->sample_rate.num / descriptor->sample_rate.den; avpriv_set_pts_info(st, 64, descriptor->sample_rate.den, descriptor->sample_rate.num); } else { av_log(mxf->fc, AV_LOG_WARNING, "invalid sample rate (%d/%d) " "found for stream #%d, time base forced to 1/48000\n", descriptor->sample_rate.num, descriptor->sample_rate.den, st->index); avpriv_set_pts_info(st, 64, 1, 48000); } if (st->duration != AV_NOPTS_VALUE) st->duration = av_rescale_q(st->duration, av_inv_q(material_track->edit_rate), st->time_base); if (st->codec->codec_id == AV_CODEC_ID_PCM_S16LE) { if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24) st->codec->codec_id = AV_CODEC_ID_PCM_S24LE; else if (descriptor->bits_per_sample == 32) st->codec->codec_id = AV_CODEC_ID_PCM_S32LE; } else if (st->codec->codec_id == AV_CODEC_ID_PCM_S16BE) { if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24) st->codec->codec_id = AV_CODEC_ID_PCM_S24BE; else if (descriptor->bits_per_sample == 32) st->codec->codec_id = AV_CODEC_ID_PCM_S32BE; } else if (st->codec->codec_id == AV_CODEC_ID_MP2) { st->need_parsing = AVSTREAM_PARSE_FULL; } } else if (st->codec->codec_type == AVMEDIA_TYPE_DATA) { int codec_id = mxf_get_codec_ul(mxf_data_essence_container_uls, essence_container_ul)->id; if (codec_id >= 0 && codec_id < FF_ARRAY_ELEMS(mxf_data_essence_descriptor)) { av_dict_set(&st->metadata, "data_type", mxf_data_essence_descriptor[codec_id], 0); } } if (descriptor->extradata) { if (!ff_alloc_extradata(st->codec, descriptor->extradata_size)) { memcpy(st->codec->extradata, descriptor->extradata, descriptor->extradata_size); } } else if (st->codec->codec_id == AV_CODEC_ID_H264) { ret = ff_generate_avci_extradata(st); if (ret < 0) return ret; } if (st->codec->codec_type != AVMEDIA_TYPE_DATA && (*essence_container_ul)[15] > 0x01) { st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS; } } ret = 0; fail_and_free: return ret; }<SPLIT>[2.9938366455468772, 5.643244739714958, 0.0, 2.9287600467940615, 5.38135174334352, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 5.503061171169283, 3.0504334461658287, 5.8571099487707885, 0.0, 0.0, 0.30852482215402843, 5.272420640638301, 2.9828110364217464, 5.607539837066367, 3.9996348932300165, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 4.891955424082776, 1.709287846751097, 3.843661791019883, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void float_to_fixed24_mips(int32_t *dst, const float *src, unsigned int len) { const float scale = 1 << 24; float src0, src1, src2, src3, src4, src5, src6, src7; int temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7; do { __asm__ volatile ( "lwc1 %[src0], 0(%[src]) \n\t" "lwc1 %[src1], 4(%[src]) \n\t" "lwc1 %[src2], 8(%[src]) \n\t" "lwc1 %[src3], 12(%[src]) \n\t" "lwc1 %[src4], 16(%[src]) \n\t" "lwc1 %[src5], 20(%[src]) \n\t" "lwc1 %[src6], 24(%[src]) \n\t" "lwc1 %[src7], 28(%[src]) \n\t" "mul.s %[src0], %[src0], %[scale] \n\t" "mul.s %[src1], %[src1], %[scale] \n\t" "mul.s %[src2], %[src2], %[scale] \n\t" "mul.s %[src3], %[src3], %[scale] \n\t" "mul.s %[src4], %[src4], %[scale] \n\t" "mul.s %[src5], %[src5], %[scale] \n\t" "mul.s %[src6], %[src6], %[scale] \n\t" "mul.s %[src7], %[src7], %[scale] \n\t" "cvt.w.s %[src0], %[src0] \n\t" "cvt.w.s %[src1], %[src1] \n\t" "cvt.w.s %[src2], %[src2] \n\t" "cvt.w.s %[src3], %[src3] \n\t" "cvt.w.s %[src4], %[src4] \n\t" "cvt.w.s %[src5], %[src5] \n\t" "cvt.w.s %[src6], %[src6] \n\t" "cvt.w.s %[src7], %[src7] \n\t" "mfc1 %[temp0], %[src0] \n\t" "mfc1 %[temp1], %[src1] \n\t" "mfc1 %[temp2], %[src2] \n\t" "mfc1 %[temp3], %[src3] \n\t" "mfc1 %[temp4], %[src4] \n\t" "mfc1 %[temp5], %[src5] \n\t" "mfc1 %[temp6], %[src6] \n\t" "mfc1 %[temp7], %[src7] \n\t" "sw %[temp0], 0(%[dst]) \n\t" "sw %[temp1], 4(%[dst]) \n\t" "sw %[temp2], 8(%[dst]) \n\t" "sw %[temp3], 12(%[dst]) \n\t" "sw %[temp4], 16(%[dst]) \n\t" "sw %[temp5], 20(%[dst]) \n\t" "sw %[temp6], 24(%[dst]) \n\t" "sw %[temp7], 28(%[dst]) \n\t" : [dst] "+r" (dst), [src] "+r" (src), [src0] "=&f" (src0), [src1] "=&f" (src1), [src2] "=&f" (src2), [src3] "=&f" (src3), [src4] "=&f" (src4), [src5] "=&f" (src5), [src6] "=&f" (src6), [src7] "=&f" (src7), [temp0] "=r" (temp0), [temp1] "=r" (temp1), [temp2] "=r" (temp2), [temp3] "=r" (temp3), [temp4] "=r" (temp4), [temp5] "=r" (temp5), [temp6] "=r" (temp6), [temp7] "=r" (temp7) : [scale] "f" (scale) : "memory" ); src = src + 8; dst = dst + 8; len -= 8; } while (len > 0); }<SPLIT>[-0.25365086435942685, 0.7511210118860397, 0.0, -0.2665172434374763, 0.6574642422318003, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.6481925938951691, -0.25297036047912586, 0.7970905448299431, 0.0, 0.0, 0.30852482215402843, 0.5646309664137475, -0.26569807294376846, 0.7043220308294131, -0.39986248560786075, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, 0.40140969673598975, 1.1342209646213146, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int config_props(AVFilterLink *inlink) { VignetteContext *s = inlink->dst->priv; AVRational sar = inlink->sample_aspect_ratio; s->desc = av_pix_fmt_desc_get(inlink->format); s->var_values[VAR_W] = inlink->w; s->var_values[VAR_H] = inlink->h; s->var_values[VAR_TB] = av_q2d(inlink->time_base); s->var_values[VAR_R] = inlink->frame_rate.num == 0 || inlink->frame_rate.den == 0 ? NAN : av_q2d(inlink->frame_rate); if (!sar.num || !sar.den) sar.num = sar.den = 1; if (sar.num > sar.den) { s->xscale = av_q2d(av_div_q(sar, s->aspect)); s->yscale = 1; } else { s->yscale = av_q2d(av_div_q(s->aspect, sar)); s->xscale = 1; } s->dmax = hypot(inlink->w / 2., inlink->h / 2.); av_log(s, AV_LOG_DEBUG, "xscale=%f yscale=%f dmax=%f\n", s->xscale, s->yscale, s->dmax); s->fmap_linesize = FFALIGN(inlink->w, 32); s->fmap = av_malloc_array(s->fmap_linesize, inlink->h * sizeof(*s->fmap)); if (!s->fmap) return AVERROR(ENOMEM); if (s->eval_mode == EVAL_MODE_INIT) update_context(s, inlink, NULL); return 0; }<SPLIT>[-0.25365086435942685, 0.0018768373536828752, 0.0, -0.2665172434374763, -0.06601402370422871, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.031089429262525795, -0.25297036047912586, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, -0.09407211557651925, -0.26569807294376846, -0.04662123679246273, 0.37651940477529405, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, -0.08904460951967552, 0.23107402248845843, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void vector_fmul_c(float *dst, const float *src0, const float *src1, int len) { int i; for (i = 0; i < len; i++) dst[i] = src0[i] * src1[i]; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.41601414702345235, -0.6720729196443977, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>AVInteger av_mul_i(AVInteger a, AVInteger b){ AVInteger out; int i, j; int na= (av_log2_i(a)+16) >> 4; int nb= (av_log2_i(b)+16) >> 4; memset(&out, 0, sizeof(out)); for(i=0; i<na; i++){ unsigned int carry=0; if(a.v[i]) for(j=i; j<AV_INTEGER_SIZE && j-i<=nb; j++){ carry= (carry>>16) + out.v[j] + a.v[i]*b.v[j-i]; out.v[j]= carry; } } return out; }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.14106852214680915, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.14353953243697165, 0.005287286955244392, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int get_channel_idx(char **map, int *ch, char delim, int max_ch) { char *next; int len; int n = 0; if (!*map) return AVERROR(EINVAL); next = split(*map, delim); if (!next && delim == '-') return AVERROR(EINVAL); len = strlen(*map); sscanf(*map, "%d%n", ch, &n); if (n != len) return AVERROR(EINVAL); if (*ch < 0 || *ch > max_ch) return AVERROR(EINVAL); *map = next; return 0; }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, 0.11772544131424245, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.03454968660237938, 0.005287286955244392, -0.21702784222394986, -0.04111270872174079, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int encode_intervals(struct sbg_script *s, AVCodecContext *avc, struct ws_intervals *inter) { int i, edata_size = 4; uint8_t *edata; for (i = 0; i < inter->nb_inter; i++) { edata_size += inter->inter[i].type == WS_SINE ? 44 : inter->inter[i].type == WS_NOISE ? 32 : 0; if (edata_size < 0) return AVERROR(ENOMEM); } if (ff_alloc_extradata(avc, edata_size)) return AVERROR(ENOMEM); edata = avc->extradata; #define ADD_EDATA32(v) do { AV_WL32(edata, (v)); edata += 4; } while(0) #define ADD_EDATA64(v) do { AV_WL64(edata, (v)); edata += 8; } while(0) ADD_EDATA32(inter->nb_inter); for (i = 0; i < inter->nb_inter; i++) { ADD_EDATA64(inter->inter[i].ts1); ADD_EDATA64(inter->inter[i].ts2); ADD_EDATA32(inter->inter[i].type); ADD_EDATA32(inter->inter[i].channels); switch (inter->inter[i].type) { case WS_SINE: ADD_EDATA32(inter->inter[i].f1); ADD_EDATA32(inter->inter[i].f2); ADD_EDATA32(inter->inter[i].a1); ADD_EDATA32(inter->inter[i].a2); ADD_EDATA32(inter->inter[i].phi); break; case WS_NOISE: ADD_EDATA32(inter->inter[i].a1); ADD_EDATA32(inter->inter[i].a2); break; } } if (edata != avc->extradata + edata_size) return AVERROR_BUG; return 0; }<SPLIT>[-0.25365086435942685, 0.2222427710396702, 0.0, -0.2665172434374763, 0.14677370157107394, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.1686994010779727, -0.25297036047912586, 0.2044756596837179, 0.0, 0.0, 0.30852482215402843, 0.09966408500885333, -0.26569807294376846, 0.1300712967656257, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, 0.9973611507722091, 0.3599080097651364, -0.14353953243697165, 0.11818065472185141, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_cold void volume_init(VolumeContext *vol) { vol->samples_align = 1; switch (av_get_packed_sample_fmt(vol->sample_fmt)) { case AV_SAMPLE_FMT_U8: if (vol->volume_i < 0x1000000) vol->scale_samples = scale_samples_u8_small; else vol->scale_samples = scale_samples_u8; break; case AV_SAMPLE_FMT_S16: if (vol->volume_i < 0x10000) vol->scale_samples = scale_samples_s16_small; else vol->scale_samples = scale_samples_s16; break; case AV_SAMPLE_FMT_S32: vol->scale_samples = scale_samples_s32; break; case AV_SAMPLE_FMT_FLT: vol->samples_align = 4; break; case AV_SAMPLE_FMT_DBL: vol->samples_align = 8; break; } if (ARCH_X86) ff_volume_init_x86(vol); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.08729279623175898, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.1134457356350565, -0.26569807294376846, -0.06870780348722379, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int asf_read_content_desc(AVFormatContext *s, const GUIDParseTable *g) { ASFContext *asf = s->priv_data; AVIOContext *pb = s->pb; int i; static const char *const titles[] = { "Title", "Author", "Copyright", "Description", "Rate" }; uint16_t len[5], buflen[5] = { 0 }; uint8_t *ch; uint64_t size = avio_rl64(pb); for (i = 0; i < 5; i++) { len[i] = avio_rl16(pb); buflen[i] = 2 * len[i] + 1; } for (i = 0; i < 5; i++) { ch = av_malloc(buflen[i]); if (!ch) return(AVERROR(ENOMEM)); asf_read_metadata(s, titles[i], len[i], ch, buflen[i]); av_freep(&ch); } align_position(pb, asf->offset, size); return 0; }<SPLIT>[-0.09900860198293619, -0.13034272285790952, 0.0, -0.11436118199787926, -0.1936866588694103, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.13098384443277505, -0.09566541730555662, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, -0.11100716297398205, -0.17914063696102905, 0.37651940477529405, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, 0.12893508214950905, 0.11818065472185141, -0.21702784222394986, 0.14602883551895066, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int iec61883_close(AVFormatContext *context) { struct iec61883_data *dv = context->priv_data; #if THREADS dv->thread_loop = 0; pthread_join(dv->receive_task_thread, NULL); pthread_cond_destroy(&dv->cond); pthread_mutex_destroy(&dv->mutex); #endif if (CONFIG_MPEGTS_DEMUXER && dv->type == IEC61883_HDV) { iec61883_mpeg2_recv_stop(dv->iec61883_mpeg2); iec61883_mpeg2_close(dv->iec61883_mpeg2); avpriv_mpegts_parse_close(dv->mpeg_demux); } else { iec61883_dv_fb_stop(dv->iec61883_dv); iec61883_dv_fb_close(dv->iec61883_dv); } while (dv->queue_first) { DVPacket *packet = dv->queue_first; dv->queue_first = packet->next; av_freep(&packet->buf); av_freep(&packet); } iec61883_cmp_disconnect(dv->raw1394, dv->node, dv->output_port, raw1394_get_local_id(dv->raw1394), dv->input_port, dv->channel, dv->bandwidth); raw1394_destroy_handle(dv->raw1394); return 0; }<SPLIT>[-0.25365086435942685, -0.020159756014915854, 0.0, -0.2665172434374763, -0.08729279623175898, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.051068312296575644, -0.25297036047912586, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.1134457356350565, -0.26569807294376846, -0.2012272036557901, 0.5059163865058198, -0.1892664641018488, 0.0, 0.3545307232390774, 0.9973611507722091, -0.0968099467164862, 0.01994523631491676, 0.4568607580216725, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void search_for_pns(AACEncContext *s, AVCodecContext *avctx, SingleChannelElement *sce) { int start = 0, w, w2, g; const float lambda = s->lambda; const float freq_mult = avctx->sample_rate/(1024.0f/sce->ics.num_windows)/2.0f; const float spread_threshold = NOISE_SPREAD_THRESHOLD*(lambda/120.f); const float thr_mult = NOISE_LAMBDA_NUMERATOR/lambda; for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) { start = 0; for (g = 0; g < sce->ics.num_swb; g++) { if (start*freq_mult > NOISE_LOW_LIMIT*(lambda/170.0f)) { float energy = 0.0f, threshold = 0.0f, spread = 0.0f; for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) { FFPsyBand *band = &s->psy.ch[s->cur_channel+0].psy_bands[(w+w2)*16+g]; energy += band->energy; threshold += band->threshold; spread += band->spread; } if (spread > spread_threshold*sce->ics.group_len[w] && ((sce->zeroes[w*16+g] && energy >= threshold) || energy < threshold*thr_mult*sce->ics.group_len[w])) { sce->band_type[w*16+g] = NOISE_BT; sce->pns_ener[w*16+g] = energy / sce->ics.group_len[w]; sce->zeroes[w*16+g] = 0; } } start += sce->ics.swb_sizes[g]; } } }<SPLIT>[-0.25365086435942685, 0.0018768373536828752, 0.0, -0.2665172434374763, -0.06601402370422871, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.031089429262525795, -0.25297036047912586, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, -0.09407211557651925, -0.26569807294376846, -0.04662123679246273, -0.011671540416283347, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 0.043718655277859224, -0.08904460951967552, 0.4568607580216725, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold int dilate_init(AVFilterContext *ctx, const char *args) { OCVContext *s = ctx->priv; DilateContext *dilate = s->priv; char default_kernel_str[] = "3x3+0x0/rect"; char *kernel_str = NULL; const char *buf = args; int ret; if (args) { kernel_str = av_get_token(&buf, "|"); if (!kernel_str) return AVERROR(ENOMEM); } ret = parse_iplconvkernel(&dilate->kernel, (!kernel_str || !*kernel_str) ? default_kernel_str : kernel_str, ctx); av_free(kernel_str); if (ret < 0) return ret; if (!buf || sscanf(buf, "|%d", &dilate->nb_iterations) != 1) dilate->nb_iterations = 1; av_log(ctx, AV_LOG_VERBOSE, "iterations_nb:%d\n", dilate->nb_iterations); if (dilate->nb_iterations <= 0) { av_log(ctx, AV_LOG_ERROR, "Invalid non-positive value '%d' for nb_iterations\n", dilate->nb_iterations); return AVERROR(EINVAL); } return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.06601402370422871, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.09407211557651925, -0.26569807294376846, -0.04662123679246273, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int audio_read_close(AVFormatContext *s1) { OSSAudioData *s = s1->priv_data; ff_oss_audio_close(s); return 0; }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int mov_write_traf_tag(AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track, int64_t moof_offset, int moof_size) { int64_t pos = avio_tell(pb); int i, start = 0; avio_wb32(pb, 0); ffio_wfourcc(pb, "traf"); mov_write_tfhd_tag(pb, mov, track, moof_offset); if (mov->mode != MODE_ISM) mov_write_tfdt_tag(pb, track); for (i = 1; i < track->entry; i++) { if (track->cluster[i].pos != track->cluster[i - 1].pos + track->cluster[i - 1].size) { mov_write_trun_tag(pb, mov, track, moof_size, start, i); start = i; } } mov_write_trun_tag(pb, mov, track, moof_size, start, track->entry); if (mov->mode == MODE_ISM) { mov_write_tfxd_tag(pb, track); if (mov->ism_lookahead) { int i, size = 16 + 4 + 1 + 16 * mov->ism_lookahead; if (track->nb_frag_info > 0) { MOVFragmentInfo *info = &track->frag_info[track->nb_frag_info - 1]; if (!info->tfrf_offset) info->tfrf_offset = avio_tell(pb); } avio_wb32(pb, 8 + size); ffio_wfourcc(pb, "free"); for (i = 0; i < size; i++) avio_w8(pb, 0); } } return update_size(pb, pos); }<SPLIT>[-0.25365086435942685, 0.11205980419667652, 0.0, -0.2665172434374763, 0.04037983893342262, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.06880498590772346, -0.25297036047912586, 0.13609701908992267, 0.0, 0.0, 0.30852482215402843, 0.0027959847161670454, -0.26569807294376846, 0.06381159668134254, 0.8941073316973973, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.043718655277859224, 0.18343000506680518, 0.6826474935548865, -0.21702784222394986, -0.22825425296243224, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 1.7623686513065309, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void vector_fmul_reverse_mips(float *dst, const float *src0, const float *src1, int len){ int i; float temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7; src1 += len-1; for(i=0; i<(len>>2); i++) { __asm__ volatile( "lwc1 %[temp0], 0(%[src0]) \n\t" "lwc1 %[temp1], 0(%[src1]) \n\t" "lwc1 %[temp2], 4(%[src0]) \n\t" "lwc1 %[temp3], -4(%[src1]) \n\t" "lwc1 %[temp4], 8(%[src0]) \n\t" "lwc1 %[temp5], -8(%[src1]) \n\t" "lwc1 %[temp6], 12(%[src0]) \n\t" "lwc1 %[temp7], -12(%[src1]) \n\t" "mul.s %[temp0], %[temp1], %[temp0] \n\t" "mul.s %[temp2], %[temp3], %[temp2] \n\t" "mul.s %[temp4], %[temp5], %[temp4] \n\t" "mul.s %[temp6], %[temp7], %[temp6] \n\t" PTR_ADDIU "%[src0], %[src0], 16 \n\t" PTR_ADDIU "%[src1], %[src1], -16 \n\t" PTR_ADDIU "%[dst], %[dst], 16 \n\t" "swc1 %[temp0], -16(%[dst]) \n\t" "swc1 %[temp2], -12(%[dst]) \n\t" "swc1 %[temp4], -8(%[dst]) \n\t" "swc1 %[temp6], -4(%[dst]) \n\t" : [dst]"+r"(dst), [src0]"+r"(src0), [src1]"+r"(src1), [temp0]"=&f"(temp0), [temp1]"=&f"(temp1),[temp2]"=&f"(temp2), [temp3]"=&f"(temp3), [temp4]"=&f"(temp4), [temp5]"=&f"(temp5), [temp6]"=&f"(temp6), [temp7]"=&f"(temp7) : : "memory" ); } }<SPLIT>[-0.09900860198293619, 0.11205980419667652, 0.0, -0.11436118199787926, 0.04037983893342262, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.08878386894177331, -0.09566541730555662, 0.13609701908992267, 0.0, 0.0, 0.30852482215402843, 0.022169604774704303, -0.11100716297398205, 0.06381159668134254, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, 0.01994523631491676, 0.23107402248845843, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int read_packets(WriterContext *w, InputFile *ifile) { AVFormatContext *fmt_ctx = ifile->fmt_ctx; int i, ret = 0; int64_t cur_ts = fmt_ctx->start_time; if (read_intervals_nb == 0) { ReadInterval interval = (ReadInterval) { .has_start = 0, .has_end = 0 }; ret = read_interval_packets(w, ifile, &interval, &cur_ts); } else { for (i = 0; i < read_intervals_nb; i++) { ret = read_interval_packets(w, ifile, &read_intervals[i], &cur_ts); if (ret < 0) break; } } return ret; }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.5292594673383866, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.41601414702345235, -0.4462861841111837, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int skip_check(MpegEncContext *s, Picture *p, Picture *ref) { int x, y, plane; int score = 0; int64_t score64 = 0; for (plane = 0; plane < 3; plane++) { const int stride = p->f->linesize[plane]; const int bw = plane ? 1 : 2; for (y = 0; y < s->mb_height * bw; y++) { for (x = 0; x < s->mb_width * bw; x++) { int off = p->shared ? 0 : 16; uint8_t *dptr = p->f->data[plane] + 8 * (x + y * stride) + off; uint8_t *rptr = ref->f->data[plane] + 8 * (x + y * stride); int v = s->mecc.frame_skip_cmp[1](s, dptr, rptr, stride, 8); switch (FFABS(s->avctx->frame_skip_exp)) { case 0: score = FFMAX(score, v); break; case 1: score += FFABS(v); break; case 2: score64 += v * (int64_t)v; break; case 3: score64 += FFABS(v * (int64_t)v * v); break; case 4: score64 += (v * (int64_t)v) * (v * (int64_t)v); break; } } } } emms_c(); if (score) score64 = score; if (s->avctx->frame_skip_exp < 0) score64 = pow(score64 / (double)(s->mb_width * s->mb_height), -1.0/s->avctx->frame_skip_exp); if (score64 < s->avctx->frame_skip_threshold) return 1; if (score64 < ((s->avctx->frame_skip_factor * (int64_t)s->lambda) >> 8)) return 1; return 0; }<SPLIT>[-0.25365086435942685, 0.13409639756527525, 0.0, -0.2665172434374763, 0.06165861146095288, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, 0.380400859743741, 0.08878386894177331, -0.25297036047912586, 0.1588898992878544, 0.0, 0.0, 0.30852482215402843, 0.022169604774704303, -0.26569807294376846, 0.08589816337610359, 0.5059163865058198, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3950401602637228, 0.5648944654878781, 0.5697541257882794, -0.21702784222394986, 0.5203119240003335, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, 0.3801362775450152, 0.04889276383167627, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 0.3766295797615486]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *in) { MergePlanesContext *s = inlink->dst->priv; return ff_framesync_filter_frame(&s->fs, inlink, in); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static inline int init_opencl_mtx(void) { #if HAVE_THREADS if (!atomic_opencl_lock) { int err; pthread_mutex_t *tmp = av_malloc(sizeof(pthread_mutex_t)); if (!tmp) return AVERROR(ENOMEM); if ((err = pthread_mutex_init(tmp, NULL))) { av_free(tmp); return AVERROR(err); } if (avpriv_atomic_ptr_cas(&atomic_opencl_lock, NULL, tmp)) { pthread_mutex_destroy(tmp); av_free(tmp); } } #endif return 0; }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.4084991676475909, 0.0, 1.457000985644429, 0.9973611507722091, -0.4129993012037634, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { AVFilterFormats *formats = NULL; AVFilterChannelLayouts *layouts = NULL; AVFilterLink *inlink = ctx->inputs[0]; AVFilterLink *outlink = ctx->outputs[0]; static const enum AVSampleFormat sample_fmts[] = { AV_SAMPLE_FMT_S16P, AV_SAMPLE_FMT_NONE }; static const enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_NONE }; formats = ff_make_format_list(sample_fmts); if (!formats) return AVERROR(ENOMEM); ff_formats_ref(formats, &inlink->out_formats); layouts = ff_all_channel_layouts(); if (!layouts) return AVERROR(ENOMEM); ff_channel_layouts_ref(layouts, &inlink->out_channel_layouts); formats = ff_all_samplerates(); if (!formats) return AVERROR(ENOMEM); ff_formats_ref(formats, &inlink->out_samplerates); formats = ff_make_format_list(pix_fmts); if (!formats) return AVERROR(ENOMEM); ff_formats_ref(formats, &outlink->in_formats); return 0; }<SPLIT>[0.05563366039355449, -0.08626953612071205, 0.0, 0.037794879441717756, -0.15112911381434976, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.07104719533062549, 0.061639525868012635, -0.06903890269146298, 0.0, 0.0, 0.30852482215402843, -0.13281935569359377, 0.04368374699580437, -0.13496750357150694, 0.24712242304476825, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, -0.08904460951967552, 0.34396739025506545, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { AVFilterChannelLayouts *layouts = NULL; AVFilterFormats *formats = NULL; static const enum AVSampleFormat sample_fmts[] = { AV_SAMPLE_FMT_U8, AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_S32, AV_SAMPLE_FMT_FLT, AV_SAMPLE_FMT_DBL, AV_SAMPLE_FMT_NONE }; int ret; layouts = ff_all_channel_layouts(); if (!layouts) { return AVERROR(ENOMEM); } ret = ff_set_common_channel_layouts(ctx, layouts); if (ret < 0) return ret; formats = ff_make_format_list(sample_fmts); if (!formats) { return AVERROR(ENOMEM); } ret = ff_set_common_formats(ctx, formats); if (ret < 0) return ret; formats = ff_all_samplerates(); if (!formats) { return AVERROR(ENOMEM); } return ff_set_common_samplerates(ctx, formats); }<SPLIT>[0.6742027098995172, 0.06798661745947907, 0.0, 0.6464191252001059, -0.0021777061216379156, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, 0.380400859743741, 0.14872051804392286, 0.6908592985622897, 0.0905112586940592, 0.0, 0.0, 0.30852482215402843, 0.08029046495031608, 0.66244738687495, 0.01963846329182043, 0.37651940477529405, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, 0.23792492798410134, 0.34396739025506545, -0.21702784222394986, 0.14602883551895066, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, 0.3801362775450152, 0.04889276383167627, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 0.3766295797615486]
0<SPLIT>static void vector_fmul_scalar_mips(float *dst, const float *src, float mul, int len) { float temp0, temp1, temp2, temp3; float *local_src = (float*)src; float *end = local_src + len; __asm__ volatile( ".set push \n\t" ".set noreorder \n\t" "1: \n\t" "lwc1 %[temp0], 0(%[src]) \n\t" "lwc1 %[temp1], 4(%[src]) \n\t" "lwc1 %[temp2], 8(%[src]) \n\t" "lwc1 %[temp3], 12(%[src]) \n\t" PTR_ADDIU "%[dst], %[dst], 16 \n\t" "mul.s %[temp0], %[temp0], %[mul] \n\t" "mul.s %[temp1], %[temp1], %[mul] \n\t" "mul.s %[temp2], %[temp2], %[mul] \n\t" "mul.s %[temp3], %[temp3], %[mul] \n\t" PTR_ADDIU "%[src], %[src], 16 \n\t" "swc1 %[temp0], -16(%[dst]) \n\t" "swc1 %[temp1], -12(%[dst]) \n\t" "swc1 %[temp2], -8(%[dst]) \n\t" "bne %[src], %[end], 1b \n\t" " swc1 %[temp3], -4(%[dst]) \n\t" ".set pop \n\t" : [temp0]"=&f"(temp0), [temp1]"=&f"(temp1), [temp2]"=&f"(temp2), [temp3]"=&f"(temp3), [dst]"+r"(dst), [src]"+r"(local_src) : [end]"r"(end), [mul]"f"(mul) : "memory" ); }<SPLIT>[-0.09900860198293619, 0.06798661745947907, 0.0, -0.11436118199787926, -0.0021777061216379156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.04882610287367361, -0.09566541730555662, 0.0905112586940592, 0.0, 0.0, 0.30852482215402843, -0.016577635342370212, -0.11100716297398205, 0.01963846329182043, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.3615192241061562, -0.10760608081136262, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void paint_mouse_pointer(AVFormatContext *s1, struct gdigrab *gdigrab) { CURSORINFO ci = {0}; #define CURSOR_ERROR(str) \ if (!gdigrab->cursor_error_printed) { \ WIN32_API_ERROR(str); \ gdigrab->cursor_error_printed = 1; \ } ci.cbSize = sizeof(ci); if (GetCursorInfo(&ci)) { HCURSOR icon = CopyCursor(ci.hCursor); ICONINFO info; POINT pos; RECT clip_rect = gdigrab->clip_rect; HWND hwnd = gdigrab->hwnd; info.hbmMask = NULL; info.hbmColor = NULL; if (ci.flags != CURSOR_SHOWING) return; if (!icon) { icon = CopyCursor(LoadCursor(NULL, IDC_ARROW)); } if (!GetIconInfo(icon, &info)) { CURSOR_ERROR("Could not get icon info"); goto icon_error; } pos.x = ci.ptScreenPos.x - clip_rect.left - info.xHotspot; pos.y = ci.ptScreenPos.y - clip_rect.top - info.yHotspot; if (hwnd) { RECT rect; if (GetWindowRect(hwnd, &rect)) { pos.x -= rect.left; pos.y -= rect.top; } else { CURSOR_ERROR("Couldn't get window rectangle"); goto icon_error; } } av_log(s1, AV_LOG_DEBUG, "Cursor pos (%li,%li) -> (%li,%li)\n", ci.ptScreenPos.x, ci.ptScreenPos.y, pos.x, pos.y); if (pos.x >= 0 && pos.x <= clip_rect.right - clip_rect.left && pos.y >= 0 && pos.y <= clip_rect.bottom - clip_rect.top) { if (!DrawIcon(gdigrab->dest_hdc, pos.x, pos.y, icon)) CURSOR_ERROR("Couldn't draw icon"); } icon_error: if (info.hbmMask) DeleteObject(info.hbmMask); if (info.hbmColor) DeleteObject(info.hbmColor); if (icon) DestroyCursor(icon); } else { CURSOR_ERROR("Couldn't get cursor info"); } }<SPLIT>[0.21027592277004517, 0.5748282649372498, 0.0, 0.18995094088131478, 0.48723406201155817, 0.0, 1.6653401555507896, 1.7015798777335354, 1.5692995750795884, 1.3698779043020206, 0.5482981787249199, 0.21894446904158188, 0.5919546230485575, 0.0, 0.0, 0.30852482215402843, 0.4677628661210612, 0.19837465696559078, 0.5055429305765636, 0.24712242304476825, 0.13958259121676436, 0.0, -0.08645738172306322, 0.417570182313826, 0.2896437087679637, 1.273328463412728, 0.5697541257882794, 4.277101146357483, 1.2688781009630994, 1.664582183638518, 1.7009206574961395, 1.5685972020260743, 1.3693714445839917, 2.6191065950439585, 0.0, 1.6594432402238268, 1.6957470663015664, 1.5635067606227984, 1.3643185231999084]
1<SPLIT>static int vp3_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; Vp3DecodeContext *s = avctx->priv_data; GetBitContext gb; int i; init_get_bits(&gb, buf, buf_size * 8); if (s->theora && get_bits1(&gb)) { av_log(avctx, AV_LOG_ERROR, "Header packet passed to frame decoder, skipping\n"); return -1; } s->keyframe = !get_bits1(&gb); if (!s->theora) skip_bits(&gb, 1); for (i = 0; i < 3; i++) s->last_qps[i] = s->qps[i]; s->nqps=0; do{ s->qps[s->nqps++]= get_bits(&gb, 6); } while(s->theora >= 0x030200 && s->nqps<3 && get_bits1(&gb)); for (i = s->nqps; i < 3; i++) s->qps[i] = -1; if (s->avctx->debug & FF_DEBUG_PICT_INFO) av_log(s->avctx, AV_LOG_INFO, " VP3 %sframe #%d: Q index = %d\n", s->keyframe?"key":"", avctx->frame_number+1, s->qps[0]); s->skip_loop_filter = !s->filter_limit_values[s->qps[0]] || avctx->skip_loop_filter >= (s->keyframe ? AVDISCARD_ALL : AVDISCARD_NONKEY); if (s->qps[0] != s->last_qps[0]) init_loop_filter(s); for (i = 0; i < s->nqps; i++) if (s->qps[i] != s->last_qps[i] || s->qps[0] != s->last_qps[0]) init_dequantizer(s, i); if (avctx->skip_frame >= AVDISCARD_NONKEY && !s->keyframe) return buf_size; s->current_frame.reference = 3; s->current_frame.pict_type = s->keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P; s->current_frame.key_frame = s->keyframe; if (ff_thread_get_buffer(avctx, &s->current_frame) < 0) { av_log(s->avctx, AV_LOG_ERROR, "get_buffer() failed\n"); goto error; } if (!s->edge_emu_buffer) s->edge_emu_buffer = av_malloc(9*FFABS(s->current_frame.linesize[0])); if (s->keyframe) { if (!s->theora) { skip_bits(&gb, 4); skip_bits(&gb, 4); if (s->version) { s->version = get_bits(&gb, 5); if (avctx->frame_number == 0) av_log(s->avctx, AV_LOG_DEBUG, "VP version: %d\n", s->version); } } if (s->version || s->theora) { if (get_bits1(&gb)) av_log(s->avctx, AV_LOG_ERROR, "Warning, unsupported keyframe coding type?!\n"); skip_bits(&gb, 2); } } else { if (!s->golden_frame.data[0]) { av_log(s->avctx, AV_LOG_WARNING, "vp3: first frame not a keyframe\n"); s->golden_frame.reference = 3; s->golden_frame.pict_type = AV_PICTURE_TYPE_I; if (ff_thread_get_buffer(avctx, &s->golden_frame) < 0) { av_log(s->avctx, AV_LOG_ERROR, "get_buffer() failed\n"); goto error; } s->last_frame = s->golden_frame; s->last_frame.type = FF_BUFFER_TYPE_COPY; ff_thread_report_progress(&s->last_frame, INT_MAX, 0); } } memset(s->all_fragments, 0, s->fragment_count * sizeof(Vp3Fragment)); ff_thread_finish_setup(avctx); if (unpack_superblocks(s, &gb)){ av_log(s->avctx, AV_LOG_ERROR, "error in unpack_superblocks\n"); goto error; } if (unpack_modes(s, &gb)){ av_log(s->avctx, AV_LOG_ERROR, "error in unpack_modes\n"); goto error; } if (unpack_vectors(s, &gb)){ av_log(s->avctx, AV_LOG_ERROR, "error in unpack_vectors\n"); goto error; } if (unpack_block_qpis(s, &gb)){ av_log(s->avctx, AV_LOG_ERROR, "error in unpack_block_qpis\n"); goto error; } if (unpack_dct_coeffs(s, &gb)){ av_log(s->avctx, AV_LOG_ERROR, "error in unpack_dct_coeffs\n"); goto error; } for (i = 0; i < 3; i++) { int height = s->height >> (i && s->chroma_y_shift); if (s->flipped_image) s->data_offset[i] = 0; else s->data_offset[i] = (height-1) * s->current_frame.linesize[i]; } s->last_slice_end = 0; for (i = 0; i < s->c_superblock_height; i++) render_slice(s, i); for (i = 0; i < 3; i++) { int row = (s->height >> (3+(i && s->chroma_y_shift))) - 1; apply_loop_filter(s, i, row, row+1); } vp3_draw_horiz_band(s, s->avctx->height); *got_frame = 1; *(AVFrame*)data= s->current_frame; if (!HAVE_THREADS || !(s->avctx->active_thread_type&FF_THREAD_FRAME)) update_frames(avctx); return buf_size; error: ff_thread_report_progress(&s->current_frame, INT_MAX, 0); if (!HAVE_THREADS || !(s->avctx->active_thread_type&FF_THREAD_FRAME)) avctx->release_buffer(avctx, &s->current_frame); return -1; }<SPLIT>[3.921690219805821, 2.1394263941077596, 0.0, 3.8416964154316435, 1.998026911466207, 0.0, 2.360513103434668, 2.4085531756423553, 2.232667521283858, 3.34883199341858, 2.4462920669596557, 3.994263105207244, 2.233041997299643, 0.0, 0.0, 0.30852482215402843, 2.308256771682101, 3.910956496240465, 2.0957757325993596, 2.8350620576552843, 1.2357461089454749, 0.0, -0.08645738172306322, -0.16222078614455715, 2.0813833841958678, 2.6357015363451315, 2.376048010053992, 0.6817979554923368, 2.485298138527594, 2.359577116822857, 2.4077474138188704, 2.231801974192358, 3.347841778661945, 1.7623686513065309, 0.0, 2.3535618892272994, 2.4016960724561396, 2.225834372863994, 3.339696410076628]
0<SPLIT>static void update_rms(SilenceRemoveContext *s, double sample) { s->rms_sum -= *s->window_current; *s->window_current = sample * sample; s->rms_sum += *s->window_current; s->window_current++; if (s->window_current >= s->window_end) s->window_current = s->window; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int test_vector_fmul(AVFloatDSPContext *fdsp, AVFloatDSPContext *cdsp, const float *v1, const float *v2) { LOCAL_ALIGNED(32, float, cdst, [LEN]); LOCAL_ALIGNED(32, float, odst, [LEN]); int ret; cdsp->vector_fmul(cdst, v1, v2, LEN); fdsp->vector_fmul(odst, v1, v2, LEN); if (ret = compare_floats(cdst, odst, LEN, FLT_EPSILON)) av_log(NULL, AV_LOG_ERROR, "vector_fmul failed\n"); return ret; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int latm_decode_frame(AVCodecContext *avctx, void *out, int *got_frame_ptr, AVPacket *avpkt) { struct LATMContext *latmctx = avctx->priv_data; int muxlength, err; GetBitContext gb; if ((err = init_get_bits8(&gb, avpkt->data, avpkt->size)) < 0) return err; if (get_bits(&gb, 11) != LOAS_SYNC_WORD) return AVERROR_INVALIDDATA; muxlength = get_bits(&gb, 13) + 3; if (muxlength > avpkt->size) return AVERROR_INVALIDDATA; if ((err = read_audio_mux_element(latmctx, &gb)) < 0) return err; if (!latmctx->initialized) { if (!avctx->extradata) { *got_frame_ptr = 0; return avpkt->size; } else { push_output_configuration(&latmctx->aac_ctx); if ((err = decode_audio_specific_config( &latmctx->aac_ctx, avctx, &latmctx->aac_ctx.oc[1].m4ac, avctx->extradata, avctx->extradata_size*8LL, 1)) < 0) { pop_output_configuration(&latmctx->aac_ctx); return err; } latmctx->initialized = 1; } } if (show_bits(&gb, 12) == 0xfff) { av_log(latmctx->aac_ctx.avctx, AV_LOG_ERROR, "ADTS header detected, probably as result of configuration " "misparsing\n"); return AVERROR_INVALIDDATA; } switch (latmctx->aac_ctx.oc[1].m4ac.object_type) { case AOT_ER_AAC_LC: case AOT_ER_AAC_LTP: case AOT_ER_AAC_LD: case AOT_ER_AAC_ELD: err = aac_decode_er_frame(avctx, out, got_frame_ptr, &gb); break; default: err = aac_decode_frame_int(avctx, out, got_frame_ptr, &gb, avpkt); } if (err < 0) return err; return muxlength; }<SPLIT>[0.05563366039355449, 0.4426087047256575, 0.0, 0.037794879441717756, 0.3595614268463766, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, 1.699703585821447, 0.40844599748657096, 0.061639525868012635, 0.4779902220588988, 0.0, 0.0, 0.30852482215402843, 0.3321475257113004, 0.04368374699580437, 0.39511009710275835, 0.8941073316973973, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, 0.043718655277859224, 0.7828741571570628, 0.7955408613214935, -0.21702784222394986, 0.7074534682410251, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, 1.6991165002636506, 1.7623686513065309, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 1.693548171012695]
0<SPLIT>static int reap_filters(int flush) { AVFrame *filtered_frame = NULL; int i; for (i = 0; i < nb_output_streams; i++) { OutputStream *ost = output_streams[i]; OutputFile *of = output_files[ost->file_index]; AVFilterContext *filter; AVCodecContext *enc = ost->enc_ctx; int ret = 0; if (!ost->filter || !ost->filter->graph->graph) continue; filter = ost->filter->filter; if (!ost->initialized) { char error[1024] = ""; ret = init_output_stream(ost, error, sizeof(error)); if (ret < 0) { av_log(NULL, AV_LOG_ERROR, "Error initializing output stream %d:%d -- %s\n", ost->file_index, ost->index, error); exit_program(1); } } if (!ost->filtered_frame && !(ost->filtered_frame = av_frame_alloc())) { return AVERROR(ENOMEM); } filtered_frame = ost->filtered_frame; while (1) { double float_pts = AV_NOPTS_VALUE; ret = av_buffersink_get_frame_flags(filter, filtered_frame, AV_BUFFERSINK_FLAG_NO_REQUEST); if (ret < 0) { if (ret != AVERROR(EAGAIN) && ret != AVERROR_EOF) { av_log(NULL, AV_LOG_WARNING, "Error in av_buffersink_get_frame_flags(): %s\n", av_err2str(ret)); } else if (flush && ret == AVERROR_EOF) { if (av_buffersink_get_type(filter) == AVMEDIA_TYPE_VIDEO) do_video_out(of, ost, NULL, AV_NOPTS_VALUE); } break; } if (ost->finished) { av_frame_unref(filtered_frame); continue; } if (filtered_frame->pts != AV_NOPTS_VALUE) { int64_t start_time = (of->start_time == AV_NOPTS_VALUE) ? 0 : of->start_time; AVRational filter_tb = av_buffersink_get_time_base(filter); AVRational tb = enc->time_base; int extra_bits = av_clip(29 - av_log2(tb.den), 0, 16); tb.den <<= extra_bits; float_pts = av_rescale_q(filtered_frame->pts, filter_tb, tb) - av_rescale_q(start_time, AV_TIME_BASE_Q, tb); float_pts /= 1 << extra_bits; float_pts += FFSIGN(float_pts) * 1.0 / (1<<17); filtered_frame->pts = av_rescale_q(filtered_frame->pts, filter_tb, enc->time_base) - av_rescale_q(start_time, AV_TIME_BASE_Q, enc->time_base); } switch (av_buffersink_get_type(filter)) { case AVMEDIA_TYPE_VIDEO: if (!ost->frame_aspect_ratio.num) enc->sample_aspect_ratio = filtered_frame->sample_aspect_ratio; if (debug_ts) { av_log(NULL, AV_LOG_INFO, "filter -> pts:%s pts_time:%s exact:%f time_base:%d/%d\n", av_ts2str(filtered_frame->pts), av_ts2timestr(filtered_frame->pts, &enc->time_base), float_pts, enc->time_base.num, enc->time_base.den); } do_video_out(of, ost, filtered_frame, float_pts); break; case AVMEDIA_TYPE_AUDIO: if (!(enc->codec->capabilities & AV_CODEC_CAP_PARAM_CHANGE) && enc->channels != av_frame_get_channels(filtered_frame)) { av_log(NULL, AV_LOG_ERROR, "Audio filter graph output is not normalized and encoder does not support parameter changes\n"); break; } do_audio_out(of, ost, filtered_frame); break; default: av_assert0(0); } av_frame_unref(filtered_frame); } } return 0; }<SPLIT>[0.5195604475230265, 1.279999252732409, 0.0, 0.4942630637605089, 1.1681547828925267, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 1.2275802018826147, 0.5335543553887203, 1.3441196695803048, 0.0, 0.0, 0.30852482215402843, 1.126465948111328, 0.5077564769051636, 1.2343996315036785, 1.9292831855416035, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.8517581167453454, 0.6738843113224704, 1.9244745389875635, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold int init(AVFilterContext *ctx) { int ret; DeshakeContext *deshake = ctx->priv; deshake->sad = av_pixelutils_get_sad_fn(4, 4, 1, deshake); if (!deshake->sad) return AVERROR(EINVAL); deshake->refcount = 20; deshake->blocksize /= 2; deshake->blocksize = av_clip(deshake->blocksize, 4, 128); if (deshake->rx % 16) { av_log(ctx, AV_LOG_ERROR, "rx must be a multiple of 16\n"); return AVERROR_PATCHWELCOME; } if (deshake->filename) deshake->fp = fopen(deshake->filename, "w"); if (deshake->fp) fwrite("Ori x, Avg x, Fin x, Ori y, Avg y, Fin y, Ori angle, Avg angle, Fin angle, Ori zoom, Avg zoom, Fin zoom\n", sizeof(char), 104, deshake->fp); if (deshake->cx > 0) { deshake->cw += deshake->cx - (deshake->cx & ~15); deshake->cx &= ~15; } deshake->transform = deshake_transform_c; if (!CONFIG_OPENCL && deshake->opencl) { av_log(ctx, AV_LOG_ERROR, "OpenCL support was not enabled in this build, cannot be selected\n"); return AVERROR(EINVAL); } if (CONFIG_OPENCL && deshake->opencl) { deshake->transform = ff_opencl_transform; ret = ff_opencl_deshake_init(ctx); if (ret < 0) return ret; } av_log(ctx, AV_LOG_VERBOSE, "cx: %d, cy: %d, cw: %d, ch: %d, rx: %d, ry: %d, edge: %d blocksize: %d contrast: %d search: %d\n", deshake->cx, deshake->cy, deshake->cw, deshake->ch, deshake->rx, deshake->ry, deshake->edge, deshake->blocksize * 2, deshake->contrast, deshake->search); return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.037794879441717756, 0.10421615651601342, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.09966408500885333, 0.04368374699580437, 0.1300712967656257, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.043718655277859224, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int config_props(AVFilterLink *link) { AVFilterContext *ctx = link->src; YADIFContext *s = link->src->priv; link->time_base.num = link->src->inputs[0]->time_base.num; link->time_base.den = link->src->inputs[0]->time_base.den * 2; link->w = link->src->inputs[0]->w; link->h = link->src->inputs[0]->h; if(s->mode&1) link->frame_rate = av_mul_q(link->src->inputs[0]->frame_rate, (AVRational){2,1}); if (link->w < 3 || link->h < 3) { av_log(ctx, AV_LOG_ERROR, "Video of less than 3 columns or lines is not supported\n"); return AVERROR(EINVAL); } s->csp = av_pix_fmt_desc_get(link->format); if (s->csp->comp[0].depth_minus1 / 8 == 1) { s->filter_line = filter_line_c_16bit; s->filter_edges = filter_edges_16bit; } else { s->filter_line = filter_line_c; s->filter_edges = filter_edges; } if (ARCH_X86) ff_yadif_init_x86(s); return 0; }<SPLIT>[-0.25365086435942685, -0.08626953612071205, 0.0, -0.2665172434374763, -0.15112911381434976, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.1110049613987252, -0.25297036047912586, -0.06903890269146298, 0.0, 0.0, 0.30852482215402843, -0.17156659581066827, -0.26569807294376846, -0.13496750357150694, -0.14106852214680915, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, -0.25252937827156396, -0.22049944857796966, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void http_av_log(void *ptr, int level, const char *fmt, va_list vargs) { static int print_prefix = 1; AVClass *avc = ptr ? *(AVClass**)ptr : NULL; if (level > av_log_get_level()) return; if (print_prefix && avc) http_log("[%s @ %p]", avc->item_name(ptr), ptr); print_prefix = strstr(fmt, "\n") != NULL; http_vlog(fmt, vargs); }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.14106852214680915, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3070243011888601, -0.22049944857796966, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void ff_fill_rectangle(FFDrawContext *draw, FFDrawColor *color, uint8_t *dst[], int dst_linesize[], int dst_x, int dst_y, int w, int h) { int plane, x, y, wp, hp; uint8_t *p0, *p; for (plane = 0; plane < draw->nb_planes; plane++) { p0 = pointer_at(draw, dst, dst_linesize, plane, dst_x, dst_y); wp = FF_CEIL_RSHIFT(w, draw->hsub[plane]); hp = FF_CEIL_RSHIFT(h, draw->vsub[plane]); if (!hp) return; p = p0; for (x = 0; x < wp; x++) { memcpy(p, color->comp[plane].u8, draw->pixelstep[plane]); p += draw->pixelstep[plane]; } wp *= draw->pixelstep[plane]; p = p0 + dst_linesize[plane]; for (y = 1; y < hp; y++) { memcpy(p, p0, wp); p += dst_linesize[plane]; } } }<SPLIT>[0.05563366039355449, -0.10830612948931077, 0.0, 0.037794879441717756, -0.17240788634188003, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.09102607836467534, 0.061639525868012635, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.152192975752131, 0.04368374699580437, -0.157054070266268, -0.011671540416283347, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, -0.25252937827156396, 0.11818065472185141, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void run_gcrypt_camellia(uint8_t *output, const uint8_t *input, unsigned size) { static gcry_cipher_hd_t camellia; if (!camellia) gcry_cipher_open(&camellia, GCRY_CIPHER_CAMELLIA128, GCRY_CIPHER_MODE_ECB, 0); gcry_cipher_setkey(camellia, hardcoded_key, 16); gcry_cipher_encrypt(camellia, output, size, input, size); }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.14106852214680915, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.4705090699407485, -0.3333928163445767, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int aac_decode_er_frame(AVCodecContext *avctx, void *data, int *got_frame_ptr, GetBitContext *gb) { AACContext *ac = avctx->priv_data; const MPEG4AudioConfig *const m4ac = &ac->oc[1].m4ac; ChannelElement *che; int err, i; int samples = m4ac->frame_length_short ? 960 : 1024; int chan_config = m4ac->chan_config; int aot = m4ac->object_type; if (aot == AOT_ER_AAC_LD || aot == AOT_ER_AAC_ELD) samples >>= 1; ac->frame = data; if ((err = frame_configure_elements(avctx)) < 0) return err; ac->avctx->profile = aot - 1; ac->tags_mapped = 0; if (chan_config < 0 || (chan_config >= 8 && chan_config < 11) || chan_config >= 13) { avpriv_request_sample(avctx, "Unknown ER channel configuration %d", chan_config); return AVERROR_INVALIDDATA; } for (i = 0; i < tags_per_config[chan_config]; i++) { const int elem_type = aac_channel_layout_map[chan_config-1][i][0]; const int elem_id = aac_channel_layout_map[chan_config-1][i][1]; if (!(che=get_che(ac, elem_type, elem_id))) { av_log(ac->avctx, AV_LOG_ERROR, "channel element %d.%d is not allocated\n", elem_type, elem_id); return AVERROR_INVALIDDATA; } che->present = 1; if (aot != AOT_ER_AAC_ELD) skip_bits(gb, 4); switch (elem_type) { case TYPE_SCE: err = decode_ics(ac, &che->ch[0], gb, 0, 0); break; case TYPE_CPE: err = decode_cpe(ac, gb, che); break; case TYPE_LFE: err = decode_ics(ac, &che->ch[0], gb, 0, 0); break; } if (err < 0) return err; } spectral_to_sample(ac, samples); ac->frame->nb_samples = samples; ac->frame->sample_rate = avctx->sample_rate; *got_frame_ptr = 1; skip_bits_long(gb, get_bits_left(gb)); return 0; }<SPLIT>[0.05563366039355449, 0.5527916715686512, 0.0, 0.037794879441717756, 0.4659552894840279, 0.0, 0.10120102281206332, 0.11088995743869048, 0.5742476557731842, -0.27925050329511203, 0.5083404126568202, 0.061639525868012635, 0.5919546230485575, 0.0, 0.0, 0.30852482215402843, 0.4290156260039867, 0.04368374699580437, 0.5055429305765636, 1.4116952586195004, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, 0.5355687622580682, 0.6738843113224704, 1.2471143323879217, -0.21702784222394986, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.5737900437766489, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.5700153422610048, -0.28182971586402455]
0<SPLIT>void av_opt_freep_ranges(AVOptionRanges **rangesp) { int i; AVOptionRanges *ranges = *rangesp; if (!ranges) return; for (i = 0; i < ranges->nb_ranges * ranges->nb_components; i++) { AVOptionRange *range = ranges->range[i]; if (range) { av_freep(&range->str); av_freep(&ranges->range[i]); } } av_freep(&ranges->range); av_freep(rangesp); }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>long WINAPI libAVFilter_GetState(libAVFilter *this, DWORD ms, FILTER_STATE *state) { dshowdebug("libAVFilter_GetState(%p)\n", this); if (!state) return E_POINTER; *state = this->state; return S_OK; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { FifoContext *fifo = ctx->priv; Buf *buf, *tmp; for (buf = fifo->root.next; buf; buf = tmp) { tmp = buf->next; av_frame_free(&buf->frame); av_free(buf); } av_frame_free(&fifo->out); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>int av_interleaved_write_uncoded_frame(AVFormatContext *s, int stream_index, AVFrame *frame) { return av_write_uncoded_frame_internal(s, stream_index, frame, 1); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>static int sdp_parse_fmtp_config_h264(AVFormatContext *s, AVStream *stream, PayloadContext *h264_data, const char *attr, const char *value) { AVCodecParameters *par = stream->codecpar; if (!strcmp(attr, "packetization-mode")) { av_log(s, AV_LOG_DEBUG, "RTP Packetization Mode: %d\n", atoi(value)); h264_data->packetization_mode = atoi(value); if (h264_data->packetization_mode > 1) av_log(s, AV_LOG_ERROR, "Interleaved RTP mode is not supported yet.\n"); } else if (!strcmp(attr, "profile-level-id")) { if (strlen(value) == 6) parse_profile_level_id(s, h264_data, value); } else if (!strcmp(attr, "sprop-parameter-sets")) { int ret; if (value[strlen(value) - 1] == ',') { av_log(s, AV_LOG_WARNING, "Missing PPS in sprop-parameter-sets, ignoring\n"); return 0; } par->extradata_size = 0; av_freep(&par->extradata); ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata, &par->extradata_size, value); av_log(s, AV_LOG_DEBUG, "Extradata set to %p (size: %d)\n", par->extradata, par->extradata_size); return ret; } return 0; }<SPLIT>[0.9834872346524985, 0.023913430722281605, 0.0, 0.9507312480792999, -0.044735251176698444, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 1.040052222782594, 0.14872051804392286, 1.0054691849094282, 0.04492549829819571, 0.0, 0.0, 0.30852482215402843, 0.08029046495031608, 0.9718292068145229, -0.024534670097701678, 0.5059163865058198, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, 0.12893508214950905, 0.11818065472185141, -0.21702784222394986, 0.14602883551895066, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 1.039626388904333, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 1.0350888753871217]
0<SPLIT>static int calc_bit_demand(AacPsyContext *ctx, float pe, int bits, int size, int short_window) { const float bitsave_slope = short_window ? PSY_3GPP_SAVE_SLOPE_S : PSY_3GPP_SAVE_SLOPE_L; const float bitsave_add = short_window ? PSY_3GPP_SAVE_ADD_S : PSY_3GPP_SAVE_ADD_L; const float bitspend_slope = short_window ? PSY_3GPP_SPEND_SLOPE_S : PSY_3GPP_SPEND_SLOPE_L; const float bitspend_add = short_window ? PSY_3GPP_SPEND_ADD_S : PSY_3GPP_SPEND_ADD_L; const float clip_low = short_window ? PSY_3GPP_CLIP_LO_S : PSY_3GPP_CLIP_LO_L; const float clip_high = short_window ? PSY_3GPP_CLIP_HI_S : PSY_3GPP_CLIP_HI_L; float clipped_pe, bit_save, bit_spend, bit_factor, fill_level; ctx->fill_level += ctx->frame_bits - bits; ctx->fill_level = av_clip(ctx->fill_level, 0, size); fill_level = av_clipf((float)ctx->fill_level / size, clip_low, clip_high); clipped_pe = av_clipf(pe, ctx->pe.min, ctx->pe.max); bit_save = (fill_level + bitsave_add) * bitsave_slope; assert(bit_save <= 0.3f && bit_save >= -0.05000001f); bit_spend = (fill_level + bitspend_add) * bitspend_slope; assert(bit_spend <= 0.5f && bit_spend >= -0.1f); bit_factor = 1.0f - bit_save + ((bit_spend - bit_save) / (ctx->pe.max - ctx->pe.min)) * (clipped_pe - ctx->pe.min); ctx->pe.max = FFMAX(pe, ctx->pe.max); ctx->pe.min = FFMIN(pe, ctx->pe.min); return FFMIN(ctx->frame_bits * bit_factor, ctx->frame_bits + size - bits); }<SPLIT>[0.8288449722760078, -0.15237931622650824, 0.0, 0.798575186639703, -0.21496543139694058, 0.0, -0.42017868810084547, -0.4193400159929245, -0.08912029043108533, -0.27925050329511203, -0.031089429262525795, 0.8481642417358589, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.09407211557651925, 0.8171382968447365, -0.2012272036557901, 0.8941073316973973, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.026545645719313483, 0.40140969673598975, 1.0213275968547075, -0.21702784222394986, -0.13468348084208653, -0.42040261591449885, -0.41955961147205284, -0.08941472838963471, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int opt_height(void *optctx, const char *opt, const char *arg) { screen_height = parse_number_or_die(opt, arg, OPT_INT64, 1, INT_MAX); return 0; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int ff_ac3_bit_alloc_calc_mask(AC3BitAllocParameters *s, int16_t *band_psd, int start, int end, int fast_gain, int is_lfe, int dba_mode, int dba_nsegs, uint8_t *dba_offsets, uint8_t *dba_lengths, uint8_t *dba_values, int16_t *mask) { int16_t excite[AC3_CRITICAL_BANDS]; int band; int band_start, band_end, begin, end1; int lowcomp, fastleak, slowleak; if (end <= 0) return AVERROR_INVALIDDATA; band_start = ff_ac3_bin_to_band_tab[start]; band_end = ff_ac3_bin_to_band_tab[end-1] + 1; if (band_start == 0) { lowcomp = 0; lowcomp = calc_lowcomp1(lowcomp, band_psd[0], band_psd[1], 384); excite[0] = band_psd[0] - fast_gain - lowcomp; lowcomp = calc_lowcomp1(lowcomp, band_psd[1], band_psd[2], 384); excite[1] = band_psd[1] - fast_gain - lowcomp; begin = 7; for (band = 2; band < 7; band++) { if (!(is_lfe && band == 6)) lowcomp = calc_lowcomp1(lowcomp, band_psd[band], band_psd[band+1], 384); fastleak = band_psd[band] - fast_gain; slowleak = band_psd[band] - s->slow_gain; excite[band] = fastleak - lowcomp; if (!(is_lfe && band == 6)) { if (band_psd[band] <= band_psd[band+1]) { begin = band + 1; break; } } } end1 = FFMIN(band_end, 22); for (band = begin; band < end1; band++) { if (!(is_lfe && band == 6)) lowcomp = calc_lowcomp(lowcomp, band_psd[band], band_psd[band+1], band); fastleak = FFMAX(fastleak - s->fast_decay, band_psd[band] - fast_gain); slowleak = FFMAX(slowleak - s->slow_decay, band_psd[band] - s->slow_gain); excite[band] = FFMAX(fastleak - lowcomp, slowleak); } begin = 22; } else { begin = band_start; fastleak = (s->cpl_fast_leak << 8) + 768; slowleak = (s->cpl_slow_leak << 8) + 768; } for (band = begin; band < band_end; band++) { fastleak = FFMAX(fastleak - s->fast_decay, band_psd[band] - fast_gain); slowleak = FFMAX(slowleak - s->slow_decay, band_psd[band] - s->slow_gain); excite[band] = FFMAX(fastleak, slowleak); } for (band = band_start; band < band_end; band++) { int tmp = s->db_per_bit - band_psd[band]; if (tmp > 0) { excite[band] += tmp >> 2; } mask[band] = FFMAX(ff_ac3_hearing_threshold_tab[band >> s->sr_shift][s->sr_code], excite[band]); } if (dba_mode == DBA_REUSE || dba_mode == DBA_NEW) { int i, seg, delta; if (dba_nsegs > 8) return -1; band = band_start; for (seg = 0; seg < dba_nsegs; seg++) { band += dba_offsets[seg]; if (band >= AC3_CRITICAL_BANDS || dba_lengths[seg] > AC3_CRITICAL_BANDS-band) return -1; if (dba_values[seg] >= 4) { delta = (dba_values[seg] - 3) * 128; } else { delta = (dba_values[seg] - 4) * 128; } for (i = 0; i < dba_lengths[seg]; i++) { mask[band++] += delta; } } } return 0; }<SPLIT>[0.36491818514653585, 1.1257430991522182, 0.0, 0.34210700232091185, 1.0192033751998149, 0.0, 1.8391333925217592, 1.8783232022107403, 1.9009835481817232, 2.3593549488603003, 1.067749137610216, 0.3762494122151511, 1.1845695081947827, 0.0, 0.0, 0.30852482215402843, 0.9714769876430299, 0.35306556693537716, 1.079793664640351, 0.8941073316973973, 2.0030605713555723, 0.0, -0.08645738172306322, -0.16222078614455715, 1.2382117722297952, 2.0362573842548737, 1.0213275968547075, -0.21702784222394986, 2.6724396827682853, 1.8383309169346027, 1.8776273465768223, 1.9001995881092162, 2.3586066116229683, 2.6191065950439585, 0.0, 1.832972902474695, 1.8722343178402097, 1.8946705667433963, 2.352007466638268]
0<SPLIT>static void drawtext(AVFrame *pic, int x, int y, const char *txt) { const uint8_t *font; int font_height; int i; font = avpriv_cga_font, font_height = 8; for (i = 0; txt[i]; i++) { int char_y, mask; uint8_t *p = pic->data[0] + y*pic->linesize[0] + (x + i*8)*4; for (char_y = 0; char_y < font_height; char_y++) { for (mask = 0x80; mask; mask >>= 1) { if (font[txt[i] * font_height + char_y] & mask) AV_WN32(p, ~AV_RN32(p)); p += 4; } p += pic->linesize[0] - 8*4; } } }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, -0.14106852214680915, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, 0.18343000506680518, 0.005287286955244392, -0.21702784222394986, 0.33317037975964214, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 1.7623686513065309, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static inline int RENAME(yuv420_bgr32)(SwsContext *c, const uint8_t *src[], int srcStride[], int srcSliceY, int srcSliceH, uint8_t *dst[], int dstStride[]) { int y, h_size, vshift; YUV2RGB_LOOP(4) YUV2RGB_INITIAL_LOAD YUV2RGB RGB_PACK_INTERLEAVE SET_EMPTY_ALPHA RGB_PACK32(REG_BLUE, REG_GREEN, REG_RED, REG_ALPHA) YUV2RGB_ENDLOOP(4) YUV2RGB_OPERANDS YUV2RGB_ENDFUNC }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static inline void draw_dot(AVFrame *out, int x, int y, uint8_t fg[4]) { uint32_t color = AV_RL32(out->data[0] + y * out->linesize[0] + x * 4); if ((color & 0xffffff) != 0) AV_WL32(out->data[0] + y * out->linesize[0] + x * 4, AV_RL32(fg) | color); else AV_WL32(out->data[0] + y * out->linesize[0] + x * 4, AV_RL32(fg)); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int parse_MP4IODescrTag(MP4DescrParseContext *d, int64_t off, int len) { avio_rb16(&d->pb); avio_r8(&d->pb); avio_r8(&d->pb); avio_r8(&d->pb); avio_r8(&d->pb); avio_r8(&d->pb); update_offsets(&d->pb, &off, &len); return parse_mp4_descr_arr(d, off, len); }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.4705090699407485, -0.3333928163445767, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int av_cold opengl_sdl_load_procedures(OpenGLContext *opengl) { FFOpenGLFunctions *procs = &opengl->glprocs; #define LOAD_OPENGL_FUN(name, type) \ procs->name = (type)SDL_GL_GetProcAddress(#name); \ if (!procs->name) { \ av_log(opengl, AV_LOG_ERROR, "Cannot load OpenGL function: '%s'\n", #name); \ return AVERROR(ENOSYS); \ } LOAD_OPENGL_FUN(glActiveTexture, FF_PFNGLACTIVETEXTUREPROC) LOAD_OPENGL_FUN(glGenBuffers, FF_PFNGLGENBUFFERSPROC) LOAD_OPENGL_FUN(glDeleteBuffers, FF_PFNGLDELETEBUFFERSPROC) LOAD_OPENGL_FUN(glBufferData, FF_PFNGLBUFFERDATAPROC) LOAD_OPENGL_FUN(glBindBuffer, FF_PFNGLBINDBUFFERPROC) LOAD_OPENGL_FUN(glGetAttribLocation, FF_PFNGLGETATTRIBLOCATIONPROC) LOAD_OPENGL_FUN(glGetUniformLocation, FF_PFNGLGETUNIFORMLOCATIONPROC) LOAD_OPENGL_FUN(glUniform1f, FF_PFNGLUNIFORM1FPROC) LOAD_OPENGL_FUN(glUniform1i, FF_PFNGLUNIFORM1IPROC) LOAD_OPENGL_FUN(glUniformMatrix4fv, FF_PFNGLUNIFORMMATRIX4FVPROC) LOAD_OPENGL_FUN(glCreateProgram, FF_PFNGLCREATEPROGRAMPROC) LOAD_OPENGL_FUN(glDeleteProgram, FF_PFNGLDELETEPROGRAMPROC) LOAD_OPENGL_FUN(glUseProgram, FF_PFNGLUSEPROGRAMPROC) LOAD_OPENGL_FUN(glLinkProgram, FF_PFNGLLINKPROGRAMPROC) LOAD_OPENGL_FUN(glGetProgramiv, FF_PFNGLGETPROGRAMIVPROC) LOAD_OPENGL_FUN(glGetProgramInfoLog, FF_PFNGLGETPROGRAMINFOLOGPROC) LOAD_OPENGL_FUN(glAttachShader, FF_PFNGLATTACHSHADERPROC) LOAD_OPENGL_FUN(glCreateShader, FF_PFNGLCREATESHADERPROC) LOAD_OPENGL_FUN(glDeleteShader, FF_PFNGLDELETESHADERPROC) LOAD_OPENGL_FUN(glCompileShader, FF_PFNGLCOMPILESHADERPROC) LOAD_OPENGL_FUN(glShaderSource, FF_PFNGLSHADERSOURCEPROC) LOAD_OPENGL_FUN(glGetShaderiv, FF_PFNGLGETSHADERIVPROC) LOAD_OPENGL_FUN(glGetShaderInfoLog, FF_PFNGLGETSHADERINFOLOGPROC) LOAD_OPENGL_FUN(glEnableVertexAttribArray, FF_PFNGLENABLEVERTEXATTRIBARRAYPROC) LOAD_OPENGL_FUN(glVertexAttribPointer, FF_PFNGLVERTEXATTRIBPOINTERPROC) return 0; #undef LOAD_OPENGL_FUN }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, 0.08293738398848315, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.04154322483324156, -0.26569807294376846, 0.01963846329182043, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, 2.1569430876889752, -0.5183957526995224, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>const char *av_get_media_type_string(enum AVMediaType media_type) { switch (media_type) { case AVMEDIA_TYPE_VIDEO: return "video"; case AVMEDIA_TYPE_AUDIO: return "audio"; case AVMEDIA_TYPE_DATA: return "data"; case AVMEDIA_TYPE_SUBTITLE: return "subtitle"; case AVMEDIA_TYPE_ATTACHMENT: return "attachment"; default: return NULL; } }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.7880534307994381, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.1980344553542678, -0.6720729196443977, 0.6817979554923368, 0.14602883551895066, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, 0.04889276383167627, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static inline void rgb15to16_c(const uint8_t *src, uint8_t *dst, int src_size) { register uint8_t *d = dst; register const uint8_t *s = src; register const uint8_t *end = s + src_size; const uint8_t *mm_end = end - 3; while (s < mm_end) { register unsigned x = *((const uint32_t *)s); *((uint32_t *)d) = (x & 0x7FFF7FFF) + (x & 0x7FE07FE0); d += 4; s += 4; } if (s < end) { register unsigned short x = *((const uint16_t *)s); *((uint16_t *)d) = (x & 0x7FFF) + (x & 0x7FE0); } }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.011671540416283347, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.3070243011888601, -0.10760608081136262, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int ff_dct_quantize_c(MpegEncContext *s, int16_t *block, int n, int qscale, int *overflow) { int i, j, level, last_non_zero, q, start_i; const int *qmat; const uint8_t *scantable= s->intra_scantable.scantable; int bias; int max=0; unsigned int threshold1, threshold2; s->fdsp.fdct(block); if(s->dct_error_sum) s->denoise_dct(s, block); if (s->mb_intra) { if (!s->h263_aic) { if (n < 4) q = s->y_dc_scale; else q = s->c_dc_scale; q = q << 3; } else q = 1 << 3; block[0] = (block[0] + (q >> 1)) / q; start_i = 1; last_non_zero = 0; qmat = n < 4 ? s->q_intra_matrix[qscale] : s->q_chroma_intra_matrix[qscale]; bias= s->intra_quant_bias*(1<<(QMAT_SHIFT - QUANT_BIAS_SHIFT)); } else { start_i = 0; last_non_zero = -1; qmat = s->q_inter_matrix[qscale]; bias= s->inter_quant_bias*(1<<(QMAT_SHIFT - QUANT_BIAS_SHIFT)); } threshold1= (1<<QMAT_SHIFT) - bias - 1; threshold2= (threshold1<<1); for(i=63;i>=start_i;i--) { j = scantable[i]; level = block[j] * qmat[j]; if(((unsigned)(level+threshold1))>threshold2){ last_non_zero = i; break; }else{ block[j]=0; } } for(i=start_i; i<=last_non_zero; i++) { j = scantable[i]; level = block[j] * qmat[j]; if(((unsigned)(level+threshold1))>threshold2){ if(level>0){ level= (bias + level)>>QMAT_SHIFT; block[j]= level; }else{ level= (bias - level)>>QMAT_SHIFT; block[j]= -level; } max |=level; }else{ block[j]=0; } } *overflow= s->max_qcoeff < max; if (s->idsp.perm_type != FF_IDCT_PERM_NONE) block_permute(block, s->idsp.idct_permutation, scantable, last_non_zero); return last_non_zero; } #define OFFSET(x) offsetof(MpegEncContext, x) #define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM static const AVOption h263_options[] = { { "obmc", "use overlapped block motion compensation.", OFFSET(obmc), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 1, VE }, { "structured_slices","Write slice start position at every GOB header instead of just GOB number.", OFFSET(h263_slice_structured), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 1, VE}, { "mb_info", "emit macroblock info for RFC 2190 packetization, the parameter value is the maximum payload size", OFFSET(mb_info), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, INT_MAX, VE }, FF_MPV_COMMON_OPTS { NULL }, }; static const AVClass h263_class = { .class_name = "H.263 encoder", .item_name = av_default_item_name, .option = h263_options, .version = LIBAVUTIL_VERSION_INT, }; AVCodec ff_h263_encoder = { .name = "h263", .long_name = NULL_IF_CONFIG_SMALL("H.263 / H.263-1996"), .type = AVMEDIA_TYPE_VIDEO, .id = AV_CODEC_ID_H263, .priv_data_size = sizeof(MpegEncContext), .init = ff_mpv_encode_init, .encode2 = ff_mpv_encode_picture, .close = ff_mpv_encode_end, .pix_fmts= (const enum AVPixelFormat[]){AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE}, .priv_class = &h263_class, }; static const AVOption h263p_options[] = { { "umv", "Use unlimited motion vectors.", OFFSET(umvplus), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 1, VE }, { "aiv", "Use alternative inter VLC.", OFFSET(alt_inter_vlc), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 1, VE }, { "obmc", "use overlapped block motion compensation.", OFFSET(obmc), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 1, VE }, { "structured_slices", "Write slice start position at every GOB header instead of just GOB number.", OFFSET(h263_slice_structured), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 1, VE}, FF_MPV_COMMON_OPTS { NULL }, }; static const AVClass h263p_class = { .class_name = "H.263p encoder", .item_name = av_default_item_name, .option = h263p_options, .version = LIBAVUTIL_VERSION_INT, }; AVCodec ff_h263p_encoder = { .name = "h263p", .long_name = NULL_IF_CONFIG_SMALL("H.263+ / H.263-1998 / H.263 version 2"), .type = AVMEDIA_TYPE_VIDEO, .id = AV_CODEC_ID_H263P, .priv_data_size = sizeof(MpegEncContext), .init = ff_mpv_encode_init, .encode2 = ff_mpv_encode_picture, .close = ff_mpv_encode_end, .capabilities = AV_CODEC_CAP_SLICE_THREADS, .pix_fmts = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE }, .priv_class = &h263p_class, }; static const AVClass msmpeg4v2_class = { .class_name = "msmpeg4v2 encoder", .item_name = av_default_item_name, .option = ff_mpv_generic_options, .version = LIBAVUTIL_VERSION_INT, }; AVCodec ff_msmpeg4v2_encoder = { .name = "msmpeg4v2", .long_name = NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 2"), .type = AVMEDIA_TYPE_VIDEO, .id = AV_CODEC_ID_MSMPEG4V2, .priv_data_size = sizeof(MpegEncContext), .init = ff_mpv_encode_init, .encode2 = ff_mpv_encode_picture, .close = ff_mpv_encode_end, .pix_fmts = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE }, .priv_class = &msmpeg4v2_class, }; static const AVClass msmpeg4v3_class = { .class_name = "msmpeg4v3 encoder", .item_name = av_default_item_name, .option = ff_mpv_generic_options, .version = LIBAVUTIL_VERSION_INT, }; AVCodec ff_msmpeg4v3_encoder = { .name = "msmpeg4", .long_name = NULL_IF_CONFIG_SMALL("MPEG-4 part 2 Microsoft variant version 3"), .type = AVMEDIA_TYPE_VIDEO, .id = AV_CODEC_ID_MSMPEG4V3, .priv_data_size = sizeof(MpegEncContext), .init = ff_mpv_encode_init, .encode2 = ff_mpv_encode_picture, .close = ff_mpv_encode_end, .pix_fmts = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE }, .priv_class = &msmpeg4v3_class, }; static const AVClass wmv1_class = { .class_name = "wmv1 encoder", .item_name = av_default_item_name, .option = ff_mpv_generic_options, .version = LIBAVUTIL_VERSION_INT, }; AVCodec ff_wmv1_encoder = { .name = "wmv1", .long_name = NULL_IF_CONFIG_SMALL("Windows Media Video 7"), .type = AVMEDIA_TYPE_VIDEO, .id = AV_CODEC_ID_WMV1, .priv_data_size = sizeof(MpegEncContext), .init = ff_mpv_encode_init, .encode2 = ff_mpv_encode_picture, .close = ff_mpv_encode_end, .pix_fmts = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE }, .priv_class = &wmv1_class, };<SPLIT>[0.5195604475230265, 0.8172307919918359, 0.0, 0.4942630637605089, 3.01940799278766, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, 0.380400859743741, 0.8080236581675679, 0.5335543553887203, 0.8654691854237383, 0.0, 0.0, 0.30852482215402843, 2.8119708932040695, 0.5077564769051636, 3.1117578005583684, 1.9292831855416035, 2.0030605713555723, 0.0, -0.08645738172306322, 0.9973611507722091, 1.2382117722297952, 2.0362573842548737, 2.376048010053992, -0.21702784222394986, 1.5495904173241366, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, 0.3801362775450152, 1.7623686513065309, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 0.3766295797615486]
0<SPLIT>static void dump_argument(const char *a) { const unsigned char *p; for (p = a; *p; p++) if (!((*p >= '+' && *p <= ':') || (*p >= '@' && *p <= 'Z') || *p == '_' || (*p >= 'a' && *p <= 'z'))) break; if (!*p) { fputs(a, report_file); return; } fputc('"', report_file); for (p = a; *p; p++) { if (*p == '\\' || *p == '"' || *p == '$' || *p == '`') fprintf(report_file, "\\%c", *p); else if (*p < ' ' || *p > '~') fprintf(report_file, "\\x%02x", *p); else fputc(*p, report_file); } fputc('"', report_file); }<SPLIT>[-0.25365086435942685, -0.17441590959510697, 0.0, -0.2665172434374763, -0.23624420392447085, 0.0, 0.27499425978303293, 0.2876332819158955, 1.2376156019774536, 0.380400859743741, -0.1909204935349246, -0.25297036047912586, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, -0.2490610760448173, -0.26569807294376846, -0.22331377035055117, -0.270465503877335, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, 0.0744401592322129, -0.3333928163445767, -0.21702784222394986, 0.42674115187998785, 0.27459231726984007, 0.28726714485067795, 1.2369948159429325, 0.3801362775450152, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 1.2323429545022004, 0.3766295797615486]
0<SPLIT>static void ffprobe_show_pixel_formats(WriterContext *w) { const AVPixFmtDescriptor *pixdesc = NULL; int i, n; writer_print_section_header(w, SECTION_ID_PIXEL_FORMATS); while (pixdesc = av_pix_fmt_desc_next(pixdesc)) { writer_print_section_header(w, SECTION_ID_PIXEL_FORMAT); print_str("name", pixdesc->name); print_int("nb_components", pixdesc->nb_components); if ((pixdesc->nb_components >= 3) && !(pixdesc->flags & AV_PIX_FMT_FLAG_RGB)) { print_int ("log2_chroma_w", pixdesc->log2_chroma_w); print_int ("log2_chroma_h", pixdesc->log2_chroma_h); } else { print_str_opt("log2_chroma_w", "N/A"); print_str_opt("log2_chroma_h", "N/A"); } n = av_get_bits_per_pixel(pixdesc); if (n) print_int ("bits_per_pixel", n); else print_str_opt("bits_per_pixel", "N/A"); if (do_show_pixel_format_flags) { writer_print_section_header(w, SECTION_ID_PIXEL_FORMAT_FLAGS); PRINT_PIX_FMT_FLAG(BE, "big_endian"); PRINT_PIX_FMT_FLAG(PAL, "palette"); PRINT_PIX_FMT_FLAG(BITSTREAM, "bitstream"); PRINT_PIX_FMT_FLAG(HWACCEL, "hwaccel"); PRINT_PIX_FMT_FLAG(PLANAR, "planar"); PRINT_PIX_FMT_FLAG(RGB, "rgb"); PRINT_PIX_FMT_FLAG(PSEUDOPAL, "pseudopal"); PRINT_PIX_FMT_FLAG(ALPHA, "alpha"); writer_print_section_footer(w); } if (do_show_pixel_format_components && (pixdesc->nb_components > 0)) { writer_print_section_header(w, SECTION_ID_PIXEL_FORMAT_COMPONENTS); for (i = 0; i < pixdesc->nb_components; i++) { writer_print_section_header(w, SECTION_ID_PIXEL_FORMAT_COMPONENT); print_int("index", i + 1); print_int("bit_depth", pixdesc->comp[i].depth); writer_print_section_footer(w); } writer_print_section_footer(w); } writer_print_section_footer(w); } writer_print_section_footer(w); }<SPLIT>[-0.25365086435942685, 0.33242573788266383, 0.0, -0.2665172434374763, 0.25316756420872527, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.268593816248222, -0.25297036047912586, 0.3640258210692401, 0.0, 0.0, 0.30852482215402843, 0.19653218530153962, -0.26569807294376846, 0.28467726362895307, 0.5059163865058198, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.4653044612608955, -0.08904460951967552, 0.4568607580216725, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int parse_block_def(struct sbg_parser *p, struct sbg_script_definition *def) { int r, tseq; lex_space(p); if (!lex_line_end(p)) return AVERROR_INVALIDDATA; tseq = p->nb_block_tseq; while (1) { r = parse_time_sequence(p, 1); if (r < 0) return r; if (!r) break; } if (!lex_char(p, '}'))<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, 0.7102265412631674, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.011671540416283347, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, 0.12893508214950905, 0.11818065472185141, -0.21702784222394986, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, 0.7098813332246741, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, 0.7058592275743352]
0<SPLIT>static int write_picture(AVFormatContext *s, AVPicture *pict) { XVContext *xv = s->priv_data; XvImage *img = xv->yuv_image; uint8_t *data[3] = { img->data + img->offsets[0], img->data + img->offsets[1], img->data + img->offsets[2] }; if (!xv->window_id) { XEvent event; while (XPending(xv->display)) { XNextEvent(xv->display, &event); if (event.type == ClientMessage && event.xclient.data.l[0] == xv->wm_delete_message) { av_log(xv, AV_LOG_DEBUG, "Window close event.\n"); return AVERROR(EPIPE); } } } av_image_copy(data, img->pitches, (const uint8_t **)pict->data, pict->linesize, xv->image_format, img->width, img->height); return xv_repaint(s); }<SPLIT>[-0.09900860198293619, -0.15237931622650824, 0.0, -0.11436118199787926, -0.21496543139694058, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1509627274668249, -0.09566541730555662, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.21031383592774278, -0.11100716297398205, -0.2012272036557901, -0.011671540416283347, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.3070243011888601, -0.10760608081136262, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int main(int argc, char **argv) { char fntemplate[FILENAME_BUF_SIZE]; char pktfilename[FILENAME_BUF_SIZE]; AVFormatContext *fctx = NULL; AVPacket pkt; int64_t pktnum = 0; int64_t maxpkts = 0; int donotquit = 0; int nowrite = 0; int err; if ((argc > 1) && !strncmp(argv[1], "-", 1)) { if (strchr(argv[1], 'w')) donotquit = 1; if (strchr(argv[1], 'n')) nowrite = 1; argv++; argc--; } if (argc < 2) return usage(1); if (argc > 2) maxpkts = atoi(argv[2]); av_strlcpy(fntemplate, argv[1], sizeof(fntemplate)); if (strrchr(argv[1], '/')) av_strlcpy(fntemplate, strrchr(argv[1], '/') + 1, sizeof(fntemplate)); if (strrchr(fntemplate, '.')) *strrchr(fntemplate, '.') = '\0'; if (strchr(fntemplate, '%')) { fprintf(stderr, "cannot use filenames containing '%%'\n"); return usage(1); } if (strlen(fntemplate) + sizeof(PKTFILESUFF) >= sizeof(fntemplate) - 1) { fprintf(stderr, "filename too long\n"); return usage(1); } strcat(fntemplate, PKTFILESUFF); printf("FNTEMPLATE: '%s'\n", fntemplate); av_register_all(); err = avformat_open_input(&fctx, argv[1], NULL, NULL); if (err < 0) { fprintf(stderr, "cannot open input: error %d\n", err); return 1; } err = avformat_find_stream_info(fctx, NULL); if (err < 0) { fprintf(stderr, "avformat_find_stream_info: error %d\n", err); return 1; } av_init_packet(&pkt); while ((err = av_read_frame(fctx, &pkt)) >= 0) { int fd; snprintf(pktfilename, sizeof(pktfilename), fntemplate, pktnum, pkt.stream_index, pkt.pts, pkt.size, (pkt.flags & AV_PKT_FLAG_KEY) ? 'K' : '_'); printf(PKTFILESUFF "\n", pktnum, pkt.stream_index, pkt.pts, pkt.size, (pkt.flags & AV_PKT_FLAG_KEY) ? 'K' : '_'); if (!nowrite) { fd = open(pktfilename, O_WRONLY | O_CREAT, 0644); err = write(fd, pkt.data, pkt.size); if (err < 0) { fprintf(stderr, "write: error %d\n", err); return 1; } close(fd); } av_free_packet(&pkt); pktnum++; if (maxpkts && (pktnum >= maxpkts)) break; } avformat_close_input(&fctx); while (donotquit) av_usleep(60 * 1000000); return 0; }<SPLIT>[-0.09900860198293619, 1.0155601323092245, 0.0, -0.11436118199787926, 0.9128095125621635, 0.0, 1.1439604446378808, 1.1713499043019204, 1.2376156019774536, 1.3698779043020206, 0.9079180733378172, -0.09566541730555662, 1.070605107205124, 0.0, 0.0, 0.30852482215402843, 0.8164880271747319, -0.11100716297398205, 0.9693608311665458, 2.8350620576552843, 1.8934442195827013, 0.0, -0.08645738172306322, -0.16222078614455715, 0.9220224177425181, 1.9817624613375777, 2.376048010053992, -0.21702784222394986, 1.4560196452037908, 1.143335983750264, 1.1708005902540914, 1.2369948159429325, 1.3693714445839917, 0.9056307075691036, 0.0, 1.1388542534712223, 1.1662853116856364, 1.2323429545022004, 1.3643185231999084]
0<SPLIT>static int yv12toyuy2_unscaled_altivec(SwsContext *c, const uint8_t *src[], int srcStride[], int srcSliceY, int srcSliceH, uint8_t *dstParam[], int dstStride_a[]) { uint8_t *dst = dstParam[0] + dstStride_a[0] * srcSliceY; const uint8_t *ysrc = src[0]; const uint8_t *usrc = src[1]; const uint8_t *vsrc = src[2]; const int width = c->srcW; const int height = srcSliceH; const int lumStride = srcStride[0]; const int chromStride = srcStride[1]; const int dstStride = dstStride_a[0]; const vector unsigned char yperm = vec_lvsl(0, ysrc); const int vertLumPerChroma = 2; register unsigned int y; for (y = 0; y < height; y++) { int i; for (i = 0; i < width - 31; i += 32) { const unsigned int j = i >> 1; vector unsigned char v_yA = vec_ld(i, ysrc); vector unsigned char v_yB = vec_ld(i + 16, ysrc); vector unsigned char v_yC = vec_ld(i + 32, ysrc); vector unsigned char v_y1 = vec_perm(v_yA, v_yB, yperm); vector unsigned char v_y2 = vec_perm(v_yB, v_yC, yperm); vector unsigned char v_uA = vec_ld(j, usrc); vector unsigned char v_uB = vec_ld(j + 16, usrc); vector unsigned char v_u = vec_perm(v_uA, v_uB, vec_lvsl(j, usrc)); vector unsigned char v_vA = vec_ld(j, vsrc); vector unsigned char v_vB = vec_ld(j + 16, vsrc); vector unsigned char v_v = vec_perm(v_vA, v_vB, vec_lvsl(j, vsrc)); vector unsigned char v_uv_a = vec_mergeh(v_u, v_v); vector unsigned char v_uv_b = vec_mergel(v_u, v_v); vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a); vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a); vector unsigned char v_yuy2_2 = vec_mergeh(v_y2, v_uv_b); vector unsigned char v_yuy2_3 = vec_mergel(v_y2, v_uv_b); vec_st(v_yuy2_0, (i << 1), dst); vec_st(v_yuy2_1, (i << 1) + 16, dst); vec_st(v_yuy2_2, (i << 1) + 32, dst); vec_st(v_yuy2_3, (i << 1) + 48, dst); } if (i < width) { const unsigned int j = i >> 1; vector unsigned char v_y1 = vec_ld(i, ysrc); vector unsigned char v_u = vec_ld(j, usrc); vector unsigned char v_v = vec_ld(j, vsrc); vector unsigned char v_uv_a = vec_mergeh(v_u, v_v); vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a); vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a); vec_st(v_yuy2_0, (i << 1), dst); vec_st(v_yuy2_1, (i << 1) + 16, dst); } if ((y & (vertLumPerChroma - 1)) == vertLumPerChroma - 1) { usrc += chromStride; vsrc += chromStride; } ysrc += lumStride; dst += dstStride; } return srcSliceH; }<SPLIT>[1.1381294970289892, 0.729084418517441, 0.0, 1.102887309518897, 0.63618546970427, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 0.8080236581675679, 1.1627741280829973, 0.7742976646320114, 0.0, 0.0, 0.30852482215402843, 0.7196199268820456, 1.1265201167843093, 0.6822354641346521, 1.4116952586195004, 0.7972807018539907, 0.0, -0.08645738172306322, -0.16222078614455715, 1.1679474712326225, 0.5648944654878781, 0.7955408613214935, -0.21702784222394986, 0.33317037975964214, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static int decode_write_frame(const char *outfilename, AVCodecContext *avctx, AVFrame *frame, int *frame_count, AVPacket *pkt, int last) { int len, got_frame; char buf[1024]; len = avcodec_decode_video2(avctx, frame, &got_frame, pkt); if (len < 0) { fprintf(stderr, "Error while decoding frame %d\n", *frame_count); return len; } if (got_frame) { printf("Saving %sframe %3d\n", last ? "last " : "", *frame_count); fflush(stdout); snprintf(buf, sizeof(buf), outfilename, *frame_count); pgm_save(frame->data[0], frame->linesize[0], frame->width, frame->height, buf); (*frame_count)++; } if (pkt->data) { pkt->size -= len; pkt->data += len; } return 0; }<SPLIT>[-0.09900860198293619, -0.13034272285790952, 0.0, -0.11436118199787926, -0.1936866588694103, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, -0.13098384443277505, -0.09566541730555662, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.19094021586920554, -0.11100716297398205, -0.17914063696102905, 0.37651940477529405, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, 0.23792492798410134, 0.23107402248845843, -0.21702784222394986, 0.23959960763929639, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static int filter_query_formats(AVFilterContext *ctx) { int ret, i; AVFilterFormats *formats; AVFilterChannelLayouts *chlayouts; AVFilterFormats *samplerates; enum AVMediaType type = ctx->inputs && ctx->inputs [0] ? ctx->inputs [0]->type : ctx->outputs && ctx->outputs[0] ? ctx->outputs[0]->type : AVMEDIA_TYPE_VIDEO; if ((ret = ctx->filter->query_formats(ctx)) < 0) { if (ret != AVERROR(EAGAIN)) av_log(ctx, AV_LOG_ERROR, "Query format failed for '%s': %s\n", ctx->name, av_err2str(ret)); return ret; } for (i = 0; i < ctx->nb_inputs; i++) sanitize_channel_layouts(ctx, ctx->inputs[i]->out_channel_layouts); for (i = 0; i < ctx->nb_outputs; i++) sanitize_channel_layouts(ctx, ctx->outputs[i]->in_channel_layouts); formats = ff_all_formats(type); if (!formats) return AVERROR(ENOMEM); ff_set_common_formats(ctx, formats); if (type == AVMEDIA_TYPE_AUDIO) { samplerates = ff_all_samplerates(); if (!samplerates) return AVERROR(ENOMEM); ff_set_common_samplerates(ctx, samplerates); chlayouts = ff_all_channel_layouts(); if (!chlayouts) return AVERROR(ENOMEM); ff_set_common_channel_layouts(ctx, chlayouts); } return 0; }<SPLIT>[-0.25365086435942685, 0.11205980419667652, 0.0, -0.2665172434374763, 0.04037983893342262, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.06880498590772346, -0.25297036047912586, 0.13609701908992267, 0.0, 0.0, 0.30852482215402843, 0.0027959847161670454, -0.26569807294376846, 0.06381159668134254, 0.7647103499668715, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.11398295627503194, 0.29241985090139744, 0.7955408613214935, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int mxf_compute_ptses_fake_index(MXFContext *mxf, MXFIndexTable *index_table) { int i, j, x; int8_t max_temporal_offset = -128; uint8_t *flags; for (i = 0; i < index_table->nb_segments; i++) { MXFIndexTableSegment *s = index_table->segments[i]; if (!s->nb_index_entries) { index_table->nb_ptses = 0; return 0; } index_table->nb_ptses += s->index_duration; } if (index_table->nb_ptses <= 0) return 0; if (!(index_table->ptses = av_calloc(index_table->nb_ptses, sizeof(int64_t))) || !(index_table->fake_index = av_calloc(index_table->nb_ptses, sizeof(AVIndexEntry))) || !(index_table->offsets = av_calloc(index_table->nb_ptses, sizeof(int8_t))) || !(flags = av_calloc(index_table->nb_ptses, sizeof(uint8_t)))) { av_freep(&index_table->ptses); av_freep(&index_table->fake_index); av_freep(&index_table->offsets); return AVERROR(ENOMEM); } for (x = 0; x < index_table->nb_ptses; x++) index_table->ptses[x] = AV_NOPTS_VALUE; for (i = x = 0; i < index_table->nb_segments; i++) { MXFIndexTableSegment *s = index_table->segments[i]; int index_delta = 1; int n = s->nb_index_entries; if (s->nb_index_entries == 2 * s->index_duration + 1) { index_delta = 2; n--; } for (j = 0; j < n; j += index_delta, x++) { int offset = s->temporal_offset_entries[j] / index_delta; int index = x + offset; if (x >= index_table->nb_ptses) { av_log(mxf->fc, AV_LOG_ERROR, "x >= nb_ptses - IndexEntryCount %i < IndexDuration %"PRId64"?\n", s->nb_index_entries, s->index_duration); break; } flags[x] = !(s->flag_entries[j] & 0x30) ? AVINDEX_KEYFRAME : 0; if (index < 0 || index >= index_table->nb_ptses) { av_log(mxf->fc, AV_LOG_ERROR, "index entry %i + TemporalOffset %i = %i, which is out of bounds\n", x, offset, index); continue; } index_table->offsets[x] = offset; index_table->ptses[index] = x; max_temporal_offset = FFMAX(max_temporal_offset, offset); } } for (x = 0; x < index_table->nb_ptses; x++) { index_table->fake_index[x].timestamp = x; if (index_table->ptses[x] != AV_NOPTS_VALUE) index_table->fake_index[index_table->ptses[x]].flags = flags[x]; } av_freep(&flags); index_table->first_dts = -max_temporal_offset; return 0; }<SPLIT>[4.849543794064766, 0.7511210118860397, 0.0, 4.7546327840692255, 0.6574642422318003, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 1.3074957340188142, 4.938092764248659, 0.7970905448299431, 0.0, 0.0, 0.30852482215402843, 1.203960428345477, 4.839101956059183, 0.7043220308294131, 0.5059163865058198, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.816625966246759, 0.18343000506680518, 0.5697541257882794, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int read_number_result(RTMPPacket *pkt, double *number) { uint8_t strbuffer[8]; int stringlen; double numbuffer; GetByteContext gbc; bytestream2_init(&gbc, pkt->data, pkt->size); if (ff_amf_read_string(&gbc, strbuffer, sizeof(strbuffer), &stringlen)) return AVERROR_INVALIDDATA; if (strcmp(strbuffer, "_result")) return AVERROR_INVALIDDATA; if (ff_amf_read_number(&gbc, &numbuffer)) return AVERROR_INVALIDDATA; if (ff_amf_read_null(&gbc)) return AVERROR_INVALIDDATA; if (ff_amf_read_number(&gbc, &numbuffer)) return AVERROR_INVALIDDATA; else *number = numbuffer; return 0; }<SPLIT>[0.5195604475230265, -0.1964525029637057, 0.0, 0.4942630637605089, -0.2575229764520011, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1110049613987252, 0.5335543553887203, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.17156659581066827, 0.5077564769051636, -0.24540033704531222, 0.11772544131424245, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.08904460951967552, 0.005287286955244392, 0.6817979554923368, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void ff_opencl_unsharp_uninit(AVFilterContext *ctx) { UnsharpContext *unsharp = ctx->priv; av_opencl_buffer_release(&unsharp->opencl_ctx.cl_inbuf); av_opencl_buffer_release(&unsharp->opencl_ctx.cl_outbuf); av_opencl_buffer_release(&unsharp->opencl_ctx.cl_luma_mask); av_opencl_buffer_release(&unsharp->opencl_ctx.cl_chroma_mask); av_opencl_buffer_release(&unsharp->opencl_ctx.cl_luma_mask_x); av_opencl_buffer_release(&unsharp->opencl_ctx.cl_chroma_mask_x); av_opencl_buffer_release(&unsharp->opencl_ctx.cl_luma_mask_y); av_opencl_buffer_release(&unsharp->opencl_ctx.cl_chroma_mask_y); clReleaseKernel(unsharp->opencl_ctx.kernel_default); clReleaseKernel(unsharp->opencl_ctx.kernel_luma); clReleaseKernel(unsharp->opencl_ctx.kernel_chroma); clReleaseProgram(unsharp->opencl_ctx.program); unsharp->opencl_ctx.command_queue = NULL; av_opencl_uninit(); }<SPLIT>[-0.25365086435942685, -0.2625622830695019, 0.0, -0.2665172434374763, -0.3213592940345919, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.270836025671124, -0.25297036047912586, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.3265555562789663, -0.26569807294376846, -0.3116600371295954, -0.270465503877335, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int parse_synth_channel_pink(struct sbg_parser *p, struct sbg_script_synth *synth) { int vol; if (!lex_fixed(p, "pink", 4)) return 0; FORWARD_ERROR(parse_volume(p, &vol)); synth->type = SBG_TYPE_NOISE; synth->vol = vol; return 1; }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.270465503877335, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.14353953243697165, -0.10760608081136262, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_cold int init(AVFilterContext *ctx) { AssContext *ass = ctx->priv; if (!ass->filename) { av_log(ctx, AV_LOG_ERROR, "No filename provided!\n"); return AVERROR(EINVAL); } ass->library = ass_library_init(); if (!ass->library) { av_log(ctx, AV_LOG_ERROR, "Could not initialize libass.\n"); return AVERROR(EINVAL); } ass_set_message_cb(ass->library, ass_log, ctx); ass_set_fonts_dir(ass->library, ass->fontsdir); ass->renderer = ass_renderer_init(ass->library); if (!ass->renderer) { av_log(ctx, AV_LOG_ERROR, "Could not initialize libass renderer.\n"); return AVERROR(EINVAL); } return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void print_md5(uint8_t *md5) { int i; for (i = 0; i < 16; i++) printf("%02x", md5[i]); printf("\n"); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static AVStream *create_stream(AVFormatContext *s, int codec_type) { AVStream *st = avformat_new_stream(s, NULL); if (!st) return NULL; st->codec->codec_type = codec_type; if (s->nb_streams>=3 ||( s->nb_streams==2 && s->streams[0]->codec->codec_type != AVMEDIA_TYPE_SUBTITLE && s->streams[1]->codec->codec_type != AVMEDIA_TYPE_SUBTITLE)) s->ctx_flags &= ~AVFMTCTX_NOHEADER; avpriv_set_pts_info(st, 32, 1, 1000); return st; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>av_always_inline static void denoise_temporal(uint8_t *src, uint8_t *dst, uint16_t *frame_ant, int w, int h, int sstride, int dstride, int16_t *temporal, int depth) { long x, y; uint32_t tmp; temporal += 256 << LUT_BITS; for (y = 0; y < h; y++) { for (x = 0; x < w; x++) { frame_ant[x] = tmp = lowpass(frame_ant[x], LOAD(x), temporal, depth); STORE(x, tmp); } src += sstride; dst += dstride; frame_ant += w; } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int gen_fcpublish_stream(URLContext *s, RTMPContext *rt) { RTMPPacket pkt; uint8_t *p; int ret; if ((ret = ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE, 0, 25 + strlen(rt->playpath))) < 0) return ret; av_log(s, AV_LOG_DEBUG, "FCPublish stream...\n"); p = pkt.data; ff_amf_write_string(&p, "FCPublish"); ff_amf_write_number(&p, ++rt->nb_invokes); ff_amf_write_null(&p); ff_amf_write_string(&p, rt->playpath); return rtmp_send_packet(rt, &pkt, 1); }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, 0.24712242304476825, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.14353953243697165, 0.11818065472185141, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int ff_framesync_init(FFFrameSync *fs, void *parent, unsigned nb_in) { fs->class = &framesync_class; fs->parent = parent; fs->nb_in = nb_in; fs->in = av_calloc(nb_in, sizeof(*fs->in)); if (!fs->in) return AVERROR(ENOMEM); return 0; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int utf8len(const uint8_t *b) { int len = 0; int val; while (*b) { GET_UTF8(val, *b++, return -1;) len++; } return len; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.41601414702345235, -0.3333928163445767, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int asf_read_stream_properties(AVFormatContext *s, const GUIDParseTable *g) { ASFContext *asf = s->priv_data; AVIOContext *pb = s->pb; uint64_t size; uint32_t err_data_len, ts_data_len; uint16_t flags; ff_asf_guid stream_type; enum AVMediaType type; int i, ret; uint8_t stream_index; AVStream *st; ASFStream *asf_st; if (asf->nb_streams >= ASF_MAX_STREAMS) return AVERROR_INVALIDDATA; size = avio_rl64(pb); ff_get_guid(pb, &stream_type); if (!ff_guidcmp(&stream_type, &ff_asf_audio_stream)) type = AVMEDIA_TYPE_AUDIO; else if (!ff_guidcmp(&stream_type, &ff_asf_video_stream)) type = AVMEDIA_TYPE_VIDEO; else if (!ff_guidcmp(&stream_type, &ff_asf_jfif_media)) type = AVMEDIA_TYPE_VIDEO; else if (!ff_guidcmp(&stream_type, &ff_asf_command_stream)) type = AVMEDIA_TYPE_DATA; else if (!ff_guidcmp(&stream_type, &ff_asf_ext_stream_embed_stream_header)) type = AVMEDIA_TYPE_UNKNOWN; else return AVERROR_INVALIDDATA; ff_get_guid(pb, &stream_type); avio_skip(pb, 8); ts_data_len = avio_rl32(pb); err_data_len = avio_rl32(pb); flags = avio_rl16(pb); stream_index = flags & ASF_STREAM_NUM; for (i = 0; i < asf->nb_streams; i++) if (stream_index == asf->asf_st[i]->stream_index) { av_log(s, AV_LOG_WARNING, "Duplicate stream found, this stream will be ignored.\n"); align_position(pb, asf->offset, size); return 0; } st = avformat_new_stream(s, NULL); if (!st) return AVERROR(ENOMEM); avpriv_set_pts_info(st, 32, 1, 1000); st->codec->codec_type = type; asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st)); if (!asf->asf_st[asf->nb_streams]) return AVERROR(ENOMEM); asf_st = asf->asf_st[asf->nb_streams]; asf->nb_streams++; asf_st->stream_index = stream_index; asf_st->index = st->index; asf_st->indexed = 0; st->id = flags & ASF_STREAM_NUM; av_init_packet(&asf_st->pkt.avpkt); asf_st->pkt.data_size = 0; avio_skip(pb, 4); switch (type) { case AVMEDIA_TYPE_AUDIO: asf_st->type = AVMEDIA_TYPE_AUDIO; if ((ret = ff_get_wav_header(s, pb, st->codec, ts_data_len, 0)) < 0) return ret; break; case AVMEDIA_TYPE_VIDEO: asf_st->type = AVMEDIA_TYPE_VIDEO; if ((ret = parse_video_info(pb, st)) < 0) return ret; break; default: avio_skip(pb, ts_data_len); break; } if (err_data_len) { if (type == AVMEDIA_TYPE_AUDIO) { uint8_t span = avio_r8(pb); if (span > 1) { asf_st->span = span; asf_st->virtual_pkt_len = avio_rl16(pb); asf_st->virtual_chunk_len = avio_rl16(pb); if (!asf_st->virtual_chunk_len || !asf_st->virtual_pkt_len) return AVERROR_INVALIDDATA; avio_skip(pb, err_data_len - 5); } else avio_skip(pb, err_data_len - 1); } else avio_skip(pb, err_data_len); } align_position(pb, asf->offset, size); return 0; }<SPLIT>[-0.09900860198293619, 1.3901822195754028, 0.0, -0.11436118199787926, 1.274548645530178, 0.0, 0.44878749675400254, 0.46437660639310047, 0.4084056692221168, 0.380400859743741, 1.2475590849166647, -0.09566541730555662, 1.4580840705699636, 0.0, 0.0, 0.30852482215402843, 1.1458395681698652, -0.11100716297398205, 1.3448324649774837, 1.4116952586195004, 0.6876643500811196, 0.0, -0.08645738172306322, -0.16222078614455715, 1.5544011267170725, 1.2188335404954318, 1.3600077001545285, 2.47944955092491, 0.7074534682410251, 0.4483410505659248, 0.46397383393136066, 0.40798885073507796, 0.3801362775450152, 1.7623686513065309, 0.0, 0.4447356044677496, 0.4603363055310632, 0.4044334392007059, 0.3766295797615486]
0<SPLIT>static void add_renditions_to_variant(HLSContext *c, struct variant *var, enum AVMediaType type, const char *group_id) { int i; for (i = 0; i < c->n_renditions; i++) { struct rendition *rend = c->renditions[i]; if (rend->type == type && !strcmp(rend->group_id, group_id)) { if (rend->playlist) dynarray_add(&var->playlists, &var->n_playlists, rend->playlist); else dynarray_add(&var->playlists[0]->renditions, &var->playlists[0]->n_renditions, rend); } } }<SPLIT>[0.36491818514653585, -0.30663546980669937, 0.0, 0.34210700232091185, -0.36391683908965244, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.2308782596030243, 0.3762494122151511, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, 0.35306556693537716, -0.3558331705191175, -0.14106852214680915, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3070243011888601, 0.005287286955244392, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void mxf_write_multi_descriptor(AVFormatContext *s) { MXFContext *mxf = s->priv_data; AVIOContext *pb = s->pb; const uint8_t *ul; int i; mxf_write_metadata_key(pb, 0x014400); PRINT_KEY(s, "multiple descriptor key", pb->buf_ptr - 16); klv_encode_ber_length(pb, 64 + 16LL * s->nb_streams); mxf_write_local_tag(pb, 16, 0x3C0A); mxf_write_uuid(pb, MultipleDescriptor, 0); PRINT_KEY(s, "multi_desc uid", pb->buf_ptr - 16); mxf_write_local_tag(pb, 8, 0x3001); avio_wb32(pb, mxf->time_base.den); avio_wb32(pb, mxf->time_base.num); mxf_write_local_tag(pb, 16, 0x3004); if (mxf->essence_container_count > 1) ul = multiple_desc_ul; else { MXFStreamContext *sc = s->streams[0]->priv_data; ul = mxf_essence_container_uls[sc->index].container_ul; } avio_write(pb, ul, 16); mxf_write_local_tag(pb, s->nb_streams * 16 + 8, 0x3F01); mxf_write_refs_count(pb, s->nb_streams); for (i = 0; i < s->nb_streams; i++) mxf_write_uuid(pb, SubDescriptor, i); }<SPLIT>[0.21027592277004517, -0.04219634938351458, 0.0, 0.18995094088131478, -0.10857156875928925, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.011110546228475942, 0.21894446904158188, -0.023453142295599506, 0.0, 0.0, 0.30852482215402843, -0.07469849551798198, 0.19837465696559078, -0.09079437018198484, 0.5059163865058198, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.11398295627503194, -0.03454968660237938, 0.34396739025506545, 0.6817979554923368, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int configure_input_filter(FilterGraph *fg, InputFilter *ifilter, AVFilterInOut *in) { if (!ifilter->ist->dec) { av_log(NULL, AV_LOG_ERROR, "No decoder for stream #%d:%d, filtering impossible\n", ifilter->ist->file_index, ifilter->ist->st->index); return AVERROR_DECODER_NOT_FOUND; } switch (avfilter_pad_get_type(in->filter_ctx->input_pads, in->pad_idx)) { case AVMEDIA_TYPE_VIDEO: return configure_input_video_filter(fg, ifilter, in); case AVMEDIA_TYPE_AUDIO: return configure_input_audio_filter(fg, ifilter, in); default: av_assert0(0); } }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.011671540416283347, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.3615192241061562, -0.22049944857796966, -0.21702784222394986, -0.4153957972031237, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_always_inline void spatial_frame_pack(FramepackContext *s, AVFrame *dst) { switch (s->format) { case AV_STEREO3D_SIDEBYSIDE: horizontal_frame_pack(s, dst, 0); break; case AV_STEREO3D_COLUMNS: horizontal_frame_pack(s, dst, 1); break; case AV_STEREO3D_TOPBOTTOM: vertical_frame_pack(s, dst, 0); break; case AV_STEREO3D_LINES: vertical_frame_pack(s, dst, 1); break; } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4129993012037634, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int config_props(AVFilterLink *outlink) { LifeContext *life = outlink->src->priv; outlink->w = life->w; outlink->h = life->h; outlink->time_base = av_inv_q(life->frame_rate); return 0; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int mov_write_ac3_tag(AVIOContext *pb, MOVTrack *track) { GetBitContext gbc; PutBitContext pbc; uint8_t buf[3]; int fscod, bsid, bsmod, acmod, lfeon, frmsizecod; if (track->vos_len < 7) return -1; avio_wb32(pb, 11); ffio_wfourcc(pb, "dac3"); init_get_bits(&gbc, track->vos_data + 4, (track->vos_len - 4) * 8); fscod = get_bits(&gbc, 2); frmsizecod = get_bits(&gbc, 6); bsid = get_bits(&gbc, 5); bsmod = get_bits(&gbc, 3); acmod = get_bits(&gbc, 3); if (acmod == 2) { skip_bits(&gbc, 2); } else { if ((acmod & 1) && acmod != 1) skip_bits(&gbc, 2); if (acmod & 4) skip_bits(&gbc, 2); } lfeon = get_bits1(&gbc); init_put_bits(&pbc, buf, sizeof(buf)); put_bits(&pbc, 2, fscod); put_bits(&pbc, 5, bsid); put_bits(&pbc, 3, bsmod); put_bits(&pbc, 3, acmod); put_bits(&pbc, 1, lfeon); put_bits(&pbc, 5, frmsizecod >> 1); put_bits(&pbc, 5, 0); flush_put_bits(&pbc); avio_write(pb, buf, sizeof(buf)); return 11; }<SPLIT>[-0.25365086435942685, 0.15613299093387398, 0.0, -0.2665172434374763, 0.08293738398848315, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.10876275197582316, -0.25297036047912586, 0.18168277948578615, 0.0, 0.0, 0.30852482215402843, 0.04154322483324156, -0.26569807294376846, 0.10798473007086465, 0.6353133682363457, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2896437087679637, 0.40140969673598975, 1.0213275968547075, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>void ff_write_quant_matrix(PutBitContext *pb, uint16_t *matrix) { int i; if (matrix) { put_bits(pb, 1, 1); for (i = 0; i < 64; i++) { put_bits(pb, 8, matrix[ff_zigzag_direct[i]]); } } else put_bits(pb, 1, 0); }<SPLIT>[-0.25365086435942685, -0.416818436649693, 0.0, -0.2665172434374763, -0.47031070172730377, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.41068820690947294, -0.25297036047912586, -0.4109321056604391, 0.0, 0.0, 0.30852482215402843, -0.46217089668872713, -0.26569807294376846, -0.4662660039929228, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3070243011888601, -0.5591795518777907, 0.6817979554923368, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int process_frame(FFFrameSync *fs) { AVFilterContext *ctx = fs->parent; AVFilterLink *outlink = ctx->outputs[0]; StackContext *s = fs->opaque; AVFrame **in = s->frames; AVFrame *out; int i, p, ret, offset[4] = { 0 }; for (i = 0; i < s->nb_inputs; i++) { if ((ret = ff_framesync_get_frame(&s->fs, i, &in[i], 0)) < 0) return ret; } out = ff_get_video_buffer(outlink, outlink->w, outlink->h); if (!out) return AVERROR(ENOMEM); out->pts = av_rescale_q(s->fs.pts, s->fs.time_base, outlink->time_base); for (i = 0; i < s->nb_inputs; i++) { AVFilterLink *inlink = ctx->inputs[i]; int linesize[4]; int height[4]; if ((ret = av_image_fill_linesizes(linesize, inlink->format, inlink->w)) < 0) { av_frame_free(&out); return ret; } height[1] = height[2] = FF_CEIL_RSHIFT(inlink->h, s->desc->log2_chroma_h); height[0] = height[3] = inlink->h; for (p = 0; p < s->nb_planes; p++) { if (s->is_vertical) { av_image_copy_plane(out->data[p] + offset[p] * out->linesize[p], out->linesize[p], in[i]->data[p], in[i]->linesize[p], linesize[p], height[p]); offset[p] += height[p]; } else { av_image_copy_plane(out->data[p] + offset[p], out->linesize[p], in[i]->data[p], in[i]->linesize[p], linesize[p], height[p]); offset[p] += linesize[p]; } } } return ff_filter_frame(outlink, out); }<SPLIT>[-0.25365086435942685, 0.35446233125126253, 0.0, -0.2665172434374763, 0.2744463367362555, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.2885726992822718, -0.25297036047912586, 0.3868187012671718, 0.0, 0.0, 0.30852482215402843, 0.21590580536007686, -0.26569807294376846, 0.3067638303237141, 0.7647103499668715, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.2896437087679637, 0.12893508214950905, 0.9084342290881006, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void read_ya16be_alpha_c(uint8_t *dst, const uint8_t *src, const uint8_t *unused1, const uint8_t *unused2, int width, uint32_t *unused) { int i; for (i = 0; i < width; i++) AV_WN16(dst + i * 2, AV_RB16(src + i * 4 + 2)); }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void mxf_write_mpegvideo_desc(AVFormatContext *s, AVStream *st) { AVIOContext *pb = s->pb; MXFStreamContext *sc = st->priv_data; int profile_and_level = (st->codec->profile<<4) | st->codec->level; if (st->codec->codec_id != AV_CODEC_ID_H264) { mxf_write_cdci_common(s, st, mxf_mpegvideo_descriptor_key, 8+5); mxf_write_local_tag(pb, 4, 0x8000); avio_wb32(pb, sc->video_bit_rate); mxf_write_local_tag(pb, 1, 0x8007); if (!st->codec->profile) profile_and_level |= 0x80; avio_w8(pb, profile_and_level); } else { mxf_write_cdci_common(s, st, mxf_mpegvideo_descriptor_key, 0); } }<SPLIT>[0.05563366039355449, -0.2845988764381006, 0.0, 0.037794879441717756, -0.34263806656212215, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.25085714263707415, 0.061639525868012635, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, 0.04368374699580437, -0.33374660382435645, -0.14106852214680915, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.25252937827156396, -0.22049944857796966, -0.21702784222394986, -0.22825425296243224, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>void ff_hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth, const uint8_t *src, int srcW, int xInc) { int i; unsigned int xpos = 0; for (i = 0; i < dstWidth; i++) { register unsigned int xx = xpos >> 16; register unsigned int xalpha = (xpos & 0xFFFF) >> 9; dst[i] = (src[xx] << 7) + (src[xx + 1] - src[xx]) * xalpha; xpos += xInc; } for (i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) dst[i] = src[srcW-1]*128; }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.14106852214680915, 0.029966239443893296, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.25252937827156396, -0.3333928163445767, -0.21702784222394986, -0.13468348084208653, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int rm_read_close(AVFormatContext *s) { int i; for (i=0;i<s->nb_streams;i++) ff_rm_free_rmstream(s->streams[i]->priv_data); return 0; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.5250039928580447, -0.5591795518777907, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int avfilter_graph_send_command(AVFilterGraph *graph, const char *target, const char *cmd, const char *arg, char *res, int res_len, int flags) { int i, r = AVERROR(ENOSYS); if (!graph) return r; if ((flags & AVFILTER_CMD_FLAG_ONE) && !(flags & AVFILTER_CMD_FLAG_FAST)) { r = avfilter_graph_send_command(graph, target, cmd, arg, res, res_len, flags | AVFILTER_CMD_FLAG_FAST); if (r != AVERROR(ENOSYS)) return r; } if (res_len && res) res[0] = 0; for (i = 0; i < graph->nb_filters; i++) { AVFilterContext *filter = graph->filters[i]; if (!strcmp(target, "all") || (filter->name && !strcmp(target, filter->name)) || !strcmp(target, filter->filter->name)) { r = avfilter_process_command(filter, cmd, arg, res, res_len, flags); if (r != AVERROR(ENOSYS)) { if ((flags & AVFILTER_CMD_FLAG_ONE) || r < 0) return r; } } } return r; }<SPLIT>[-0.25365086435942685, -0.13034272285790952, 0.0, -0.2665172434374763, -0.1936866588694103, 0.0, 0.27499425978303293, 0.2876332819158955, 0.4084056692221168, 0.7102265412631674, -0.1509627274668249, -0.25297036047912586, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.21031383592774278, -0.26569807294376846, -0.17914063696102905, -0.39986248560786075, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, 0.01994523631491676, -0.22049944857796966, -0.21702784222394986, 0.23959960763929639, 0.27459231726984007, 0.28726714485067795, 0.40798885073507796, 0.7098813332246741, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.4044334392007059, 0.7058592275743352]
0<SPLIT>static inline void yuvPlanartouyvy_c(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst, int width, int height, int lumStride, int chromStride, int dstStride, int vertLumPerChroma) { int y, i; const int chromWidth = width >> 1; for (y = 0; y < height; y++) { #if HAVE_FAST_64BIT uint64_t *ldst = (uint64_t *)dst; const uint8_t *yc = ysrc, *uc = usrc, *vc = vsrc; for (i = 0; i < chromWidth; i += 2) { uint64_t k = uc[0] + (yc[0] << 8) + (vc[0] << 16) + ((unsigned) yc[1] << 24); uint64_t l = uc[1] + (yc[2] << 8) + (vc[1] << 16) + ((unsigned) yc[3] << 24); *ldst++ = k + (l << 32); yc += 4; uc += 2; vc += 2; } #else int *idst = (int32_t *)dst; const uint8_t *yc = ysrc, *uc = usrc, *vc = vsrc; for (i = 0; i < chromWidth; i++) { #if HAVE_BIGENDIAN *idst++ = (uc[0] << 24) + (yc[0] << 16) + (vc[0] << 8) + (yc[1] << 0); #else *idst++ = uc[0] + (yc[0] << 8) + (vc[0] << 16) + (yc[1] << 24); #endif yc += 2; uc++; vc++; } #endif if ((y & (vertLumPerChroma - 1)) == vertLumPerChroma - 1) { usrc += chromStride; vsrc += chromStride; } ysrc += lumStride; dst += dstStride; } }<SPLIT>[-0.25365086435942685, 0.35446233125126253, 0.0, -0.2665172434374763, 0.2744463367362555, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.2885726992822718, -0.25297036047912586, -0.06903890269146298, 0.0, 0.0, 0.30852482215402843, 0.21590580536007686, -0.26569807294376846, -0.13496750357150694, 0.24712242304476825, -0.07965011232897776, 0.0, 1.457000985644429, 3.3165250246057414, 0.2545115582693773, -0.03454968660237938, -0.22049944857796966, -0.21702784222394986, 0.14602883551895066, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static int do_adobe_auth(RTMPContext *rt, const char *user, const char *salt, const char *opaque, const char *challenge) { uint8_t hash[16]; char hashstr[AV_BASE64_SIZE(sizeof(hash))], challenge2[10]; struct AVMD5 *md5 = av_md5_alloc(); if (!md5) return AVERROR(ENOMEM); snprintf(challenge2, sizeof(challenge2), "%08x", av_get_random_seed()); av_md5_init(md5); av_md5_update(md5, user, strlen(user)); av_md5_update(md5, salt, strlen(salt)); av_md5_update(md5, rt->password, strlen(rt->password)); av_md5_final(md5, hash); av_base64_encode(hashstr, sizeof(hashstr), hash, sizeof(hash)); av_md5_init(md5); av_md5_update(md5, hashstr, strlen(hashstr)); if (opaque) av_md5_update(md5, opaque, strlen(opaque)); else if (challenge) av_md5_update(md5, challenge, strlen(challenge)); av_md5_update(md5, challenge2, strlen(challenge2)); av_md5_final(md5, hash); av_base64_encode(hashstr, sizeof(hashstr), hash, sizeof(hash)); snprintf(rt->auth_params, sizeof(rt->auth_params), "?authmod=%s&user=%s&challenge=%s&response=%s", "adobe", user, challenge2, hashstr); if (opaque) av_strlcatf(rt->auth_params, sizeof(rt->auth_params), "&opaque=%s", opaque); av_free(md5); return 0; }<SPLIT>[-0.25365086435942685, 0.11205980419667652, 0.0, -0.2665172434374763, 0.04037983893342262, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.06880498590772346, -0.25297036047912586, 0.13609701908992267, 0.0, 0.0, 0.30852482215402843, 0.0027959847161670454, -0.26569807294376846, 0.06381159668134254, 0.6353133682363457, 0.9068970536268617, 0.0, -0.08645738172306322, -0.16222078614455715, 0.07885080577644558, 0.7828741571570628, 0.9084342290881006, -0.21702784222394986, 0.6138826961206794, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static av_cold int alac_encode_init(AVCodecContext *avctx) { AlacEncodeContext *s = avctx->priv_data; int ret; uint8_t *alac_extradata; avctx->frame_size = s->frame_size = DEFAULT_FRAME_SIZE; if (avctx->sample_fmt == AV_SAMPLE_FMT_S32P) { if (avctx->bits_per_raw_sample != 24) av_log(avctx, AV_LOG_WARNING, "encoding as 24 bits-per-sample\n"); avctx->bits_per_raw_sample = 24; } else { avctx->bits_per_raw_sample = 16; s->extra_bits = 0; } if (avctx->compression_level == FF_COMPRESSION_DEFAULT) s->compression_level = 2; else s->compression_level = av_clip(avctx->compression_level, 0, 2); s->rc.history_mult = 40; s->rc.initial_history = 10; s->rc.k_modifier = 14; s->rc.rice_modifier = 4; s->max_coded_frame_size = get_max_frame_size(avctx->frame_size, avctx->channels, avctx->bits_per_raw_sample); avctx->extradata = av_mallocz(ALAC_EXTRADATA_SIZE + AV_INPUT_BUFFER_PADDING_SIZE); if (!avctx->extradata) { ret = AVERROR(ENOMEM); goto error; } avctx->extradata_size = ALAC_EXTRADATA_SIZE; alac_extradata = avctx->extradata; AV_WB32(alac_extradata, ALAC_EXTRADATA_SIZE); AV_WB32(alac_extradata+4, MKBETAG('a','l','a','c')); AV_WB32(alac_extradata+12, avctx->frame_size); AV_WB8 (alac_extradata+17, avctx->bits_per_raw_sample); AV_WB8 (alac_extradata+21, avctx->channels); AV_WB32(alac_extradata+24, s->max_coded_frame_size); AV_WB32(alac_extradata+28, avctx->sample_rate * avctx->channels * avctx->bits_per_raw_sample); AV_WB32(alac_extradata+32, avctx->sample_rate); if (s->compression_level > 0) { AV_WB8(alac_extradata+18, s->rc.history_mult); AV_WB8(alac_extradata+19, s->rc.initial_history); AV_WB8(alac_extradata+20, s->rc.k_modifier); } s->min_prediction_order = DEFAULT_MIN_PRED_ORDER; if (avctx->min_prediction_order >= 0) { if (avctx->min_prediction_order < MIN_LPC_ORDER || avctx->min_prediction_order > ALAC_MAX_LPC_ORDER) { av_log(avctx, AV_LOG_ERROR, "invalid min prediction order: %d\n", avctx->min_prediction_order); ret = AVERROR(EINVAL); goto error; } s->min_prediction_order = avctx->min_prediction_order; } s->max_prediction_order = DEFAULT_MAX_PRED_ORDER; if (avctx->max_prediction_order >= 0) { if (avctx->max_prediction_order < MIN_LPC_ORDER || avctx->max_prediction_order > ALAC_MAX_LPC_ORDER) { av_log(avctx, AV_LOG_ERROR, "invalid max prediction order: %d\n", avctx->max_prediction_order); ret = AVERROR(EINVAL); goto error; } s->max_prediction_order = avctx->max_prediction_order; } if (s->max_prediction_order < s->min_prediction_order) { av_log(avctx, AV_LOG_ERROR, "invalid prediction orders: min=%d max=%d\n", s->min_prediction_order, s->max_prediction_order); ret = AVERROR(EINVAL); goto error; } s->avctx = avctx; if ((ret = ff_lpc_init(&s->lpc_ctx, avctx->frame_size, s->max_prediction_order, FF_LPC_TYPE_LEVINSON)) < 0) { goto error; } return 0; error: alac_encode_close(avctx); return ret; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, 0.18995094088131478, 1.1255972378374661, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 1.0489714678771789, 0.19837465696559078, 1.1902264981141564, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 1.027418869238277, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int request_frame(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; AudioDelayContext *s = ctx->priv; int ret; ret = ff_request_frame(ctx->inputs[0]); if (ret == AVERROR_EOF && !ctx->is_disabled && s->max_delay) { int nb_samples = FFMIN(s->max_delay, 2048); AVFrame *frame; frame = ff_get_audio_buffer(outlink, nb_samples); if (!frame) return AVERROR(ENOMEM); s->max_delay -= nb_samples; av_samples_set_silence(frame->extended_data, 0, frame->nb_samples, outlink->channels, frame->format); frame->pts = s->next_pts; if (s->next_pts != AV_NOPTS_VALUE) s->next_pts += av_rescale_q(nb_samples, (AVRational){1, outlink->sample_rate}, outlink->time_base); ret = filter_frame(ctx->inputs[0], frame); } return ret; }<SPLIT>[-0.25365086435942685, -0.13034272285790952, 0.0, -0.2665172434374763, -0.1936866588694103, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1509627274668249, -0.25297036047912586, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.21031383592774278, -0.26569807294376846, -0.17914063696102905, 0.24712242304476825, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.20220639821224526, -0.08904460951967552, 0.23107402248845843, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void fill_from_cache(AVFilterContext *ctx, uint32_t *color, int *in_cidx, int *out_cidx, double py, double scale){ MBContext *mb = ctx->priv; if(mb->morphamp) return; for(; *in_cidx < mb->cache_used; (*in_cidx)++){ Point *p= &mb->point_cache[*in_cidx]; int x; if(p->p[1] > py) break; x= round((p->p[0] - mb->start_x) / scale + mb->w/2); if(x<0 || x >= mb->w) continue; if(color) color[x] = p->val; if(out_cidx && *out_cidx < mb->cache_allocated) mb->next_cache[(*out_cidx)++]= *p; } }<SPLIT>[-0.25365086435942685, -0.2845988764381006, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.29081490870517385, -0.25297036047912586, -0.27417482447284863, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.5292594673383866, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.4705090699407485, -0.5591795518777907, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int process_frame(FFFrameSync *fs) { AVFilterContext *ctx = fs->parent; FFDualInputContext *s = fs->opaque; AVFrame *mainpic = NULL, *secondpic = NULL; int ret = 0; if ((ret = ff_framesync_get_frame(&s->fs, 0, &mainpic, 1)) < 0 || (ret = ff_framesync_get_frame(&s->fs, 1, &secondpic, 0)) < 0) { av_frame_free(&mainpic); return ret; } av_assert0(mainpic); mainpic->pts = av_rescale_q(mainpic->pts, s->fs.time_base, ctx->outputs[0]->time_base); if (secondpic && !ctx->is_disabled) mainpic = s->process(ctx, mainpic, secondpic); ret = ff_filter_frame(ctx->outputs[0], mainpic); av_assert1(ret != AVERROR(EAGAIN)); return ret; }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, 0.11772544131424245, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.08904460951967552, 0.11818065472185141, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static struct variant *new_variant(HLSContext *c, struct variant_info *info, const char *url, const char *base) { struct variant *var; struct playlist *pls; pls = new_playlist(c, url, base); if (!pls) return NULL; var = av_mallocz(sizeof(struct variant)); if (!var) return NULL; if (info) { var->bandwidth = atoi(info->bandwidth); strcpy(var->audio_group, info->audio); strcpy(var->video_group, info->video); strcpy(var->subtitles_group, info->subtitles); } dynarray_add(&c->variants, &c->n_variants, var); dynarray_add(&var->playlists, &var->n_playlists, pls); return var; }<SPLIT>[-0.25365086435942685, -0.1964525029637057, 0.0, -0.2665172434374763, -0.2575229764520011, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.21089937656897445, -0.25297036047912586, -0.1830033036811217, 0.0, 0.0, 0.30852482215402843, -0.2684346961033546, -0.26569807294376846, -0.24540033704531222, 0.24712242304476825, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.03454968660237938, 0.34396739025506545, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static const GUIDParseTable *find_guid(ff_asf_guid guid) { int j, ret; const GUIDParseTable *g; swap_guid(guid); g = gdef; for (j = 0; j < FF_ARRAY_ELEMS(gdef); j++) { if (!(ret = memcmp(guid, g->guid, sizeof(g->guid)))) return g; g++; } return NULL; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.14106852214680915, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.3615192241061562, -0.10760608081136262, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int load_font_file(AVFilterContext *ctx, const char *path, int index) { DrawTextContext *s = ctx->priv; int err; err = FT_New_Face(s->library, path, index, &s->face); if (err) { av_log(ctx, AV_LOG_ERROR, "Could not load font \"%s\": %s\n", s->fontfile, FT_ERRMSG(err)); return AVERROR(EINVAL); } return 0; }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.14106852214680915, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.3070243011888601, -0.22049944857796966, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void mxf_write_common_fields(AVFormatContext *s, AVStream *st) { MXFContext *mxf = s->priv_data; AVIOContext *pb = s->pb; mxf_write_local_tag(pb, 16, 0x0201); if (st == mxf->timecode_track) avio_write(pb, smpte_12m_timecode_track_data_ul, 16); else { const MXFCodecUL *data_def_ul = mxf_get_data_definition_ul(st->codec->codec_type); avio_write(pb, data_def_ul->uid, 16); } mxf_write_local_tag(pb, 8, 0x0202); if (st != mxf->timecode_track && s->oformat == &ff_mxf_opatom_muxer && st->codec->codec_type == AVMEDIA_TYPE_AUDIO){ avio_wb64(pb, mxf->body_offset / mxf->edit_unit_byte_count); } else { avio_wb64(pb, mxf->duration); } }<SPLIT>[0.05563366039355449, -0.2625622830695019, 0.0, 0.037794879441717756, -0.3213592940345919, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.2308782596030243, 0.061639525868012635, -0.2513819442749169, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, 0.04368374699580437, -0.3116600371295954, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.25252937827156396, -0.22049944857796966, 0.6817979554923368, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { return ff_set_common_formats(ctx, ff_draw_supported_pixel_formats(0)); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void set_meta(AVDictionary **metadata, int chan, const char *key, const char *fmt, double val) { uint8_t value[128]; uint8_t key2[128]; snprintf(value, sizeof(value), fmt, val); if (chan) snprintf(key2, sizeof(key2), "lavfi.astats.%d.%s", chan, key); else snprintf(key2, sizeof(key2), "lavfi.astats.%s", key); av_dict_set(metadata, key2, value, 0); }<SPLIT>[-0.25365086435942685, -0.3947818432810943, 0.0, -0.2665172434374763, -0.44903192919977347, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3907093238754231, -0.25297036047912586, -0.38813922546250734, 0.0, 0.0, 0.30852482215402843, -0.44279727663018986, -0.26569807294376846, -0.44417943729816173, -0.39986248560786075, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int ff_aac_ac3_parse(AVCodecParserContext *s1, AVCodecContext *avctx, const uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size) { AACAC3ParseContext *s = s1->priv_data; ParseContext *pc = &s->pc; int len, i; int new_frame_start; get_next: i=END_NOT_FOUND; if(s->remaining_size <= buf_size){ if(s->remaining_size && !s->need_next_header){ i= s->remaining_size; s->remaining_size = 0; }else{ len=0; for(i=s->remaining_size; i<buf_size; i++){ s->state = (s->state<<8) + buf[i]; if((len=s->sync(s->state, s, &s->need_next_header, &new_frame_start))) break; } if(len<=0){ i=END_NOT_FOUND; }else{ s->state=0; i-= s->header_size -1; s->remaining_size = len; if(!new_frame_start || pc->index+i<=0){ s->remaining_size += i; goto get_next; } } } } if(ff_combine_frame(pc, i, &buf, &buf_size)<0){ s->remaining_size -= FFMIN(s->remaining_size, buf_size); *poutbuf = NULL; *poutbuf_size = 0; return buf_size; } *poutbuf = buf; *poutbuf_size = buf_size; if(s->codec_id) avctx->codec_id = s->codec_id; if (avctx->codec_id != AV_CODEC_ID_AAC) { avctx->sample_rate = s->sample_rate; #if FF_API_REQUEST_CHANNELS FF_DISABLE_DEPRECATION_WARNINGS if (avctx->request_channels == 1) avctx->request_channel_layout = AV_CH_LAYOUT_MONO; else if (avctx->request_channels == 2) avctx->request_channel_layout = AV_CH_LAYOUT_STEREO; FF_ENABLE_DEPRECATION_WARNINGS #endif if (s->channels > 1 && avctx->request_channel_layout == AV_CH_LAYOUT_MONO) { avctx->channels = 1; avctx->channel_layout = AV_CH_LAYOUT_MONO; } else if (s->channels > 2 && avctx->request_channel_layout == AV_CH_LAYOUT_STEREO) { avctx->channels = 2; avctx->channel_layout = AV_CH_LAYOUT_STEREO; } else { avctx->channels = s->channels; avctx->channel_layout = s->channel_layout; } s1->duration = s->samples; avctx->audio_service_type = s->service_type; } avctx->bit_rate = s->bit_rate; return i; }<SPLIT>[0.6742027098995172, 0.9494503522034282, 0.0, 0.6464191252001059, 0.8489731949795727, 0.0, 1.3177536816088504, 1.3480932287791254, 1.2376156019774536, 1.699703585821447, 0.9478758394059169, 0.6908592985622897, 0.8198834250278749, 0.0, 0.0, 0.30852482215402843, 0.8552352672918063, 0.66244738687495, 0.7264085975241742, 0.11772544131424245, 1.0165134053997327, 0.0, 0.5750247757201478, 0.9973611507722091, 0.6409652137538272, 0.7283792342397666, -0.10760608081136262, 1.5806237532086234, 1.1753073288427536, 1.3170847170463484, 1.3475072793347742, 1.2369948159429325, 1.6991165002636506, 2.6191065950439585, 0.0, 1.3123839157220905, 1.3427725632242797, 1.2323429545022004, 1.693548171012695]
0<SPLIT>static void ff_acelp_interpolatef_mips(float *out, const float *in, const float *filter_coeffs, int precision, int frac_pos, int filter_length, int length) { int n, i; int prec = precision * 4; int fc_offset = precision - frac_pos; float in_val_p, in_val_m, fc_val_p, fc_val_m; for (n = 0; n < length; n++) { const float *p_in_p = &in[n]; const float *p_in_m = &in[n-1]; const float *p_filter_coeffs_p = &filter_coeffs[frac_pos]; const float *p_filter_coeffs_m = filter_coeffs + fc_offset; float v = 0; for (i = 0; i < filter_length;i++) { __asm__ volatile ( "lwc1 %[in_val_p], 0(%[p_in_p]) \n\t" "lwc1 %[fc_val_p], 0(%[p_filter_coeffs_p]) \n\t" "lwc1 %[in_val_m], 0(%[p_in_m]) \n\t" "lwc1 %[fc_val_m], 0(%[p_filter_coeffs_m]) \n\t" PTR_ADDIU "%[p_in_p], %[p_in_p], 4 \n\t" "madd.s %[v],%[v], %[in_val_p],%[fc_val_p] \n\t" PTR_ADDIU "%[p_in_m], %[p_in_m], -4 \n\t" PTR_ADDU "%[p_filter_coeffs_p],%[p_filter_coeffs_p], %[prec] \n\t" PTR_ADDU "%[p_filter_coeffs_m],%[p_filter_coeffs_m], %[prec] \n\t" "madd.s %[v],%[v],%[in_val_m], %[fc_val_m] \n\t" : [v] "+&f" (v),[p_in_p] "+r" (p_in_p), [p_in_m] "+r" (p_in_m), [p_filter_coeffs_p] "+r" (p_filter_coeffs_p), [in_val_p] "=&f" (in_val_p), [in_val_m] "=&f" (in_val_m), [fc_val_p] "=&f" (fc_val_p), [fc_val_m] "=&f" (fc_val_m), [p_filter_coeffs_m] "+r" (p_filter_coeffs_m) : [prec] "r" (prec) : "memory" ); } out[n] = v; } }<SPLIT>[0.36491818514653585, 0.1781695843024727, 0.0, 0.34210700232091185, 0.10421615651601342, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, 0.2086571671460724, 0.3762494122151511, 0.2044756596837179, 0.0, 0.0, 0.30852482215402843, 0.13841132512592785, 0.35306556693537716, 0.1300712967656257, 0.6353133682363457, 0.5780479983082486, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, 0.40140969673598975, 0.6826474935548865, -0.21702784222394986, 0.14602883551895066, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void writer_register_all(void) { static int initialized; if (initialized) return; initialized = 1; writer_register(&default_writer); writer_register(&compact_writer); writer_register(&csv_writer); writer_register(&flat_writer); writer_register(&ini_writer); writer_register(&json_writer); writer_register(&xml_writer); }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void perform_compression(DynamicAudioNormalizerContext *s, AVFrame *frame) { int is_first_frame = cqueue_empty(s->gain_history_original[0]); int c, i; if (s->channels_coupled) { const double standard_deviation = compute_frame_std_dev(s, frame, -1); const double current_threshold = FFMIN(1.0, s->compress_factor * standard_deviation); const double prev_value = is_first_frame ? current_threshold : s->compress_threshold[0]; double prev_actual_thresh, curr_actual_thresh; s->compress_threshold[0] = is_first_frame ? current_threshold : update_value(current_threshold, s->compress_threshold[0], (1.0/3.0)); prev_actual_thresh = setup_compress_thresh(prev_value); curr_actual_thresh = setup_compress_thresh(s->compress_threshold[0]); for (c = 0; c < s->channels; c++) { double *const dst_ptr = (double *)frame->extended_data[c]; for (i = 0; i < frame->nb_samples; i++) { const double localThresh = fade(prev_actual_thresh, curr_actual_thresh, i, s->fade_factors); dst_ptr[i] = copysign(bound(localThresh, fabs(dst_ptr[i])), dst_ptr[i]); } } } else { for (c = 0; c < s->channels; c++) { const double standard_deviation = compute_frame_std_dev(s, frame, c); const double current_threshold = setup_compress_thresh(FFMIN(1.0, s->compress_factor * standard_deviation)); const double prev_value = is_first_frame ? current_threshold : s->compress_threshold[c]; double prev_actual_thresh, curr_actual_thresh; double *dst_ptr; s->compress_threshold[c] = is_first_frame ? current_threshold : update_value(current_threshold, s->compress_threshold[c], 1.0/3.0); prev_actual_thresh = setup_compress_thresh(prev_value); curr_actual_thresh = setup_compress_thresh(s->compress_threshold[c]); dst_ptr = (double *)frame->extended_data[c]; for (i = 0; i < frame->nb_samples; i++) { const double localThresh = fade(prev_actual_thresh, curr_actual_thresh, i, s->fade_factors); dst_ptr[i] = copysign(bound(localThresh, fabs(dst_ptr[i])), dst_ptr[i]); } } } }<SPLIT>[-0.25365086435942685, 0.15613299093387398, 0.0, -0.2665172434374763, 0.08293738398848315, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.10876275197582316, -0.25297036047912586, 0.18168277948578615, 0.0, 0.0, 0.30852482215402843, 0.04154322483324156, -0.26569807294376846, 0.10798473007086465, 1.4116952586195004, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3950401602637228, 0.8373690800743588, 2.1502612745207776, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>int av_audio_fifo_read(AVAudioFifo *af, void **data, int nb_samples) { int i, ret, size; if (nb_samples < 0) return AVERROR(EINVAL); nb_samples = FFMIN(nb_samples, af->nb_samples); if (!nb_samples) return 0; size = nb_samples * af->sample_size; for (i = 0; i < af->nb_buffers; i++) { if ((ret = av_fifo_generic_read(af->buf[i], data[i], size, NULL)) < 0) return AVERROR_BUG; } af->nb_samples -= nb_samples; return nb_samples; }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.270465503877335, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.1980344553542678, -0.10760608081136262, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int mxf_is_partition_pack_key(UID key) { return !memcmp(key, mxf_header_partition_pack_key, 13) && key[13] >= 2 && key[13] <= 4; }<SPLIT>[-0.09900860198293619, -0.5490379968612854, 0.0, -0.11436118199787926, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.09566541730555662, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.11100716297398205, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int pre_estimate_motion_thread(AVCodecContext *c, void *arg){ MpegEncContext *s= *(void**)arg; s->me.pre_pass=1; s->me.dia_size= s->avctx->pre_dia_size; s->first_slice_line=1; for(s->mb_y= s->end_mb_y-1; s->mb_y >= s->start_mb_y; s->mb_y--) { for(s->mb_x=s->mb_width-1; s->mb_x >=0 ;s->mb_x--) { ff_pre_estimate_p_frame_motion(s, s->mb_x, s->mb_y); } s->first_slice_line=0; } s->me.pre_pass=0; return 0; }<SPLIT>[-0.25365086435942685, -0.3507086565438968, 0.0, -0.2665172434374763, -0.406474384144713, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3507515578073234, -0.25297036047912586, -0.34255346506664386, 0.0, 0.0, 0.30852482215402843, -0.4040500365131154, -0.26569807294376846, -0.4000063039086396, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>void ff_decode_10_pulses_35bits(const int16_t *fixed_index, AMRFixed *fixed_sparse, const uint8_t *gray_decode, int half_pulse_count, int bits) { int i; int mask = (1 << bits) - 1; fixed_sparse->no_repeat_mask = 0; fixed_sparse->n = 2 * half_pulse_count; for (i = 0; i < half_pulse_count; i++) { const int pos1 = gray_decode[fixed_index[2*i+1] & mask] + i; const int pos2 = gray_decode[fixed_index[2*i ] & mask] + i; const float sign = (fixed_index[2*i+1] & (1 << bits)) ? -1.0 : 1.0; fixed_sparse->x[2*i+1] = pos1; fixed_sparse->x[2*i ] = pos2; fixed_sparse->y[2*i+1] = sign; fixed_sparse->y[2*i ] = pos2 < pos1 ? -sign : sign; } }<SPLIT>[-0.25365086435942685, -0.24052568970090316, 0.0, -0.2665172434374763, -0.30008052150706166, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.25085714263707415, -0.25297036047912586, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.30718193622042905, -0.26569807294376846, -0.28957347043483433, 0.24712242304476825, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.25252937827156396, -0.22049944857796966, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void mxf_write_generic_sound_common(AVFormatContext *s, AVStream *st, const UID key, unsigned size) { AVIOContext *pb = s->pb; MXFContext *mxf = s->priv_data; int show_warnings = !mxf->footer_partition_offset; int duration_size = 0; if (s->oformat == &ff_mxf_opatom_muxer) duration_size = 12; mxf_write_generic_desc(s, st, key, size+duration_size+5+12+8+8); if (duration_size > 0){ mxf_write_local_tag(pb, 8, 0x3002); avio_wb64(pb, mxf->body_offset / mxf->edit_unit_byte_count); } mxf_write_local_tag(pb, 1, 0x3D02); avio_w8(pb, 1); mxf_write_local_tag(pb, 8, 0x3D03); avio_wb32(pb, st->codec->sample_rate); avio_wb32(pb, 1); mxf_write_local_tag(pb, 4, 0x3D07); if (mxf->channel_count == -1) { if (show_warnings && (s->oformat == &ff_mxf_d10_muxer) && (st->codec->channels != 4) && (st->codec->channels != 8)) av_log(s, AV_LOG_WARNING, "the number of audio channels shall be 4 or 8 : the output will not comply to MXF D-10 specs, use -d10_channelcount to fix this\n"); avio_wb32(pb, st->codec->channels); } else if (s->oformat == &ff_mxf_d10_muxer) { if (show_warnings && (mxf->channel_count < st->codec->channels)) av_log(s, AV_LOG_WARNING, "d10_channelcount < actual number of audio channels : some channels will be discarded\n"); if (show_warnings && (mxf->channel_count != 4) && (mxf->channel_count != 8)) av_log(s, AV_LOG_WARNING, "d10_channelcount shall be set to 4 or 8 : the output will not comply to MXF D-10 specs\n"); avio_wb32(pb, mxf->channel_count); } else { if (show_warnings && mxf->channel_count != -1 && s->oformat != &ff_mxf_opatom_muxer) av_log(s, AV_LOG_ERROR, "-d10_channelcount requires MXF D-10 and will be ignored\n"); avio_wb32(pb, st->codec->channels); } mxf_write_local_tag(pb, 4, 0x3D01); avio_wb32(pb, av_get_bits_per_sample(st->codec->codec_id)); }<SPLIT>[0.05563366039355449, 0.15613299093387398, 0.0, 0.037794879441717756, 0.08293738398848315, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 0.14872051804392286, 0.061639525868012635, 0.18168277948578615, 0.0, 0.0, 0.30852482215402843, 0.08029046495031608, 0.04368374699580437, 0.10798473007086465, 0.37651940477529405, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, 0.11398295627503194, 0.0744401592322129, 0.23107402248845843, -0.21702784222394986, -0.04111270872174079, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.04889276383167627, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static const char *test_get_name(void *ctx) { return "test"; }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.7880534307994381, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.7849662874110047, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void quantize_triangular_ns(DitherContext *c, DitherState *state, int16_t *dst, const float *src, int nb_samples) { int i, j; float *dither = &state->noise_buf[state->noise_buf_ptr]; if (state->mute > c->mute_reset_threshold) memset(state->dither_a, 0, sizeof(state->dither_a)); for (i = 0; i < nb_samples; i++) { float err = 0; float sample = src[i] * S16_SCALE; for (j = 0; j < 4; j++) { err += c->ns_coef_b[j] * state->dither_b[j] - c->ns_coef_a[j] * state->dither_a[j]; } for (j = 3; j > 0; j--) { state->dither_a[j] = state->dither_a[j - 1]; state->dither_b[j] = state->dither_b[j - 1]; } state->dither_a[0] = err; sample -= err; if (state->mute > c->mute_dither_threshold) { dst[i] = av_clip_int16(lrintf(sample)); state->dither_b[0] = 0; } else { dst[i] = av_clip_int16(lrintf(sample + dither[i])); state->dither_b[0] = av_clipf(dst[i] - sample, -1.5f, 1.5f); } state->mute++; if (src[i]) state->mute = 0; } }<SPLIT>[-0.25365086435942685, 0.06798661745947907, 0.0, -0.2665172434374763, -0.0021777061216379156, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, -0.27925050329511203, 0.02884721983962376, -0.25297036047912586, 0.0905112586940592, 0.0, 0.0, 0.30852482215402843, -0.03595125540090747, -0.26569807294376846, 0.01963846329182043, 0.37651940477529405, 0.2491989429896354, 0.0, -0.08645738172306322, -0.16222078614455715, 0.07885080577644558, 0.40140969673598975, 0.23107402248845843, -0.21702784222394986, 0.5203119240003335, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, -0.27935383381430245, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, -0.28182971586402455]
0<SPLIT>static void envelope_peak16(WaveformContext *s, AVFrame *out, int plane, int component) { const int dst_linesize = out->linesize[component] / 2; const int bg = s->bg_color[component] * (s->max / 256); const int limit = s->max - 1; const int is_chroma = (component == 1 || component == 2); const int shift_w = (is_chroma ? s->desc->log2_chroma_w : 0); const int shift_h = (is_chroma ? s->desc->log2_chroma_h : 0); const int dst_h = FF_CEIL_RSHIFT(out->height, shift_h); const int dst_w = FF_CEIL_RSHIFT(out->width, shift_w); const int start = s->estart[plane]; const int end = s->eend[plane]; int *emax = s->emax[plane][component]; int *emin = s->emin[plane][component]; uint16_t *dst; int x, y; if (s->mode) { for (x = 0; x < dst_w; x++) { for (y = start; y < end && y < emin[x]; y++) { dst = (uint16_t *)out->data[component] + y * dst_linesize + x; if (dst[0] != bg) { emin[x] = y; break; } } for (y = end - 1; y >= start && y >= emax[x]; y--) { dst = (uint16_t *)out->data[component] + y * dst_linesize + x; if (dst[0] != bg) { emax[x] = y; break; } } } if (s->envelope == 3) envelope_instant16(s, out, plane, component); for (x = 0; x < dst_w; x++) { dst = (uint16_t *)out->data[component] + emin[x] * dst_linesize + x; dst[0] = limit; dst = (uint16_t *)out->data[component] + emax[x] * dst_linesize + x; dst[0] = limit; } } else { for (y = 0; y < dst_h; y++) { dst = (uint16_t *)out->data[component] + y * dst_linesize; for (x = start; x < end && x < emin[y]; x++) { if (dst[x] != bg) { emin[y] = x; break; } } for (x = end - 1; x >= start && x >= emax[y]; x--) { if (dst[x] != bg) { emax[y] = x; break; } } } if (s->envelope == 3) envelope_instant16(s, out, plane, component); for (y = 0; y < dst_h; y++) { dst = (uint16_t *)out->data[component] + y * dst_linesize + emin[y]; dst[0] = limit; dst = (uint16_t *)out->data[component] + y * dst_linesize + emax[y]; dst[0] = limit; } } }<SPLIT>[-0.25365086435942685, 0.8172307919918359, 0.0, -0.2665172434374763, 0.7213005598143911, 0.0, 1.8391333925217592, 1.8783232022107403, 2.564351494385993, 3.34883199341858, 0.7081292429973187, -0.25297036047912586, 0.8654691854237383, 0.0, 0.0, 0.30852482215402843, 0.6227518265893592, -0.26569807294376846, 0.7705817309136963, 1.0235043134279231, 1.564595164264088, 0.0, -0.08645738172306322, -0.16222078614455715, 1.09768317023545, 2.1997421530067625, 1.0213275968547075, -0.21702784222394986, 2.9531519991293225, 1.8383309169346027, 1.8776273465768223, 2.5634043602755, 3.347841778661945, 2.6191065950439585, 0.0, 1.832972902474695, 1.8722343178402097, 2.556998178984592, 3.339696410076628]
0<SPLIT>static int query_formats(AVFilterContext *ctx) { static const enum AVPixelFormat pix_fmts[] = { AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUVJ440P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUV440P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV411P, AV_PIX_FMT_YUV410P, AV_PIX_FMT_YUVJ411P, AV_PIX_FMT_GRAY8, AV_PIX_FMT_NONE }; AVFilterFormats *fmts_list = ff_make_format_list(pix_fmts); if (!fmts_list) return AVERROR(ENOMEM); return ff_set_common_formats(ctx, fmts_list); }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.14106852214680915, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.3615192241061562, -0.10760608081136262, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int ff_rtsp_open_transport_ctx(AVFormatContext *s, RTSPStream *rtsp_st) { RTSPState *rt = s->priv_data; AVStream *st = NULL; int reordering_queue_size = rt->reordering_queue_size; if (reordering_queue_size < 0) { if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP || !s->max_delay) reordering_queue_size = 0; else reordering_queue_size = RTP_REORDER_QUEUE_DEFAULT_SIZE; } if (rtsp_st->stream_index >= 0) st = s->streams[rtsp_st->stream_index]; if (!st) s->ctx_flags |= AVFMTCTX_NOHEADER; if (CONFIG_RTSP_MUXER && s->oformat && st) { int ret = ff_rtp_chain_mux_open((AVFormatContext **)&rtsp_st->transport_priv, s, st, rtsp_st->rtp_handle, RTSP_TCP_MAX_PACKET_SIZE, rtsp_st->stream_index); rtsp_st->rtp_handle = NULL; if (ret < 0) return ret; st->time_base = ((AVFormatContext*)rtsp_st->transport_priv)->streams[0]->time_base; } else if (rt->transport == RTSP_TRANSPORT_RAW) { return 0; } else if (CONFIG_RTPDEC && rt->transport == RTSP_TRANSPORT_RDT && st) rtsp_st->transport_priv = ff_rdt_parse_open(s, st->index, rtsp_st->dynamic_protocol_context, rtsp_st->dynamic_handler); else if (CONFIG_RTPDEC) rtsp_st->transport_priv = ff_rtp_parse_open(s, st, rtsp_st->sdp_payload_type, reordering_queue_size); if (!rtsp_st->transport_priv) { return AVERROR(ENOMEM); } else if (CONFIG_RTPDEC && rt->transport == RTSP_TRANSPORT_RTP) { if (rtsp_st->dynamic_handler) { ff_rtp_parse_set_dynamic_protocol(rtsp_st->transport_priv, rtsp_st->dynamic_protocol_context, rtsp_st->dynamic_handler); } if (rtsp_st->crypto_suite[0]) ff_rtp_parse_set_crypto(rtsp_st->transport_priv, rtsp_st->crypto_suite, rtsp_st->crypto_params); } return 0; }<SPLIT>[0.05563366039355449, 0.42057211135705874, 0.0, 0.037794879441717756, 0.33828265431884635, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, 0.7102265412631674, 0.3884671144525211, 0.061639525868012635, 0.45519734186096705, 0.0, 0.0, 0.30852482215402843, 0.31277390565276314, 0.04368374699580437, 0.3730235304079973, 0.11772544131424245, 0.35881529476250645, 0.0, -0.08645738172306322, -0.16222078614455715, -0.06167779621789984, 0.3469147738186936, 0.11818065472185141, 0.6817979554923368, 0.42674115187998785, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, 0.7098813332246741, 0.9056307075691036, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, 0.7058592275743352]
1<SPLIT>static uint8_t *advance_line(uint8_t *start, uint8_t *line, int stride, int *y, int h, int interleave) { *y += interleave; if (*y < h) { return line + interleave * stride; } else { *y = (*y + 1) & (interleave - 1); if (*y) { return start + *y * stride; } else { return NULL; } } }<SPLIT>[-0.09900860198293619, -0.32867206317529807, 0.0, -0.11436118199787926, -0.3851956116171827, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.3107937917392237, -0.09566541730555662, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.11100716297398205, -0.37791973721387856, -0.7880534307994381, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5183957526995224, -0.4705090699407485, -0.7849662874110047, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>void ff_channel_layouts_unref(AVFilterChannelLayouts **ref) { FORMATS_UNREF(ref, channel_layouts); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int rm_assemble_video_frame(AVFormatContext *s, AVIOContext *pb, RMDemuxContext *rm, RMStream *vst, AVPacket *pkt, int len, int *pseq, int64_t *timestamp) { int hdr; int seq = 0, pic_num = 0, len2 = 0, pos = 0; int type; int ret; hdr = avio_r8(pb); len--; type = hdr >> 6; if(type != 3){ seq = avio_r8(pb); len--; } if(type != 1){ len2 = get_num(pb, &len); pos = get_num(pb, &len); pic_num = avio_r8(pb); len--; } if(len<0) { av_log(s, AV_LOG_ERROR, "Insufficient data\n"); return -1; } rm->remaining_len = len; if(type&1){ if(type == 3){ len= len2; *timestamp = pos; } if(rm->remaining_len < len) { av_log(s, AV_LOG_ERROR, "Insufficient remaining len\n"); return -1; } rm->remaining_len -= len; if(av_new_packet(pkt, len + 9) < 0) return AVERROR(EIO); pkt->data[0] = 0; AV_WL32(pkt->data + 1, 1); AV_WL32(pkt->data + 5, 0); if ((ret = avio_read(pb, pkt->data + 9, len)) != len) { av_free_packet(pkt); av_log(s, AV_LOG_ERROR, "Failed to read %d bytes\n", len); return ret < 0 ? ret : AVERROR(EIO); } return 0; } *pseq = seq; if((seq & 0x7F) == 1 || vst->curpic_num != pic_num){ if (len2 > ffio_limit(pb, len2)) { av_log(s, AV_LOG_ERROR, "Impossibly sized packet\n"); return AVERROR_INVALIDDATA; } vst->slices = ((hdr & 0x3F) << 1) + 1; vst->videobufsize = len2 + 8*vst->slices + 1; av_free_packet(&vst->pkt); if(av_new_packet(&vst->pkt, vst->videobufsize) < 0) return AVERROR(ENOMEM); memset(vst->pkt.data, 0, vst->pkt.size); vst->videobufpos = 8*vst->slices + 1; vst->cur_slice = 0; vst->curpic_num = pic_num; vst->pktpos = avio_tell(pb); } if(type == 2) len = FFMIN(len, pos); if(++vst->cur_slice > vst->slices) { av_log(s, AV_LOG_ERROR, "cur slice %d, too large\n", vst->cur_slice); return 1; } if(!vst->pkt.data) return AVERROR(ENOMEM); AV_WL32(vst->pkt.data - 7 + 8*vst->cur_slice, 1); AV_WL32(vst->pkt.data - 3 + 8*vst->cur_slice, vst->videobufpos - 8*vst->slices - 1); if(vst->videobufpos + len > vst->videobufsize) { av_log(s, AV_LOG_ERROR, "outside videobufsize\n"); return 1; } if (avio_read(pb, vst->pkt.data + vst->videobufpos, len) != len) return AVERROR(EIO); vst->videobufpos += len; rm->remaining_len-= len; if (type == 2 || vst->videobufpos == vst->videobufsize) { vst->pkt.data[0] = vst->cur_slice-1; *pkt= vst->pkt; vst->pkt.data= NULL; vst->pkt.size= 0; vst->pkt.buf = NULL; #if FF_API_DESTRUCT_PACKET FF_DISABLE_DEPRECATION_WARNINGS vst->pkt.destruct = NULL; FF_ENABLE_DEPRECATION_WARNINGS #endif if(vst->slices != vst->cur_slice) memmove(pkt->data + 1 + 8*vst->cur_slice, pkt->data + 1 + 8*vst->slices, vst->videobufpos - 1 - 8*vst->slices); pkt->size = vst->videobufpos + 8*(vst->cur_slice - vst->slices); pkt->pts = AV_NOPTS_VALUE; pkt->pos = vst->pktpos; vst->slices = 0; return 0; } return 1; }<SPLIT>[-0.09900860198293619, 1.6105481532613901, 0.0, -0.11436118199787926, 1.4873363708054808, 0.0, 1.8391333925217592, 1.8783232022107403, 1.7351415616306558, 1.699703585821447, 1.447347915257163, -0.09566541730555662, 1.5720484715596224, 0.0, 0.0, 0.30852482215402843, 1.3395757687552379, -0.11100716297398205, 1.455265298451289, 1.799886203811078, 1.8934442195827013, 0.0, 0.24428369699854227, 0.9973611507722091, 1.5895332772156587, 1.8727726155029853, 1.4729010679211356, -0.21702784222394986, 2.0174442779258652, 1.8383309169346027, 1.8776273465768223, 1.7343983950676451, 1.6991165002636506, 0.9056307075691036, 0.0, 1.832972902474695, 1.8722343178402097, 1.7290886636830973, 1.693548171012695]
0<SPLIT>static int request_frame(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; MixContext *s = ctx->priv; int ret; int wanted_samples, available_samples; ret = calc_active_inputs(s); if (ret < 0) return ret; if (s->input_state[0] == INPUT_OFF) { ret = request_samples(ctx, 1); if (ret < 0) return ret; ret = calc_active_inputs(s); if (ret < 0) return ret; available_samples = get_available_samples(s); if (!available_samples) return AVERROR(EAGAIN); return output_frame(outlink, available_samples); } if (s->frame_list->nb_frames == 0) { ret = ff_request_frame(ctx->inputs[0]); if (ret == AVERROR_EOF) { s->input_state[0] = INPUT_OFF; if (s->nb_inputs == 1) return AVERROR_EOF; else return AVERROR(EAGAIN); } else if (ret < 0) return ret; } av_assert0(s->frame_list->nb_frames > 0); wanted_samples = frame_list_next_frame_size(s->frame_list); if (s->active_inputs > 1) { ret = request_samples(ctx, wanted_samples); if (ret < 0) return ret; ret = calc_active_inputs(s); if (ret < 0) return ret; } if (s->active_inputs > 1) { available_samples = get_available_samples(s); if (!available_samples) return AVERROR(EAGAIN); available_samples = FFMIN(available_samples, wanted_samples); } else { available_samples = wanted_samples; } s->next_pts = frame_list_next_pts(s->frame_list); frame_list_remove_samples(s->frame_list, available_samples); return output_frame(outlink, available_samples); }<SPLIT>[-0.25365086435942685, 0.5307550782000524, 0.0, -0.2665172434374763, 0.4446765169564977, 0.0, 1.49154691857982, 1.5248365532563304, 1.403457588528521, 3.0190063118991532, 0.44840376355467065, -0.25297036047912586, 0.5691617428506257, 0.0, 0.0, 0.30852482215402843, 0.37089476582837494, -0.26569807294376846, 0.4834563638818026, 0.8941073316973973, 1.2357461089454749, 0.0, -0.08645738172306322, -0.16222078614455715, 0.3950401602637228, 1.1098436946608394, 0.7955408613214935, -0.21702784222394986, 1.2688781009630994, 1.4908334503424332, 1.524213968415457, 1.4027960089845035, 3.018096722982286, 0.9056307075691036, 0.0, 1.4859135779729586, 1.519259814762923, 1.3979248575624994, 3.0104667622638415]
0<SPLIT>static int ac3_sync(uint64_t state, AACAC3ParseContext *hdr_info, int *need_next_header, int *new_frame_start) { int err; union { uint64_t u64; uint8_t u8[8 + AV_INPUT_BUFFER_PADDING_SIZE]; } tmp = { av_be2ne64(state) }; AC3HeaderInfo hdr, *phdr = &hdr; GetBitContext gbc; init_get_bits(&gbc, tmp.u8+8-AC3_HEADER_SIZE, 54); err = avpriv_ac3_parse_header2(&gbc, &phdr); if(err < 0) return 0; hdr_info->sample_rate = hdr.sample_rate; hdr_info->bit_rate = hdr.bit_rate; hdr_info->channels = hdr.channels; hdr_info->channel_layout = hdr.channel_layout; hdr_info->samples = hdr.num_blocks * 256; hdr_info->service_type = hdr.bitstream_mode; if (hdr.bitstream_mode == 0x7 && hdr.channels > 1) hdr_info->service_type = AV_AUDIO_SERVICE_TYPE_KARAOKE; if(hdr.bitstream_id>10) hdr_info->codec_id = AV_CODEC_ID_EAC3; else if (hdr_info->codec_id == AV_CODEC_ID_NONE) hdr_info->codec_id = AV_CODEC_ID_AC3; *need_next_header = (hdr.frame_type != EAC3_FRAME_TYPE_AC3_CONVERT); *new_frame_start = (hdr.frame_type != EAC3_FRAME_TYPE_DEPENDENT); return hdr.frame_size; } static av_cold int ac3_parse_init(AVCodecParserContext *s1) { AACAC3ParseContext *s = s1->priv_data; s->header_size = AC3_HEADER_SIZE; s->sync = ac3_sync; return 0; } AVCodecParser ff_ac3_parser = { .codec_ids = { AV_CODEC_ID_AC3, AV_CODEC_ID_EAC3 }, .priv_data_size = sizeof(AACAC3ParseContext), .parser_init = ac3_parse_init, .parser_parse = ff_aac_ac3_parse, .parser_close = ff_parse_close, };<SPLIT>[-0.25365086435942685, 0.0018768373536828752, 0.0, -0.2665172434374763, 0.231888791681195, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.031089429262525795, -0.25297036047912586, 0.022132618100263974, 0.0, 0.0, 0.30852482215402843, 0.17715856524300236, -0.26569807294376846, 0.262590696934192, 0.37651940477529405, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.21937940777079099, -0.08904460951967552, 0.23107402248845843, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static inline double get_dither_value(VignetteContext *s) { double dv = 0; if (s->do_dither) { dv = s->dither / (double)(1LL<<32); s->dither = s->dither * 1664525 + 1013904223; } return dv; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.6586564490689124, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5250039928580447, -0.6720729196443977, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static LayeredAVStream *add_av_stream1(FFServerStream *stream, AVCodecContext *codec, int copy) { LayeredAVStream *fst; if(stream->nb_streams >= FF_ARRAY_ELEMS(stream->streams)) return NULL; fst = av_mallocz(sizeof(*fst)); if (!fst) return NULL; if (copy) { fst->codec = avcodec_alloc_context3(codec->codec); if (!fst->codec) { av_free(fst); return NULL; } avcodec_copy_context(fst->codec, codec); } else fst->codec = codec; fst->codecpar = avcodec_parameters_alloc(); fst->index = stream->nb_streams; fst->time_base = codec->time_base; fst->pts_wrap_bits = 33; fst->sample_aspect_ratio = codec->sample_aspect_ratio; stream->streams[stream->nb_streams++] = fst; return fst; }<SPLIT>[0.36491818514653585, -0.08626953612071205, 0.0, 0.34210700232091185, -0.15112911381434976, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.031089429262525795, 0.3762494122151511, -0.06903890269146298, 0.0, 0.0, 0.30852482215402843, -0.09407211557651925, 0.35306556693537716, -0.13496750357150694, -0.011671540416283347, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.13194209721507255, -0.1980344553542678, -0.10760608081136262, 0.6817979554923368, -0.321825025082778, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { ReplayGainContext *s = ctx->priv; float gain = calc_replaygain(s->histogram); av_log(ctx, AV_LOG_INFO, "track_gain = %+.2f dB\n", gain); av_log(ctx, AV_LOG_INFO, "track_peak = %.6f\n", s->peak); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { DecimateContext *decimate = ctx->priv; av_frame_free(&decimate->ref); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static av_cold int opengl_compile_shaders(OpenGLContext *opengl, enum AVPixelFormat pix_fmt) { GLint result; const char *fragment_shader_code = opengl_get_fragment_shader_code(pix_fmt); if (!fragment_shader_code) { av_log(opengl, AV_LOG_ERROR, "Provided pixel format '%s' is not supported\n", av_get_pix_fmt_name(pix_fmt)); return AVERROR(EINVAL); } opengl->vertex_shader = opengl_load_shader(opengl, FF_GL_VERTEX_SHADER, FF_OPENGL_VERTEX_SHADER); if (!opengl->vertex_shader) { av_log(opengl, AV_LOG_ERROR, "Vertex shader loading failed.\n"); goto fail; } opengl->fragment_shader = opengl_load_shader(opengl, FF_GL_FRAGMENT_SHADER, fragment_shader_code); if (!opengl->fragment_shader) { av_log(opengl, AV_LOG_ERROR, "Fragment shader loading failed.\n"); goto fail; } opengl->program = opengl->glprocs.glCreateProgram(); if (!opengl->program) goto fail; opengl->glprocs.glAttachShader(opengl->program, opengl->vertex_shader); opengl->glprocs.glAttachShader(opengl->program, opengl->fragment_shader); opengl->glprocs.glLinkProgram(opengl->program); opengl->glprocs.glGetProgramiv(opengl->program, FF_GL_LINK_STATUS, &result); if (!result) { char *log; opengl->glprocs.glGetProgramiv(opengl->program, FF_GL_INFO_LOG_LENGTH, &result); if (result) { log = av_malloc(result); if (!log) goto fail; opengl->glprocs.glGetProgramInfoLog(opengl->program, result, NULL, log); av_log(opengl, AV_LOG_ERROR, "Link error: %s\n", log); av_free(log); } goto fail; } opengl->position_attrib = opengl->glprocs.glGetAttribLocation(opengl->program, "a_position"); opengl->texture_coords_attrib = opengl->glprocs.glGetAttribLocation(opengl->program, "a_textureCoords"); opengl->projection_matrix_location = opengl->glprocs.glGetUniformLocation(opengl->program, "u_projectionMatrix"); opengl->model_view_matrix_location = opengl->glprocs.glGetUniformLocation(opengl->program, "u_modelViewMatrix"); opengl->color_map_location = opengl->glprocs.glGetUniformLocation(opengl->program, "u_colorMap"); opengl->texture_location[0] = opengl->glprocs.glGetUniformLocation(opengl->program, "u_texture0"); opengl->texture_location[1] = opengl->glprocs.glGetUniformLocation(opengl->program, "u_texture1"); opengl->texture_location[2] = opengl->glprocs.glGetUniformLocation(opengl->program, "u_texture2"); opengl->texture_location[3] = opengl->glprocs.glGetUniformLocation(opengl->program, "u_texture3"); opengl->chroma_div_w_location = opengl->glprocs.glGetUniformLocation(opengl->program, "u_chroma_div_w"); opengl->chroma_div_h_location = opengl->glprocs.glGetUniformLocation(opengl->program, "u_chroma_div_h"); OPENGL_ERROR_CHECK(opengl); return 0; fail: opengl->glprocs.glDeleteShader(opengl->vertex_shader); opengl->glprocs.glDeleteShader(opengl->fragment_shader); opengl->glprocs.glDeleteProgram(opengl->program); opengl->fragment_shader = opengl->vertex_shader = opengl->program = 0; return AVERROR_EXTERNAL; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, 0.5936279246492095, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.5065101062381357, -0.26569807294376846, 0.63806233074513, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.7814938157481727, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>uint64_t av_get_channel_layout(const char *name) { return ff_get_channel_layout(name, 1); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>long WINAPI libAVPin_QueryPinInfo(libAVPin *this, PIN_INFO *info) { dshowdebug("libAVPin_QueryPinInfo(%p)\n", this); if (!info) return E_POINTER; if (this->filter) libAVFilter_AddRef(this->filter); info->pFilter = (IBaseFilter *) this->filter; info->dir = PINDIR_INPUT; wcscpy(info->achName, L"Capture"); return S_OK; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void row_fdct_c(int16_t *data, const uint8_t *pixels, ptrdiff_t line_size, int cnt) { int_simd16_t tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7; int_simd16_t tmp10, tmp11, tmp12, tmp13; int_simd16_t z1, z2, z3, z4, z5, z11, z13; int16_t *dataptr; cnt *= 4; dataptr = data; for (; cnt > 0; cnt--) { tmp0 = pixels[line_size * 0] + pixels[line_size * 7]; tmp7 = pixels[line_size * 0] - pixels[line_size * 7]; tmp1 = pixels[line_size * 1] + pixels[line_size * 6]; tmp6 = pixels[line_size * 1] - pixels[line_size * 6]; tmp2 = pixels[line_size * 2] + pixels[line_size * 5]; tmp5 = pixels[line_size * 2] - pixels[line_size * 5]; tmp3 = pixels[line_size * 3] + pixels[line_size * 4]; tmp4 = pixels[line_size * 3] - pixels[line_size * 4]; tmp10 = tmp0 + tmp3; tmp13 = tmp0 - tmp3; tmp11 = tmp1 + tmp2; tmp12 = tmp1 - tmp2; dataptr[2] = tmp10 + tmp11; dataptr[3] = tmp10 - tmp11; z1 = MULTIPLY16H((tmp12 + tmp13) << 2, FIX_0_707106781); dataptr[0] = tmp13 + z1; dataptr[1] = tmp13 - z1; tmp10 = (tmp4 + tmp5) << 2; tmp11 = (tmp5 + tmp6) << 2; tmp12 = (tmp6 + tmp7) << 2; z5 = MULTIPLY16H(tmp10 - tmp12, FIX_0_382683433); z2 = MULTIPLY16H(tmp10, FIX_0_541196100) + z5; z4 = MULTIPLY16H(tmp12, FIX_1_306562965) + z5; z3 = MULTIPLY16H(tmp11, FIX_0_707106781); z11 = tmp7 + z3; z13 = tmp7 - z3; dataptr[4] = z13 + z2; dataptr[5] = z13 - z2; dataptr[6] = z11 + z4; dataptr[7] = z11 - z4; pixels++; dataptr += DCTSIZE; } }<SPLIT>[0.6742027098995172, 0.2883525511454664, 0.0, 0.6464191252001059, 0.21061001915366473, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, 0.3485093483844214, 0.6908592985622897, 0.3184400606733766, 0.0, 0.0, 0.30852482215402843, 0.27402666553568866, 0.66244738687495, 0.24050413023943099, -0.6586564490689124, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, 0.7112295147509999, -0.41601414702345235, -0.6720729196443977, 0.6817979554923368, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void show_opts(const AVOption *opts, int per_stream) { const AVOption *o; printf("@table @option\n"); for (o = opts; o->name; o++) { if (o->type != AV_OPT_TYPE_CONST) print_option(opts, o, per_stream); } printf("@end table\n"); }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.41601414702345235, -0.4462861841111837, -0.21702784222394986, -0.321825025082778, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int process_command(AVFilterContext *ctx, const char *cmd, const char *args, char *res, int res_len, int flags) { HueContext *hue = ctx->priv; int ret; #define SET_EXPR(expr, option) \ do { \ ret = set_expr(&hue->expr##_pexpr, &hue->expr##_expr, \ args, option, ctx); \ if (ret < 0) \ return ret; \ } while (0) if (!strcmp(cmd, "h")) { SET_EXPR(hue_deg, "h"); av_freep(&hue->hue_expr); } else if (!strcmp(cmd, "H")) { SET_EXPR(hue, "H"); av_freep(&hue->hue_deg_expr); } else if (!strcmp(cmd, "s")) { SET_EXPR(saturation, "s"); } else if (!strcmp(cmd, "b")) { SET_EXPR(brightness, "b"); } else return AVERROR(ENOSYS); return 0; }<SPLIT>[-0.25365086435942685, -0.08626953612071205, 0.0, -0.2665172434374763, -0.15112911381434976, 0.0, 1.6653401555507896, 1.7015798777335354, 1.5692995750795884, 3.6786576749380067, -0.1110049613987252, -0.25297036047912586, -0.09183178288939473, 0.0, 0.0, 0.30852482215402843, -0.17156659581066827, -0.26569807294376846, -0.157054070266268, -0.14106852214680915, 0.2491989429896354, 0.0, -0.08645738172306322, 0.417570182313826, -0.27247069920941797, 0.5648944654878781, -0.22049944857796966, 0.6817979554923368, 1.081736556722408, 1.664582183638518, 1.7009206574961395, 1.5685972020260743, 3.6775868343416036, 1.7623686513065309, 0.0, 1.6594432402238268, 1.6957470663015664, 1.5635067606227984, 3.6689260578894145]
0<SPLIT>static int64_t int_pow(int64_t a, int p) { int64_t v = FIXP; for (; p; p--) { v *= a; v /= FIXP; } return v; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.7880534307994381, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5250039928580447, -0.7849662874110047, 0.6817979554923368, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static void put_str(AVIOContext *bc, const char *string) { size_t len = strlen(string); ff_put_v(bc, len); avio_write(bc, string, len); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.39986248560786075, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.4705090699407485, -0.3333928163445767, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int filter_frame(AVFilterLink *inlink, AVFrame *in) { AVFilterContext *ctx = inlink->dst; DCTdnoizContext *s = ctx->priv; AVFilterLink *outlink = inlink->dst->outputs[0]; int direct, plane; AVFrame *out; if (av_frame_is_writable(in)) { direct = 1; out = in; } else { direct = 0; out = ff_get_video_buffer(outlink, outlink->w, outlink->h); if (!out) { av_frame_free(&in); return AVERROR(ENOMEM); } av_frame_copy_props(out, in); } s->color_decorrelation(s->cbuf[0], s->p_linesize, in->data[0], in->linesize[0], s->pr_width, s->pr_height); for (plane = 0; plane < 3; plane++) { ThreadData td = { .src = s->cbuf[0][plane], .dst = s->cbuf[1][plane], }; ctx->internal->execute(ctx, filter_slice, &td, NULL, s->nb_threads); } s->color_correlation(out->data[0], out->linesize[0], s->cbuf[1], s->p_linesize, s->pr_width, s->pr_height); if (!direct) { int y; uint8_t *dst = out->data[0]; const uint8_t *src = in->data[0]; const int dst_linesize = out->linesize[0]; const int src_linesize = in->linesize[0]; const int hpad = (inlink->w - s->pr_width) * 3; const int vpad = (inlink->h - s->pr_height); if (hpad) { uint8_t *dstp = dst + s->pr_width * 3; const uint8_t *srcp = src + s->pr_width * 3; for (y = 0; y < s->pr_height; y++) { memcpy(dstp, srcp, hpad); dstp += dst_linesize; srcp += src_linesize; } } if (vpad) { uint8_t *dstp = dst + s->pr_height * dst_linesize; const uint8_t *srcp = src + s->pr_height * src_linesize; for (y = 0; y < vpad; y++) { memcpy(dstp, srcp, inlink->w * 3); dstp += dst_linesize; srcp += src_linesize; } } av_frame_free(&in); } return ff_filter_frame(outlink, out); }<SPLIT>[-0.25365086435942685, 0.7070478251488422, 0.0, -0.2665172434374763, 0.6149066971767397, 0.0, 0.7963739706959416, 0.8178632553475105, 0.7400896423242515, -0.27925050329511203, 0.6082348278270694, -0.25297036047912586, 0.7515047844340796, 0.0, 0.0, 0.30852482215402843, 0.525883726296673, -0.26569807294376846, 0.660148897439891, 1.2822982768889746, 0.4684316465353775, 0.0, -0.08645738172306322, -0.16222078614455715, 0.7463616652495864, 0.9463589259089511, 1.1342209646213146, -0.21702784222394986, 0.7074534682410251, 0.7958385171580944, 0.8173872120927261, 0.7395912368182198, -0.27935383381430245, 1.7623686513065309, 0.0, 0.791794928969486, 0.8133108086083498, 0.7355972453213037, -0.28182971586402455]
0<SPLIT>void av_frame_move_ref(AVFrame *dst, AVFrame *src) { *dst = *src; if (src->extended_data == src->data) dst->extended_data = dst->data; memset(src, 0, sizeof(*src)); get_frame_defaults(src); }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void writer_print_integers(WriterContext *wctx, const char *name, uint8_t *data, int size, const char *format, int columns, int bytes, int offset_add) { AVBPrint bp; int offset = 0, l, i; av_bprint_init(&bp, 0, AV_BPRINT_SIZE_UNLIMITED); av_bprintf(&bp, "\n"); while (size) { av_bprintf(&bp, "%08x: ", offset); l = FFMIN(size, columns); for (i = 0; i < l; i++) { if (bytes == 1) av_bprintf(&bp, format, *data); else if (bytes == 2) av_bprintf(&bp, format, AV_RN16(data)); else if (bytes == 4) av_bprintf(&bp, format, AV_RN32(data)); data += bytes; size --; } av_bprintf(&bp, "\n"); offset += offset_add; } writer_print_string(wctx, name, bp.str, 0); av_bprint_finalize(&bp, NULL); }<SPLIT>[-0.25365086435942685, -0.13034272285790952, 0.0, -0.2665172434374763, -0.1936866588694103, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.1509627274668249, -0.25297036047912586, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.21031383592774278, -0.26569807294376846, -0.17914063696102905, 0.5059163865058198, 0.13958259121676436, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, 0.23792492798410134, 0.34396739025506545, -0.21702784222394986, 0.14602883551895066, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static void compute_overlay_rect(AVFormatContext *s) { AVRational sar, dar; SDLContext *sdl = s->priv_data; AVStream *st = s->streams[0]; AVCodecContext *encctx = st->codec; SDL_Rect *overlay_rect = &sdl->overlay_rect; sar = st->sample_aspect_ratio.num ? st->sample_aspect_ratio : (AVRational){ 1, 1 }; dar = av_mul_q(sar, (AVRational){ encctx->width, encctx->height }); if (sdl->window_width && sdl->window_height) { if (av_cmp_q(dar, (AVRational){ sdl->window_width, sdl->window_height }) > 0) { overlay_rect->w = sdl->window_width; overlay_rect->h = av_rescale(overlay_rect->w, dar.den, dar.num); } else { overlay_rect->h = sdl->window_height; overlay_rect->w = av_rescale(overlay_rect->h, dar.num, dar.den); } } else { if (sar.num > sar.den) { overlay_rect->w = encctx->width; overlay_rect->h = av_rescale(overlay_rect->w, dar.den, dar.num); } else { overlay_rect->h = encctx->height; overlay_rect->w = av_rescale(overlay_rect->h, dar.num, dar.den); } sdl->window_width = overlay_rect->w; sdl->window_height = overlay_rect->h; }<SPLIT>[0.5195604475230265, -0.04219634938351458, 0.0, 0.4942630637605089, -0.10857156875928925, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.02884721983962376, 0.5335543553887203, -0.023453142295599506, 0.0, 0.0, 0.30852482215402843, -0.03595125540090747, 0.5077564769051636, -0.09079437018198484, -0.39986248560786075, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.0968099467164862, -0.3615192241061562, -0.4462861841111837, -0.21702784222394986, -0.22825425296243224, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static void free_tracked_methods(RTMPContext *rt) { int i; for (i = 0; i < rt->nb_tracked_methods; i ++) av_freep(&rt->tracked_methods[i].name); av_freep(&rt->tracked_methods); rt->tracked_methods_size = 0; rt->nb_tracked_methods = 0; }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.44813145170234975, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int open_stream(void *log, MovieStream *st) { AVCodec *codec; int ret; codec = avcodec_find_decoder(st->st->codec->codec_id); if (!codec) { av_log(log, AV_LOG_ERROR, "Failed to find any codec\n"); return AVERROR(EINVAL); } st->st->codec->refcounted_frames = 1; if ((ret = avcodec_open2(st->st->codec, codec, NULL)) < 0) { av_log(log, AV_LOG_ERROR, "Failed to open codec\n"); return ret; } return 0; }<SPLIT>[-0.25365086435942685, -0.30663546980669937, 0.0, -0.2665172434374763, -0.36391683908965244, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, -0.27925050329511203, -0.3107937917392237, -0.25297036047912586, -0.2969677046707804, 0.0, 0.0, 0.30852482215402843, -0.36530279639604085, -0.26569807294376846, -0.3558331705191175, -0.14106852214680915, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.377867150705177, -0.1980344553542678, -0.22049944857796966, -0.21702784222394986, -0.13468348084208653, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, -0.27935383381430245, 0.04889276383167627, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, -0.28182971586402455]
0<SPLIT>static av_always_inline void yuv2rgb_full_1_c_template(SwsContext *c, const int16_t *buf0, const int16_t *ubuf[2], const int16_t *vbuf[2], const int16_t *abuf0, uint8_t *dest, int dstW, int uvalpha, int y, enum AVPixelFormat target, int hasAlpha) { const int16_t *ubuf0 = ubuf[0], *vbuf0 = vbuf[0]; int i; int step = (target == AV_PIX_FMT_RGB24 || target == AV_PIX_FMT_BGR24) ? 3 : 4; int err[4] = {0}; if( target == AV_PIX_FMT_BGR4_BYTE || target == AV_PIX_FMT_RGB4_BYTE || target == AV_PIX_FMT_BGR8 || target == AV_PIX_FMT_RGB8) step = 1; if (uvalpha < 2048) { int A = 0; for (i = 0; i < dstW; i++) { int Y = buf0[i] << 2; int U = (ubuf0[i] - (128<<7)) * 4; int V = (vbuf0[i] - (128<<7)) * 4; if (hasAlpha) { A = (abuf0[i] + 64) >> 7; if (A & 0x100) A = av_clip_uint8(A); } yuv2rgb_write_full(c, dest, i, Y, A, U, V, y, target, hasAlpha, err); dest += step; } } else { const int16_t *ubuf1 = ubuf[1], *vbuf1 = vbuf[1]; int A = 0; for (i = 0; i < dstW; i++) { int Y = buf0[i] << 2; int U = (ubuf0[i] + ubuf1[i] - (128<<8)) << 1; int V = (vbuf0[i] + vbuf1[i] - (128<<8)) << 1; if (hasAlpha) { A = (abuf0[i] + 64) >> 7; if (A & 0x100) A = av_clip_uint8(A); } yuv2rgb_write_full(c, dest, i, Y, A, U, V, y, target, hasAlpha, err); dest += step; } } c->dither_error[0][i] = err[0]; c->dither_error[1][i] = err[1]; c->dither_error[2][i] = err[2]; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, 0.31700388179131606, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.2546530454771514, -0.26569807294376846, 0.35093696371323624, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.32477585926655006, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static void free_rendition_list(HLSContext *c) { int i; for (i = 0; i < c->n_renditions; i++) av_freep(&c->renditions[i]); av_freep(&c->renditions); c->n_renditions = 0; }<SPLIT>[-0.25365086435942685, -0.4829282167554892, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4706248560116225, -0.25297036047912586, -0.4793107462542343, 0.0, 0.0, 0.30852482215402843, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5794989157753407, -0.5591795518777907, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int av_tempfile(const char *prefix, char **filename, int log_offset, void *log_ctx) { FileLogContext file_log_ctx = { &file_log_ctx_class, log_offset, log_ctx }; int fd = -1; #if !HAVE_MKSTEMP void *ptr= tempnam(NULL, prefix); if(!ptr) ptr= tempnam(".", prefix); *filename = av_strdup(ptr); #undef free free(ptr); #else size_t len = strlen(prefix) + 12; *filename = av_malloc(len); #endif if (!*filename) { av_log(&file_log_ctx, AV_LOG_ERROR, "ff_tempfile: Cannot allocate file name\n"); return AVERROR(ENOMEM); } #if !HAVE_MKSTEMP # ifndef O_BINARY # define O_BINARY 0 # endif # ifndef O_EXCL # define O_EXCL 0 # endif fd = open(*filename, O_RDWR | O_BINARY | O_CREAT | O_EXCL, 0600); #else snprintf(*filename, len, "/tmp/%sXXXXXX", prefix); fd = mkstemp(*filename); #ifdef _WIN32 if (fd < 0) { snprintf(*filename, len, "./%sXXXXXX", prefix); fd = mkstemp(*filename); } #endif #endif if (fd < 0) { int err = AVERROR(errno); av_log(&file_log_ctx, AV_LOG_ERROR, "ff_tempfile: Cannot open temporary file %s\n", *filename); av_freep(filename); return err; } return fd; }<SPLIT>[0.05563366039355449, 0.33242573788266383, 0.0, 0.037794879441717756, 0.25316756420872527, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.3085515823163217, 0.061639525868012635, -0.16021042348318995, 0.0, 0.0, 0.30852482215402843, 0.23527942541861413, 0.04368374699580437, -0.22331377035055117, 0.37651940477529405, 0.5780479983082486, 0.0, 1.0160128806822883, 8.53464374073119, 0.00858650477927287, 0.3469147738186936, 0.34396739025506545, -0.21702784222394986, 0.33317037975964214, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.04889276383167627, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>void ff_set_fixed_vector(float *out, const AMRFixed *in, float scale, int size) { int i; for (i=0; i < in->n; i++) { int x = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1); float y = in->y[i] * scale; if (in->pitch_lag > 0) av_assert0(x < size); do { out[x] += y; y *= in->pitch_fac; x += in->pitch_lag; } while (x < size && repeats); } }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.270465503877335, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.41601414702345235, -0.22049944857796966, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void sum_square_butterfly(AC3EncodeContext *s, float sum[4], const float *coef0, const float *coef1, int len) { s->ac3dsp.sum_square_butterfly_float(sum, coef0, coef1, len); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.5292594673383866, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>AVFrame *ff_get_video_buffer(AVFilterLink *link, int w, int h) { AVFrame *ret = NULL; FF_TPRINTF_START(NULL, get_video_buffer); ff_tlog_link(NULL, link, 0); if (link->dstpad->get_video_buffer) ret = link->dstpad->get_video_buffer(link, w, h); if (!ret) ret = ff_default_get_video_buffer(link, w, h); return ret; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.5292594673383866, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int handle_notify(URLContext *s, RTMPPacket *pkt) { RTMPContext *rt = s->priv_data; uint8_t commandbuffer[64]; char statusmsg[128]; int stringlen, ret, skip = 0; GetByteContext gbc; bytestream2_init(&gbc, pkt->data, pkt->size); if (ff_amf_read_string(&gbc, commandbuffer, sizeof(commandbuffer), &stringlen)) return AVERROR_INVALIDDATA; if (!strcmp(commandbuffer, "onMetaData")) { if (bytestream2_get_byte(&gbc) == AMF_DATA_TYPE_MIXEDARRAY) { rt->received_metadata = 1; bytestream2_skip(&gbc, 4); while (bytestream2_get_bytes_left(&gbc) > 3) { if (ff_amf_get_string(&gbc, statusmsg, sizeof(statusmsg), &stringlen)) return AVERROR_INVALIDDATA; stringlen = ff_amf_tag_size(gbc.buffer, gbc.buffer_end); if (stringlen < 0) return AVERROR_INVALIDDATA; bytestream2_skip(&gbc, stringlen); if (!strcmp(statusmsg, "videocodecid")) { rt->has_video = 1; } if (!strcmp(statusmsg, "audiocodecid")) { rt->has_audio = 1; } } if (bytestream2_get_be24(&gbc) != AMF_END_OF_OBJECT) return AVERROR_INVALIDDATA; } } if (!strcmp(commandbuffer, "@setDataFrame")) { skip = gbc.buffer - pkt->data; ret = ff_amf_read_string(&gbc, statusmsg, sizeof(statusmsg), &stringlen); if (ret < 0) return AVERROR_INVALIDDATA; } return append_flv_data(rt, pkt, skip); }<SPLIT>[0.9834872346524985, 0.2883525511454664, 0.0, 0.9507312480792999, 0.21061001915366473, 0.0, 0.10120102281206332, 0.11088995743869048, 0.07672169611998206, -0.27925050329511203, 0.3884671144525211, 1.0054691849094282, 0.3184400606733766, 0.0, 0.0, 0.30852482215402843, 0.31277390565276314, 0.9718292068145229, 0.24050413023943099, 0.7647103499668715, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, 0.23792492798410134, 0.7955408613214935, -0.21702784222394986, -0.22825425296243224, 0.10084358397375535, 0.11056045576999526, 0.07638646465193619, -0.27935383381430245, 0.9056307075691036, 0.0, 0.09767627996601334, 0.10736180245377658, 0.07326963308010803, -0.28182971586402455]
0<SPLIT>static int request_frame(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; RandomContext *s = ctx->priv; int ret; ret = ff_request_frame(ctx->inputs[0]); if (ret == AVERROR_EOF && !ctx->is_disabled && s->nb_frames > 0) { AVFrame *out = s->frames[s->nb_frames - 1]; out->pts = s->pts[s->flush_idx++]; ret = ff_filter_frame(outlink, out); s->frames[s->nb_frames - 1] = NULL; s->nb_frames--; } return ret; }<SPLIT>[-0.25365086435942685, -0.32867206317529807, 0.0, -0.2665172434374763, -0.3851956116171827, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.33077267477327355, -0.25297036047912586, -0.3197605848687121, 0.0, 0.0, 0.30852482215402843, -0.3846764164545781, -0.26569807294376846, -0.37791973721387856, -0.39986248560786075, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.41601414702345235, -0.4462861841111837, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int copy_tag(AVIOContext *in, AVIOContext *out, int32_t tag_name) { int32_t size, tag; size = avio_rb32(in); tag = avio_rb32(in); avio_wb32(out, size); avio_wb32(out, tag); if (expect_tag(tag, tag_name) != 0) return -1; size -= 8; while (size > 0) { char buf[1024]; int len = FFMIN(sizeof(buf), size); int got; if ((got = avio_read(in, buf, len)) != len) { fprintf(stderr, "short read, wanted %d, got %d\n", len, got); break; } avio_write(out, buf, len); size -= len; } return 0; }<SPLIT>[-0.25365086435942685, -0.15237931622650824, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.17094161050087475, -0.25297036047912586, -0.1374175432852582, 0.0, 0.0, 0.30852482215402843, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, 0.37651940477529405, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, 0.01994523631491676, 0.34396739025506545, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int flush_buffer(DynamicAudioNormalizerContext *s, AVFilterLink *inlink, AVFilterLink *outlink) { AVFrame *out = ff_get_audio_buffer(outlink, s->frame_len); int c, i; if (!out) return AVERROR(ENOMEM); for (c = 0; c < s->channels; c++) { double *dst_ptr = (double *)out->extended_data[c]; for (i = 0; i < out->nb_samples; i++) { dst_ptr[i] = s->alt_boundary_mode ? DBL_EPSILON : ((s->target_rms > DBL_EPSILON) ? FFMIN(s->peak_value, s->target_rms) : s->peak_value); if (s->dc_correction) { dst_ptr[i] *= ((i % 2) == 1) ? -1 : 1; dst_ptr[i] += s->dc_correction_value[c]; } } } s->delay--; return filter_frame(inlink, out); }<SPLIT>[-0.25365086435942685, -0.21848909633230443, 0.0, -0.2665172434374763, -0.27880174897953136, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.2308782596030243, -0.25297036047912586, -0.20579618387905343, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.26569807294376846, -0.2674869037400733, 0.11772544131424245, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.3070243011888601, 0.005287286955244392, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static inline int qsort_sparsecoeff(const SparseCoeff *a, const SparseCoeff *b) { if (fabsf(a->value) >= fabsf(b->value)) return 1; else return -1; }<SPLIT>[-0.25365086435942685, -0.5049648101240879, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4906037390456724, -0.25297036047912586, -0.502103626452166, 0.0, 0.0, 0.30852482215402843, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.6586564490689124, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.4705090699407485, -0.6720729196443977, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static int write_begin(URLContext *s) { RTMPContext *rt = s->priv_data; PutByteContext pbc; RTMPPacket spkt = { 0 }; int ret; if ((ret = ff_rtmp_packet_create(&spkt, RTMP_NETWORK_CHANNEL, RTMP_PT_PING, 0, 6)) < 0) { av_log(s, AV_LOG_ERROR, "Unable to create response packet\n"); return ret; } bytestream2_init_writer(&pbc, spkt.data, spkt.size); bytestream2_put_be16(&pbc, 0); bytestream2_put_be32(&pbc, rt->nb_streamid); ret = ff_rtmp_packet_write(rt->stream, &spkt, rt->out_chunk_size, &rt->prev_pkt[1], &rt->nb_prev_pkt[1]); ff_rtmp_packet_destroy(&spkt); return ret; }<SPLIT>[-0.09900860198293619, -0.24052568970090316, 0.0, -0.11436118199787926, -0.30008052150706166, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.2308782596030243, -0.09566541730555662, -0.22858906407698518, 0.0, 0.0, 0.30852482215402843, -0.28780831616189184, -0.11100716297398205, -0.28957347043483433, 0.24712242304476825, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.27247069920941797, -0.08904460951967552, 0.11818065472185141, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { ASyncContext *s = ctx->priv; if (s->avr) { avresample_close(s->avr); avresample_free(&s->avr); } }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5341470193098945, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5202917568643389, -0.26569807294376846, -0.5325257040772059, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5886600536966952, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int opt_width(void *optctx, const char *opt, const char *arg) { screen_width = parse_number_or_die(opt, arg, OPT_INT64, 1, INT_MAX); return 0; }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.5794989157753407, -0.6720729196443977, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
1<SPLIT>static av_cold int che_configure(AACContext *ac, enum ChannelPosition che_pos, int type, int id, int *channels) { if (*channels >= MAX_CHANNELS) return AVERROR_INVALIDDATA; if (che_pos) { if (!ac->che[type][id]) { if (!(ac->che[type][id] = av_mallocz(sizeof(ChannelElement)))) return AVERROR(ENOMEM); AAC_RENAME(ff_aac_sbr_ctx_init)(ac, &ac->che[type][id]->sbr); } if (type != TYPE_CCE) { if (*channels >= MAX_CHANNELS - (type == TYPE_CPE || (type == TYPE_SCE && ac->oc[1].m4ac.ps == 1))) { av_log(ac->avctx, AV_LOG_ERROR, "Too many channels\n"); return AVERROR_INVALIDDATA; } ac->output_element[(*channels)++] = &ac->che[type][id]->ch[0]; if (type == TYPE_CPE || (type == TYPE_SCE && ac->oc[1].m4ac.ps == 1)) { ac->output_element[(*channels)++] = &ac->che[type][id]->ch[1]; } } } else { if (ac->che[type][id]) AAC_RENAME(ff_aac_sbr_ctx_close)(&ac->che[type][id]->sbr); av_freep(&ac->che[type][id]); } return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.06601402370422871, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.09407211557651925, -0.26569807294376846, -0.04662123679246273, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.3427350002065907, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static av_cold void uninit(AVFilterContext *ctx) { int k; ShowCQTContext *s = ctx->priv; av_fft_end(s->fft_context); s->fft_context = NULL; for (k = 0; k < VIDEO_WIDTH; k++) av_freep(&s->coeffs[k]); av_freep(&s->fft_data); av_freep(&s->fft_result_left); av_freep(&s->fft_result_right); av_freep(&s->coeff_sort); av_freep(&s->spectogram); av_freep(&s->font_alpha); av_frame_free(&s->outpicref); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.34263806656212215, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.3459291763375036, -0.26569807294376846, -0.33374660382435645, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.1670742477136589, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>const char *av_get_channel_description(uint64_t channel) { int i; if (av_get_channel_layout_nb_channels(channel) != 1) return NULL; for (i = 0; i < FF_ARRAY_ELEMS(channel_names); i++) if ((1ULL<<i) & channel) return channel_names[i].description; return NULL; }<SPLIT>[-0.25365086435942685, -0.43885503001829174, 0.0, -0.2665172434374763, -0.491589474254834, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.4306670899435228, -0.25297036047912586, -0.4337249858583708, 0.0, 0.0, 0.30852482215402843, -0.4815445167472644, -0.26569807294376846, -0.48835257068768384, -0.39986248560786075, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.5250039928580447, -0.4462861841111837, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static av_cold int init_dict(AVFilterContext *ctx, AVDictionary **opts) { AResampleContext *aresample = ctx->priv; int ret = 0; aresample->next_pts = AV_NOPTS_VALUE; aresample->swr = swr_alloc(); if (!aresample->swr) { ret = AVERROR(ENOMEM); goto end; } if (opts) { AVDictionaryEntry *e = NULL; while ((e = av_dict_get(*opts, "", e, AV_DICT_IGNORE_SUFFIX))) { if ((ret = av_opt_set(aresample->swr, e->key, e->value, 0)) < 0) goto end; } av_dict_free(opts); } if (aresample->sample_rate_arg > 0) av_opt_set_int(aresample->swr, "osr", aresample->sample_rate_arg, 0); end: return ret; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.21496543139694058, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.22968745598628004, -0.26569807294376846, -0.2012272036557901, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.30760284970800433, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>opt->default_val.i64 : opt->default_val.dbl) static int set_string_number(void *obj, void *target_obj, const AVOption *o, const char *val, void *dst) { int ret = 0; int num, den; char c; if (sscanf(val, "%d%*1[:/]%d%c", &num, &den, &c) == 2) { if ((ret = write_number(obj, o, dst, 1, den, num)) >= 0) return ret; ret = 0; } for (;;) { int i = 0; char buf[256]; int cmd = 0; double d; int64_t intnum = 1; if (o->type == AV_OPT_TYPE_FLAGS) { if (*val == '+' || *val == '-') cmd = *(val++); for (; i < sizeof(buf) - 1 && val[i] && val[i] != '+' && val[i] != '-'; i++) buf[i] = val[i]; buf[i] = 0; } { const AVOption *o_named = av_opt_find(target_obj, i ? buf : val, o->unit, 0, 0); int res; int ci = 0; double const_values[64]; const char * const_names[64]; if (o_named && o_named->type == AV_OPT_TYPE_CONST) d = DEFAULT_NUMVAL(o_named); else { if (o->unit) { for (o_named = NULL; o_named = av_opt_next(target_obj, o_named); ) { if (o_named->type == AV_OPT_TYPE_CONST && o_named->unit && !strcmp(o_named->unit, o->unit)) { if (ci + 6 >= FF_ARRAY_ELEMS(const_values)) { av_log(obj, AV_LOG_ERROR, "const_values array too small for %s\n", o->unit); return AVERROR_PATCHWELCOME; } const_names [ci ] = o_named->name; const_values[ci++] = DEFAULT_NUMVAL(o_named); } } } const_names [ci ] = "default"; const_values[ci++] = DEFAULT_NUMVAL(o); const_names [ci ] = "max"; const_values[ci++] = o->max; const_names [ci ] = "min"; const_values[ci++] = o->min; const_names [ci ] = "none"; const_values[ci++] = 0; const_names [ci ] = "all"; const_values[ci++] = ~0; const_names [ci] = NULL; const_values[ci] = 0; res = av_expr_parse_and_eval(&d, i ? buf : val, const_names, const_values, NULL, NULL, NULL, NULL, NULL, 0, obj); if (res < 0) { av_log(obj, AV_LOG_ERROR, "Unable to parse option value \"%s\"\n", val); return res; } } } if (o->type == AV_OPT_TYPE_FLAGS) { read_number(o, dst, NULL, NULL, &intnum); if (cmd == '+') d = intnum | (int64_t)d; else if (cmd == '-') d = intnum &~(int64_t)d; } if ((ret = write_number(obj, o, dst, d, 1, 1)) < 0) return ret; val += i; if (!i || !*val) return 0; } return 0; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, 0.9979246026722846, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, 0.8746088873503436, -0.26569807294376846, 1.05770709794559, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 1.09768317023545, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int compare_doubles(const double *a, const double *b, int len, double max_diff) { int i; for (i = 0; i < len; i++) { if (fabs(a[i] - b[i]) > max_diff) { av_log(NULL, AV_LOG_ERROR, "%d: %- .12f - %- .12f = % .12g\n", i, a[i], b[i], a[i] - b[i]); return -1; } } return 0; }<SPLIT>[-0.25365086435942685, -0.3727452499124955, 0.0, -0.2665172434374763, -0.42775315667224323, 0.0, -0.07259221415890627, -0.06585336703851451, -0.08912029043108533, 0.380400859743741, -0.37073044084137324, -0.25297036047912586, -0.3653463452645756, 0.0, 0.0, 0.30852482215402843, -0.4234236565716526, -0.26569807294376846, -0.42209287060340067, -0.270465503877335, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.4832636022009361, -0.1980344553542678, -0.4462861841111837, -0.21702784222394986, 0.05245806339860493, -0.07290514932232937, -0.06614623331068743, -0.08941472838963471, 0.3801362775450152, 0.9056307075691036, 0.0, -0.0758533822848548, -0.06912544908486672, -0.0923122699801909, 0.3766295797615486]
0<SPLIT>int av_crc_init(AVCRC *ctx, int le, int bits, uint32_t poly, int ctx_size) { unsigned i, j; uint32_t c; if (bits < 8 || bits > 32 || poly >= (1LL << bits)) return -1; if (ctx_size != sizeof(AVCRC) * 257 && ctx_size != sizeof(AVCRC) * 1024) return -1; for (i = 0; i < 256; i++) { if (le) { for (c = i, j = 0; j < 8; j++) c = (c >> 1) ^ (poly & (-(c & 1))); ctx[i] = c; } else { for (c = i << 24, j = 0; j < 8; j++) c = (c << 1) ^ ((poly << (32 - bits)) & (((int32_t) c) >> 31)); ctx[i] = av_bswap32(c); } } ctx[256] = 1; #if !CONFIG_SMALL if (ctx_size >= sizeof(AVCRC) * 1024) for (i = 0; i < 256; i++) for (j = 0; j < 3; j++) ctx[256 *(j + 1) + i] = (ctx[256 * j + i] >> 8) ^ ctx[ctx[256 * j + i] & 0xFF]; #endif return 0; }<SPLIT>[-0.25365086435942685, -0.020159756014915854, 0.0, -0.2665172434374763, -0.08729279623175898, 0.0, 0.27499425978303293, 0.2876332819158955, 0.24256368267104944, 0.380400859743741, -0.051068312296575644, -0.25297036047912586, -0.04624602249353125, 0.0, 0.0, 0.30852482215402843, -0.1134457356350565, -0.26569807294376846, -0.1128809368767459, -0.5292594673383866, 0.2491989429896354, 0.0, -0.08645738172306322, 0.9973611507722091, 0.043718655277859224, -0.03454968660237938, -0.4462861841111837, -0.21702784222394986, 0.33317037975964214, 0.27459231726984007, 0.28726714485067795, 0.24218765769350709, 0.3801362775450152, 0.9056307075691036, 0.0, 0.2712059422168815, 0.2838490539924199, 0.23885153614040697, 0.3766295797615486]
0<SPLIT>static void pulse_overflow(pa_stream *stream, void *userdata) { AVFormatContext *h = userdata; avdevice_dev_to_app_control_message(h, AV_DEV_TO_APP_BUFFER_OVERFLOW, NULL, 0); }<SPLIT>[-0.25365086435942685, -0.5490379968612854, 0.0, -0.2665172434374763, -0.5979833368924854, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5305615051137721, -0.25297036047912586, -0.5476893868480295, 0.0, 0.0, 0.30852482215402843, -0.5784126170399507, -0.26569807294376846, -0.5987854041614891, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static void stream_close(VideoState *is) { is->abort_request = 1; SDL_WaitThread(is->read_tid, NULL); if (is->audio_stream >= 0) stream_component_close(is, is->audio_stream); if (is->video_stream >= 0) stream_component_close(is, is->video_stream); if (is->subtitle_stream >= 0) stream_component_close(is, is->subtitle_stream); avformat_close_input(&is->ic); packet_queue_destroy(&is->videoq); packet_queue_destroy(&is->audioq); packet_queue_destroy(&is->subtitleq); frame_queue_destory(&is->pictq); frame_queue_destory(&is->sampq); frame_queue_destory(&is->subpq); SDL_DestroyCond(is->continue_read_thread); sws_freeContext(is->img_convert_ctx); sws_freeContext(is->sub_convert_ctx); av_free(is->filename); if (is->vis_texture) SDL_DestroyTexture(is->vis_texture); if (is->vid_texture) SDL_DestroyTexture(is->vid_texture); if (is->sub_texture) SDL_DestroyTexture(is->sub_texture); av_free(is); }<SPLIT>[0.21027592277004517, -0.020159756014915854, 0.0, 0.18995094088131478, -0.08729279623175898, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.008868336805573909, 0.21894446904158188, -0.0006602620976677653, 0.0, 0.0, 0.30852482215402843, -0.05532487545944473, 0.19837465696559078, -0.06870780348722379, 0.37651940477529405, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, 0.00858650477927287, -0.1980344553542678, 0.23107402248845843, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>av_cold void AAC_RENAME(ff_ps_ctx_init)(PSContext *ps) { AAC_RENAME(ff_psdsp_init)(&ps->dsp); }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.917450412529964, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.7429836845272292, -0.8978596551776118, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>static int opengl_write_packet(AVFormatContext *h, AVPacket *pkt) { return opengl_draw(h, pkt, 0, 1); }<SPLIT>[-0.25365086435942685, -0.5710745902298842, 0.0, -0.2665172434374763, -0.6192621094200156, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, -0.5505403881478219, -0.25297036047912586, -0.5704822670459613, 0.0, 0.0, 0.30852482215402843, -0.5977862370984879, -0.26569807294376846, -0.6208719708562501, -0.6586564490689124, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6589243546938679, -0.6339938386926369, -0.6720729196443977, -0.21702784222394986, -0.5089665693234694, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>static int config_input(AVFilterLink *inlink) { AVFilterContext *ctx = inlink->dst; SilenceRemoveContext *s = ctx->priv; s->window_size = (inlink->sample_rate / 50) * inlink->channels; s->window = av_malloc_array(s->window_size, sizeof(*s->window)); if (!s->window) return AVERROR(ENOMEM); clear_rms(s); s->start_duration = av_rescale(s->start_duration, inlink->sample_rate, AV_TIME_BASE); s->stop_duration = av_rescale(s->stop_duration, inlink->sample_rate, AV_TIME_BASE); s->start_holdoff = av_malloc_array(FFMAX(s->start_duration, 1), sizeof(*s->start_holdoff) * inlink->channels); if (!s->start_holdoff) return AVERROR(ENOMEM); s->start_holdoff_offset = 0; s->start_holdoff_end = 0; s->start_found_periods = 0; s->stop_holdoff = av_malloc_array(FFMAX(s->stop_duration, 1), sizeof(*s->stop_holdoff) * inlink->channels); if (!s->stop_holdoff) return AVERROR(ENOMEM); s->stop_holdoff_offset = 0; s->stop_holdoff_end = 0; s->stop_found_periods = 0; if (s->start_periods) s->mode = SILENCE_TRIM; else s->mode = SILENCE_COPY; return 0; }<SPLIT>[-0.25365086435942685, 0.11205980419667652, 0.0, -0.2665172434374763, 0.04037983893342262, 0.0, -0.42017868810084547, -0.4193400159929245, -0.4208042635332201, -0.27925050329511203, 0.06880498590772346, -0.25297036047912586, 0.13609701908992267, 0.0, 0.0, 0.30852482215402843, 0.0027959847161670454, -0.26569807294376846, 0.06381159668134254, -0.14106852214680915, -0.4084991676475909, 0.0, -0.08645738172306322, -0.16222078614455715, 0.043718655277859224, -0.3615192241061562, -0.22049944857796966, -0.21702784222394986, -0.4153957972031237, -0.42040261591449885, -0.41955961147205284, -0.4210171144727765, -0.27935383381430245, -0.8078451799057511, 0.0, -0.4229127067865911, -0.42209995216215335, -0.4234760761007888, -0.28182971586402455]
0<SPLIT>int av_dict_get_string(const AVDictionary *m, char **buffer, const char key_val_sep, const char pairs_sep) { AVDictionaryEntry *t = NULL; AVBPrint bprint; int cnt = 0; char special_chars[] = {pairs_sep, key_val_sep, '\0'}; if (!buffer || pairs_sep == '\0' || key_val_sep == '\0' || pairs_sep == key_val_sep || pairs_sep == '\\' || key_val_sep == '\\') return AVERROR(EINVAL); if (!av_dict_count(m)) { *buffer = av_strdup(""); return *buffer ? 0 : AVERROR(ENOMEM); } av_bprint_init(&bprint, 64, AV_BPRINT_SIZE_UNLIMITED); while ((t = av_dict_get(m, "", t, AV_DICT_IGNORE_SUFFIX))) { if (cnt++) av_bprint_append_data(&bprint, &pairs_sep, 1); av_bprint_escape(&bprint, t->key, special_chars, AV_ESCAPE_MODE_BACKSLASH, 0); av_bprint_append_data(&bprint, &key_val_sep, 1); av_bprint_escape(&bprint, t->value, special_chars, AV_ESCAPE_MODE_BACKSLASH, 0); } return av_bprint_finalize(&bprint, buffer); }<SPLIT>[-0.25365086435942685, -0.13034272285790952, 0.0, -0.2665172434374763, -0.1936866588694103, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.1509627274668249, -0.25297036047912586, -0.11462466308732647, 0.0, 0.0, 0.30852482215402843, -0.21031383592774278, -0.26569807294376846, -0.17914063696102905, 0.6353133682363457, -0.07965011232897776, 0.0, -0.08645738172306322, -0.16222078614455715, -0.2373385487108316, -0.03454968660237938, 0.34396739025506545, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>void exit_program(int ret) { if (program_exit) program_exit(ret); exit(ret); }<SPLIT>[-0.25365086435942685, -0.5270014034926866, 0.0, -0.2665172434374763, -0.5767045643649551, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.5105826220797223, -0.25297036047912586, -0.5248965066500978, 0.0, 0.0, 0.30852482215402843, -0.5590389969814135, -0.26569807294376846, -0.576698837466728, -0.5292594673383866, -0.1892664641018488, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.41601414702345235, -0.5591795518777907, -0.21702784222394986, -0.22825425296243224, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
0<SPLIT>long WINAPI libAVPin_QueryInternalConnections(libAVPin *this, IPin **pin, unsigned long *npin) { dshowdebug("libAVPin_QueryInternalConnections(%p)\n", this); return E_NOTIMPL; }<SPLIT>[-0.25365086435942685, -0.6592209637042791, 0.0, -0.2665172434374763, -0.5554257918374248, 0.0, -0.5939719250718151, -0.5960833404701295, -0.5866462500842875, -0.6090761848145386, -0.6304559202840213, -0.25297036047912586, -0.6616537878376882, 0.0, 0.0, -2.7318950064237044, -0.5396653769228762, -0.26569807294376846, -0.554612270771967, -0.7880534307994381, -0.518115519420462, 0.0, -0.08645738172306322, -0.16222078614455715, -0.6237922041952815, -0.6884887616099331, -0.7849662874110047, -0.21702784222394986, -0.5089665693234694, -0.5941513492105835, -0.5962663005527356, -0.5868183075143474, -0.6090988894939613, -0.8078451799057511, 0.0, -0.5964423690374593, -0.5985872037007967, -0.5890579791610877, -0.6110593636768111]
0<SPLIT>int avdevice_list_input_sources(AVInputFormat *device, const char *device_name, AVDictionary *device_options, AVDeviceInfoList **device_list) { AVFormatContext *s = NULL; int ret; if ((ret = ff_alloc_input_device_context(&s, device, device_name)) < 0) return ret; return list_devices_for_context(s, device_options, device_list); }<SPLIT>[-0.25365086435942685, -0.46089162338689044, 0.0, -0.2665172434374763, -0.5128682467823643, 0.0, -0.24638545112987587, -0.2425966915157195, -0.2549622769821527, -0.27925050329511203, -0.4506459729775727, -0.25297036047912586, -0.45651786605630257, 0.0, 0.0, 0.30852482215402843, -0.5009181368058017, -0.26569807294376846, -0.5104391373824448, -0.270465503877335, -0.2988828158747199, 0.0, -0.08645738172306322, -0.16222078614455715, -0.5535279031981089, -0.41601414702345235, -0.4462861841111837, -0.21702784222394986, -0.321825025082778, -0.2466538826184141, -0.24285292239137013, -0.2552159214312056, -0.27935383381430245, 0.04889276383167627, 0.0, -0.24938304453572296, -0.24561270062351, -0.25789417304048984, -0.28182971586402455]
